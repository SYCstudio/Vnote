<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.9.9" created="2018-12-16 05:03" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>SYCstudio</title>
	<link>http://sycstudio.com</link>
	<description>SYC个人站点</description>
	<pubDate>Sun, 16 Dec 2018 05:03:46 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://sycstudio.com</wp:base_site_url>
	<wp:base_blog_url>http://sycstudio.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[sycstudio]]></wp:author_login><wp:author_email><![CDATA[1726016246@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[sycstudio]]></wp:author_display_name><wp:author_first_name><![CDATA[宋]]></wp:author_first_name><wp:author_last_name><![CDATA[聿辰]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>13</wp:author_id><wp:author_login><![CDATA[dsl2002]]></wp:author_login><wp:author_email><![CDATA[778315932@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[dsl2002]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>11</wp:author_id><wp:author_login><![CDATA[flashhu]]></wp:author_login><wp:author_email><![CDATA[1258661899@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[flashhu]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>8</wp:author_id><wp:author_login><![CDATA[yyb]]></wp:author_login><wp:author_email><![CDATA[1357828232@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[yyb]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category>
		<wp:term_id>49</wp:term_id>
		<wp:category_nicename><![CDATA[mine]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[mine]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>13</wp:term_id>
		<wp:category_nicename><![CDATA[oj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[OJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>16</wp:term_id>
		<wp:category_nicename><![CDATA[poj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[POJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>123</wp:term_id>
		<wp:category_nicename><![CDATA[scu]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[SCU]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>22</wp:term_id>
		<wp:category_nicename><![CDATA[spoj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[SPOJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>203</wp:term_id>
		<wp:category_nicename><![CDATA[topcoder]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[Topcoder]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>69</wp:term_id>
		<wp:category_nicename><![CDATA[uoj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[UOJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>30</wp:term_id>
		<wp:category_nicename><![CDATA[uva]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[UVA]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>6</wp:term_id>
		<wp:category_nicename><![CDATA[wordpress]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[wordpress]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>26</wp:term_id>
		<wp:category_nicename><![CDATA[zoj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[ZOJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>144</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%be%85%e5%a1%ab%e5%9d%91-%e5%be%85%e6%9b%b4%e6%96%b0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[待填坑/待更新]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>27</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[数学]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>18</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[数学思想]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>53</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[数据结构]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>8</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[数论]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>25</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[数论分块]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>217</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a0%91%e5%a5%97%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[树套树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>185</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[树状数组]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>54</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a0%91%e9%93%be%e5%89%96%e5%88%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[树链剖分]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>9</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[欧拉函数]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>114</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[欧拉定理/扩展欧拉定理]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>2</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%b5%8b%e8%af%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[测试]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>150</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[点分治]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>35</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[真题]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>178</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[矩阵快速幂]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>10</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[研究总结]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>43</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[积性函数]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>52</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[算法]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>190</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ba%bf%e6%80%a7%e5%9f%ba]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[线性基]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>57</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[线段树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>136</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:category_parent>
		<wp:cat_name><![CDATA[线段树合并]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>248</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[组合数学]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>253</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%bb%bc%e5%90%88]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[综合]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>21</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[莫比乌斯反演]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>87</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[莫队算法]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>240</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%99%9a%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[虚树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>19</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%a1%a5%e9%9b%86%e6%80%9d%e6%83%b3]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[补集思想]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>175</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[计算几何]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>116</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%80%86%e5%85%83]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[逆元]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>55</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[重要思想]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>92</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%9a%8f%e6%9c%ba%e5%8c%96]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[随机化]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>50</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[高斯消元]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>153</wp:term_id>
		<wp:category_nicename><![CDATA[%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[高维前缀和]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>83</wp:term_id>
		<wp:category_nicename><![CDATA[51nod]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[51nod]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>237</wp:term_id>
		<wp:category_nicename><![CDATA[aizu]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[Aizu]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>105</wp:term_id>
		<wp:category_nicename><![CDATA[apio]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[APIO]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>250</wp:term_id>
		<wp:category_nicename><![CDATA[bsgs-%e6%89%a9%e5%b1%95bsgs]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[BSGS/扩展BSGS]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>33</wp:term_id>
		<wp:category_nicename><![CDATA[bzoj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[BZOJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>75</wp:term_id>
		<wp:category_nicename><![CDATA[codechef]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[Codechef]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>205</wp:term_id>
		<wp:category_nicename><![CDATA[codeforces]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[Codeforces]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>146</wp:term_id>
		<wp:category_nicename><![CDATA[ctsc]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[CTSC]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>173</wp:term_id>
		<wp:category_nicename><![CDATA[dfs%e5%ba%8f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[dfs序]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>195</wp:term_id>
		<wp:category_nicename><![CDATA[fft]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[FFT]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>14</wp:term_id>
		<wp:category_nicename><![CDATA[hdu]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[HDU]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>169</wp:term_id>
		<wp:category_nicename><![CDATA[hihocoder]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[hihocoder]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>159</wp:term_id>
		<wp:category_nicename><![CDATA[ioi]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[IOI]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>231</wp:term_id>
		<wp:category_nicename><![CDATA[kdt]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[KDT]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>77</wp:term_id>
		<wp:category_nicename><![CDATA[lca]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[LCA]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>63</wp:term_id>
		<wp:category_nicename><![CDATA[link-cut-tree]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[Link-Cut-Tree]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>67</wp:term_id>
		<wp:category_nicename><![CDATA[loj]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[LOJ]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>41</wp:term_id>
		<wp:category_nicename><![CDATA[luogu]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[Luogu]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>36</wp:term_id>
		<wp:category_nicename><![CDATA[noi]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[NOI]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>37</wp:term_id>
		<wp:category_nicename><![CDATA[noip]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[NOIP]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>254</wp:term_id>
		<wp:category_nicename><![CDATA[nowcoder]]></wp:category_nicename>
		<wp:category_parent><![CDATA[oj]]></wp:category_parent>
		<wp:cat_name><![CDATA[nowcoder]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>229</wp:term_id>
		<wp:category_nicename><![CDATA[pa]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[PA]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>218</wp:term_id>
		<wp:category_nicename><![CDATA[poi]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[POI]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>180</wp:term_id>
		<wp:category_nicename><![CDATA[st%e8%a1%a8]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[ST表]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>182</wp:term_id>
		<wp:category_nicename><![CDATA[usaco]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[USACO]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>71</wp:term_id>
		<wp:category_nicename><![CDATA[%e4%b8%bb%e5%b8%ad%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[主席树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>61</wp:term_id>
		<wp:category_nicename><![CDATA[%e4%ba%8c%e5%88%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[二分]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>89</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%88%86%e5%9d%97]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[分块]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>208</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%88%86%e6%b2%bb]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[分治]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>188</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[动态点分治]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>98</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>103</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[单调队列/单调栈]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>122</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[可并堆]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>38</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:category_parent>
		<wp:cat_name><![CDATA[各省省选]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>176</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%90%91%e9%87%8f%e7%82%b9%e7%a7%af-%e5%8f%89%e7%a7%af]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[向量点积/叉积]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>112</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%90%af%e5%8f%91%e5%bc%8f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[启发式]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>142</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%9b%be%e4%b8%8a%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[图上动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>96</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[图论]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>212</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%9f%ba%e7%8e%af%e6%a0%91%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[基环树动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>157</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%a0%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[堆]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>138</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[字符串]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>161</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2hash]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[字符串Hash]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>47</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[容斥原理]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>221</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b0%ba%e5%8f%96%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[尺取法]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>168</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b7%a6%e5%81%8f%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:category_parent>
		<wp:cat_name><![CDATA[左偏树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>79</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b7%ae%e5%88%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[差分]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>224</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[差分约束]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>110</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b9%b3%e8%a1%a1%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[平衡树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>155</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[平面图对偶图]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>64</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:category_parent>
		<wp:cat_name><![CDATA[并查集]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>252</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[拉格朗日插值法]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>225</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%8b%93%e6%89%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[拓扑]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>164</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:category_parent>
		<wp:cat_name><![CDATA[搜索]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>152</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[数位动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>210</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%88%86%e6%b2%bb]]></wp:category_parent>
		<wp:cat_name><![CDATA[整体二分]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>104</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[斜率优化动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>108</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[最短/长路径]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>192</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%9e%84%e9%80%a0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[构造]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>236</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a0%91hash]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[树Hash]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>211</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[树型动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>99</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[概率动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>201</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:category_parent>
		<wp:cat_name><![CDATA[模拟退火/爬山算法]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>100</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[状态压缩]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>132</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[状态压缩动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>148</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%94%9f%e6%88%90%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[生成树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>251</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[矩阵树定理]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>73</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[离散化]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>56</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[离线处理]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>249</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%ac%ac%e4%b8%80%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:category_parent>
		<wp:cat_name><![CDATA[第一类斯特林数]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>97</wp:term_id>
		<wp:category_nicename><![CDATA[%e7%bd%91%e7%bb%9c%e6%b5%81]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[网络流]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>131</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[计数动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>215</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:category_parent>
		<wp:cat_name><![CDATA[记忆化搜索]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>133</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:category_parent>
		<wp:cat_name><![CDATA[贪心]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>245</wp:term_id>
		<wp:category_nicename><![CDATA[2-sat]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[2-sat]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>167</wp:term_id>
		<wp:category_nicename><![CDATA[ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[AC自动机]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>209</wp:term_id>
		<wp:category_nicename><![CDATA[cdq%e5%88%86%e6%b2%bb]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%88%86%e6%b2%bb]]></wp:category_parent>
		<wp:cat_name><![CDATA[CDQ分治]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>139</wp:term_id>
		<wp:category_nicename><![CDATA[kmp]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[KMP]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>194</wp:term_id>
		<wp:category_nicename><![CDATA[manacher]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[Manacher]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>143</wp:term_id>
		<wp:category_nicename><![CDATA[tarjan]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[Tarjan]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>213</wp:term_id>
		<wp:category_nicename><![CDATA[trie%e6%a0%91]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[Trie树]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>119</wp:term_id>
		<wp:category_nicename><![CDATA[%e4%ba%8c%e5%88%86%e5%9b%be]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:category_parent>
		<wp:cat_name><![CDATA[二分图]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>198</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:category_parent>
		<wp:cat_name><![CDATA[决策单调性动态规划]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>166</wp:term_id>
		<wp:category_nicename><![CDATA[%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:category_parent>
		<wp:cat_name><![CDATA[后缀数组]]></wp:cat_name>
	</wp:category>
	<wp:tag>
		<wp:term_id>246</wp:term_id>
		<wp:tag_slug><![CDATA[2-sat]]></wp:tag_slug>
		<wp:tag_name><![CDATA[2-sat]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>82</wp:term_id>
		<wp:tag_slug><![CDATA[51nod]]></wp:tag_slug>
		<wp:tag_name><![CDATA[51nod]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>172</wp:term_id>
		<wp:tag_slug><![CDATA[ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[AC自动机]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>238</wp:term_id>
		<wp:tag_slug><![CDATA[aizu]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Aizu]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>134</wp:term_id>
		<wp:tag_slug><![CDATA[apio]]></wp:tag_slug>
		<wp:tag_name><![CDATA[APIO]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>163</wp:term_id>
		<wp:tag_slug><![CDATA[bkdrhash]]></wp:tag_slug>
		<wp:tag_name><![CDATA[BKDRHash]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>39</wp:term_id>
		<wp:tag_slug><![CDATA[bzoj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[BZOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>207</wp:term_id>
		<wp:tag_slug><![CDATA[cdq%e5%88%86%e6%b2%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[CDQ分治]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>76</wp:term_id>
		<wp:tag_slug><![CDATA[codechef]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Codechef]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>206</wp:term_id>
		<wp:tag_slug><![CDATA[codeforces]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Codeforces]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>147</wp:term_id>
		<wp:tag_slug><![CDATA[ctsc]]></wp:tag_slug>
		<wp:tag_name><![CDATA[CTSC]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>174</wp:term_id>
		<wp:tag_slug><![CDATA[dfs%e5%ba%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[dfs序]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>196</wp:term_id>
		<wp:tag_slug><![CDATA[fft]]></wp:tag_slug>
		<wp:tag_name><![CDATA[FFT]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>162</wp:term_id>
		<wp:tag_slug><![CDATA[hash]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Hash]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>15</wp:term_id>
		<wp:tag_slug><![CDATA[hdu]]></wp:tag_slug>
		<wp:tag_name><![CDATA[HDU]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>170</wp:term_id>
		<wp:tag_slug><![CDATA[hihocoder]]></wp:tag_slug>
		<wp:tag_name><![CDATA[hihocoder]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>160</wp:term_id>
		<wp:tag_slug><![CDATA[ioi]]></wp:tag_slug>
		<wp:tag_name><![CDATA[IOI]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>232</wp:term_id>
		<wp:tag_slug><![CDATA[kdt]]></wp:tag_slug>
		<wp:tag_name><![CDATA[KDT]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>140</wp:term_id>
		<wp:tag_slug><![CDATA[kmp]]></wp:tag_slug>
		<wp:tag_name><![CDATA[KMP]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>78</wp:term_id>
		<wp:tag_slug><![CDATA[lca]]></wp:tag_slug>
		<wp:tag_name><![CDATA[LCA]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>65</wp:term_id>
		<wp:tag_slug><![CDATA[link-cut-tree]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Link-Cut-Tree]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>68</wp:term_id>
		<wp:tag_slug><![CDATA[loj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[LOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>42</wp:term_id>
		<wp:tag_slug><![CDATA[luogu]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Luogu]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>197</wp:term_id>
		<wp:tag_slug><![CDATA[manacher]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Manacher]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>40</wp:term_id>
		<wp:tag_slug><![CDATA[noi]]></wp:tag_slug>
		<wp:tag_name><![CDATA[NOI]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>230</wp:term_id>
		<wp:tag_slug><![CDATA[pa]]></wp:tag_slug>
		<wp:tag_name><![CDATA[PA]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>219</wp:term_id>
		<wp:tag_slug><![CDATA[poi]]></wp:tag_slug>
		<wp:tag_name><![CDATA[POI]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[poj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[POJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>127</wp:term_id>
		<wp:tag_slug><![CDATA[scu]]></wp:tag_slug>
		<wp:tag_name><![CDATA[SCU]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>128</wp:term_id>
		<wp:tag_slug><![CDATA[snmoj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[SNMOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[spoj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[SPOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>181</wp:term_id>
		<wp:tag_slug><![CDATA[st%e8%a1%a8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ST表]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>145</wp:term_id>
		<wp:tag_slug><![CDATA[tarjan]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Tarjan]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>204</wp:term_id>
		<wp:tag_slug><![CDATA[topcoder]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Topcoder]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>214</wp:term_id>
		<wp:tag_slug><![CDATA[trie%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Trie树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>70</wp:term_id>
		<wp:tag_slug><![CDATA[uoj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[UOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>183</wp:term_id>
		<wp:tag_slug><![CDATA[usaco]]></wp:tag_slug>
		<wp:tag_name><![CDATA[USACO]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[uva]]></wp:tag_slug>
		<wp:tag_name><![CDATA[UVA]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>7</wp:term_id>
		<wp:tag_slug><![CDATA[wordpress]]></wp:tag_slug>
		<wp:tag_name><![CDATA[wordpress]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>124</wp:term_id>
		<wp:tag_slug><![CDATA[zoj]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ZOJ]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>72</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%b8%bb%e5%b8%ad%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[主席树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>62</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8c%e5%88%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[二分]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>120</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8c%e5%88%86%e5%9b%be]]></wp:tag_slug>
		<wp:tag_name><![CDATA[二分图]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>200</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[决策单调性]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>90</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%88%86%e5%9d%97]]></wp:tag_slug>
		<wp:tag_name><![CDATA[分块]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>243</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%88%86%e7%b1%bb%e8%ae%a8%e8%ae%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[分类讨论]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>189</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[动态点分治]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>101</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:tag_slug>
		<wp:tag_name><![CDATA[动态规划]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>106</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:tag_slug>
		<wp:tag_name><![CDATA[单调队列/单调栈]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>126</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[可并堆]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>46</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89]]></wp:tag_slug>
		<wp:tag_name><![CDATA[各省省选]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>171</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[后缀数组]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>129</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[后缀自动机]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>113</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%af%e5%8f%91%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[启发式]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>86</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[回文树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>81</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[回文树/回文自动机]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>141</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[图论]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>158</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%a0%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[堆]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>3</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[字符串]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>48</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ae%b9%e6%96%a5]]></wp:tag_slug>
		<wp:tag_name><![CDATA[容斥]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>244</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[容斥原理]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>222</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b0%ba%e5%8f%96%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[尺取法]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>125</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b7%a6%e5%81%8f%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[左偏树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>80</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b7%ae%e5%88%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[差分]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>227</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[差分约束]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>111</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b3%e8%a1%a1%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[平衡树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>156</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be]]></wp:tag_slug>
		<wp:tag_name><![CDATA[平面图对偶图]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>66</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[并查集]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>228</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8b%93%e6%89%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[拓扑]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>165</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[搜索]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>11</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数论]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数论分块]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>223</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[整体二分]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>107</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[斜率优化]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>109</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[最短/长路]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>193</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%9e%84%e9%80%a0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[构造]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>239</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a0%91hash]]></wp:tag_slug>
		<wp:tag_name><![CDATA[树Hash]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>220</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a0%91%e5%a5%97%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[树套树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>187</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[树状数组]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>58</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a0%91%e9%93%be%e5%89%96%e5%88%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[树链剖分]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>117</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[概率/期望]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>202</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[模拟退火/爬山算法]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>12</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[欧拉函数]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>115</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[欧拉定理/扩展欧拉定理]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>151</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[点分治]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>102</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9]]></wp:tag_slug>
		<wp:tag_name><![CDATA[状态压缩]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>149</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%94%9f%e6%88%90%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[生成树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>242</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%9b%b4%e5%be%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[直径]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>179</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:tag_slug>
		<wp:tag_name><![CDATA[矩阵快速幂]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>4</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93]]></wp:tag_slug>
		<wp:tag_name><![CDATA[研究总结]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>74</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[离散化]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>59</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[离线处理]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>44</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[积性函数]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>191</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ba%bf%e6%80%a7%e5%9f%ba]]></wp:tag_slug>
		<wp:tag_name><![CDATA[线性基]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>45</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ba%bf%e6%80%a7%e7%ad%9b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[线性筛]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>60</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[线段树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>137</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6]]></wp:tag_slug>
		<wp:tag_name><![CDATA[线段树合并]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>95</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%bd%91%e7%bb%9c%e6%b5%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[网络流]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94]]></wp:tag_slug>
		<wp:tag_name><![CDATA[莫比乌斯反演]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>88</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[莫队算法]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>241</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%99%9a%e6%a0%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[虚树]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%a1%a5%e9%9b%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[补集]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>177</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[计算几何]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>216</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2]]></wp:tag_slug>
		<wp:tag_name><![CDATA[记忆化搜索]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>135</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[贪心]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>118</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%80%86%e5%85%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[逆元]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>94</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%9a%8f%e6%9c%ba%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[随机化]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>51</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[高斯消元]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>154</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[高维前缀和]]></wp:tag_name>
	</wp:tag>
	<wp:term>
		<wp:term_id><![CDATA[246]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[2-sat]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[2-sat]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[82]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[51nod]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[51nod]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[172]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[AC自动机]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[238]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[aizu]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Aizu]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[134]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[apio]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[APIO]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[163]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bkdrhash]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[BKDRHash]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[39]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bzoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[BZOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[207]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[cdq%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CDQ分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[link_category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[cj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[76]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[codechef]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Codechef]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[206]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[codeforces]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Codeforces]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[147]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ctsc]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CTSC]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[174]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[dfs%e5%ba%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[dfs序]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[196]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[fft]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[FFT]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[162]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hash]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Hash]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hdu]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[HDU]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[170]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hihocoder]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[hihocoder]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[160]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ioi]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[IOI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[232]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[kdt]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[KDT]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[140]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[kmp]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[KMP]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[78]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[lca]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[LCA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[65]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[link-cut-tree]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Link-Cut-Tree]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[68]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[loj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[LOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[42]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[luogu]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Luogu]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[235]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[nav_menu]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[main]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[main]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[197]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[manacher]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Manacher]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[49]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mine]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[mine]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[40]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[noi]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[NOI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[oj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[OJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[230]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pa]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[PA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[219]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[poi]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[POI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[poj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[POJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[poj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[POJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[123]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[scu]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[SCU]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[127]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[scu]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[SCU]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[128]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[snmoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[SNMOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[SPOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[spoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[SPOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[181]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[st%e8%a1%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ST表]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[145]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[tarjan]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Tarjan]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[203]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[topcoder]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[Topcoder]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[204]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[topcoder]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Topcoder]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[214]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[trie%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Trie树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Uncategorized]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[69]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[UOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[70]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[UOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[183]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[usaco]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[USACO]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uva]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[UVA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uva]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[UVA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[6]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[wordpress]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[wordpress]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[7]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[wordpress]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[wordpress]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[zoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[ZOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[124]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[zoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ZOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[72]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%b8%bb%e5%b8%ad%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[主席树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[62]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[二分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[120]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%88%86%e5%9b%be]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[二分图]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[200]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[决策单调性]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[90]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e5%9d%97]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[分块]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[243]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e7%b1%bb%e8%ae%a8%e8%ae%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[分类讨论]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[189]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[动态点分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[101]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[106]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[单调队列/单调栈]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[link_category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%8b%e6%83%85%e9%93%be%e6%8e%a5]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[友情链接]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[126]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[可并堆]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[46]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[各省省选]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[171]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[后缀数组]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[129]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[后缀自动机]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[113]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%af%e5%8f%91%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[启发式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[86]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[回文树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[81]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[回文树/回文自动机]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[141]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[图论]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[158]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%a0%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[堆]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[字符串]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[48]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ae%b9%e6%96%a5]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[容斥]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[244]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[容斥原理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[222]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b0%ba%e5%8f%96%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[尺取法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[125]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%a6%e5%81%8f%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[左偏树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[80]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%ae%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[差分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[227]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[差分约束]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[111]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b3%e8%a1%a1%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[平衡树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[156]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[平面图对偶图]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[66]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[并查集]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[144]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%be%85%e5%a1%ab%e5%9d%91-%e5%be%85%e6%9b%b4%e6%96%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[待填坑/待更新]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[228]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8b%93%e6%89%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[拓扑]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[165]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数学]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[数学思想]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[53]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数据结构]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[8]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[数论]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数论]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[数论分块]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数论分块]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[223]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[整体二分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[107]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[斜率优化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[109]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[最短/长路]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[193]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9e%84%e9%80%a0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[构造]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[239]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91hash]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[树Hash]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[217]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e5%a5%97%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[树套树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[220]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e5%a5%97%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[树套树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[185]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[树状数组]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[187]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[树状数组]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[54]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e9%93%be%e5%89%96%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[树链剖分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[58]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e9%93%be%e5%89%96%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[树链剖分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[117]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[概率/期望]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[202]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[模拟退火/爬山算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[9]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[欧拉函数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[欧拉函数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[114]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[欧拉定理/扩展欧拉定理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[115]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[欧拉定理/扩展欧拉定理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[2]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%b5%8b%e8%af%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[测试]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[150]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[点分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[151]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[点分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[102]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[状态压缩]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[149]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%94%9f%e6%88%90%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[生成树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[242]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%9b%b4%e5%be%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[直径]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[35]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[真题]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[178]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[矩阵快速幂]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[179]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[矩阵快速幂]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[研究总结]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[10]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[研究总结]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[74]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[离散化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[59]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[离线处理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[43]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[积性函数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[44]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[积性函数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[52]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[190]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%80%a7%e5%9f%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[线性基]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[191]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%80%a7%e5%9f%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线性基]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[45]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%80%a7%e7%ad%9b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线性筛]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[57]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[线段树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[60]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线段树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[136]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91]]></wp:term_parent>
		<wp:term_name><![CDATA[线段树合并]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[137]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线段树合并]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[248]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[组合数学]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[253]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bb%bc%e5%90%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[综合]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[95]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bd%91%e7%bb%9c%e6%b5%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[网络流]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[莫比乌斯反演]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[莫比乌斯反演]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[87]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[莫队算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[88]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[莫队算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[240]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%99%9a%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[虚树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[241]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%99%9a%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[虚树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%a1%a5%e9%9b%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[补集]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%a1%a5%e9%9b%86%e6%80%9d%e6%83%b3]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[补集思想]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[175]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[计算几何]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[177]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[计算几何]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[216]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[记忆化搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[135]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[贪心]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[116]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%80%86%e5%85%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[逆元]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[118]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%80%86%e5%85%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[逆元]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[55]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[重要思想]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[92]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9a%8f%e6%9c%ba%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[随机化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[94]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9a%8f%e6%9c%ba%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[随机化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[50]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[高斯消元]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[51]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[高斯消元]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[153]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[高维前缀和]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[154]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[高维前缀和]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[83]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[51nod]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[51nod]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[237]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[aizu]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[Aizu]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[105]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[apio]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[APIO]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[250]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bsgs-%e6%89%a9%e5%b1%95bsgs]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[BSGS/扩展BSGS]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bzoj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[BZOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[75]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[codechef]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[Codechef]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[205]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[codeforces]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[Codeforces]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[146]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ctsc]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[CTSC]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[173]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[dfs%e5%ba%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[dfs序]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[195]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[fft]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[FFT]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hdu]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[HDU]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[169]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hihocoder]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[hihocoder]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[159]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ioi]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[IOI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[231]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[kdt]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[KDT]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[77]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[lca]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[LCA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[63]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[link-cut-tree]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[Link-Cut-Tree]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[67]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[loj]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[LOJ]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[41]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[luogu]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[Luogu]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[noi]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[NOI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[noip]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[NOIP]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[254]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[nowcoder]]></wp:term_slug>
		<wp:term_parent><![CDATA[oj]]></wp:term_parent>
		<wp:term_name><![CDATA[nowcoder]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[229]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pa]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[PA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[218]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[poi]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[POI]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[180]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[st%e8%a1%a8]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[ST表]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[182]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[usaco]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[USACO]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[71]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%b8%bb%e5%b8%ad%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[主席树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[61]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[二分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[89]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e5%9d%97]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[分块]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[208]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[188]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[动态点分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[98]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[103]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[单调队列/单调栈]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[122]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[可并堆]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%9c%9f%e9%a2%98]]></wp:term_parent>
		<wp:term_name><![CDATA[各省省选]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[176]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%91%e9%87%8f%e7%82%b9%e7%a7%af-%e5%8f%89%e7%a7%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95]]></wp:term_parent>
		<wp:term_name><![CDATA[向量点积/叉积]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[112]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%af%e5%8f%91%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[启发式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[142]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%be%e4%b8%8a%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[图上动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[96]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[图论]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[212]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%9f%ba%e7%8e%af%e6%a0%91%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[基环树动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[157]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%a0%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[堆]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[138]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[字符串]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[161]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2hash]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[字符串Hash]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[47]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[容斥原理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[221]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b0%ba%e5%8f%96%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[尺取法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[168]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%a6%e5%81%8f%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86]]></wp:term_parent>
		<wp:term_name><![CDATA[左偏树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[79]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%ae%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[差分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[224]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[差分约束]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[110]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b3%e8%a1%a1%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[平衡树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[155]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[平面图对偶图]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[64]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b6%e6%9f%a5%e9%9b%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84]]></wp:term_parent>
		<wp:term_name><![CDATA[并查集]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[252]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[拉格朗日插值法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[225]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8b%93%e6%89%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[拓扑]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[164]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%ae%97%e6%b3%95]]></wp:term_parent>
		<wp:term_name><![CDATA[搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[152]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[数位动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[210]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%88%86%e6%b2%bb]]></wp:term_parent>
		<wp:term_name><![CDATA[整体二分]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[104]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[斜率优化动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[108]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[最短/长路径]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[192]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9e%84%e9%80%a0]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[构造]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[236]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91hash]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[树Hash]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[211]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[树型动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[99]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[概率动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[201]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:term_parent>
		<wp:term_name><![CDATA[模拟退火/爬山算法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[100]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[状态压缩]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[132]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[状态压缩动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[148]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%94%9f%e6%88%90%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[生成树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[251]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[矩阵树定理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[73]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a6%bb%e6%95%a3%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[离散化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[56]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[离线处理]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[249]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ac%ac%e4%b8%80%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6]]></wp:term_parent>
		<wp:term_name><![CDATA[第一类斯特林数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[97]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bd%91%e7%bb%9c%e6%b5%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[网络流]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[131]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[计数动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[215]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:term_parent>
		<wp:term_name><![CDATA[记忆化搜索]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[133]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b4%aa%e5%bf%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3]]></wp:term_parent>
		<wp:term_name><![CDATA[贪心]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[245]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[2-sat]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[2-sat]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[167]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ac%e8%87%aa%e5%8a%a8%e6%9c%ba]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[AC自动机]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[209]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[cdq%e5%88%86%e6%b2%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%88%86%e6%b2%bb]]></wp:term_parent>
		<wp:term_name><![CDATA[CDQ分治]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[139]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[kmp]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[KMP]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[194]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[manacher]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[Manacher]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[143]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[tarjan]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[Tarjan]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[213]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[trie%e6%a0%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[Trie树]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[119]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8c%e5%88%86%e5%9b%be]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%9b%be%e8%ae%ba]]></wp:term_parent>
		<wp:term_name><![CDATA[二分图]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[198]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]]></wp:term_parent>
		<wp:term_name><![CDATA[决策单调性动态规划]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[166]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:term_parent>
		<wp:term_name><![CDATA[后缀数组]]></wp:term_name>
	</wp:term>
	<wp:term><wp:term_id>235</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[main]]></wp:term_slug><wp:term_name><![CDATA[main]]></wp:term_name>
</wp:term>

	<generator>https://wordpress.org/?v=4.9.9</generator>

<image>
	<url>http://sycstudio.com/wp-content/uploads/2018/02/cropped-head-1-32x32.png</url>
	<title>SYCstudio</title>
	<link>http://sycstudio.com</link>
	<width>32</width>
	<height>32</height>
</image> 

	<item>
		<title>cropped-53369934_p0.jpg</title>
		<link>http://sycstudio.com/cropped-53369934_p0-jpg/</link>
		<pubDate>Sun, 07 Jan 2018 07:51:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/01/cropped-53369934_p0.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[http://sycstudio.com/wp-content/uploads/2018/01/cropped-53369934_p0.jpg]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>93</wp:post_id>
		<wp:post_date><![CDATA[2018-01-06 23:51:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-07 07:51:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-53369934_p0-jpg]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/01/cropped-53369934_p0.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/01/cropped-53369934_p0.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[site-icon]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:31:"2018/01/cropped-53369934_p0.jpg";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:31:"cropped-53369934_p0-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:31:"cropped-53369934_p0-300x300.jpg";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:10:"image/jpeg";}s:13:"site_icon-270";a:4:{s:4:"file";s:31:"cropped-53369934_p0-270x270.jpg";s:5:"width";i:270;s:6:"height";i:270;s:9:"mime-type";s:10:"image/jpeg";}s:13:"site_icon-192";a:4:{s:4:"file";s:31:"cropped-53369934_p0-192x192.jpg";s:5:"width";i:192;s:6:"height";i:192;s:9:"mime-type";s:10:"image/jpeg";}s:13:"site_icon-180";a:4:{s:4:"file";s:31:"cropped-53369934_p0-180x180.jpg";s:5:"width";i:180;s:6:"height";i:180;s:9:"mime-type";s:10:"image/jpeg";}s:12:"site_icon-32";a:4:{s:4:"file";s:29:"cropped-53369934_p0-32x32.jpg";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>bzoj2005</title>
		<link>http://sycstudio.com/archives/186/bzoj2005/</link>
		<pubDate>Tue, 16 Jan 2018 13:40:30 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/01/bzoj2005.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>192</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 05:40:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-16 13:40:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2005]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>186</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/01/bzoj2005.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:520;s:6:"height";i:436;s:4:"file";s:20:"2018/01/bzoj2005.jpg";s:5:"sizes";a:2:{s:9:"thumbnail";a:4:{s:4:"file";s:20:"bzoj2005-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:20:"bzoj2005-300x252.jpg";s:5:"width";i:300;s:6:"height";i:252;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/01/bzoj2005.jpg]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>湖南省队集训2013day7T1sol</title>
		<link>http://sycstudio.com/archives/470/%e6%b9%96%e5%8d%97%e7%9c%81%e9%98%9f%e9%9b%86%e8%ae%ad2013day7t1sol/</link>
		<pubDate>Fri, 02 Feb 2018 12:13:19 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>471</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:13:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:13:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b9%96%e5%8d%97%e7%9c%81%e9%98%9f%e9%9b%86%e8%ae%ad2013day7t1sol]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>470</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:991;s:6:"height";i:340;s:4:"file";s:44:"2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:44:"08b351bf1f0b5abf6c96dca75fb9c6d1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:44:"08b351bf1f0b5abf6c96dca75fb9c6d1-300x103.png";s:5:"width";i:300;s:6:"height";i:103;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:44:"08b351bf1f0b5abf6c96dca75fb9c6d1-768x263.png";s:5:"width";i:768;s:6:"height";i:263;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2018-02-02 20-34-22屏幕截图</title>
		<link>http://sycstudio.com/2018-02-02-20-34-22%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be/</link>
		<pubDate>Fri, 02 Feb 2018 12:34:43 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/6b76c88e1cb3223fed264246defc621f.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>472</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:34:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:34:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[2018-02-02-20-34-22%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/6b76c88e1cb3223fed264246defc621f.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/6b76c88e1cb3223fed264246defc621f.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:841;s:6:"height";i:376;s:4:"file";s:44:"2018/02/6b76c88e1cb3223fed264246defc621f.png";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:44:"6b76c88e1cb3223fed264246defc621f-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:44:"6b76c88e1cb3223fed264246defc621f-300x134.png";s:5:"width";i:300;s:6:"height";i:134;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:44:"6b76c88e1cb3223fed264246defc621f-768x343.png";s:5:"width";i:768;s:6:"height";i:343;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2018-02-02 21-00-04屏幕截图</title>
		<link>http://sycstudio.com/2018-02-02-21-00-04%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be/</link>
		<pubDate>Fri, 02 Feb 2018 13:00:21 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/9b271accda790e22924ce99052694f28.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>475</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 21:00:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 13:00:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[2018-02-02-21-00-04%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/9b271accda790e22924ce99052694f28.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/9b271accda790e22924ce99052694f28.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:931;s:6:"height";i:834;s:4:"file";s:44:"2018/02/9b271accda790e22924ce99052694f28.png";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:44:"9b271accda790e22924ce99052694f28-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:44:"9b271accda790e22924ce99052694f28-300x269.png";s:5:"width";i:300;s:6:"height";i:269;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:44:"9b271accda790e22924ce99052694f28-768x688.png";s:5:"width";i:768;s:6:"height";i:688;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>prob</title>
		<link>http://sycstudio.com/prob/</link>
		<pubDate>Sat, 10 Feb 2018 14:49:44 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/prob.pdf</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>501</wp:post_id>
		<wp:post_date><![CDATA[2018-02-10 22:49:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-10 14:49:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[prob]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/prob.pdf]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/prob.pdf]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[105]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>head</title>
		<link>http://sycstudio.com/head/</link>
		<pubDate>Wed, 21 Feb 2018 10:58:27 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/head.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>527</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 18:58:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 10:58:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[head]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/head.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/head.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:200;s:6:"height";i:200;s:4:"file";s:16:"2018/02/head.png";s:5:"sizes";a:1:{s:9:"thumbnail";a:4:{s:4:"file";s:16:"head-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-head.png</title>
		<link>http://sycstudio.com/cropped-head-png/</link>
		<pubDate>Wed, 21 Feb 2018 10:58:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/cropped-head.png</guid>
		<description></description>
		<content:encoded><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/cropped-head.png]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>528</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 18:58:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 10:58:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-head-png]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/cropped-head.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/cropped-head.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[site-icon]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:24:"2018/02/cropped-head.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:24:"cropped-head-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:24:"cropped-head-300x300.png";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-270";a:4:{s:4:"file";s:24:"cropped-head-270x270.png";s:5:"width";i:270;s:6:"height";i:270;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-192";a:4:{s:4:"file";s:24:"cropped-head-192x192.png";s:5:"width";i:192;s:6:"height";i:192;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-180";a:4:{s:4:"file";s:24:"cropped-head-180x180.png";s:5:"width";i:180;s:6:"height";i:180;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-32";a:4:{s:4:"file";s:22:"cropped-head-32x32.png";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>文章总览</title>
		<link>http://sycstudio.com/article/</link>
		<pubDate>Tue, 20 Mar 2018 08:17:01 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?page_id=556</guid>
		<description></description>
		<content:encoded><![CDATA[[cleanarchivesreloaded]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>556</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 16:17:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 08:17:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[article]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[893]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-head-1.png</title>
		<link>http://sycstudio.com/cropped-head-1-png/</link>
		<pubDate>Fri, 11 May 2018 13:06:27 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/02/cropped-head-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/cropped-head-1.png]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>659</wp:post_id>
		<wp:post_date><![CDATA[2018-05-11 21:06:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-11 13:06:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-head-1-png]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/02/cropped-head-1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[site-icon]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:26:"2018/02/cropped-head-1.png";s:5:"sizes";a:7:{s:9:"thumbnail";a:4:{s:4:"file";s:26:"cropped-head-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:26:"cropped-head-1-300x300.png";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:26:"cropped-head-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-270";a:4:{s:4:"file";s:26:"cropped-head-1-270x270.png";s:5:"width";i:270;s:6:"height";i:270;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-192";a:4:{s:4:"file";s:26:"cropped-head-1-192x192.png";s:5:"width";i:192;s:6:"height";i:192;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-180";a:4:{s:4:"file";s:26:"cropped-head-1-180x180.png";s:5:"width";i:180;s:6:"height";i:180;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-32";a:4:{s:4:"file";s:24:"cropped-head-1-32x32.png";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/02/cropped-head-1.png]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>公告&amp;施工日志</title>
		<link>http://sycstudio.com/announcement/</link>
		<pubDate>Fri, 11 May 2018 13:50:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?page_id=712</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

这里是SYCstudio
坐标HN-CS-CJ
高一萌新蒟蒻
欢迎交流
<a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=yLuxq7u8vayhp4i5uearp6U" style="text-decoration:none;"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_02.png"/></a>
<del>欢迎友链，在下面申请就可以了</del>（呜呜，友联挂掉啦，什么时候修好再说）

<h1>施工日志</h1>

博客仍然在施工中……
如果出现问题，请在留言板向我反馈，我会尽快修复
2017.12.23 域名购买及备案完成
2017.12.30 空间准备完成，wordpress上传
2017.12.31 采用hzwer的主题
2018.1.1 2048及2147483648上线
2018.1.1 完成Latex公式支持和Markdown语法支持
2018.1.5 离线BZOJ上线
2018.1.7 统计上线，一言上线
2018.1.12 设置全局评论关键字屏蔽，具体参见本站说明
2018.1.21 升级至wordpress4.9.2
2018.1.23 更改部分css，修复页面在不同分辨率下显示的BUG，修复wp-Cumulus的BUG，修复文字遮盖下一行的BUG
2018.1.27 鉴于乱膜现象严重，开启全站审核
2018.1.28 在后台发现奇怪的注册用户，现已停止开放注册，如有需要注册，请与博主联系在后台修改
2018.3.24 在更新markdown解析器后修复了删除线的解析错误
2018.4.1 升级至wordpress4.9.4，同时更新了markdown解析器，现在已经支持github清单。
2018.4.8 优化了一下访问速度。去掉了原来比较耗时的Google Analize相关代码。
2018.5.11 正式弃用hzwer较多BUG的博客模板，现在改用$$Akina-Siren$$主题，由<a href="http://skyarea.cn/archives/466">keith</a>开发，修复了一些兼容的问题
2018.5.14 经过3天紧张的施工，$$live2d$$正式上线啦

<h1>BUG反馈</h1>

本人并不会多少$$html,php,css$$技术，博客很有可能出现奇怪的错误。如果出现问题（特别是数学公式出鬼或是图片加载不了），请统一在这里回复我。
目前已经发现的问题
<del>1.侧边栏最新评论的评论人会全部变成当前所在文章的最新评论人。（这个BUG是hzwer模板上的，目前没有找到好的解决办法，只能先去掉最新评论）</del>已弃用hzwer主题
2.$$2147483648$$会无故GameOver或者是渲染出错。（感谢TPLY<del>在颓的时候</del>找到了这个错误，不过似乎出现概率比较低？）
<del>3.markdown无法渲染删除线（正在抢修）</del>(修复完成)
4.数字字母加载不出。这个问题主要出现在&#92;(bzojch&#92;)和后台，对阅读影响不大。目测原因是字体文件缺失。（解决办法：如果您在阅读文章时出现了这类错误，可以到浏览器设置中设置不允许页面使用自己的字体）
<del>5.用户注册可能出现注册不成功，请与我联系在后台修改</del>（已经修复完毕，是邮件的错误）
6.另，自2018.5.11后更新博客主题，一些功能或链接可能失效，目前正在抢修的有：友联，分类目录，标签分类，bzojch，2048，2147483648。另考虑恢复侧边栏？]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>712</wp:post_id>
		<wp:post_date><![CDATA[2018-05-11 21:50:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-11 13:50:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[announcement]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[703]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://sycstudio.com/?p=831</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=831</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>831</wp:post_id>
		<wp:post_date><![CDATA[2018-05-12 20:00:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>13</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[taxonomy]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[75]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[category]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://sycstudio.com/archives/854</link>
		<pubDate>Sat, 12 May 2018 12:23:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=854</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>854</wp:post_id>
		<wp:post_date><![CDATA[2018-05-12 20:23:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-12 12:23:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[854]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[712]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://sycstudio.com/archives/855</link>
		<pubDate>Sat, 12 May 2018 12:23:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=855</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>855</wp:post_id>
		<wp:post_date><![CDATA[2018-05-12 20:23:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-12 12:23:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[855]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>5</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[556]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://sycstudio.com/archives/856</link>
		<pubDate>Sat, 12 May 2018 12:23:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=856</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>856</wp:post_id>
		<wp:post_date><![CDATA[2018-05-12 20:23:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-12 12:23:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[856]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>6</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[post]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[141]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://sycstudio.com/archives/857</link>
		<pubDate>Sat, 12 May 2018 12:23:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=857</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>857</wp:post_id>
		<wp:post_date><![CDATA[2018-05-12 20:23:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-12 12:23:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[857]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[post]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[78]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>SYCOJ</title>
		<link>http://sycstudio.com/archives/911</link>
		<pubDate>Thu, 31 May 2018 10:34:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=911</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>911</wp:post_id>
		<wp:post_date><![CDATA[2018-05-31 18:34:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-31 10:34:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[sycoj]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[911]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://oj.sycstudio.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cs</title>
		<link>http://sycstudio.com/cs/</link>
		<pubDate>Wed, 26 Sep 2018 06:34:10 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/09/cs.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>948</wp:post_id>
		<wp:post_date><![CDATA[2018-09-26 14:34:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-26 06:34:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cs]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/09/cs.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/09/cs.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:4160;s:6:"height";i:3120;s:4:"file";s:14:"2018/09/cs.jpg";s:5:"sizes";a:5:{s:9:"thumbnail";a:4:{s:4:"file";s:14:"cs-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:14:"cs-300x225.jpg";s:5:"width";i:300;s:6:"height";i:225;s:9:"mime-type";s:10:"image/jpeg";}s:12:"medium_large";a:4:{s:4:"file";s:14:"cs-768x576.jpg";s:5:"width";i:768;s:6:"height";i:576;s:9:"mime-type";s:10:"image/jpeg";}s:5:"large";a:4:{s:4:"file";s:15:"cs-1024x768.jpg";s:5:"width";i:1024;s:6:"height";i:768;s:9:"mime-type";s:10:"image/jpeg";}s:14:"post-thumbnail";a:4:{s:4:"file";s:14:"cs-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"2";s:6:"credit";s:0:"";s:6:"camera";s:8:"SLA-AL00";s:7:"caption";s:0:"";s:17:"created_timestamp";s:10:"1504032004";s:9:"copyright";s:0:"";s:12:"focal_length";s:4:"3.54";s:3:"iso";s:3:"100";s:13:"shutter_speed";s:11:"0.004272972";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_is_custom_background]]></wp:meta_key>
			<wp:meta_value><![CDATA[ASky]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>archives-949-pic1</title>
		<link>http://sycstudio.com/20171211134651684/</link>
		<pubDate>Wed, 26 Sep 2018 16:10:03 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/wp-content/uploads/2018/09/20171211134651684.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>950</wp:post_id>
		<wp:post_date><![CDATA[2018-09-27 00:10:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-26 16:10:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[20171211134651684]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://sycstudio.com/wp-content/uploads/2018/09/20171211134651684.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/09/20171211134651684.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:713;s:6:"height";i:613;s:4:"file";s:29:"2018/09/20171211134651684.png";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:29:"20171211134651684-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:29:"20171211134651684-300x258.png";s:5:"width";i:300;s:6:"height";i:258;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:29:"20171211134651684-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Vnote</title>
		<link>http://sycstudio.com/archives/1002</link>
		<pubDate>Sun, 25 Nov 2018 11:16:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1002</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1002</wp:post_id>
		<wp:post_date><![CDATA[2018-11-25 19:16:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-25 11:16:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[vnote]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[main]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://sycstudio.com/vnote]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[1002]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>本站说明&amp;留言版</title>
		<link>http://sycstudio.com/archives/78</link>
		<pubDate>Sun, 07 Jan 2018 06:12:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=78</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>本站说明</h1>

本站由SYCstudio建于2017.12.23
基于$$wordpress$$搭建，主题采用<del><a href="http://hzwer.com" title="hzwer">hzwer</a></del>现在已改成<a href="http://skyarea.cn/archives/466">keith</a>的主题

<h1>鸣谢</h1>

感谢$$Matt Mullenweg$$及其他作者制作的&#92;(wordpress&#92;)提供自由、开放的博客搭建平台
<del>感谢<a href="http://hzwer.com">hzwer</a>和<a href="http://lianyue.org">lianyue</a>强大的博客主题</del>
感谢<a href="http://ruanx.pw/">阮行止</a>的BZOJ离线题库:&#92;(BZOJCH&#92;)，下面是其<a href="https://github.com/Ruanxingzhi/bzojch">github地址</a>
感谢<a href="https://github.com/CyberZHG?tab=repositories">Zhao HG</a>的2147483647和<a href="https://github.com/gabrielecirulli">gabrielecirulli</a>的2048<del>为广大oier提供了简易的颓废工具</del>

<h1>本站的一些工具<del>和颓废</del>的入口</h1>

<a href="http://sycstudio.com/bzojch/">BZOJ离线版</a>
<a href="http://sycstudio.com/game/2048/">2048</a>
<a href="http://sycstudio.com/game/2147483648/">2147483648</a>
另：我的旧博客地址:<a href="http://cnblogs.com/sycstudio">cnblogs</a>

<h1>一些说明</h1>

<h2>评论审核</h2>

为了维护和谐的博客环境，拒绝虚伪风气蔓延，本站已开启评论审核，包含以下关键字的评论（包括评论内容，评论人名字等等，只要是你输入的内容）将被审核。为了方便您的交流，请不要使用以下审核关键字
当前审核关键字：（更新于2018.1.19）
Upt：2018.1.22感谢xzz提供了新的审核关键字
Upt：2018.1.24感谢k-xzy提供了新的审核关键字
Upt：2018.1.25感谢hjt提供了新的审核关键字
Upt：2018.1.27介于乱膜现象严重，本站已全面开启评论审核，所有评论均要经过审核才能公开，如果有急事需要询问博主，可以通过邮箱交流

<pre data-language=><code class=" line-numbers">orz
Orz
ORZ
OTZ
蒟蒻
大佬
%
STO
stO
dalao
膜
srO
OΩ
0TZ
ST0
Grz
强无敌
crz
</code></pre>

如果还有新的关键字，会及时更新]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>78</wp:post_id>
		<wp:post_date><![CDATA[2018-01-06 22:12:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-07 06:12:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%ac%e7%ab%99%e8%af%b4%e6%98%8e]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="wordpress"><![CDATA[wordpress]]></category>
		<category domain="post_tag" nicename="wordpress"><![CDATA[wordpress]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2441]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>109</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.29.217]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-08 12:48:31]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-08 04:48:31]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[啥？反正第一次听就是您讲的，就是您讲的了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>107</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>81</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 11:09:17]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 03:09:17]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[萝卜，为什么我在回收站发现了你的评论？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>76</wp:comment_id>
			<wp:comment_author><![CDATA[iot]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3057244225@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-03 10:59:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-03 02:59:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[观光]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>24</wp:comment_id>
			<wp:comment_author><![CDATA[k-XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 16:17:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 08:17:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[(和谐)太强了mol mol mol
MMP去你的违禁字符QvQ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 17:27:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 09:27:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[违禁字已和谐。
（注意是用户名里面也不能出现违禁字的）
拒绝虚伪风气蔓延，共建和谐博客环境\滑稽]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[蒟蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 18:56:58]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 10:56:58]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[啊？
我不是写了（和谐）咩
注意是0
不是O
还有我觉得禁掉了百分号会不会不太好QvQ
万一，，，以后要发代码，里面要取模捏？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>28</wp:comment_id>
			<wp:comment_author><![CDATA[蒟蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 18:59:23]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 10:59:23]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[QvQ我怎么提供了新的关键字=。=
QvQ
那干脆还是
(和谐)太强了!]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[litble]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[litble@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/litble/article/list/1</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 21:02:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 13:02:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[（和谐） SYC 真是too strong.我等（和谐）难以瞻您后尘啊......
(话说您开了(和谐)真是让人更想（和谐）了呢=w=)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>30</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 22:36:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 14:36:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哦，是的，原来写错啦，已经改好了。
另外提醒您一句，您的名字里面有关键字juruo所以每一次都会被审核。。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>27</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>31</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:12:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:12:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你们都这么强，我们这些菜鸡瑟瑟发抖]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>29</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>32</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:12:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:12:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我们都太（和谐）了，强无敌呗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>33</wp:comment_id>
			<wp:comment_author><![CDATA[TPLY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1727367172@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:16:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:16:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[太强了！！！
(和谐)(和谐)(和谐)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>4</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>69</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:59:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:59:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哦，我知道了，没有设置权限，现在已经好了
另：权限说明
①订阅者：只有阅读权限，可以修改自己的个人资料，例如昵称、联系信息、密码等。
②投稿者：具有订阅者的所有权限。可以发表文章，但需要经过管理员审核后才能在博客上显示出来；对待审中的文章可以编辑，但对已通过审核的文章不能编辑。
③作者：具有投稿者的所有权限。发布文章不需要审核，并且可以编辑已通过审核的文章，还可以上传文件和使用媒体库。
④编辑：具有作者的所有权限。可以对文章标签、分类进行管理，可以添加或编辑页面，可以管理友情链接、可以上传文件等等。编辑拥有除系统功能设置外的所有权限。
⑤管理员：可以控制用户写文章、创建页面、管理插件、管理主题，以及管理其他用户的权限。管理员可以通过后天分配用户权限。
现在已经全部设置为作者了！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>66</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>68</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:58:25]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:58:25]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[？？？应该是可以的啊？？？
你再试试？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>66</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>66</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.52]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:22:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:22:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我感觉很迷...,因为那篇文章有问题要改]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>65</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.54]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:15:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:15:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[为什么我不能编辑我写的文章？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>46</wp:comment_id>
			<wp:comment_author><![CDATA[lrj124]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1584634848@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/lrj124</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[124.226.40.221]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 22:56:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 14:56:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<del datetime="2018-01-25T15:21:40+00:00">Θrz</del>
（和谐）]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>82</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.67.125]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 11:11:16]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 03:11:16]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[因为有人冒充它人ID
警告这个IP的人：61.187.87.194]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>81</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>83</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:04:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:04:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是机房的IP啊。我记得球爷在机房了发了一个。我自己在机房了在我的文章下发一个试试。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>82</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>86</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.5.120]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:18:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:18:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我严重怀疑是xzz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>85</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>87</wp:comment_id>
			<wp:comment_author><![CDATA[TPLY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1727367172@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-06 07:57:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 23:57:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[申请友链]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>4</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>85</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:08:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:08:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我看了一下，这是机房的IP。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>82</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>88</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.3.198]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-06 13:35:38]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-06 05:35:38]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已加！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>87</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>89</wp:comment_id>
			<wp:comment_author><![CDATA[ju蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.k-xzy.xyz</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 11:05:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 03:05:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[QvQ
julao%%%%Orz
我的博客更换了地址啦，已经不是k-xzy.cf了
换成了www.k-xzy.xyz
请问能否麻烦您更新一下友链呢？
谢谢您啦！QvQ
（我才不会告诉你我这段换都是复制的呢）]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>90</wp:comment_id>
			<wp:comment_author><![CDATA[WHZ0325]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wuhaozhong0325@sina.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://whzstudio.coding.me</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.77.57.22]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 12:24:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 04:24:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[来自HA的高一蒟蒻OIer求加友链～～]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>91</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.190.129]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 14:50:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 06:50:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已更改]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>89</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>92</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.6.165]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 22:44:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 14:44:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已经加了！
互相学习吧！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>90</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>103</wp:comment_id>
			<wp:comment_author><![CDATA[Cyhlnj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1806599497@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-26 19:38:25]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-26 11:38:25]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我要你的练习计划密码]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>9</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>106</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-26 20:24:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-26 12:24:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已发]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>103</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>107</wp:comment_id>
			<wp:comment_author><![CDATA[wfj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[653496492@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-06 15:16:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-06 07:16:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嗯。。你那个一言里面那句话不是我讲的，我也不记得是谁讲的了。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>112</wp:comment_id>
			<wp:comment_author><![CDATA[xzz]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xuzhouzi@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/xzz_233</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-30 17:05:52]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-30 09:05:52]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[61.187.87.194是机房IP啊，你想封掉自己？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>113</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.218]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-30 23:48:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-30 15:48:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是你跳的理由]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>112</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>119</wp:comment_id>
			<wp:comment_author><![CDATA[chazz]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xuzhouzi@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/xzz_233</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-02 19:48:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-02 11:48:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[瑟瑟发抖(和谐)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>113</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>125</wp:comment_id>
			<wp:comment_author><![CDATA[FlashHu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[flash-hu@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/flashhu</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-11 19:37:53]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-11 11:37:53]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[（和谐）
（和谐）申请友链qwq]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>128</wp:comment_id>
			<wp:comment_author><![CDATA[hz2016]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[root@hz2016.cn]]></wp:comment_author_email>
			<wp:comment_author_url>https://hz2016.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.142.103.99]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-04 13:29:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-04 05:29:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[求加qq另外你blogcss文件爆炸。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>129</wp:comment_id>
			<wp:comment_author><![CDATA[hz2016]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[root@hz2016.cn]]></wp:comment_author_email>
			<wp:comment_author_url>https://hz2016.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.142.103.99]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-04 13:31:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-04 05:31:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[忘了发qq，我找不到你qq，762670604]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>173</wp:comment_id>
			<wp:comment_author><![CDATA[路人甲]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3838383838@38.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.136.30.200]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-11-12 15:21:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-11-12 07:21:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个感觉很费流量]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>欧拉函数</title>
		<link>http://sycstudio.com/archives/96</link>
		<pubDate>Thu, 11 Jan 2018 16:08:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>欧拉函数</h1>

<h1>定义</h1>

定义&#92;(\phi(i)&#92;)为<strong>不大于</strong>&#92;(i&#92;)的与&#92;(i&#92;)互质的数的个数，公式表达为
&#92;[\sum&#95;{i=1}^{n-1}[gcd(i,n)==1]&#92;]
规定：&#92;(\phi(1)=1&#92;)

<h2>基本计算公式</h2>

&#92;[\phi(x)=x(1-\frac{1}{p&#95;1})(1-\frac{1}{p&#95;2})...(1-\frac{1}{p&#95;n})&#92;]其中&#92;(p&#95;1,p&#95;2....p&#95;n&#92;)为&#92;(x&#92;)的质因子
这个公式比较直观，即对于数&#92;(x&#92;)来说，有&#92;(x-1&#92;)个比它小的数，枚举&#92;(x&#92;)的因子在这些数中删去它们，最后剩下的就是与&#92;(x&#92;)互质且小于x的数了

<h1>基本性质</h1>

<h2>性质1</h2>

<blockquote>
  对于任意质数&#92;(p&#92;)，&#92;(\phi(p)=p-1&#92;)
</blockquote>

证明：这个比较好想，对于任意一个质数，小于它的数都与它互质

<h2>性质2</h2>

<blockquote>
  对于任意质数$$p$$，$$\phi(p^k)=(p-1)&#42;p^{k-1}$$
</blockquote>

证明：根据基本公式$$\phi(p^k)=p^k&#42;(1-\frac{1}{p})=p^k&#42;\frac{p-1}{p}=p^{k-1}$$

<h2>性质3</h2>

<blockquote>
  $$\phi(xy)=\phi(x)&#42;\phi(y)$$其中$$gcd(x,y)==1$$
</blockquote>

这个可以由欧拉函数是积性函数推出来

#欧拉函数的求法
知道了上面的若干性质，有什么用呢？它们可以用来求解欧拉函数

<h2>单个欧拉函数的求法</h2>

直接运用基本公式求解。对于数$$x$$分解出它的每一个质因子$$p$$，依次计算即可
由于考虑到一个数$$x$$最多只会有一个大于$$\sqrt{x}$$的因子，所以可以只枚举到$$\sqrt{x}$$，那么如果最后还剩下一个非$$1$$的因子，累计到答案里即可

<pre><code class="cpp">ll Phi(ll x)//求φ
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)//找到一个质因子
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;//把x除干净
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}
</code></pre>

<h2>线性筛求法</h2>

当我们要求$$1...n$$每一个数的欧拉函数时，上面的复杂度就过高了。而我们知道在筛素数的时候有线性素数筛的方法，那么欧拉函数时候有线性筛的算法呢？
有，不过在此之前我们先说一说能线性筛的原理
基本条件：
$$\phi(p)=p-1$$其中$$p$$是质数
$$\phi(p^k)=(p-1)&#42;p^{k-1}$$
欧拉函数是积性函数，即$$\phi(pq)=\phi(p)&#42;\phi(q) [gcd(p,q)==1]$$
这里首先给出线性求欧拉函数的算法

<pre><code class="cpp">//notprime[i]为0表示是质数，为1表示不是质数
//Prime[]存放已经筛出来的质数
//maxNum值域
void GetPhi()
{
    notprime[1]=1;phi[1]=1;//设置初始值
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) phi[i]=i-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)Prime[j]*i&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                phi[i*Prime[j]]=phi[i]*Prime[j];
                break;
            }
            phi[i*Prime[j]]=phi[i]*phi[Prime[j]];
        }
    }
    return;
}
</code></pre>

然后我们现在给出欧拉函数的递推公式（下文中的$$p$$均为质数且保证$$p&lt;=i$$（这个是$$for$$循环从小到大能够保证的））
$$ \phi(i&#42;p)= \begin{cases}p-1 \quad i==1 &#92;&#92; \phi(i)&#42;\phi(p) &#92;quad gcd(i,p)==1 &#92;&#92; \phi(i)&#42;p &#92;quad gcd(i,p)!=1 \end{cases} $$

第一条不需要多解释，根据性质一可以直接得到
第二条同样，由性质三积性函数可以得到
第三条作如下说明
因为$$gcd(i,p)!=1$$且$$p&lt;=i$$，而$$p$$又是质数，所以$$i\ mod\ p==0$$，则可知$$\phi(i)$$中已经有$$(1-\frac{1}{p})$$这一项了，所以可以不用再乘了。同时，执行完这一句后就$$break$$了，这是因为为了保证每一个数$$i&#42;p$$只能由它的最小的质因子$$p$$筛到，这时线性筛的复杂度保证。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:08:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:08:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0phii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[457]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>博客模板</title>
		<link>http://sycstudio.com/archives/108</link>
		<pubDate>Thu, 11 Jan 2018 16:35:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=108</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<h3>Tag</h3>

<h2>题目大意</h2>

<h2>解决思路</h2>

<h2>代码</h2>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>108</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:35:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:35:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8d%9a%e5%ae%a2%e6%a8%a1%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU2588]GCD（欧拉函数）</title>
		<link>http://sycstudio.com/archives/110</link>
		<pubDate>Thu, 11 Jan 2018 16:54:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=110</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

The greatest common divisor GCD(a,b) of two positive integers a and b,sometimes written (a,b),is the largest divisor common to a and b,For example,(1,2)=1,(12,18)=6.
(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:
Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)>=M.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-2588">HDU</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

给定数&#92;(N&#92;)，求满足&#92;(gcd(x,N)>=M&#92;)的&#92;(X&#92;)的数量

<h2>解决思路</h2>

考虑&#92;(N=a&#42;b&#92;)，若&#92;(gcd(N=a&#42;b,a&#42;c)==a&#92;)，则$$b$$与$$c$$互质，而可能的$$c$$的数量就是与$$b$$互质的数的个数，即为$$\phi(b)$$，所以可以考虑枚举$$N$$的因子$$a$$，求$$\phi(a)$$之和。
但是考虑到$$N$$的范围，直接枚举会超时。因为对于$$N$$的因数$$a$$，一定存在一个对应的因数$$b$$使得$$N=a&#42;b$$，所以我们只需要枚举到$$\sqrt{n}$$即可，注意判断$$n$$为完全平方数的情况，此时$$\sqrt{n}$$只能算一遍

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

ll Phi(ll x);

int main()
{
    int T;scanf("%d",&amp;T);
    while(T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);
        ll ans=0;
        for (ll i=1;i*i&lt;=n;i++)
            if (n%i==0)
            {
                if (i&gt;=m) ans=ans+Phi(n/i);
                if ((n/i&gt;=m)&amp;&amp;(i*i!=n)) ans=ans+Phi(i);//注意这里不能重复计算完全平方数
            }
        printf("%lld\n",ans);
    }
    return 0;
}

ll Phi(ll x)//求φ
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>110</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:54:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:54:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2588-gcd%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_933d88cdaf6eec748c7c1bb98ebf80bc]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[291]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ2478]Farey Sequence （欧拉函数）</title>
		<link>http://sycstudio.com/archives/112</link>
		<pubDate>Thu, 11 Jan 2018 17:13:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=112</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

The Farey Sequence Fn for any integer n with n >= 2 is the set of irreducible rational numbers a/b with 0 &lt; a &lt; b &lt;= n and gcd(a,b) = 1 arranged in increasing order. The first few are
F2 = {1/2}
F3 = {1/3, 1/2, 2/3}
F4 = {1/4, 1/3, 1/2, 2/3, 3/4}
F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5}

You task is to calculate the number of terms in the Farey sequence Fn.

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-2478">POJ</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

给定正整数&#92;(N&#92;)，求小于等于&#92;(N&#92;)的互质的数的个数

<h2>解决思路</h2>

求小于等于&#92;(N&#92;)的互质的数的个数，就是求&#92;(\sum \phi(i)&#92;)，线性筛出$$\phi(i)$$即可，但要注意虽然$$\phi(1)==1$$，但这里不能统计进去

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

ll phi[maxNum];
ll sum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Phi();

int main()
{
    Phi();
    sum[1]=0;
    for (int i=2;i&lt;maxNum;i++) sum[i]=sum[i-1]+phi[i];//求前缀和
    int n;
    while (scanf("%d",&amp;n)!=EOF)
    {
        if (n==0) break;
        printf("%lld\n",sum[n]);
    }
    return 0;
}

void Phi()
{
    notprime[1]=1;phi[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,phi[i]=i-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                phi[i*Prime[j]]=phi[i]*Prime[j];
                break;
            }
            phi[i*Prime[j]]=phi[i]*phi[Prime[j]];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>112</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 01:13:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 17:13:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2478-farey-sequence-%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_b28b13d5829a362926ff7c63192379e7]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[257]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU3501]Calculation 2 （欧拉函数）</title>
		<link>http://sycstudio.com/archives/115</link>
		<pubDate>Thu, 11 Jan 2018 17:34:26 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>HDU 3501 Calculation 2</h1>

<h3>Description</h3>

Given a positive integer N, your task is to calculate the sum of the positive integers less than N which are not coprime to N. A is said to be coprime to B if A, B share no common positive divisors except 1.

<h3>Http</h3>

https://vjudge.net/problem/HDU-3501

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} [gcd(i,n)!=1]&#42;i&#92;)

<h2>解决思路</h2>

考虑若有&#92;(gcd(i,n)==1&#92;)，那一定会有$$gcd(n-i,n)==1$$，那么可以知道，与一个数互质的数一定是一组一组出现的，所以可以知道与$$N$$互质的数的和就是$$N&#42;\phi(N)/2$$。那么根据补集原理，用$$1~N$$的和减去与$$N$$互质的数之和就是与$$N$$不互质的数之和啦。
注意特判1。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const ll Mod=1000000007;

ll Phi(ll x);
ll Inv(ll a,ll b);
void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y);

int main()
{
    ll inv2=Inv(2,Mod);
    ll n;
    while (scanf("%lld",&amp;n))
    {
        if (n==0) break;
        if (n==1) {printf("0\n");continue;}
        printf("%lld\n",(ll)n*(ll)(n-1ll-Phi(n))%Mod*inv2%Mod);
    }
    return 0;
}

ll Phi(ll x)
{
    if (x==1) return 1;
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}

ll Inv(ll a,ll b)
{
    ll x,y;
    Exgcd(a,b,x,y);
    return (x%b+b)%b;
}

void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y)
{
    if (b==0)
    {
        x=1;y=0;
        return;
    }
    Exgcd(b,a%b,x,y);
    ll tmp=x;
    x=y;y=tmp-a/b*y;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 01:34:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 17:34:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-3501-calculation-2-%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e8%a1%a5%e9%9b%86"><![CDATA[补集]]></category>
		<category domain="category" nicename="%e8%a1%a5%e9%9b%86%e6%80%9d%e6%83%b3"><![CDATA[补集思想]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_1ea53f370a042a9b1756bf166419b50b]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_58d1f106c3f6e566f400ba0b9178e426]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[226]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ VLATTICE] Visible Lattice Points（莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/119</link>
		<pubDate>Thu, 11 Jan 2018 22:44:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=119</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Consider a N&#42;N&#42;N lattice. One corner is at (0,0,0) and the opposite one is at (N,N,N). How many lattice points are visible from corner at (0,0,0) ? A point X is visible from point Y iff no other lattice point lies on the segment joining X and Y.

<h3>Http</h3>

<a href="http://www.spoj.com/problems/VLATTICE/en/" title="http://www.spoj.com/problems/VLATTICE/en/">http://www.spoj.com/problems/VLATTICE/en/</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求从三维坐标系的原点&#92;((0,0,0)&#92;)朝第一卦限看去，在&#92;(n&#42;n&#42;n&#92;)的范围内能看到多少个不被遮蔽的整点

<h2>解决思路</h2>

把题目化成数学形式就是求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==1]&#92;]
考虑莫比乌斯反演。
设&#92;[F(x)=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==x]&#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)=\sum&#95;{x|d} \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==d]&#92;]
看到第二个式子，由于$$gcd(i,j,k)==d$$，所以有$$d|i,d|j,d|k$$，又因为$$x|d$$，所以计算贡献可以发现$$G(x)={\lfloor \frac{n}{x} \rfloor}^3$$
那么根据莫比乌斯反演，可以得到&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x})&#42;G(d)&#92;]
把$$x==1$$带进去，得到最终的式子
&#92;[F(x)=\sum&#95;{i=1}^n \mu (i) {\lfloor \frac{n}{i} \rfloor}^3&#92;]
需要注意的是，这是三维的情况，即$$gcd(i,j,k)==1$$，这要求$$i,j,k!=0$$，即没有计算在三个平面的情况。而由我们上面的分析可以知道，三个平面上的答案就是$$\sum&#95;{i=1}^n \mu (i) &#42;3&#42;{\lfloor \frac{n}{i} \rfloor}^2$$要乘三的原因是有三个平面。
当然，相信你也猜到了，我们计算这三个平面的时候，是不包括三根数轴的，所以最后还要答案要加上这三根数轴的贡献，即$$(1,0,0),(0,1,0),(0,0,1)$$，即加上三

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n;scanf("%d",&amp;n);
        ll ans=0;
        for (int i=1;i&lt;=n;i++)
        {
            ll x=n/i;
            ans=ans+(ll)Mu[i]*(ll)x*(ll)x*(ll)(x+3);
        }
        printf("%lld\n",ans+3ll);
    }
    return 0;
}

void GetMu()//线性筛求Mu
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)Prime[j]*(ll)i&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>119</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 06:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 22:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-vlattice-visible-lattice-points%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[294]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[ZOJ3435] Ideal Puzzle Bobble （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/129</link>
		<pubDate>Fri, 12 Jan 2018 15:33:24 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=129</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Have you ever played Puzzle Bobble, a very famous PC game? In this game, as a very cute bobble dragon, you must keep shooting powerful bubbles to crush all the colorful bubbles upwards. Victory comes when all the bubbles upwards are crushed.

Little Tom is crazy about this game. One day, he finds that all kinds of Puzzle Bobble are 2D Games. To be more excited when playing this game, he comes up with a new idea to design a 3D Puzzle Bobble game! In this game, the bobble dragon is standing in a cubic room with L in length, W in width and H in height. Around him are so many colorful bubbles. We can use 3D Cartesian coordinates (x, y, z) to represent the locations of the bobble dragon and those bubbles. All these coordinates (x, y, z) are triple positive integers ranged from (1, 1, 1) to (L, W, H).

To simplify the problem, let's assume the bobble dragon is standing at (1, 1, 1) in the room. And there is one colorful bubble at every (x, y, z) in the room except (1, 1, 1). The dragon is so strong that he can shoot out a magical bubble to crush all the colorful bubbles in the straight line which the magical bubble flies every single time. Note that bubbles are significantly small with respect to the distances between each two bubbles. Our question remains, how many magical bubbles will the cute dragon shoot before crushing all the colorful bubbles around him?
<img src="https://odzkskevi.qnssl.com/6efa53acbde993696100f15dc519b0e5?v=1515590581" alt="" />

<h3>Http</h3>

<a href="https://vjudge.net/problem/22239/origin">zoj</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

在空间坐标系的第一卦限给定$$L&#42;H&#42;W$$的范围，问从$$(1,1,1)$$这个点看去，能看到多少个不被遮住的整数点？

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/119">这一题</a>有些类似，都是求$$\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==1] $$，但本题不同的地方是，这里是从$$(1,1,1)$$看的，所以可以考虑把整个立体空间平移到$$(0,0,0)$$，即把$$L,H,W$$都减一。
那么我们把整个立体空间分为三个部分考虑。
第一部分是三根正轴，我们定义为$$L$$轴,$$H$$轴和$$W$$轴，很容易知道这三根数轴上面的贡献分别是$$1$$。
第二部分是三个平面:$$LoH,HoW,LoR$$，三个平面分别的贡献是$$\sum&#95;{i} \sum&#95;{j} [gcd(i,j)==1]$$。
第三部分就是除去三个平面和三根数轴剩下的$$L&#42;H&#42;W$$的空间，根据上面的式子，我们知道是求$$\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==1] $$
然后我们考虑如何将上面的式子化简，先来看三维的情况
设&#92;[F(x)=\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==x] &#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)=\sum&#95;{x|d} \sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==d] &#92;]可以发现，与上面那一题类似的，&#92;[G(x)=\lfloor \frac{L}{x} \rfloor &#42; \lfloor \frac{H}{x} \rfloor &#42; \lfloor \frac{W}{x} \rfloor &#92;]
好，那么根据莫比乌斯反演，可以得到&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x}) G(d)&#92;] 最终得到&#92;[F(1)=\sum&#95;{i=1}^n \mu (i) \lfloor \frac{L}{i} \rfloor &#42; \lfloor \frac{H}{i} \rfloor &#42; \lfloor \frac{W}{i} \rfloor&#92;]
那么相应的，二维的情况就是&#92;[\sum&#95;{i=1}^n \mu (i) \lfloor \frac{L}{i} \rfloor &#42; \lfloor \frac{H}{i} \rfloor &#92;]
虽然说我们把$$O(n^3)$$的复杂度降到了$$O(n)$$，但是这还不够，因为题目有多组数据。怎么办呢？我们来看到这组例子。
&#92;[\lfloor \frac{100}{20} \rfloor =5 &#92;&#92; \lfloor \frac{100}{21} \rfloor =\lfloor \frac{100}{22} \rfloor =\lfloor \frac{100}{23} \rfloor =\lfloor \frac{100}{24} \rfloor =\lfloor \frac{100}{25} \rfloor =4 \lfloor \frac{100}{26} \rfloor =3 &#92;&#92; ……&#92;]
我们发现，对于$$n==100$$的时候，$$i=21,22,23,24,25$$时的代价是一样的，并且这个相同的区间在$$i$$变大的时候，区间也会越来越大。
这就是<strong>数论分块</strong>的原理：考虑把一样的东西一起做。$$\lfloor \frac{n}{\frac{n}{i}} \rfloor$$这样就可以找到与$$i$$在同一区间（同一个块）的最后一个位置，利用提前计算好的$$\mu(i)$$的前缀和，就可以一个区间一个区间地算了

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=1000010;
const int inf=2147483647;

int n;
ll Mu[maxNum],SumMu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
int L,W,H;

void GetMu();

int main()
{
    GetMu();
    while (scanf("%d%d%d",&amp;L,&amp;W,&amp;H)!=EOF)
    {
        L--;W--;H--;
        ll ans=3;
        int limit=min(L,min(W,H));
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=W/i,k3=H/i;
            last=min(L/k1,min(W/k2,H/k3));
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2*k3;
        }
        limit=min(L,W);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=W/i;
            last=min(L/k1,W/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        limit=min(L,H);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=H/i;
            last=min(L/k1,H/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        limit=min(W,H);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=W/i,k2=H/i;
            last=min(W/k1,H/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]!=0) Mu[i*Prime[j]]=-Mu[i];
            else break;
        }
    }
    for (int i=1;i&lt;maxNum;i++) SumMu[i]=SumMu[i-1]+Mu[i];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>129</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 23:33:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-12 15:33:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-3435-ideal-puzzle-bobble-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[292]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>练习计划</title>
		<link>http://sycstudio.com/plan</link>
		<pubDate>Sat, 13 Jan 2018 18:23:14 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=141</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>目前计划</h1>

<h2>数论部分</h2>

<h3>莫比乌斯反演：</h3>

<ul>
<li>[x] HDU 1695 GCD</li>
<li>[x] HDU 4746 Mophues</li>
<li>[x] HDU 5212 Code （备注：此题还可以用容斥做，未实现）</li>
<li>[ ] HDU 5321 Beautiful Set</li>
<li>[ ] HDU 5663 Hillan and the girl</li>
<li>[ ] HDU 6053 TrickGCD</li>
<li>[ ] HDU 6134 Battlestation Operational</li>
<li>[ ] HDU 4947 GCD Array</li>
<li>[x] BZOJ 2005 [Noi2010]能量采集</li>
<li>[x] BZOJ 2154 Crash的数字表格</li>
<li>[x]  BZOJ 2301 [HAOI2011]Problem b</li>
<li>[x] BZOJ 2820 YY的GCD</li>
<li>[x] BZOJ 2440 [中山市选2011]完全平方数</li>
<li>[x]  BZOJ 2818 Gcd</li>
<li>[x] BZOJ 3994 [SDOI2015]约数个数和</li>
<li>[x] BZOJ 4407 于神之怒加强版</li>
<li>[x] BZOJ 4816 [Sdoi2017]数字表格</li>
<li>[x] BZOJ 2693 jzptab</li>
<li>[x] CJOJ 2512 【UVA 11426】gcd之和</li>
<li>[ ] BZOJ 2186 [Sdoi2008]沙拉公主的困惑</li>
<li>[ ] POJ 3904 Sky Code</li>
<li>[x] UVA 11426 GCD - Extreme (II)</li>
</ul>

<h3>高斯消元</h3>

<ul>
<li>[x] BZOJ 1013 [JSOI2008]球形空间产生器sphere</li>
<li>[x] BZOJ 1923 [Sdoi2010]外星千足虫</li>
<li>[x] BZOJ 1770 [Usaco2009 Nov]lights 燈</li>
<li>[x] BZOJ 1178 [Usaco2010 Hol]Dotp 驱逐猪猡</li>
<li>[x] BZOJ 3270 博物馆</li>
<li>[x] BZOJ 2337 [HNOI2011]XOR和路径</li>
<li>[x] BZOJ 3143 [Hnoi2013]游走</li>
<li>[ ] BZOJ 4004 [JLOI2015]装备购买</li>
<li>[ ] HDU 4418 Time travel</li>
<li>[ ] HDU 3364 Lanterns</li>
<li>[ ] HDU 4870 Rating</li>
<li>[ ] HDU 4936 Rainbow Island</li>
<li>[ ] HDU 4592 Boring仪仗队</li>
<li>[ ] BZOJ 1968 [Ahoi2005]COMMON 约数研究</li>
<li>[ ] BZOJ 1477 青蛙的约会</li>
<li>[ ] BZOJ 1008 [HNOI2008]越狱</li>
<li>[ ] BZOJ 2729 [HNOI2012]排队</li>
<li>[ ]  BZOJ 4804 欧拉心算</li>
<li>[ ] BZOJ 1406 [AHOI2007]密码箱</li>
<li>[ ] Luogu 1414 又是毕业季II</li>
<li>[ ] Codeforces 113 D Museum</li>
</ul>

<a href="https://www.zybuluo.com/l1ll5/note/1027211">参考：随机游走相关</a>

<h3>扩展欧拉定理</h3>

<ul>
<li>[x] BZOJ 3884 上帝与集合的正确用法</li>
<li>[ ] BZOJ 4869 [Shoi2017]相逢是问候</li>
<li>[ ] HDU 3221 Brute-force Algorithm</li>
<li>[ ] HDU 5895 Mathematician QSC</li>
<li>[ ] HDU 3221 Brute-force Algorithm</li>
</ul>

<h3>多项式exp</h3>

<a href="http://www.mamicode.com/info-detail-1403144.html">参考</a>

<h3>BSGS</h3>

<ul>
<li>[ ] POJ 2417 Discrete Logging</li>
<li>[ ] POJ 3243 Clever Y</li>
<li>[ ] HDU 2815 Mod Tree</li>
<li>[ ] HDU 4887 Endless Punishment</li>
<li>[ ] BZOJ 3239 Discrete Logging</li>
<li>[ ] BZOJ 4128 Matrix</li>
<li>[ ] BZOJ 3283 运算器</li>
</ul>

<h2>数据结构</h2>

<h3>线段树：</h3>

<ul>
<li>[x] BZOJ 4071 巴邻旁之桥</li>
<li>[x] BZOJ 1018 [SHOI2008]堵塞的交通traffic</li>
<li>[x] BZOJ 3295 [Cqoi2011]动态逆序对</li>
<li>[x] BZOJ 4653 [noi2006] 区间</li>
<li>[x] BZOJ 4355 Play with sequence</li>
<li>[x] BZOJ 2243 [SDOI2011]染色</li>
<li>[x] BZOJ 1558 [JSOI2009]等差数列</li>
<li>[x] BZOJ 3122 花神游历各国</li>
<li>[x] BZOJ 2957 楼房重建</li>
<li>[ ] BZOJ 4821 [Sdoi2017]相关分析</li>
<li>[ ] Luogu 1973 [NOI2011]Noi嘉年华</li>
<li>[ ] Luogu 1428 无聊的数列</li>
<li>[x] UOJ 228 基础数据结构练习题</li>
<li>[x] Codeforces 834D The Bakery</li>
<li>[ ] Codeforese 903G Yet Another Maxflow Problem</li>
<li>[ ] Codeforese 817F MEX Queries</li>
<li>[ ] HDU 5692 Snacks</li>
<li>[ ] HDU 4942 Game on S♂play</li>
<li>[ ] HDU 4578 Transformation</li>
<li>[ ] POJ 1151 Atlantis</li>
</ul>

<h4>线段树合并</h4>

<ul>
<li>[x] BZOJ 4552 [Tjoi2016&amp;Heoi2016]排序</li>
<li>[x] BZOJ 2212 [Poi2011]Tree Rotations</li>
<li>[x] BZOJ 4756 [Usaco2017 Jan]Promotion Counting</li>
<li>[ ] BZOJ 3307 雨天的尾巴</li>
<li>[x] HDU 5709 Claris Loves Painting</li>
</ul>

<h3>平衡树</h3>

<ul>
<li>[x] BZOJ 3506 [Cqoi2014]排序机械臂</li>
<li>[x] BZOJ 3196 Tyvj 1730 二逼平衡树</li>
<li>[x] BZOJ 1483 [HNOI2009]梦幻布丁</li>
<li>[ ] HDU 5324 Boring Class</li>
<li>[ ] BZOJ 2827 千山鸟飞绝</li>
<li>[ ] BZOJ 4864 [BeiJing 2017 Wc]神秘物质</li>
<li>[ ] BZOJ 3729 Gty的游戏</li>
<li>[ ] BZOJ 3786 星系探索</li>
</ul>

<h3>主席树</h3>

<ul>
<li>[x] BZOJ 4012 [HNOI2015]开店</li>
<li>[ ] BZOJ 1926 [Sdoi2010]粟粟的书架</li>
<li>[ ] BZOJ 4571 [Scoi2016]美味</li>
<li>[x] BZOJ 3932 [CQOI2015]任务查询系统</li>
<li>[x] BZOJ 3123 [Sdoi2013]森林</li>
<li>[x] BZOJ 2588 Spoj 10628. Count on a tree</li>
<li>[x] BZOJ 1901 Dynamic Ranking</li>
<li>[x] BZOJ 2006 [NOI2010]超级钢琴</li>
<li>[x] BZOJ 2653 middle</li>
<li>[x] BZOJ 3524 [Poi2014]Couriers</li>
<li>[x] HDU 2665 Kth number</li>
<li>[x]  HDU 4417 Super Mario</li>
<li>[x] HDU 5919 Sequence II</li>
<li>[x] HDU 4348 To the moon</li>
<li>[x] HDU 4251 The Famous ICPC Team Again</li>
<li>[x] HDU 5919 Sequence II</li>
<li>[x] SPOJ 3267 D-query</li>
<li>[ ] Codeforces 757G Can Bash Save the Day?</li>
<li>[x] Codeforces 831F Army Creation</li>
</ul>

<h3>Link-Cut-Tree</h3>

<ul>
<li>[x]  BZOJ 4736 温暖会指引我们前行</li>
<li>[x] BZOJ 4825 [Hnoi2017]单旋</li>
<li>[ ] BZOJ 5020 [THUWC 2017]在美妙的数学王国中畅游</li>
<li>[x]  BZOJ 3669 [Noi2014]魔法森林</li>
<li>[x] BZOJ 3514 Codechef MARCH14 GERALD07加强版</li>
<li>[x]  BZOJ 1969 航线规划</li>
<li>[x] BZOJ 4817 [Sdoi2017]树点涂色</li>
<li>[ ] BZOJ 3914 Jabby's shadows</li>
<li>[x]  BZOJ 2959 长跑</li>
<li>[x] BZOJ 4998 星球联盟</li>
<li>[x] BZOJ 4530 [Bjoi2014]大融合</li>
<li>[x] BZOJ 2594 [Wc2006]水管局长数据加强版</li>
<li>[x] BZOJ 2243 [SDOI2011]染色</li>
<li>[x] HDU 5398 GCD Tree</li>
<li>[ ] HDU 4718 The LCIS on the Tree</li>
<li>[ ] HDU 5002 Tree</li>
<li>[ ] HDU 5333 Undirected Graph</li>
<li>[ ] HDU 5967 小R与手机</li>
<li>[ ] HDU 6200 mustedge mustedge mustedge</li>
<li>[x] UOJ 207 共价大爷游长沙</li>
<li>[ ] Luogu 3348 [ZJOI2016]大森林</li>
<li>[ ] SPOJ QTREE5</li>
<li>[ ] SPOJ QTREE6</li>
<li>[ ] SPOJ QTREE7</li>
</ul>

<h3>左偏树</h3>

<ul>
<li>[x] BZOJ 4003 [JLOI2015]城池攻占</li>
<li>[x]  BZOJ 2809 [Apio2012]dispatching</li>
<li>[ ] BZOJ 1367 [Baltic2004]sequence</li>
<li>[x] BZOJ 2333 [SCOI2011]棘手的操作</li>
<li>[x] Luogu 3066 [USACO12DEC]逃跑的BarnRunning Away From…</li>
<li>[x] HDU 5818 Joint Stacks</li>
<li>[x] HDU 3031 To Be Or Not To Be</li>
<li>[x] HDU 1512 Monkey King</li>
</ul>

<h3>树链剖分</h3>

<ul>
<li>[x]  BZOJ 3626 [LNOI2014]LCA（也可以LCT）</li>
<li>[x]  BZOJ 3531 [Sdoi2014]旅行</li>
<li>[x] BZOJ 1977 [BeiJing2010组队]次小生成树 Tree</li>
<li>[ ] BZOJ 4196 [Noi2015]软件包管理器</li>
<li>[x] BZOJ 4538 [Hnoi2016]网络</li>
<li>[ ] BZOJ 4034 [HAOI2015]树上操作</li>
<li>[x] BZOJ 2157 旅游</li>
</ul>

<h3>KD-Tree</h3>

<ul>
<li>[x] BZOJ 2648 SJY摆棋子</li>
<li>[x] BZOJ 1941 [Sdoi2010]Hide and Seek</li>
<li>[x] BZOJ 4066 简单题</li>
<li>[x] BZOJ 4520 [Cqoi2016]K远点对</li>
<li>[x] BZOJ 2850 巧克力王国</li>
</ul>

<a href="http://ljqpaper.duapp.com/index.php/archives/177/">jesseliu612</a>
<a href="https://www.zybuluo.com/l1ll5/note/967681">KD-tree</a>

<h3>虚树</h3>

<ul>
<li>[x] BZOJ 3572 [Hnoi2014]世界树</li>
<li>[x] BZOJ 3611 [Heoi2014]大工程</li>
<li>[x] BZOJ 3991 [SDOI2015]寻宝游戏</li>
<li>[x] BZOJ 2286 [Sdoi2011]消耗战</li>
<li>[x] BZOJ 3879 SvT</li>
</ul>

<a href="https://www.cnblogs.com/zzqsblog/p/5560645.html">参考</a>
<a href="http://blog.csdn.net/horizon_smz/article/details/50668658">题集</a>

<h3>线段树/树状数组</h3>

<ul>
<li>[x] POJ 2985 The k-th Largest Group</li>
</ul>

<h3>树套树</h3>

<ul>
<li>[x] BZOJ 3110 [Zjoi2013]K大数查询</li>
<li>[ ] BZOJ 2877 [Noi2012]魔幻棋盘</li>
<li>[x] BZOJ 3196 Tyvj 1730 二逼平衡树</li>
<li>[ ] BZOJ 4553 [Tjoi2016&amp;Heoi2016]序列</li>
<li>[ ] BZOJ 4785 [Zjoi2017]树状数组</li>
<li>[ ] BZOJ 4605 崂山白花蛇草水</li>
<li>[x] BZOJ 1901 Dynamic Rankings</li>
<li>[x] BZOJ 1513 [POI2006]TET-Tetris 3D</li>
<li>[ ] BZOJ 4539 [Hnoi2016]树</li>
<li>[ ] BZOJ 3215/3216 [Zjoi2013]话旧</li>
<li>[ ] BZOJ 4009 [HNOI2015]接水果</li>
<li>[ ] BZOJ 3217 ALOEXT</li>
<li>[ ] BZOJ 1146 [CTSC2008]网络管理Network</li>
</ul>

<a href="https://www.zybuluo.com/l1ll5/note/971817">树套树</a>

<a href="https://www.zybuluo.com/l1ll5/note/978844">基础数据结构杂谈</a>

<h3>支配树</h3>

<a href="http://www.cnblogs.com/fenghaoran/p/dominator_tree.html">fhr</a>

<h3>B树/B+树</h3>

<a href="https://www.cnblogs.com/George1994/p/7008732.html">B树</a>

<h3>仙人掌/圆方树</h3>

<a href="http://immortalco.blog.uoj.ac/blog/1955">cjk</a>

<h2>算法</h2>

<h3>点分治</h3>

<ul>
<li>[x] BZOJ 2152 聪聪可可</li>
<li>[x] HDU 5977 Garden of Eden</li>
<li>[x] HDU 4812 D Tree</li>
<li>[x] HDU 5909 Tree Cutting</li>
<li>[x] HDU 5469 Antonidas</li>
<li>[x] BZOJ 3672 [Noi2014]购票</li>
<li>[x] BZOJ 4016 [FJOI2014]最短路径树问题</li>
<li>[x] BZOJ 1758 [Wc2010]重建计划</li>
<li>[ ] BZOJ 4598 [Sdoi2016]模式字符串</li>
</ul>

<h3>动态点分治：</h3>

<ul>
<li>[ ] BZOJ 4372 烁烁的游戏</li>
<li>[x] BZOJ 3730 震波</li>
<li>[ ] BZOJ 3924 [Zjoi2015]幻想乡战略游戏</li>
<li>[x] BZOJ 1095 [ZJOI2007]Hide 捉迷藏</li>
<li>[ ] BZOJ 4317 Atm的树</li>
<li>[ ] HDU 5571 tree</li>
</ul>

<h3>(CDQ)分治</h3>

<ul>
<li>[ ] BZOJ 2726 [SDOI2012]任务安排</li>
<li>[x] BZOJ 3295 [Cqoi2011]动态逆序对</li>
<li>[x] BZOJ 4237 稻草人</li>
<li>[x] BZOJ 3262 陌上花开</li>
</ul>

<h3>整体二分</h3>

<ul>
<li>[x] BZOJ 2527 [Poi2011]Meteors</li>
<li>[ ] BZOJ 3110 [Zjoi2013]K大数查询</li>
<li>[ ] BZOJ 4009 [HNOI2015]接水果</li>
<li>[ ] BZOJ 2001 [Hnoi2010]City 城市建设</li>
<li>[ ] BZOJ 4025 二分图</li>
<li>[ ] BZOJ 3571 [Hnoi2014]画框</li>
<li>[ ] BZOJ 1196 [HNOI2006]公路修建问题</li>
<li>[ ] BZOJ 3237 [Ahoi2013]连通图</li>
<li>[ ] BZOJ 4700 适者</li>
<li>[ ] BZOJ 2369 区间 交与并</li>
<li>[ ] UVALive 3177 Beijing Guards</li>
<li>[ ] BZOJ 2674 Attack</li>
<li>[ ] BZOJ 2738 矩阵乘法</li>
<li>[ ] BZOJ 3524 [Poi2014]Couriers</li>
</ul>

各种偏序

<h3>动态规划</h3>

<ul>
<li>[x] BZOJ 1076 [SCOI2008]奖励关</li>
<li>[x] BZOJ 3675 [Apio2014]序列分割</li>
<li>[x] BZOJ 2748 [HAOI2012]音量调节</li>
<li>[x] BZOJ 1084 [SCOI2005]最大子矩阵</li>
<li>[x] BZOJ 1003 [ZJOI2006]物流运输</li>
<li>[x] BZOJ 4872 [shoi2017]分手是祝愿</li>
<li>[x] BZOJ 1087 [SCOI2005]互不侵犯King</li>
<li>[x] BZOJ 1801 [Ahoi2009]chess 中国象棋</li>
<li>[x] BZOJ 2734 [HNOI2012]集合选数</li>
<li>[x] BZOJ 1207 [HNOI2004]打鼹鼠</li>
<li>[x] BZOJ 1040 [ZJOI2008]骑士</li>
<li>[x] BZOJ 1017 [JSOI2008]魔兽地图DotR</li>
<li>[x] BZOJ 3997 [TJOI2015]组合数学</li>
<li>[x] BZOJ 1037 [ZJOI2008]生日聚会Party</li>
<li>[x] BZOJ 2037 [Sdoi2008]Sue的小球</li>
<li>[ ] BZOJ 1057 [ZJOI2007]棋盘制作</li>
<li>[x] BZOJ 4709 [Jsoi2011]柠檬</li>
<li>[x] BZOJ 3156 防御准备</li>
<li>[ ] BZOJ 3090 Coci2009 [podjela]</li>
<li>[x] BZOJ 4380 [POI2015]Myjnie</li>
<li>[x] HDU 4352 XHXJ's LIS</li>
<li>[ ] HDU 6170 Two strings</li>
<li>[ ] HDU 4719 Oh My Holy FFF</li>
<li>[x] Codeforces 868 F Yet Another Minimization Problem</li>
<li>[x] Topcoder 11387 FoxAndFlowerShopDivOne</li>
<li>[x] Topcoder 12118 ConversionMachine</li>
<li>[x] Topcoder 12464 WolfPack</li>
<li>[ ] SPOJ - BALNUM Balanced Numbers（数位？）</li>
</ul>

<a href="http://www.cnblogs.com/Konjakmoyu/category/797626.html">参考</a>

<h3>三分</h3>

<ul>
<li>[ ] BZOJ 1857 [Scoi2010]传送带</li>
<li>[ ] BZOJ 4868 [Shoi2017]期末考试</li>
<li>[ ] BZOJ 3330 [BeiJing2013]分数</li>
<li>[ ] BZOJ 4014 [FJOI2014]病毒防护带</li>
<li>[ ] BZOJ 3874 [Ahoi2014&amp;Jsoi2014]宅男计划</li>
<li>[ ] BZOJ 3203 [Sdoi2013]保护出题人</li>
<li>[ ] HDU 2438 Turn the corner</li>
<li>[ ] HDU 2298 Toxophily</li>
</ul>

<h3>莫队算法</h3>

<ul>
<li>[x] BZOJ 1878 [SDOI2009]HH的项链</li>
<li>[x] BZOJ 2120 数颜色</li>
<li>[x] BZOJ 2038 [2009国家集训队]小Z的袜子(hose)</li>
<li>[ ] BZOJ 4540 [Hnoi2016]序列</li>
<li>[ ] BZOJ 3460 jc的宿舍</li>
<li>[ ] Luogu 2709 小B的询问</li>
</ul>

<h3>模拟退火/爬山等随机算法</h3>

<ul>
<li>[x] BZOJ 3680 吊打XXX</li>
<li>[ ] BZOJ 2428 [HAOI2006]均分数据</li>
<li>[ ] BZOJ 2832 宅男小C</li>
<li>[ ] BZOJ 3874 [Ahoi2014]宅男计划</li>
<li>[ ] BZOJ 1038 [ZJOI2008]瞭望塔</li>
<li>[ ] BZOJ 1379  [Baltic2001]Postman</li>
<li>[ ] HDU 5017 Ellipsoid</li>
<li>[ ] HDU 3644 A Chocolate Manufacturer's Problem</li>
<li>[x] HDU 1109 Run Away</li>
<li>[ ] HDU 3922 Enchantress</li>
<li>[ ] HDU 2899 Strange fuction</li>
</ul>

<h2>字符串</h2>

<h3>后缀数组</h3>

<ul>
<li>[x] BZOJ 3238 [Ahoi2013]差异</li>
<li>[x] BZOJ 4650 [NOI2016]优秀的拆分</li>
<li>[x] BZOJ 4199 [Noi2015]品酒大会</li>
<li>[x] BZOJ 4566 [Haoi2016]找相同字符</li>
<li>[x] BZOJ 1031 [JSOI2007]字符加密Cipher</li>
<li>[x] BZOJ 4310 跳蚤</li>
<li>[x] BZOJ 4556 [Tjoi2016&amp;Heoi2016]字符串</li>
<li>[x] BZOJ 3879 SvT</li>
<li>[x] BZOJ 3998 [TJOI2015]弦论</li>
<li>[x] BZOJ 2119 股市的预测</li>
<li>[x] BZOJ 3277 串</li>
<li>[x] BZOJ 4892 [Tjoi2017]dna</li>
<li>[x] Luogu 1368 工艺</li>
<li>[x]  Luogu 2852 [USACO06DEC]牛奶模式Milk Patterns</li>
<li>[x]  Luogu 2463 [SDOI2008]Sandy的卡片</li>
<li>[x]  Hihocoder 1403 后缀数组一·重复旋律</li>
<li>[x] Hihocoder 1407 后缀数组二·重复旋律2</li>
<li>[x] Hihocoder 1415 后缀数组三·重复旋律3</li>
<li>[x] Hihocoder 1419  后缀数组四·重复旋律4</li>
<li>[ ] POJ 1743 Musical Theme</li>
<li>[ ] POJ 3261 Milk Patterns</li>
<li>[ ] POJ 2774 Long Long Message</li>
<li>[ ] POJ 3693 Maximum repetition substring</li>
<li>[ ] HDU 5769 Substring</li>
<li>[ ] HDU 3518 Boring counting</li>
<li>[ ] HDU 4622 Reincarnation</li>
</ul>

<a href="https://www.cnblogs.com/kuangbin/category/473752.html">参考</a>

<h3>后缀自动机/广义后缀自动机</h3>

<ul>
<li>[ ] SPOJ 8222 Substrings</li>
<li>[ ] SPOJ 1812 Longest Common Substring II</li>
<li>[ ] SPOJ 7258 Lexicographical Substring Search</li>
<li>[x] BZOJ 2555 SubString</li>
<li>[x] BZOJ 3998 [TJOI2015]弦论</li>
<li>[x] BZOJ 3676 [Apio2014]回文串</li>
<li>[x] BZOJ 3926 [Zjoi2015]诸神眷顾的幻想乡</li>
<li>[x] BZOJ 4566 [Haoi2016]找相同字符</li>
<li>[x] BZOJ 4516 [Sdoi2016]生成魔咒</li>
<li>[x] BZOJ 4032 [HEOI2015]最短不公共子串</li>
<li>[x] BZOJ 3277 串</li>
<li>[x] BZOJ 2806 [Ctsc2012]Cheat</li>
<li>[x] BZOJ 5084 hashit</li>
</ul>

<h3>后缀树</h3>

<ul>
<li>[ ] BZOJ 3413 匹配</li>
</ul>

<h3>KMP算法</h3>

<ul>
<li>[x] HDU 6153 A Secret</li>
<li>[x] HDU 2203 亲和串</li>
<li>[x] HDU 4763 Theme Section</li>
<li>[x] HDU 3746 Cyclic Nacklace</li>
<li>[x]  BZOJ 3670 [Noi2014]动物园</li>
<li>[x]  BZOJ 3620 似乎在梦中见过的样子</li>
<li>[x]  BZOJ 4974 [Lydsy八月月赛]字符串大师</li>
<li>[x]  BZOJ 1009 [HNOI2008]GT考试</li>
<li>[x] BZOJ 4820 [Sdoi2017]硬币游戏
<del>- [ ] BZOJ 4560 [JLoi2016]字符串覆盖</del></li>
<li>[x] BZOJ 5130 [Lydsy12月赛]字符串的周期</li>
<li>[x] BZOJ 4572 [Scoi2016]围棋</li>
<li>[ ] POJ 3167 Cow Patterns</li>
<li>[ ] hihocoder 1084 扩展KMP</li>
<li>[x] Codeforces 535 D Tavas and Malekas</li>
<li>[x] Codeforces 631 D Messenger</li>
</ul>

<h3>AC自动机</h3>

<ul>
<li>[x] BZOJ 3172 [Tjoi2013]单词</li>
<li>[x]  BZOJ 2754 [SCOI2012]喵星球上的点名</li>
<li>[x]  BZOJ 3530 [Sdoi2014]数数</li>
<li>[x] BZOJ 1444 [Jsoi2009]有趣的游戏</li>
<li>[x]  BZOJ 2434 [Noi2011]阿狸的打字机</li>
<li>[x] BZOJ 2553 [BeiJing2011]禁忌</li>
<li>[ ] BZOJ 1966 [Ahoi2005]VIRUS 病毒检测</li>
<li>[x]  BZOJ 3507 [Cqoi2014]通配符匹配</li>
<li>[x] BZOJ 1195 [HNOI2006]最短母串</li>
<li>[x] BZOJ 2746 [HEOI2012]旅行问题</li>
<li>[ ] POJ 1625 Censored!</li>
<li>[ ] POJ 3691 DNA repair</li>
<li>[ ] POJ 2778 DNA Sequence</li>
<li>[ ] HDU 2296 Ring</li>
<li>[ ] HDU 4117 GRE Words</li>
<li>[x] Codeforces 710 F String Set Queries</li>
<li>[x] Codeforces 163 E e-Government</li>
<li>[ ] Codeforces 696 D Legen...</li>
<li>[ ] Codeforces 434 C Tachibana Kanade's Tofu</li>
<li>[ ] Codeforces 717 G Underfail</li>
<li>[ ] Codeforces 86 C Genetic engineering</li>
<li>[ ] Codeforces 547 E Mike and Friends</li>
<li>[ ] Codeforces 590 E Birthday</li>
</ul>

<h3>Hash</h3>

<ul>
<li>[ ] 51nod 1676 无向图同构</li>
<li>[x] BZOJ 3507 [Cqoi2014]通配符匹配</li>
<li>[x] BZOJ 3162 独钓寒江雪</li>
<li>[ ] BZOJ 4337 BJOI2015 树的同构</li>
<li>[x] BZOJ 3555 [Ctsc2014]企鹅QQ</li>
<li>[ ] BZOJ 4598 [Sdoi2016]模式字符串</li>
<li>[ ] BZOJ 2124 等差子序列</li>
<li>[ ] BZOJ 3198 [Sdoi2013]spring</li>
<li>[x] BZOJ 1014 [JSOI2008]火星人prefix</li>
<li>[ ] BZOJ 1206 [HNOI2005]虚拟内存</li>
<li>[ ] BZOJ 1414 [ZJOI2009]对称的正方形</li>
<li>[ ] BZOJ 3574 [Hnoi2014]抄卡组</li>
<li>[ ] BZOJ 3207 花神的嘲讽计划Ⅰ</li>
<li>[ ] BZOJ 2151 种树</li>
<li>[ ] BZOJ 1090 [SCOI2003]字符串折叠</li>
<li>[ ] BZOJ 4310 跳蚤</li>
<li>[ ] BZOJ 2462 [BeiJing2011]矩阵模板</li>
<li>[ ] BZOJ 4236 JOIOJI</li>
<li>[ ] BZOJ 4084  [Sdoi2015]双旋转字符串</li>
<li>[ ] BZOJ 3197 [Sdoi2013]assassin</li>
<li>[ ] BZOJ 2565 最长双回文串</li>
<li>[ ] BZOJ 2761 [JLOI2011]不重复数字</li>
<li>[x] BZOJ 4298[ONTAK2015]Bajtocja</li>
</ul>

<h3>Manacher</h3>

<ul>
<li>[x] BZOJ 2342 [Shoi2011]双倍回文</li>
<li>[x] BZOJ 2160 拉拉队排练</li>
<li>[ ] BZOJ 1414 [ZJOI2009]对称的正方形</li>
<li>[x] BZOJ 3160 万径人踪灭</li>
<li>[x] BZOJ 2565 最长双回文串</li>
<li>[ ] HDU 4513 吉哥系列故事——完美队形II</li>
<li>[ ] HDU 5371 Hotaru's problem</li>
<li>[ ] HDU 5785 Interesting</li>
<li>[ ] HDU 3068 最长回文</li>
<li>[ ] HDU 3613 Best Reward</li>
</ul>

<h3>回文树</h3>

<ul>
<li>[ ] HDU 5157 Harry and magic string</li>
<li>[ ] HDU 3948 The Number of Palindromes</li>
<li>[x] HDU 5421 Victor and String</li>
<li>[ ] HDU 5658 CA Loves Palindromic</li>
</ul>

<h3>Trie</h3>

<ul>
<li>[ ] BZOJ 1819 [JSOI]Word Query电子字典</li>
<li>[ ] BZOJ 4523 [Cqoi2016]路由表</li>
<li>[ ] BZOJ 3261 最大异或和</li>
<li>[ ] BZOJ 2741 【FOTILE模拟赛】L</li>
<li>[ ] BZOJ 3217 ALOEXT</li>
<li>[ ] BZOJ 4896 [Thu Summer Camp2016]补退选</li>
<li>[ ] BZOJ 4260 Codechef REBXOR</li>
<li>[x] BZOJ 4567 [Scoi2016]背单词</li>
</ul>

<h3>扩展kmp</h3>

<a href="https://blog.csdn.net/dyx404514/article/details/41831947">扩展kmp</a>

<h3>最小表示法</h3>

<a href="https://wenku.baidu.com/view/0e1a6013a216147917112820.html?rec_flag=default">周源</a>

<h2>图论</h2>

<h3>网络流</h3>

<ul>
<li>[x] BZOJ 2132 圈地计划</li>
<li>[x] BZOJ 2127 happiness</li>
<li>[x] BZOJ 1189 [HNOI2007]紧急疏散evacuate</li>
<li>[x]  BZOJ 4554 [Tjoi2016&amp;Heoi2016]游戏</li>
<li>[x] BZOJ 3993 [SDOI2015]星际战争</li>
<li>[x]  BZOJ 3140 [Hnoi2013]消毒</li>
<li>[x]  BZOJ 1305 [CQOI2009]dance跳舞</li>
<li>[x]  BZOJ 3931 [CQOI2015]网络吞吐量</li>
<li>[x] BZOJ 2324 [ZJOI2011]营救皮卡丘</li>
<li>[x] BZOJ 3144 [Hnoi2013]切糕</li>
<li>[x] BZOJ 2768 [JLOI2010]冠军调查</li>
<li>[x] BZOJ 2756 [SCOI2012]奇怪的游戏</li>
<li>[ ] BZOJ 1059 [ZJOI2007]矩阵游戏</li>
<li>[ ] BZOJ 3996 [TJOI2015]线性代数</li>
<li>[x] BZOJ 3876 [Ahoi2014&amp;Jsoi2014]支线剧情</li>
<li>[x] BZOJ 5120 [2017国家集训队测试]无限之环</li>
<li>[x] BZOJ 2229 [Zjoi2011]最小割</li>
<li>[ ] BZOJ 4519 [Cqoi2016]不同的最小割</li>
<li>[ ] BZOJ 4532 [Sdoi2014]Lis</li>
<li>[ ] BZOJ 2668 [cqoi2012]交换棋子</li>
<li>[ ] BZOJ 3504 [Cqoi2014]危桥</li>
<li>[ ] BZOJ 3218</li>
<li>[ ] Luogu 2570 [ZJOI2010]贪吃的老鼠</li>
<li>[ ] CF 802C Heidi and Library(hard)</li>
</ul>

<a href="http://blog.csdn.net/jzq233jzq/article/details/73123089">zkw费用流</a>

<h3>传递闭包</h3>

<ul>
<li>[ ] POJ 2594 Treasure Exploration</li>
<li>[ ] HDU 1704 Rank</li>
</ul>

<h3>生成树</h3>

<ul>
<li>[x] BZOJ 3551 [ONTAK2010]Peaks加强版</li>
</ul>

<h3>最短路</h3>

<ul>
<li>[x] BZOJ 2763 [JLOI2011]飞行路线</li>
<li>[x] BZOJ 4152 [AMPPZ2014]The Captain</li>
<li>[x] BZOj 4289 PA2012 Tax</li>
</ul>

<h3>2-sat</h3>

<ul>
<li>[x] BZOJ 3495 PA2010 Riddle</li>
</ul>

<h4>Matrix-tree</h4>

<a href="https://blog.csdn.net/u013010295/article/details/47451451">参考1</a>
<a href="https://blog.csdn.net/longshuai0821/article/details/7764267">参考2</a>

<h3>斯坦那树</h3>

<ul>
<li>[ ] BZOJ 4774 修路</li>
</ul>

<h3>优化建图</h3>

<ul>
<li>[ ] Atcoder ARC 069F Flags</li>
<li>[ ] BZOJ 4383 [POI2015]Pustynia</li>
<li>[ ] BZOJ 3073 [Pa2011]Journeys</li>
<li>[ ] BZOJ 3681 Arietta</li>
<li>[ ] BZOJ 4276 [ONTAK2015]Bajtman i Okrągły Robin</li>
<li>[ ] BZOJ 5017 炸弹</li>
<li>[ ] BZOJ 4070 [Apio2015]雅加达的摩天楼</li>
<li>[ ] HDU 5669 Road</li>
</ul>

<h3>图论综合</h3>

<ul>
<li>[x] BZOJ 1064 [Noi2008]假面舞会</li>
<li>[ ] BZOJ 3436 小K的农场</li>
<li>[ ] BZOJ 2330 [SCOI2011]糖果</li>
<li>[x] BZOJ 1924 [Sdoi2010]所驼门王的宝藏</li>
<li>[x] BZOJ 1922 [Sdoi2010]大陆争霸</li>
<li>[x] BZOJ 1143 [CTSC2008]祭祀river</li>
<li>[ ] BZOJ 1027 [JSOI2007]合金</li>
<li>[x] BZOJ 2753 [SCOI2012]滑雪与时间胶囊</li>
<li>[ ] BZOJ 1191 [HNOI2006]超级英雄Hero</li>
<li>[ ] BZOJ 4423 [AMPPZ2013]Bytehattan</li>
<li>[ ] BZOJ 4541 [Hnoi2016]矿区</li>
<li>[ ] BZOJ 1196 [HNOI2006]公路修建问题</li>
<li>[x] BZOJ 1880 [Sdoi2009]Elaxia的路线</li>
<li>[ ] BZOJ 4356 Ceoi2014 Wall</li>
<li>[ ] Luogu 3731 [HAOI2017]新型城市化</li>
<li>[ ] Luogu 2410 [SDOI2009]最优图像</li>
<li>[x] Atcoder 2167 Blackout</li>
<li>[x] Codeforces 542E Playing on Graph</li>
<li>[x] Codeforces 550D Regular Bridge</li>
</ul>

<h3>欧拉回路</h3>

<ul>
<li>[ ] UOJ 117 欧拉回路</li>
<li>[ ] BZOJ 3303</li>
<li>[ ] BZOJ 2095</li>
</ul>

<h3>弦图</h3>

<ul>
<li>[ ] BZOJ1006 [HNOI2008]神奇的国度</li>
<li>[ ] BZOJ 1242 Zju1015 Fishing Net弦图判定</li>
<li>[ ] BZOJ 3103 Palindromic Equivalence</li>
<li>[ ] BZOJ 3350 相似回文串</li>
</ul>

<h2>博弈论</h2>

<ul>
<li>[ ] Codeforces 705B Spider Man</li>
<li>[ ] POJ 1740 A New Stone Game(for xzy)</li>
<li>[ ] HDU 1079 Calendar Game</li>
<li>[ ] HDU 4111 Alice and Bob(for xzy)</li>
<li>[ ] HDU 2516 取石子游戏</li>
<li>[x] HDU 2897 邂逅明下</li>
<li>[ ] HDU 2486 A simple stone game</li>
</ul>

<a href="https://www.cnblogs.com/MashiroSky/p/5914590.html">Mashirosky</a>

<h2>其它</h2>

<h3>科技</h3>

<h4>高维前缀和</h4>

<ul>
<li>[x] SPOJ TLE - Time Limit Exceeded</li>
<li>[ ] CF 449D Jzzhu and Numbers</li>
<li>[ ] Hdu 5765 Bonds</li>
<li>[ ] BZOJ 5092 分割序列</li>
</ul>

<a href="http://blog.csdn.net/WeYoungg/article/details/77073140">参考</a>

<h4>线性基</h4>

<ul>
<li>[ ] SGU 275 To xor or not to xor</li>
<li>[ ] HDU 3949 XOR</li>
<li>[ ] BZOJ 2115 [Wc2011] Xor</li>
<li>[x] BZOJ 3569 DZY Loves Chinese II</li>
<li>[ ] BZOJ 2844 albus就是要第一个出场</li>
<li>[ ] BZOJ 3811 玛里苟斯</li>
<li>[ ] BZOJ 2460 [BeiJing2011]元素</li>
<li>[ ] BZOJ 4568 [Scoi2016]幸运数字</li>
</ul>

<h3>真·其它</h3>

<ul>
<li>[ ] BZOJ 4195 [Noi2015]程序自动分析</li>
<li>[ ] BZOJ 1216 [HNOI2003]操作系统</li>
<li>[ ] BZOJ 1975 [Sdoi2010]魔法猪学院</li>
<li>[ ] BZOJ 1875 [SDOI2009]HH去散步</li>
<li>[ ] BZOJ 1972 [Sdoi2010]猪国杀</li>
<li>[ ] BZOJ 1150 [CTSC2007]数据备份Backup</li>
<li>[ ] BZOJ 3065 带插入区间K小值</li>
<li>[ ] BZOJ 4543 [POI2014]Hotel加强版</li>
<li>[ ] BZOJ 4198 [Noi2015]荷马史诗</li>
<li>[ ] Luogu 1196 [NOI2002]银河英雄传说</li>
<li>[ ] Luogu 3425 [POI2005]KOS-Dicing</li>
<li>[ ] Luogu 3426 [POI2005]SZA-Template</li>
<li>[ ] HDU 5242 Game</li>
<li>[ ] HDU 5245 Joyful</li>
</ul>

<a href="https://vjudge.net/article/55">参考</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>141</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 02:23:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-13 18:23:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b0%b4%e8%a1%a8%e8%ae%b0%e5%bd%95%ef%bc%88%e7%bb%83%e4%b9%a0%e8%ae%a1%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3040]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[custom_permalink]]></wp:meta_key>
			<wp:meta_value><![CDATA[plan]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>48</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-26 12:53:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-26 04:53:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[BZOJ2333棘手的操作就是左偏树~~毒瘤题~~呀]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-3]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>50</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-27 08:42:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-27 00:42:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已更正]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>48</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[2]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>104</wp:comment_id>
			<wp:comment_author><![CDATA[Cyhlnj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1806599497@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-26 20:23:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-26 12:23:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主太棒辣]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>9</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>105</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-26 20:24:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-26 12:24:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您更棒！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>104</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>167</wp:comment_id>
			<wp:comment_author><![CDATA[SRlif]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3361879051@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.cnblogs.com/tpgzy/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[119.187.151.131]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-11 17:01:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-11 09:01:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哇塞,后悔没有早些看到.(早些看到也不会..现在也不会........)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>154</wp:comment_id>
			<wp:comment_author><![CDATA[keith]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wuliang_6023@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://skyarea.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[222.240.205.178]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-08-01 16:20:01]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-08-01 08:20:01]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:grin:  我就不应该点进来..一脸蒙蔽]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>159</wp:comment_id>
			<wp:comment_author><![CDATA[XZYQvQ]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.k-xzy.xyz</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-09-17 21:45:22]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-09-17 13:45:22]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[。。。这怕不是您用的主题的作者。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>156</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>156</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-08-18 16:34:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-08-18 08:34:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您是？？？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>154</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU1695]GCD （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/146</link>
		<pubDate>Sat, 13 Jan 2018 21:35:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=146</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given 5 integers: a, b, c, d, k, you're to find x in a...b, y in c...d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you're only required to output the total number of different number pairs.
Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.

Yoiu can assume that a = c = 1 in all test cases.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1695">HDU</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

给定&#92;(a,b,K&#92;)求&#92;(\sum&#95;i^a \sum&#95;j^b [gcd(i,j)==K]&#92;)

<h2>解决思路</h2>

设&#92;[F(x)=\sum&#95;i^a \sum&#95;j^b [gcd(i,j)==K]&#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)&#92;]
&#92;[G(x)=\sum&#95;{x|d} \sum&#95;i^a \sum&#95;j^b [gcd(i,j)==d]=\lfloor \frac{a}{x} \rfloor &#42; \lfloor \frac{b}{x} \rfloor &#92;]
那么根据莫比乌斯反演，可以得到
&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x}) &#42; \lfloor \frac{a}{d} \rfloor &#42; \lfloor \frac{b}{d} \rfloor &#92;]
但是同时要注意到，题目中表明了$$(a,b)$$与$$(b,a)$$是同一种方案，所以接下来考虑如何去重。
我们假定$$a\leq b$$，记包括了重复的答案为$$ans$$。我们知道$$[1,a]$$的方案是被重复算了的，所以我们再算一遍到$$a$$的代价，记为$$sum$$。需要注意的是，这里的$$sum$$中计算的也是计算了两次的，所以最终的答案应该是$$sum-\frac{ans}{2}$$
最后要注意的是，$$K$$可以取到$$0$$，所以要特判

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=100010;
const int inf=2147483647;

int a,b,c,d,k;
ll Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求Mu

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    for (int ti=1;ti&lt;=T;ti++)
    {
        scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);
        if (k==0)
        {
            printf("Case %d: 0\n",ti);
            continue;
        }
        if (d&lt;b) swap(b,d);
        ll ans=0,sum=0;
        for (ll i=k;i&lt;=b;i+=k)//先计算出包括重复的
            if (i%k==0) ans=ans+Mu[i/k]*(ll)(b/i)*(ll)(d/i);
        for (ll i=k;i&lt;=b;i+=k)//求出重复的
            if (i%k==0) sum=sum+Mu[i/k]*(ll)(b/i)*(ll)(b/i);
        printf("Case %d: %lld\n",ti,ans-sum/2);//算出最终答案
    }
    return 0;
}

void GetMu()
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>146</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 05:35:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-13 21:35:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1695-gcd-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[605]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4746] Mophues （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/156</link>
		<pubDate>Sun, 14 Jan 2018 13:14:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=156</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

As we know, any positive integer C ( C >= 2 ) can be written as the multiply of some prime numbers:
&#92;(C = p&#95;1&#42;p&#95;2&#42;p&#95;3&#42;...&#42;p_k&#92;)
which &#92;(p&#95;1, p&#95;2 ... p&#95;k&#92;)are all prime numbers.For example, if &#92;(C = 24&#92;), then:
&#92;(24 = 2&#42;2&#42;2&#42;3&#92;)
here, &#92;(p&#95;1 = p&#95;2 = p&#95;3 = 2, p&#95;4 = 3, k = 4&#92;)

Given two integers P and C. if k&lt;=P( k is the number of C's prime factors), we call C a lucky number of P.

Now, XXX needs to count the number of pairs (a, b), which 1&lt;=a&lt;=n , 1&lt;=b&lt;=m, and gcd(a,b) is a lucky number of a given P ( "gcd" means "greatest common divisor").

Please note that we define 1 as lucky number of any non-negative integers because 1 has no prime factor.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4746">HDU</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

设$$Fact(x)$$表示把$$x$$唯一分解后，分解出来的质因子的个数（注意，相同的质因子不算同一个），求&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{m} [Fact(gcd(i,j))&lt;=P] &#92;]

<h2>解决思路</h2>

首先考虑$$Fact(x)$$这个函数，我们发现它是可以线性筛出来的，具体来说，根据其性质可以这样递推出来
设$$p$$为质数
&#92;[\begin{cases} Fact(p)=1 &#92;&#92; Fact(p^k)=k &#92;&#92; Fact(p&#42;i)=Fact(i)+1 \end{cases}&#92;]
由于对于每一个$$x=gcd(i,j)$$，其$$Fact(x)$$是一定的，所以我们先不考虑这个质因子个数的限制。
设&#92;[f(x)=\sum&#95;{i}^{n} \sum&#95;{j}^{m} [gcd(i,j)==x]&#92;] &#92;[g(x)=\sum&#95;{x|d} f(d)&#92;]
根据我们之前做过的题目（<a href="http://sycstudio.com/archives/119">比如这里</a>），可以知道$$g(x)=\lfloor \frac{n}{x} \rfloor &#42; \lfloor \frac{m}{x} \rfloor$$，根据莫比乌斯反演，可以得到$$f(x)=\sum&#95;{x|d} g(d)$$。
假定我们最后要求的是$$\sum&#95;{i} f(i)$$（也就是不考虑$$P$$的限制时的方案数），那么我们现在得到了一种$$O(n&#42;\sqrt{n})$$的办法，就是枚举$$i$$算出每一个$$f(i)$$求和，而算$$f(i)$$的过程可以通过数论分块降到$$O(\sqrt{n})$$的复杂度。
很明显，对于题目的数据范围，这样的复杂度是不行的。考虑到是求和操作，我们来看一看每一个$$g(x)$$最后给答案贡献了多少次。
&#92;[f(1)=\mu(\frac{1}{1})&#42;g(1)+\mu(\frac{2}{1})&#42;g(2)+\mu(\frac{3}{1})&#42;g(3)...... &#92;&#92; f(2)=\mu(\frac{2}{2})&#42;g(2)+\mu(\frac{4}{2})&#42;g(4)+\mu(\frac{6}{2})&#42;g(6)...... &#92;&#92; f(3)=\mu(\frac{3}{3})&#42;g(3)+\mu(\frac{6}{3})&#42;g(6)+\mu(\frac{9}{3})&#42;g(9)...... &#92;&#92; ...... &#92;&#92; f(x)=\mu(\frac{1&#42;x}{x})&#42;g(1&#42;x)+\mu(\frac{2&#42;x}{x})&#42;g(2&#42;x)+\mu(\frac{3&#42;x}{x})&#42;g(3&#42;x)......&#92;&#92; =\mu(1)&#42;g(1&#42;x)+\mu(2)&#42;g(2&#42;x)+\mu(3)&#42;g(3&#42;x).....&#92;]
可以发现，每一个数$$x$$给它的倍数$$d=kx$$的$$g(d)$$贡献了$$\mu(j)$$的莫比乌斯系数，所以我们可以考虑线性推出这个系数的和。设$$F[d]$$表示$$g(d)$$前面莫比乌斯系数的和，那么枚举$$x$$的倍数$$d=kx$$，$$F[d]+=\mu (\frac{d}{x})$$。
最后我们把对质因子个数的条件放进去。先考虑要求质因子个数一定等于$$P$$的。这时候也就是说对于一个数$$x$$，它只能在给定的$$P$$与它的质因子个数相同的时候才能贡献，所以考虑把$$F[d]$$加一维变成$$F&#91;d&#93;&#91;p&#93;$$，表示$$x$$分解质因子个数为$$p$$时对$$x$$的倍数$$d=kx$$的$$g(d)$$的贡献，那么就是$$F&#91;d&#93;&#91;Fact(x)]+=\mu(\frac{d}{x})$$。
最后把条件再放宽，即质因子个数小于等于$$P$$的，那么求$$[p]$$这一维的前缀和即可。由于我们需要数论分块将复杂度，需要求$$[d]$$这一维的前缀和，所以我们求二维前缀和即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=500010;
const int maxP=20;
const int inf=2147483647;

int n,m,P,Q;
ll Mu[maxNum];
ll Fact[maxNum];//每一个数分解后有多少个质因子
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll F[maxNum][maxP];

void GetMu();

int main()
{
    GetMu();
    for (int i=1;i&lt;maxNum;i++)//求F[d][p]
        for (int j=i;j&lt;maxNum;j+=i)
            F[j][Fact[i]]+=Mu[j/i];
    for (int i=0;i&lt;maxNum;i++)//求前缀和，注意因为要累加0的前缀和，所以把行和列分开考虑
        for (int j=1;j&lt;maxP;j++)
            F[i][j]+=F[i][j-1];
    for (int i=1;i&lt;maxNum;i++)
        for (int j=0;j&lt;maxP;j++)
            F[i][j]+=F[i-1][j];
    scanf("%d",&amp;Q);
    while (Q--)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;P);
        if (P&gt;=maxP)
        {
            printf("%lld\n",(ll)n*(ll)m);
            continue;
        }
        ll ans=0;
        if (m&lt;n) swap(n,m);
        for (int i=1,last;i&lt;=n;i=last+1)//数论分块求解
        {
            last=min(n/(int)(n/i),m/(int)(m/i));
            ans=ans+(F[last][P]-F[i-1][P])*(ll)(n/i)*(ll)(m/i);
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;Fact[1]=0;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Fact[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            Fact[i*Prime[j]]=Fact[i]+1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>156</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 21:14:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-14 13:14:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-4746-mophues-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[339]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5212]Code （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/169</link>
		<pubDate>Sun, 14 Jan 2018 19:26:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=169</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

WLD likes playing with codes.One day he is writing a function.Howerver,his computer breaks down because the function is too powerful.He is very sad.Can you help him?

The function:

<pre><code class="language-cpp ">int calc
{
  int res=0;
  for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++)
    {
      res+=gcd(a[i],a[j])*(gcd(a[i],a[j])-1);
      res%=10007;
    }
  return res;
} 
</code></pre>

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5212">HDU</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{n} gcd(A[i],A[j])&#42;(gcd(A[i],A[j])-1)&#92;]

<h2>解决思路</h2>

换一个思路，考虑到值域直到&#92;(10000&#92;)，所以可以开桶统计每一个数出现了多少次，记&#92;(Cnt[i]&#92;)表示数&#92;(i&#92;)出现了多少次。在值域里枚举，那么答案就是&#92;[Ans=\sum&#95;{i}^{10000} \sum&#95;{j}^{10000} Cnt[i]&#42;Cnt[j]&#42;gcd(i,j)&#42;(gcd(i,j)-1)&#92;]
令&#92;(f(x)=x&#42;(x-1)&#92;)，构造$$g(x)$$，使$$f(x)=\sum&#95;{d|x} g(d)$$，则根据莫比乌斯反演，可以得到$$g(x)=\sum&#95;{d|x}\mu(\frac{x}{d}) f(d)$$。
这样有什么用呢？根据我们得到的$$g(x)$$，我们可以把对答案的求解式化成这个形式
&#92;[Ans=\sum&#95;{i}^{10000} \sum&#95;{j}^{10000} Cnt[i]&#42;Cnt[j]&#42;\sum&#95;{d|i,d|j} g(d)&#92;]
为什么可以这样化呢？因为$$d|i,d|j$$保证了$$d$$一定是$$i,j$$的因子，而$$\sum&#95;{d|x} g(d)=f(x)$$，所以就可以直接替换原来的$$gcd$$
那么接着我们把原来枚举$$i,j$$换成枚举$$d$$，即把后面的$$\sum$$换到前面来。考虑每一对$$i,j$$对$$d$$的贡献，那么式子可以这样列
&#92;[Ans=\sum&#95;{d}^{10000} \sum&#95;{d|i}^{10000} \sum&#95;{d|j}^{10000} Cnt[i]&#42;Cnt[j] &#42;g(d)&#92;]
重新观察一下这个式子，既然我们把$$d$$已经提到外面了，那么里面枚举的$$i$$和$$j$$其实是一样的，那么我们可以把两次枚举合二为一
&#92;[Ans=\sum&#95;{d}^{10000} g(d) &#42; {(\sum&#95;{d|i} Cnt[i])}^2&#92;]
这样，计算的复杂度就降到$$O(n\sqrt{n})$$

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10010;
const int Mod=10007;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
int n,Cnt[maxNum];
ll G[maxNum];

void GetMu();//线性筛莫比乌斯函数

int main()
{
    GetMu();
    for (int i=1;i&lt;maxNum;i++)//得到我们构造的函数G
    {
        int j;
        for (j=1;j*j&lt;i;j++)
            if (i%j==0)
                G[i]=((G[i]+Mu[i/j]*j%Mod*(j-1)%Mod+Mu[i/(i/j)]*(i/j)%Mod*(i/j-1)%Mod)%Mod+Mod)%Mod;
        if (j*j==i) G[i]=((G[i]+Mu[i/j]*j%Mod*(j-1)%Mod)%Mod+Mod)%Mod;
    }
    while (scanf("%d",&amp;n)!=EOF)
    {
        mem(Cnt,0);//桶
        for (int i=1;i&lt;=n;i++)
        {
            int x;scanf("%d",&amp;x);
            Cnt[x]++;//桶计数
        }
        ll ans=0;
        for (int i=1;i&lt;maxNum;i++)//这里就是按照那个式子求解了
        {
            ll sum=0;
            for (int j=i;j&lt;maxNum;j=j+i) sum=(sum+Cnt[j])%Mod;
            sum=sum*sum%Mod;
            ans=((ans+sum*G[i]%Mod)%Mod+Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>169</wp:post_id>
		<wp:post_date><![CDATA[2018-01-15 03:26:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-14 19:26:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-5212-code-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[313]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[杜少龙]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/DSL_HN_2002/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-16 02:54:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-16 10:54:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[求交换友链]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[UVA11426]GCD - Extreme (II) （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/180</link>
		<pubDate>Mon, 15 Jan 2018 19:43:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=180</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given the value of N, you will have to find the value of G. The definition of G is given below:

Here GCD(i,j) means the greatest common divisor of integer i and integer j.

For those who have trouble understanding summation notation, the meaning of G is given in the following code:

<pre><code class="language-cpp ">G=0;
for(i=1;i&lt;N;i++)
    for(j=i+1;j&lt;=N;j++)
    {
        G+=gcd(i,j);
    }
/*Here gcd() is a function that finds the greatest common divisor of the two input numbers*/
</code></pre>

<h3>Http</h3>

<a href="https://vjudge.net/problem/UVA-11426">UVA</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

给定&#92;(N&#92;)，求&#92;(\sum&#95;{i=1}^{N} \sum&#95;{j=i+1}^{N} gcd(i,j)&#92;)

<h2>解决思路</h2>

先不考虑&#92;(j=i+1&#92;)的限制，假设&#92;(j&#92;)也是&#92;([1,n]&#92;)，则有
&#92;[Ans=\sum&#95;{i=1}^{N} \sum&#95;{j=1}^{N} gcd(i,j) &#92;]
我们设&#92;(gcd(i,j)==d&#92;)，把&#92;(d&#92;)提出来
&#92;[Ans=\sum&#95;{d}^{N} d &#42; \sum&#95;{i}^{N} \sum&#95;{j}^{N} [gcd(i,j)==d]=\sum&#95;{d}^{N} d &#42; \sum&#95;{i}^{N/d} \sum&#95;{j}^{N/d} [gcd(i,j)==1]&#92;]
观察里面这一部分，就是莫比乌斯反演的经典例子。根据前面的题，可以得到
&#92;[\sum&#95;{i}^{N/d} \sum&#95;{j}^{N/d} [gcd(i,j)==1]=\sum&#95;{i}^{N/d} \mu(i) &#42;\lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;]
把这个等式代回去，可以得到
&#92;[Ans=\sum&#95;{d=1}^{N} d&#42; \sum&#95;{i=1}^{n/d} \mu(i) &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;]
这样直接算的复杂度是$$O(n&#42;n)=O(n^2)$$的。考虑数论分块降低复杂度。由于对于外面的&#92;(d&#92;)，&#92;(n/d&#92;)对于多个连续的&#92;(d&#92;)的取值是一样的，外面可以数论分块。同理，&#92;(\lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;)也是可以分块做的。所以复杂度就降为&#92;(O(\sqrt{n}&#42;\sqrt{n})=O(n)&#92;)。
最后我们把&#92;(j=i+1&#92;)的条件加上，其实意思就是不能重复计算&#92;(gcd(i,j)&#92;)和&#92;(gcd(j,i)&#92;)。考虑我们上面的&#92;(Ans&#92;)计算出来的，它是把每一个&#92;(gcd(i,i)&#92;)都计算了一遍，再加上对于&#92;(i &lt; j&#92;)，&#92;(gcd(i,j)&#92;)计算了两边，即既计算了&#92;(gcd(i,j)&#92;)，又计算了&#92;(gcd(j,i)&#92;)。所以我们可以在&#92;(Ans&#92;)中先减去&#92;(gcd(i,i)&#92;)这一类的贡献（其实就是&#92;(1..n&#92;)的等差数列），再除以二。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=4000010;
const int inf=2147483647;

ll Mu[maxNum];
ll Musum[maxNum];
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求mu
ll Calc(ll n);//内层线性筛

int main()
{
    GetMu();
    ll n;
    while (scanf("%lld",&amp;n)!=EOF)
    {
        if (n==0) break;
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)//外层线性筛
        {
            last=n/(n/i);
            ans=ans+(last+i)*(last-i+1)/2*Calc(n/i);
        }
        printf("%lld\n",(ans-n*(n+1)/2)/2);
    }
    return 0;
}

void GetMu()
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

ll Calc(ll n)//内层线性筛
{
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        ret=ret+(Musum[last]-Musum[i-1])*(ll)(n/i)*(ll)(n/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>180</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 03:43:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-15 19:43:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-11426-gcd-extreme-ii-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="post_tag" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[264]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2005/Luogu1447][NOI2010]能量采集（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/186</link>
		<pubDate>Mon, 15 Jan 2018 21:36:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=186</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。 栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。 由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。 能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。 下面给出了一个能量采集的例子，其中n = 5，m = 4，一共有20棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。 在这个例子中，总共产生了36的能量损失。
<img src="http://sycstudio.com/wp-content/uploads/2018/01/bzoj2005.jpg" alt="BZOJ2005" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2005">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} (2&#42;gcd(i,j)-1)&#92;]

<h2>解决思路</h2>

&#92;[Ans=2&#42; \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j) -n&#42;m&#92;]
那么就是关键是求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)&#92;]
提取&#92;(gcd(i,j)==d&#92;)，假设&#92;(n &lt; m&#92;)，那么有
&#92;[\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d]=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n/i} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1]&#92;]
后面那一部分可以莫比乌斯反演一下，根据&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{m} [gcd(i,j)==1] =\sum&#95;{i=1}^{n} \mu(i) \lfloor \frac{n}{i} \rfloor &#42; \lfloor \frac{m}{i} \rfloor &#92;]，式子可以化为
&#92;[\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n/d} \mu(i) &#42; \lfloor \frac{n/d}{i} \rfloor &#42; \lfloor \frac{m/d}{i} \rfloor&#92;]
这样，可以外层与内层两次数论分块计算，复杂度为&#92;(O(\sqrt{n}&#42;\sqrt{n})=O(n)&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=100010;
const int inf=2147483647;

int Mu[maxNum];
ll Musum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();
ll Calc(ll n,ll m);//内层数论分块求

int main()
{
    GetMu();
    ll n,m;
    scanf("%lld%lld",&amp;n,&amp;m);if (m&lt;n) swap(n,m);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));//外层数论分块
        ans=ans+(ll)(last+i)*(ll)(last-i+1)/2ll*Calc(n/i,m/i);
    }
    printf("%lld\n",ans*2-n*m);
    return 0;
}

void GetMu()//线性筛求mu
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

ll Calc(ll n,ll m)
{
    if (n&gt;m) swap(n,m);
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ret=ret+(Musum[last]-Musum[i-1])*(ll)(n/i)*(ll)(m/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>186</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 05:36:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-15 21:36:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-2005-noi2010%e8%83%bd%e9%87%8f%e9%87%87%e9%9b%86%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[319]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2154/Luogu1829 ]Crash的数字表格（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/201</link>
		<pubDate>Tue, 16 Jan 2018 14:18:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=201</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

今天的数学课上，Crash小朋友学习了最小公倍数(Least Common Multiple)。对于两个正整数a和b，LCM(a, b)表示能同时被a和b整除的最小正整数。例如，LCM(6, 8) = 24。回到家后，Crash还在想着课上学的东西，为了研究最小公倍数，他画了一张N&#42;M的表格。每个格子里写了一个数字，其中第i行第j列的那个格子里写着数为LCM(i, j)。一个4&#42;5的表格如下： 1 2 3 4 5 2 2 6 4 10 3 6 3 12 15 4 4 12 4 20 看着这个表格，Crash想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当N和M很大时，Crash就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，Crash只想知道表格里所有数的和mod 20101009的值。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2154">BZOJ</a>
<a href="https://www.luogu.org/record/show?rid=5368858">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i}^{n} \sum&#95;{j}^{m} lcm(i,j)&#92;)，其中&#92;(lcm(i,j)&#92;)表示&#92;(i,j&#92;)的最小公倍数

<h2>解决思路</h2>

根据&#92;(lcm(i,j)=\frac{ij}{gcd(i,j)}&#92;)，式子可以化为
&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \frac{ij}{gcd(i,j)}&#92;]
令&#92;(d=gcd(i,j)&#92;)，把&#92;(d&#92;)提出来，即变成枚举&#92;(d&#92;)。
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d] &#42; \frac{ij}{d}&#92;]
<code>[  ]</code>里面有&#92;(d&#92;)，把它提出来。后面的&#92;(i,j&#92;)相当于都提取出一个公因子&#92;(d&#92;)，变成&#92;(\frac{i}{d},\frac{j}{d}&#92;)
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1] &#42; dij &#92;&#92; Ans=\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1] &#42; ij&#92;]
前面先不管它，先看后面这一部分
设&#92;[f(x)=\sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==x] &#42; ij&#92;]。设&#92;[g(x)=\sum&#95;{x|t} f(t)&#92;]
&#92;[g(x)=\sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [x|gcd(i,j)]&#42; ij &#92;]
提一个&#92;(x&#92;)出来
&#92;[g(x)=\sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} [1|gcd(i,j)] i&#42;x &#42;j&#42;x&#92;]
&#92;([1|gcd(i,j)]&#92;)是显然成立的。所以
&#92;[g(x)=x^2&#42;\sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} ij&#92;]
那么这就是两个等差数列相乘了，可以&#92;(O(1)&#92;)地做
根据莫比乌斯反演
&#92;[f(x)=\sum&#95;{x|t}^{n/d} \mu(\frac{t}{x}) g(t) &#92;&#92; = \sum&#95;{x|t}^{n/d} \mu(\frac{t}{x}) t^2 \sum&#95;{i=1}^{n/d/t} \sum&#95;{j=1}^{m/d/t} ij&#92;]
由于我们要求的是&#92;(f(1)&#92;)
所以得到&#92;[f(1)=\sum&#95;{k=1}^{n/d} \mu(k) k^2 \sum&#95;{i=1}^{n/d/k} \sum&#95;{j=1}^{m/d/k} ij&#92;]
把&#92;(f(1)&#92;)代回到&#92;(Ans&#92;)
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{k=1}^{n/d} \mu(k) &#42; k^2 \sum&#95;{i=1}^{n/d/k} \sum&#95;{j=1}^{m/d/k} ij&#92;]
内外两层数论分块，可以做到总复杂度&#92;(O(n)&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000010;
const int inf=2147483647;
const ll Mod=20101009;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll Sum[maxNum];

void GetMu();//计算mu
ll Calc(ll n,ll m);//内层数论分块

int main()
{
    GetMu();
    ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));//外层数论分块
        ll s=(last+i)*(last-i+1)/2;
        ans=(ans+s%Mod*Calc(n/i,m/i)%Mod)%Mod;
    }
    printf("%lld\n",ans);
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Sum[i]=((Sum[i-1]+(ll)Mu[i]*(ll)i*(ll)i)%Mod+Mod)%Mod;
    return;
}

ll Calc(ll n,ll m)
{
    if (n&gt;m) swap(n,m);
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ll l1=n/i,l2=m/i;
        ll s1=(1+l1)*l1/2%Mod,s2=(1+l2)*l2/2%Mod;
        ret=(ret+((Sum[last]-Sum[i-1])+Mod)%Mod*s1%Mod*s2%Mod)%Mod;
    }
    return (ret%Mod+Mod)%Mod;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>201</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 22:18:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-16 14:18:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-2154-luogu-1829-crash%e7%9a%84%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[173]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2693] jzptab （莫比乌斯反演，积性函数，线性筛）</title>
		<link>http://sycstudio.com/archives/208</link>
		<pubDate>Tue, 16 Jan 2018 14:54:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=208</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="http://sycstudio.com/bzojch/file/2693_0.jpg" alt="BZOJ2693" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2693">BZOJ</a>
权限题，提供本站离线版本：<a href="http://sycstudio.com/bzojch/p/2693.html">bzojch</a>

<h3>Tag</h3>

莫比乌斯反演，线性筛，积性函数

<h2>题目大意</h2>

与<a href="http://sycstudio.com/archives/201">这道题</a>一样，但变成了多组数据。

<h2>解决思路</h2>

前面的式子到<a href="http://sycstudio.com/archives/201">这道题</a>查看，我们直接从那一道题的结尾开始推。
在那道题的最后，我们得到
&#92;[Ans=\sum&#95;{d=1}^{n} d &#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; \sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} ij&#92;]
由于后面是两个等差数列求和，所以我们设&#92;(S(i)=\frac{(i+1)&#42;i}{2}&#92;)，那么就有
&#92;[Ans=\sum&#95;{d=1}^{n} d&#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; S(\frac{n}{dx}) &#42; S(\frac{m}{dx})&#92;]
设&#92;(T=x&#42; d&#92;)，则
&#92;[Ans=\sum&#95;{d=1}^{n} d&#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; S(\frac{n}{T}) &#42; S(\frac{m}{T})&#92;]
现在我们考虑枚举&#92;(T&#92;)，那么因为&#92;(T=x&#42;d&#92;)，所以对于每一个&#92;(d|T&#92;)，&#92;(d&#92;)都有&#92;(\mu(x)&#42;d&#42;x^2&#92;)的贡献。又因为&#92;(x=\frac{T}{d}&#92;)，所以，式子就化为
&#92;[Ans=\sum&#95;{T=1}^{n} S(\frac{n}{T}) &#42; S(\frac{m}{T}) &#42; \sum&#95;{d|T} \mu(d) Td&#92;]
后面这一部分是积性函数，可以线性筛出来的，具体讨论一下。
设&#92;(p&#92;)为质数，设&#92;[f(x)=\sum&#95;{d|T} \mu(d) T&#42;d=T&#42;\sum&#95;{d|T} \mu(d) &#42; d&#92;]
那么就有
&#92;[\begin{cases} f(p)=p&#42;(\mu(1)&#42;1+\mu(p)&#42;p)=p-p^2 &#92;&#92; f(p&#42;i)=f(p)&#42;f(i) \quad \quad \quad \quad \quad \quad \quad gcd(i,p)==1 &#92;&#92; f(p&#42;i)=p&#42;f(i) \quad \quad \quad \quad \quad \quad \quad \quad gcd(i,p)==p \end{cases}&#92;]
线性筛出&#92;(f(i)&#92;)，求前缀和数论分块，就可以把单次询问的复杂度降到&#92;(O(\sqrt{n})&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000100;
const ll Mod=100000009;
const int inf=2147483647;

ll Sum[maxNum];
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Sieve();//线性筛求f(i)

int main()
{
    Sieve();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));//数论分块
            ll l1=n/i,l2=m/i;
            ll s1=l1*(1ll+l1)/2%Mod,s2=l2*(1ll+l2)/2%Mod;//这里计算出来的是两个等差数列的和
            ans=((ans+(((Sum[last]-Sum[i-1])%Mod+Mod)%Mod)*s1%Mod*s2%Mod)%Mod+Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Sieve()//线性筛
{
    notprime[1]=1;Sum[1]=1;
    for (ll i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Sum[i]=(i-i*i+Mod)%Mod;
        for (ll j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                Sum[i*Prime[j]]=Sum[i]*Prime[j]%Mod;break;
            }
            Sum[i*Prime[j]]=Sum[i]*Sum[Prime[j]]%Mod;
        }
    }
    for (int i=1;i&lt;maxNum;i++) Sum[i]=((Sum[i]+Sum[i-1])%Mod+Mod)%Mod;//计算前缀和
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>208</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 22:54:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-16 14:54:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2693-jzptab-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0%ef%bc%8c%e7%ba%bf%e6%80%a7%e7%ad%9b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[193]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ2480/Luogu2303/BZOJ2705] [SDOI2012]Longge的问题（欧拉函数）</title>
		<link>http://sycstudio.com/archives/230</link>
		<pubDate>Wed, 17 Jan 2018 14:57:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=230</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Longge的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。现在问题来了：给定一个整数N，你需要求出∑gcd(i, N)(1&lt;=i &lt;=N)。

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-2480">POJ</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2705">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2303">Luogu</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=1}^{n} gcd(i,n)&#92;]

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/110">这一题</a>类似，设&#92;(n=a&#42;b&#92;)，那么若有&#92;(gcd(a&#42;b,a&#42;c)==a&#92;)，则&#92;(gcd(b,c)==1&#92;)，那么题目变成求&#92;(\phi(n/a)&#92;)。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

ll Phi(ll x);

int main()
{
    ll n;
    while (scanf("%lld",&amp;n)!=EOF)
    {
        ll ans=0;
        for (ll i=1;(ll)i*(ll)i&lt;=n;i++)
            if (n%i==0)
            {
                ans=ans+(ll)i*(ll)Phi(n/i);
                if (i*i!=n) ans=ans+(ll)(n/i)*(ll)Phi(i);
            }
        printf("%lld\n",ans);
    }
    return 0;
}

ll Phi(ll x)
{
    //cout&lt;&lt;"Phi:"&lt;&lt;x&lt;&lt;" ";
    ll ret=x;
    for (ll i=2;(ll)i*(ll)i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x!=1) ret=ret/x*(x-1);
    //cout&lt;&lt;ret&lt;&lt;endl;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>230</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 22:57:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 14:57:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[poj2480-luogu2303-bzoj2705-sdoi2012longge%e7%9a%84%e9%97%ae%e9%a2%98%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[199]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2301/Luogu2522][HAOI2011]Problem b（莫比乌斯反演，容斥原理，数论分块）</title>
		<link>http://sycstudio.com/archives/233</link>
		<pubDate>Wed, 17 Jan 2018 15:17:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=233</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2301">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2522">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，容斥原理，数论分块

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=a}^{b} \sum&#95;{j=c}^{d} [gcd(i,j)==K]&#92;]

<h2>解决思路</h2>

先考虑求解&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)==K&#92;]
这个式子可以化成&#92;[Ans=\sum&#95;{i=1}^{n/K} \sum&#95;{j=1}^{m/K} [gcd(i,j)==1]&#92;]
由莫比乌斯反演可得（具体推导可以参考<a href="http://sycstudio.com/archives/146">这里</a>）
&#92;[Ans=\sum&#95;{i=1}^{n/K} \mu(i) \lfloor \frac{n/K}{i} \rfloor &#42; \lfloor \frac{m/K}{i} \rfloor&#92;]
那么再考虑&#92;(i&#92;)从&#92;(a&#92;)开始，&#92;(j&#92;)从&#92;(c&#92;)开始。可以像求二维前缀和一样简单容斥一下，设&#92;[Calc(n,m)=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==1]&#92;]，那么最后的答案就是
&#92;[Ans=Calc(b,d)-Calc(a-1,d)-Calc(b,c-1)+Calc(a-1,c-1)&#92;]

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=50010;
const int inf=2147483647;

int Mu[maxNum];
int Musum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求mu
int Calc(int n,int m);//计算子问题

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int a,b,c,d,K;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;K);
        printf("%d\n",Calc(b/K,d/K)-Calc((a-1)/K,d/K)-Calc(b/K,(c-1)/K)+Calc((a-1)/K,(c-1)/K));
    }
    return 0;
}

void GetMu()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

int Calc(int n,int m)
{
    int ret=0;if (n&gt;m) swap(n,m);
    for (int i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ret=ret+(Musum[last]-Musum[i-1])*(n/i)*(m/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>233</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 23:17:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 15:17:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2301-luogu2522haoi2011problem-b%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[171]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>关站通知</title>
		<link>http://sycstudio.com/?p=908</link>
		<pubDate>Wed, 30 May 2018 05:47:19 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=908</guid>
		<description></description>
		<content:encoded><![CDATA[由于博主退役，本站将不再维护。
内容将保留至&#92;(2018.12.23&#92;)，届时域名和空间将到期，本站正式关闭。
评论审核关闭。
sycstudio.com存活了：158天13小时45分7秒

以上
站长 SYC
2018.5.30

2018.8.14 Update:
博主并没有弃坑啊，只是写了懒得发上来了，如果需要可以到<a href="https://github.com/SYCstudio/Vnote">github</a> 查看。<del>不保证能看懂</del><br />
顺带清理了下面的无用评论]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>908</wp:post_id>
		<wp:post_date><![CDATA[2018-05-30 13:47:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-30 05:47:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e7%ab%99%e9%80%9a%e7%9f%a5]]></wp:post_name>
		<wp:status><![CDATA[pending]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<category domain="category" nicename="wordpress"><![CDATA[wordpress]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[%e5%85%b3%e7%ab%99%e5%85%ac%e5%91%8a]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1646]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>133</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-30 18:37:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-30 10:37:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[sycstudio.com倒闭了，不干了。
原价600的AC代码，现在只要1.8！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>134</wp:comment_id>
			<wp:comment_author><![CDATA[xzz]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xuzhouzi@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://cnblogs.com/xzz_233</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-30 18:40:13]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-30 10:40:13]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[宣布倒闭 http://sycstudio.com 倒闭了 不干了 现有大量AK代码出售 一套5份随机代码出售 60套AK代码只需388元，一套AK代码至少包含一份稀有代码]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>16</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>135</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-30 18:41:04]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-30 10:41:04]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[湖南长郡湖南长郡最大个人博客sycstudio.com倒闭了，倒闭了
湖南长郡湖南长郡 sycstudio.com倒闭了
湖南长郡 最大个人博客  sycstudio.com倒闭了
王八蛋王八蛋根根博主 天天看番天天看番
各大考试gg了 带着他的万由里跑了
我们没有没有没有办法办法 拿着博文抵工资工资
原价都是100多 200多 300多的代码 统统20块
20块20块统统20块 统统统统统统20块
根根王八蛋 王八蛋根根 你不是你不是你不是人
100多 200多 300多的博文 统统20块统统20块
根根王八蛋 王八蛋根根 你不是你不是你不是人
我们辛辛苦苦干了 辛辛苦苦追你博文大半年
你你你不更不更博文博文 你还我还我血汗钱
还我血汗钱！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>137</wp:comment_id>
			<wp:comment_author><![CDATA[Cyhlnj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1806599497@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjoieryl</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-30 21:20:40]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-30 13:20:40]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您进队稳了，不要搞这种fake的事情]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>138</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-31 08:02:54]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-31 00:02:54]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主你什么时候退役的？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>139</wp:comment_id>
			<wp:comment_author><![CDATA[asas]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[983521345@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[171.215.206.11]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-31 09:13:06]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-31 01:13:06]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[假的吧？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>140</wp:comment_id>
			<wp:comment_author><![CDATA[iotang]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3057244225@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-06-07 20:31:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-06-07 12:31:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主真fAKe]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>141</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-06-08 14:13:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-06-08 06:13:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[sycstudio.com倒闭了，不干了。
原价600的AC代码，现在只要1.8！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>155</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-08-14 20:32:06]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-08-14 12:32:06]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[真的/滑稽]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>139</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>157</wp:comment_id>
			<wp:comment_author><![CDATA[XZYQvQ]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.k-xzy.xyz</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[149.28.83.246]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-08-21 20:34:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-08-21 12:34:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[蛤？
发github上比发wp上更方便？？？
<del>你是没钱了吧</del>]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>158</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.119]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-08-21 21:23:51]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-08-21 13:23:51]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[因为我现在都是在本地机子上写的，反正也要同步到github上去。
<del>钱？这辈子都不可能有钱的</del>]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>157</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>test</title>
		<link>http://sycstudio.com/?p=946</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=946</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>section</h1>

<h2>subsection</h2>

<h3>subsubsection</h3>

<pre><code class="language-cpp ">#include&lt;bits/stdc++.h&gt;
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>946</wp:post_id>
		<wp:post_date><![CDATA[2018-09-26 14:16:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1257/Luogu2261][CQOI2007]余数求和（数论分块）</title>
		<link>http://sycstudio.com/archives/239</link>
		<pubDate>Wed, 17 Jan 2018 15:35:13 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=239</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给出正整数n和k，计算G(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如G(10, 5)=5 mod 1 + 5 mod 2 + 5 mod 3 + 5 mod 4 + 5 mod 5 …… + 5 mod 10=0+1+2+1+0+5+5+5+5+5=29

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1257">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2261">Luogu</a>

<h3>Tag</h3>

数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} K\ mod\ i &#92;)

<h2>解决思路</h2>

由于&#92;(a%b=a-b&#42;\lfloor \frac{a}{b} \rfloor&#92;)，所以式子可以化为
&#92;[\sum&#95;{i=1}^{n} (K-i&#42;\lfloor \frac{K}{i} \rfloor ) &#92;&#92; =n&#42;K-\sum&#95;{i=1} \lfloor \frac{K}{i} \rfloor&#92;]
后面这个式子可以数论分块做。
需要注意&#92;(n &lt; K&#92;)的情况，此时分块会浮点溢出（除&#92;(0&#92;)错误），所以要控制循环上界

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

int main()
{
    ll n,K;scanf("%lld%lld",&amp;n,&amp;K);
    ll ans=0;
    ans=n*K;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        if ((ll)(K/i)==0) break;//及时退出，防止除0
        last=min(K/((ll)(K/i)),n);
        ll s1=(last+i)*(last-i+1)/2;
        //cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;
        ans=ans-s1*(ll)((K/i));
    }
    printf("%lld\n",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>239</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 23:35:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 15:35:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1257-luogu2261cqoi2007%e4%bd%99%e6%95%b0%e6%b1%82%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[218]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3994/Luogu3327][SDOI2015]约数个数和（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/244</link>
		<pubDate>Wed, 17 Jan 2018 17:03:44 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=244</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

设d(x)为x的约数个数，给定N、M，求
 <img src="http://sycstudio.com/bzojch/file/3994_0.jpg" alt="BZOJ3994" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3994">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3327">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块，线性筛

<h2>题目大意</h2>

求&#92;( \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} d(ij) &#92;)，其中&#92;( d(x) &#92;)表示&#92;( x &#92;)的约数个数

<h2>解决思路</h2>

首先观察&#92;( d(ij) &#92;)，这个式子我们不好处理。假设我们枚举&#92;( u|i,v|j &#92;)，那么&#92;( u&#42;\frac{m}{v} &#92;)就一定对&#92;( d(ij) &#92;)有&#92;( 1 &#92;)的贡献。
那么式子是不是就变成
&#92;[ \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \sum&#95;{u|i} \sum&#95;{v|i} &#92;]
显然不是的。这样会算重。具体来说，设$$p$$为质数，若&#92;( u'=u&#42;p &#92;)，&#92;( v'=v&#42;p&#92;)，那么&#92;( u'&#92;)与&#92;(v'&#92;)对答案的贡献会与&#92;(u&#92;)和&#92;(v&#92;)重复，即&#92;(u'&#42; \frac{m}{v'}=u&#42;p &#42; \frac{m}{v&#42;p}=u&#42;\frac{m}{v}&#92;)
所以我们发现，对于这个式子，应该要求$$u,v$$互质，即&#92;(gcd(u,v)==1&#92;)
结合上面的分析，我们可以得到这个初始式子
&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \sum&#95;{u|i} \sum&#95;{v|j} [gcd(i,j)==1]&#92;]
把&#92;(u,v&#92;)提到前面来，因为&#92;(i&#92;)是&#92;(u&#92;)的倍数，在&#92;([1..n]&#92;)内一共有&#92;(\lfloor \frac{n}{u} \rfloor&#92;)这么多个&#92;(u&#92;)的倍数，那么也就有这么多个给&#92;(u&#92;)的代价，&#92;(v&#92;)的分析也是同理，所以得到
&#92;[Ans=\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [gcd(u,v)==1]&#92;]
接下来莫比乌斯反演
设&#92;[f(x)=\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [gcd(u,v)==x]&#92;]
设&#92;[g(x)=\sum&#95;{x|d}^{n} f(d) &#92;&#92; =\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [x|gcd(u,v)] &#92;&#92; =\sum&#95;{u=1}^{n/x} \sum&#95;{v=1}^{m/x} \lfloor \frac{n/x}{u} \rfloor &#42; \lfloor \frac{m/x}{v} \rfloor [1|gcd(u,v)]&#92;]
&#92;([1|gcd(u,v)]&#92;)显然成立，所以
&#92;[g(x)=\sum&#95;{u=1}^{n/x} \sum&#95;{v=1}^{m/x} \lfloor \frac{n/x}{u} \rfloor &#42; \lfloor \frac{m/x}{v} \rfloor&#92;]
现在的问题就变成，如何快速地求&#92;(\sum&#95;{i=1}^{n} \lfloor \frac{n}{i} \rfloor&#92;) ？
考虑&#92;(\lfloor \frac{n}{i} \rfloor&#92;)的概念，它就是&#92;(n&#92;)内有多少个&#92;(i&#92;)的因数。而把这些次数累加起来，是不是就是&#92;(1&#92;)到&#92;(n&#92;)的约数个数和？
形式化的，设&#92;(F(x)&#92;)表示数&#92;(x&#92;)有多少个约数，则有&#92;(\sum&#95;{i=1}^{n} \lfloor \frac{n}{i} \rfloor=\sum&#95;{i=1}^{n} F(i)&#92;)。非常巧妙。
而&#92;(F(x)&#92;)是积性函数，可以线性筛，这样我们就把求解&#92;(\sum \lfloor \frac{n}{i} \rfloor&#92;)的复杂度由&#92;(O(n&#42;\sqrt{n})&#92;)降到了&#92;(O(n)&#92;)。
具体来说，&#92;(F(x)&#92;)可以这样求。
根据唯一分解定理&#92;(x=\prod p&#95;{i}^{a^i}&#92;)，其中&#92;(p&#92;)为质数。
那么我们可以得到求解单个&#92;(F(x)&#92;)的方法，即&#92;(F(x)=\prod ({a^i}+1)&#92;)。知道这个式子，对于我们下面的推导有帮助。
接下来分类讨论，设&#92;(p&#92;)为质数
首先&#92;(F(p)&#92;)很好求，它就是&#92;(2&#92;)
再来考虑&#92;(F(p&#42;i)\ [gcd(p,i)==1]&#92;)，这个也很好求，根据积性函数的性质，&#92;(F(p&#42;i)=F(p)&#42;F(i)&#92;)
关键是&#92;(F(p&#42;i)\ [gcd(p,i)==p]&#92;)的情况。由于&#92;(i&#92;)中已经有了&#92;(p&#92;)，形式化地，设&#92;(i=i'&#42;p^k&#92;)，那么在&#92;(F(i)&#92;)中已经乘进去了&#92;((k+1)&#92;)这一项。我们若想得到&#92;(F(p&#42;i)&#92;)，那么就把&#92;(F(i)&#92;)除掉&#92;((k+1)&#92;)这一项再乘以&#92;((k+2)&#92;)。具体来说，我们对于每一个&#92;(i&#92;)再记录一个&#92;(Low(i)&#92;)表示把&#92;(i&#92;)唯一分解后最小的质因子&#92;(p&#95;1&#92;)的指数，那么&#92;(F(p&#42;i)=F(i)/(Low[i]+1)&#42;(Low[i]+2)&#92;)
现在，我们就可以&#92;(O(1)&#92;)地求&#92;(g(x)&#92;)了。回到莫比乌斯反演。
&#92;[f(x)=\sum&#95;{x|d} \mu(\frac{d}{x}) g(d) &#92;&#92; = \sum&#95;{x|d} \mu(\frac{d}{x}) \sum&#95;{u=1}^{n/d} \lfloor \frac{\frac{n}{d}}{u} \rfloor \sum&#95;{v=1}^{m/d} \lfloor \frac{\frac{m}{d}}{v} \rfloor&#92;]
最后把我们要求的$$f(1)$$带进去
&#92;[f(1)=\sum&#95;{i=1}^{n} \mu(i) \sum&#95;{u=1}^{n/i} \lfloor \frac{\frac{n}{i}}{u} \rfloor \sum&#95;{v=1}^{m/i} \lfloor \frac{\frac{m}{i}}{v} \rfloor&#92;]
后面一块是可以&#92;(O(1)&#92;)求的，那么我们把前面分块，预处理&#92;(\mu(i)&#92;)的前缀和就可以了。
预处理复杂度&#92;(O(n)&#92;)
单次询问复杂度&#92;(O(\sqrt{n})&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=50010;
const int inf=2147483647;

ll Mu[maxNum],Low[maxNum];//莫比乌斯函数，唯一分解的最小质因子个数
ll Musum[maxNum],F[maxNum];//mu前缀和，约数个数和前缀和
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Init();//线性筛求mu和约数个数

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));//数论分块
            ans=ans+(Musum[last]-Musum[i-1])*F[n/i]*F[m/i];
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;Low[1]=1;F[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Low[i]=1,F[i]=2;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                Low[i*Prime[j]]=Low[i]+1;
                F[i*Prime[j]]=F[i]/(Low[i]+1)*(Low[i]+2);
                break;
            }
            Mu[i*Prime[j]]=-Mu[i];
            F[i*Prime[j]]=F[i]*F[Prime[j]];
            Low[i*Prime[j]]=1;
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i],F[i]+=F[i-1];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>244</wp:post_id>
		<wp:post_date><![CDATA[2018-01-18 01:03:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 17:03:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3994-luogu3327sdoi2015%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[201]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2818/Luogu2568] gcd （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/294</link>
		<pubDate>Fri, 19 Jan 2018 23:45:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的
数对(x,y)有多少对.

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)\ is\ a\ prime]&#92;)

<h2>解决思路</h2>

设&#92;( f(d)=\begin{cases} 1 \quad d\ is\ a\ prime &#92;&#92; 0 \quad\ d\ is\ not\ a\ prime\end{cases}&#92;)
提取$$gcd(i,j)==d$$，得到
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==1]&#92;]
根据以前（<a href="http://sycstudio.com/archives/146">这里</a>）推出的式子，由莫比乌斯反演得
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor^2&#92;]
那么记一下质数个数的前缀和以及&#92;(\mu()&#92;)的前缀和前后两层数论分块即可

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000010;
const int inf=2147483647;

int Mu[maxNum],Musum[maxNum];
int Prisum[maxNum];
int pricnt=0,Prime[maxNum/1000];
bool notprime[maxNum];

void Init();//线性筛求mu
ll Calc(int n);//内层分块

int main()
{
    Init();
    int n;scanf("%d",&amp;n);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);//外层分块
        ans=ans+(Prisum[last]-Prisum[i-1])*Calc(n/i);
    }
    printf("%lld\n",ans);
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Prisum[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i],Prisum[i]+=Prisum[i-1];
    return;
}

ll Calc(int n)
{
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        ret=ret+(Musum[last]-Musum[i-1])*(ll)((n/i))*(ll)((n/i));
    }
    //cout&lt;&lt;n&lt;&lt;" "&lt;&lt;ret&lt;&lt;endl;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 07:45:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-19 23:45:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2818-luogu2568-gcd-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[319]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>116</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.53]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-31 23:47:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-31 15:47:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[萝卜，你的luogu链接假了，是你的提交记录链接]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>118</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.2.3]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-01 19:46:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-01 11:46:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已更改]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>116</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>122</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-03 15:17:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-03 07:17:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[改的方式是删除链接？！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>118</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>123</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-03 17:33:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-03 09:33:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您真聪明]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>122</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2820/Luogu2257]YY的GCD（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/314</link>
		<pubDate>Sat, 20 Jan 2018 00:08:35 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=314</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

神犇YY虐完数论后给傻×kAc出了一题给定N, M,求1&lt;=x&lt;=N, 1&lt;=y&lt;=M且gcd(x, y)为质数的(x, y)有多少对kAc这种
傻×必然不会了，于是向你来请教……多组输入

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2820">BZOJ</a>
权限题，提供本站离线版本<a href="http://sycstudio.com/bzojch/p/2820.html">BZOJch</a>
<a href="https://www.luogu.org/problemnew/show/P2257">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块，线性筛

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)\ is\ a\ prime]&#92;)

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/294">这一题</a>类似，但是有多组数据。
直接从那一题的结尾开始推
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor^2&#92;]
另&#92;(T=id&#92;)，变枚举&#92;(d&#92;)为枚举&#92;(T&#92;)
&#92;[Ans=\sum&#95;{T=1}^{n} \lfloor \frac{n}{T} \rfloor ^2 \sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;]
后面这个东西&#92;(\sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;)虽然不是积性函数，但是可以线性筛的，具体来说，设&#92;(h(x)=\sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;)，那么有
设&#92;(p&#92;)为质数
&#92;(h(p)=1&#92;)，这个很容易得到
&#92;(h(p&#42;i)=\mu(i) \quad [gcd(p,i)==p]&#92;)。这个的原理是如果乘进去一个质数&#92;(p&#92;)，并且这个&#92;(p&#92;)在&#92;(i&#92;)中已经出现过了，那么在&#92;(\mu(x)&#92;)中就必定有大于等于&#92;(2&#92;)个质因子&#92;(p&#92;)，根据莫比乌斯函数的定义&#92;(\mu(x)==0&#92;)，所以就只剩&#92;(\mu(i))&#92;)自己的贡献
&#92;(h(p&#42;i)=\mu(i)-h(i) \quad [gcd(p,i)==1]&#92;)。原因是由于乘进去一个互质质数&#92;(p&#92;)，原来的莫比乌斯函数要变号，再加上&#92;(mu(i)&#92;)的贡献。
那么结合数论分块，可以做到&#92;(O(n)&#92;)预处理，&#92;(O(\sqrt{n})&#92;)单次询问

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=10000010;
const int inf=2147483647;

ll F[maxNum];
int Mu[maxNum];
int pricnt=0,Prime[maxNum/100];
bool notprime[maxNum];

void Init();

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n,m;scanf("%d%d",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (int i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));
            ans=ans+(F[last]-F[i-1])*(ll)((n/i))*(ll)((m/i));
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    Mu[1]=1;F[1]=0;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,F[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                F[i*Prime[j]]=Mu[i];
                break;
            }
            Mu[i*Prime[j]]=-Mu[i];
            F[i*Prime[j]]=Mu[i]-F[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) F[i]+=F[i-1];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>314</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 08:08:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 00:08:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2820-luogu2257yy%e7%9a%84gcd%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c%e7%ba%bf%e6%80%a7%e7%ad%9b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[223]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4407]于神之怒加强版（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/316</link>
		<pubDate>Sat, 20 Jan 2018 13:02:35 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=316</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给下N,M,K.求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)^k \mod (10^9+7) &#92;)

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4407">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)^k&#92;)

<h2>解决思路</h2>

先提取&#92;(gcd(i,j)==d&#92;)
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d]&#92;]
继续化为
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1]&#92;]
根据莫比乌斯反演，后面部分可以化简，所以得到
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \lfloor \frac{n}{id} \rfloor \lfloor \frac{m}{id} \rfloor &#92;]
令&#92;(T=id&#92;)，则有
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor &#92;]
把枚举&#92;(d&#92;)变成枚举&#92;(T&#92;)，考虑每一个&#92;(\mu(i)&#92;)的贡献，可以得到
&#92;[\sum&#95;{T=1}^{n} \lfloor \frac{n}{T} \rfloor \lfloor \frac{n}{T} \rfloor \sum&#95;{d|T} d^k \mu(\frac{T}{d}) &#92;]
后面一块东西是积性函数，可以线性筛，具体来说，设&#92;(g(x)=\sum&#95;{d|x} d^k \mu(\frac{x}{d})&#92;)，则分情况讨论
设&#92;(p&#92;)为质数
&#92;[g(p)=p^k-1&#92;]
这个比较好理解，&#92;(p&#92;)是质数那么&#92;(d&#92;)就只有两种取值，一个得到&#92;(p^k&#42;\mu(1)=p^k&#92;)，另一个得到&#92;(1^k&#42;\mu(p)=-1&#92;)。
&#92;[g(p&#42;i)=g(p)&#42;g(i) \quad [gcd(i,p)==1]&#92;]
这个直接由积性函数性质得到
&#92;[g(p&#42;i)=g(i)&#42;p^k \quad [gcd(i,p)==p]&#92;]
这个的话，考虑加进去一个原来已经存在的质因子&#92;(p&#92;)，那么只会影响&#92;(d^k&#92;)变成&#92;((d&#42;p)^k&#92;)，所以补一个&#92;(p^k&#92;)进去就可以了
那么求出后面那一块之后，前缀和数论分块即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=5000010;
const ll Mod=1e9+7;
const int inf=2147483647;

int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll H[maxNum];
ll Pow[maxNum];

int K;

void Init();
int QPow(ll x,int cnt);

int main()
{
    int T;
    scanf("%d%d",&amp;T,&amp;K);
    Init();//线性筛初始化
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {//数论分块
            last=min(n/(n/i),m/(m/i));
            ans=(ans+(H[last]-H[i-1]+Mod)%Mod*(ll)((n/i))%Mod*(ll)((m/i))%Mod)%Mod;
        }
        printf("%lld\n",ans%Mod);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;H[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Pow[pricnt]=QPow(i,K),H[i]=Pow[pricnt]-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                H[i*Prime[j]]=H[i]*Pow[j]%Mod;
                break;
            }
            H[i*Prime[j]]=H[i]*H[Prime[j]]%Mod;
        }
    }
    for (int i=1;i&lt;maxNum;i++) H[i]=(H[i]+H[i-1])%Mod;
    return;
}

int QPow(ll x,int cnt)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>316</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 21:02:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 13:02:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4407%e4%ba%8e%e7%a5%9e%e4%b9%8b%e6%80%92%e5%8a%a0%e5%bc%ba%e7%89%88%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c%e7%ba%bf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[206]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1013/Luogu4035][JSOI2008]球形空间产生器sphere（高斯消元）</title>
		<link>http://sycstudio.com/archives/324</link>
		<pubDate>Sat, 20 Jan 2018 13:57:17 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=324</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4035">Luogu</a>

<h3>Tag</h3>

高斯消元

<h2>题目大意</h2>

求解方程组

<h2>解决思路</h2>

根据题目给出的计算&#92;(n&#92;)维空间的两点坐标公式，我们可以列出&#92;(n+1&#92;)个连等式，随便选择一个作为基准，其它的都与它相消，便可以去掉所有的未知数的平方项，然后高斯消元即可

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ld long double

const int maxN=20;
const int inf=2147483647;

int n;
ld Mat[maxN][maxN];
ld Input[maxN][maxN];
ld Ans[maxN];

void Guess();

int main()
{
    scanf("%d",&amp;n);//读入数据
    for (int i=0;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) scanf("%LF",&amp;Input[i][j]);
    for (int i=1;i&lt;=n;i++)//构造n个方程
    {
        for (int j=1;j&lt;=n;j++) Mat[i][j]=(ld)2*(Input[i][j]-Input[0][j]);
        ld s1=0,s2=0;
        for (int j=1;j&lt;=n;j++) s1=s1+Input[i][j]*Input[i][j],s2=s2+Input[0][j]*Input[0][j];
        Mat[i][n+1]=s1-s2;
    }
    Guess();//高斯消元
    printf("%.3LF",Ans[1]);
    for (int i=2;i&lt;=n;i++) printf(" %.3LF",Ans[i]);
    return 0;
}

void Guess()//从上到下消元
{
    for (int i=1;i&lt;=n;i++)
        for (int j=i+1;j&lt;=n;j++)
        {
            ld ret=Mat[j][i]/Mat[i][i];
            for (int k=i;k&lt;=n+1;k++)
                Mat[j][k]-=Mat[i][k]*ret;
        }
    Ans[n]=Mat[n][n+1]/Mat[n][n];
    for (int i=n-1;i&gt;=1;i--)//从下到上得到答案
    {
        ld sum=0;
        for (int j=i;j&lt;=n;j++) sum=sum+Mat[i][j]*Ans[j];
        Ans[i]=(Mat[i][n+1]-sum)/Mat[i][i];
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>324</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 21:57:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 13:57:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1013-luogu4035jsoi2008%e7%90%83%e5%bd%a2%e7%a9%ba%e9%97%b4%e4%ba%a7%e7%94%9f%e5%99%a8sphere%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[200]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3626][LNOI2014]LCA（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/328</link>
		<pubDate>Sat, 20 Jan 2018 15:04:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=328</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。有q次询问，每次询问给出l r z，求&#92;(\sum&#95;{l&lt;=i&lt;=r}dep[LCA(i,z)]&#92;)。（即，求在[l,r]区间内的每个节点i与z的最近公共祖先的深度之和）

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3626">BZOJ</a>

<h3>Tag</h3>

树链剖分，离线

<h2>解决思路</h2>

先考虑单次询问，如果我们对于点&#92;(i \in [l,r]&#92;)，都把&#92;(i&#92;)到根的路径加一，那么从我们询问的点到根的路径权值之和就是此次询问的答案。
处理路径覆盖，我们可以采用树链剖分+线段树的方式实现。
现在考虑多组数据，我们可以离线操作，把输入读进来排序，记录左端点和右端点分别处理，这样就可以回答多组询问了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=60010;
const int maxM=maxN*2;
const int Mod=201314;
const int inf=2147483647;

class Question//每一个询问
{
public:
    int pos,id;//位置，询问的编号
    int lr;//是id这个询问的左区间还是右区间
};

bool operator &lt; (Question A,Question B)//排序区间方便离线
{
    return A.pos&lt;B.pos;
}

int n;
int edgecnt=-1,Head[maxN],Next[maxM],V[maxM];//图
int Depth[maxN],Fa[maxN],Size[maxN],Hson[maxN],Top[maxN];//树链剖分
int idcnt=0,Id[maxN];
int Seg[maxN*8],Lazy[maxN*8];//线段树
Question Qn[maxN*4];//询问
int QPos[maxN],Ans[maxN];//答案

void Add_Edge(int u,int v);
void dfs1(int u);
void dfs2(int u,int nowtop);
void TCAdd(int pos);
int TCQuery(int pos);
void SegModify(int now,int l,int r,int ql,int qr,int delta);
int SegQuery(int now,int l,int r,int ql,int qr);
void PushDown(int now,int l,int r);
void SegOutp(int now,int l,int r);

int main()
{
    mem(Head,-1);int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;n;i++){ int fa;scanf("%d",&amp;fa);Add_Edge(fa+1,i+1);Fa[i+1]=fa+1; }
    //树链剖分预处理
    Depth[1]=1;
    dfs1(1);
    dfs2(1,1);
    //读入询问
    int qtot=0;
    for (int i=1;i&lt;=Q;i++)
    {
        int l,r;scanf("%d%d%d",&amp;l,&amp;r,&amp;QPos[i]);l++;r++;QPos[i]++;
        if (l!=1) {Qn[++qtot].id=i;Qn[qtot].pos=l-1;Qn[qtot].lr=0;}//注意这里的-1
        Qn[++qtot].id=i;Qn[qtot].pos=r;Qn[qtot].lr=1;
    }
    sort(&amp;Qn[1],&amp;Qn[qtot+1]);//排序询问
    int nowr=0;
    for (int i=1;i&lt;=qtot;i++)
    {
        while (nowr&lt;Qn[i].pos)
        {
            nowr++;TCAdd(nowr);//插入
        }
        //得到询问
        if (Qn[i].lr==0) Ans[Qn[i].id]-=TCQuery(QPos[Qn[i].id]);
        else Ans[Qn[i].id]+=TCQuery(QPos[Qn[i].id]);
    }
    for (int i=1;i&lt;=Q;i++)
        printf("%d\n",(Ans[i]%Mod+Mod)%Mod);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u)
{
    Size[u]=1;
    int mxsz=0;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        Depth[V[i]]=Depth[u]+1;
        dfs1(V[i]);
        Size[u]+=Size[V[i]];
        if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
    }
    return;
}

void dfs2(int u,int nowtop)
{
    Top[u]=nowtop;
    Id[u]=++idcnt;
    if (Hson[u]!=0) dfs2(Hson[u],nowtop);
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Hson[u])
            dfs2(V[i],V[i]);
    return;
}

void TCAdd(int pos)//将pos到根的路径上的每一条边+1
{
    while (Top[pos]!=1)
    {
        SegModify(1,1,n,Id[Top[pos]],Id[pos],1);
        pos=Fa[Top[pos]];
    }
    SegModify(1,1,n,1,Id[pos],1);
    return;
}

int TCQuery(int pos)//询问pos到根的路径上的权值之和
{
    int ret=0;
    while (Top[pos]!=1)
    {
        ret=(ret+SegQuery(1,1,n,Id[Top[pos]],Id[pos])%Mod)%Mod;
        pos=Fa[Top[pos]];
    }
    ret=(ret+SegQuery(1,1,n,1,Id[pos])%Mod)%Mod;
    return ret;
}

void SegModify(int now,int l,int r,int ql,int qr,int delta)//线段树区间修改
{
    PushDown(now,l,r);
    if ((l==ql)&amp;&amp;(r==qr))
    {
        Seg[now]=(Seg[now]+(ll)(r-l+1)*(ll)delta%Mod)%Mod;
        Lazy[now]+=delta;
        return;
    }
    int mid=(l+r)/2;
    if (qr&lt;=mid) SegModify(now*2,l,mid,ql,qr,delta);
    else if (ql&gt;mid) SegModify(now*2+1,mid+1,r,ql,qr,delta);
    else
    {
        SegModify(now*2,l,mid,ql,mid,delta);
        SegModify(now*2+1,mid+1,r,mid+1,qr,delta);
    }
    Seg[now]=(Seg[now*2]+Seg[now*2+1])%Mod;
    return;
}

int SegQuery(int now,int l,int r,int ql,int qr)//线段树区间查询
{
    PushDown(now,l,r);
    if ((ql==l)&amp;&amp;(qr==r))
        return Seg[now]%Mod;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return SegQuery(now*2,l,mid,ql,qr)%Mod;
    if (ql&gt;=mid+1) return SegQuery(now*2+1,mid+1,r,ql,qr)%Mod;
    return (SegQuery(now*2,l,mid,ql,mid)+SegQuery(now*2+1,mid+1,r,mid+1,qr))%Mod;
}

void PushDown(int now,int l,int r)//下放操作
{
    if (Lazy[now]==0) return;
    int mid=(l+r)/2;
    Seg[now*2]=(Seg[now*2]+(ll)Lazy[now]*(ll)(mid-l+1))%Mod;
    Seg[now*2+1]=(Seg[now*2+1]+(ll)Lazy[now]*(ll)(r-mid)%Mod);
    Lazy[now*2]=(Lazy[now*2]+Lazy[now])%Mod;
    Lazy[now*2+1]=(Lazy[now*2+1]+Lazy[now])%Mod;
    Lazy[now]=0;
    return;
}

void SegOutp(int now,int l,int r)
{
    PushDown(now,l,r);
    printf("[%d,%d] %d\n",l,r,Seg[now]);
    if (l==r) return;
    int mid=(l+r)/2;
    SegOutp(now*2,l,mid);
    SegOutp(now*2+1,mid+1,r);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>328</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 23:04:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 15:04:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3626lnoi2014lca%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[282]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>常用跟踪博客</title>
		<link>http://sycstudio.com/follow</link>
		<pubDate>Sun, 21 Jan 2018 06:26:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=334</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>一级跟踪</h2>

<a href="http://blog.csdn.net/popoqqq">popoqqq</a>
<a href="http://www.cnblogs.com/Zars19/">Zars19</a>
<a href="http://www.cnblogs.com/GXZlegend/">GXZlegend</a>
<a href="http://www.cnblogs.com/MashiroSky/">MashiroSky</a>
<a href="http://www.cnblogs.com/candy99/">Candy?</a>
<a href="http://www.cnblogs.com/CQzhangyu/">CQzhangyu</a>
<a href="http://www.cnblogs.com/TheRoadToTheGold/">TheRoadToTheGold</a>[BZOJ千题计划]
<a href="http://www.cnblogs.com/LadyLex/">LadyLex</a>[有比较多的总结和好题]
<a href="http://www.cnblogs.com/SilverNebula/">SilverNebula</a>[同样也是有很多不错的题目]
<a href="https://blog.csdn.net/u013368721">poursoul</a>[有很多不错的题，较全]
<a href="http://www.cnblogs.com/DaD3zZ-Beyonder/">Dad3zZ</a>
<a href="http://www.cnblogs.com/zj75211/">&#42;ZJ</a>[有很多期望概率DP类题]

<h2>二级跟踪</h2>

<a href="https://www.zgz233.xyz/">zgz233</a>
<a href="http://www.yhzq-blog.cc/">yzzq</a>
<a href="http://www.cnblogs.com/Skyminer">Skyminer</a>
<a href="https://ahackh.ac.cn/">ahackh</a>
<a href="http://www.cnblogs.com/ljh2000-jump/">ljh</a>
<a href="http://blog.csdn.net/clover_hxy">clover_hxy</a>
<a href="http://www.cnblogs.com/DMoon">DMoon</a>
<a href="http://seter.is-programmer.com/">Seter</a>
<a href="http://www.cnblogs.com/zcysky">zcysky</a>
<a href="https://blog.sengxian.com/">sengxian</a>

<h2>三级跟踪</h2>

<a href="http://blog.godofthefallen.win/">gtf</a>
<a href="http://www.cnblogs.com/LCF-2000">lcf</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>334</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 14:26:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 06:26:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%b8%b8%e7%94%a8%e8%b7%9f%e8%b8%aa%e5%8d%9a%e5%ae%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[sycsycsyc]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[custom_permalink]]></wp:meta_key>
			<wp:meta_value><![CDATA[follow]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[94]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2440][中山市选2011]完全平方数（莫比乌斯反演，二分）</title>
		<link>http://sycstudio.com/archives/342</link>
		<pubDate>Sun, 21 Jan 2018 10:11:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=342</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。
这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第 K个数送给了小X。小X很开心地收下了。
然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2440">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，二分

<h2>解决思路</h2>

先考虑二分，把题目变成判定问题，即询问在某个范围内，不包含完全平方数因子的数有多少个。
一个数不包含完全平方数，那么就是说唯一分解后没有任何一个质数的质数超过&#92;(1&#92;)。
容斥一下，那么答案就是
Ans-至少一个质因子个数大于1+至少两个质因子个数大于1-至少三个质因子个数大于1-至少四个质因子个数大于1
考虑每一个数对这个式子的贡献，呃，不就是&#92;(\mu()&#92;)吗？
那么线性筛出&#92;(\mu&#92;)，二分答案求解就可以啦！

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();
ll Check(ll n);

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n;scanf("%d",&amp;n);
        ll l=1,r=1e10,ans;
        do
        {
            ll mid=(l+r)/2;
            if (Check(mid)&gt;=n)//二分判定
                ans=mid,r=mid-1;
            else l=mid+1;
        }
        while (l&lt;=r);
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛求mu
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}

ll Check(ll n)
{
    ll ret=0;
    for (ll i=1;i*i&lt;=n;i++) ret=ret+Mu[i]*n/i/i;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>342</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 18:11:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 10:11:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2440%e4%b8%ad%e5%b1%b1%e5%b8%82%e9%80%892011%e5%ae%8c%e5%85%a8%e5%b9%b3%e6%96%b9%e6%95%b0%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[220]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4816/Luogu3704][Sdoi2017]数字表格（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/347</link>
		<pubDate>Sun, 21 Jan 2018 12:40:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=347</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Doris刚刚学习了fibonacci数列。用f[i]表示数列的第i项，那么
f[0]=0
f[1]=1
f[n]=f[n-1]+f[n-2],n>=2
Doris用老师的超级计算机生成了一个n×m的表格，第i行第j列的格子中的数是f[gcd(i,j)]，其中gcd(i,j)表示i,j的最大公约数。Doris的表格中共有n×m个数，她想知道这些数的乘积是多少。答案对10^9+7取模。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4816">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3704">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\prod&#95;{i=1}^{n} \prod&#95;{j=1}^{m} fab(gcd(i,j))&#92;)

<h2>解决思路</h2>

依照惯例，提取出&#92;(d=gcd(i,j)&#92;)，则
&#92;[Ans=\prod&#95;{d=1}^{n} fab(d)^{\sum&#95;{i=1}^{n} \sum{j=1}^{m} [gcd(i,j)==1]}&#92;]
&#92;(fab(d)&#92;)的指数可以根据莫比乌斯反演变成
&#92;[Ans=\prod&#95;{d=1}^{n} fab(d)^{\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor \lfloor \frac{m}{id} \rfloor }&#92;]
令&#92;(T=id&#92;)，把&#92;(T&#92;)提出来，得到
&#92;[ Ans=\prod&#95;{T=1}^{n} [\prod&#95;{i|T} fab(\frac{T}{i})^{\mu(i)}]^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} &#92;]
里面这个东西并不是积性函数，怎么办呢？
考虑到&#92;(n&#92;)只有&#92;(10^6&#92;)，可以&#92;(O(n&#42;log&#95;{2}n)&#92;)暴力算，提前处理好斐波那契数列和其逆元即可。
那么设&#92;(H(x)=\prod&#95;{i|x} f(\frac{x}{i})^{\mu(i)}&#92;)，求出它的前缀积和前缀积的逆元即可数论分块了

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=1000010;
const int Mod=1e9+7;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum/100];
bool notprime[maxNum];
int Fab[maxNum],InvFab[maxNum];
int H[maxNum],InvH[maxNum];

void Init();//线性筛求mu，以及预处理Fab，H及其逆元
int QPow(ll x,ll cnt,ll Mod);//快速幂
int Inv(ll x,ll Mod);//求逆元

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=1;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));
            ans=ans*QPow((ll)H[last]*(ll)InvH[i-1]%Mod,(ll)(n/i)*(ll)(m/i)%(Mod-1),Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)//线性筛出mu
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    Fab[0]=0;Fab[1]=1;H[0]=InvH[0]=1;
    //递推出fab
    for (int i=2;i&lt;maxNum;i++) Fab[i]=(Fab[i-1]+Fab[i-2])%Mod;
    //求出fab的逆元
    for (int i=1;i&lt;maxNum;i++) InvFab[i]=Inv(Fab[i],Mod),H[i]=1;
    for (int i=1;i&lt;maxNum;i++)//求H
        if (Mu[i]!=0)
            for (int j=i;j&lt;maxNum;j=j+i)
                H[j]=(ll)H[j]*(ll)((Mu[i]==1)?(Fab[j/i]):(InvFab[j/i]))%Mod;
    //求H的逆元
    for (int i=1;i&lt;maxNum;i++) InvH[i]=Inv(H[i],Mod);
    //求前缀积
    for (int i=2;i&lt;maxNum;i++) H[i]=(ll)H[i]*(ll)H[i-1]%Mod,InvH[i]=(ll)InvH[i]*(ll)InvH[i-1]%Mod;
    return;
}

int QPow(ll x,ll cnt,ll Mod)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret%Mod;
}

int Inv(ll x,ll Mod)
{
    return QPow(x,Mod-2,Mod)%Mod;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>347</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 20:40:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 12:40:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4816-luogu3704sdoi2017%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[233]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4998]星球联盟（LCT，并查集）</title>
		<link>http://sycstudio.com/archives/354</link>
		<pubDate>Sun, 21 Jan 2018 14:41:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=354</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在遥远的S星系中一共有N个星球，编号为1…N。其中的一些星球决定组成联盟，以方便相互间的交流。但是，组成联盟的首要条件就是交通条件。初始时，在这N个星球间有M条太空隧道。每条太空隧道连接两个星球，使得它们能够相互到达。若两个星球属于同一个联盟，则必须存在一条环形线路经过这两个星球，即两个星球间存在两条没有公共隧道的路径。为了壮大联盟的队伍，这些星球将建设P条新的太空隧道。这P条新隧道将按顺序依次建成。一条新轨道建成后，可能会使一些星球属于同一个联盟。你的任务是计算出，在一条新隧道建设完毕后，判断这条新轨道连接的两个星球是否属于同一个联盟，如果属于同一个联盟就计算出这个联盟中有多少个星球。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4998">BZOJ</a>

<h3>Tag</h3>

LCT，并查集

<h2>题目大意</h2>

简单一句话，动态维护边双联通分量

<h2>解决思路</h2>

在线做法
用并查集1维护连通性，并用LCT维护在同一个联通块（注意这里还不是双联通）的点。
如果遇到加入一条边时，两个端点已经在同一个联通块了，说明新形成了一个双联通分量，找出这两点之间的路径，把这个环缩成一个点（这个用并查集2维护），环上所有点都指向一个编号，&#92;(dfs&#92;)一遍可以遍历所有这些点，把它们的&#92;(size&#92;)累加。
要注意，因为我们有缩点的操作，所以在&#92;(LCT&#92;)的各种操作中都要注意及时&#92;(find&#92;)找到编号。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200110;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
};

int n,m,P;
Splay_Data S[maxN];
int Stack[maxN];
int Set1[maxN],Set2[maxN];
int Size[maxN];

bool Isroot(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
void Link(int x,int y);
int Add_Edge(int u,int v);
int Find(int *f,int x);
void dfs(int now,int fa);

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;P);
    for (int i=1;i&lt;=n;i++) Size[i]=1,Set1[i]=Set2[i]=i;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        u=Find(Set2,u);v=Find(Set2,v);//注意及时Find
        Add_Edge(u,v);
    }
    for (int i=1;i&lt;=P;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        u=Find(Set2,u);v=Find(Set2,v);
        int ret=Add_Edge(u,v);
        if (ret==-1) printf("No\n");
        else printf("%d\n",ret);
    }
    return 0;
}

bool Isroot(int x)
{
    if ((S[Find(Set2,S[x].fa)].ch[0]==x)||(S[Find(Set2,S[x].fa)].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev==1)
    {
        S[x].rev=0;
        if (S[x].ch[0]) S[S[x].ch[0]].rev^=1,swap(S[S[x].ch[0]].ch[0],S[S[x].ch[0]].ch[1]);
        if (S[x].ch[1]) S[S[x].ch[1]].rev^=1,swap(S[S[x].ch[1]].ch[0],S[S[x].ch[1]].ch[1]);
    }
    return;
}

void Rotate(int x)
{
    int y=Find(Set2,S[x].fa);int z=Find(Set2,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;S[y].ch[sx]=S[x].ch[sx^1];
    S[y].fa=x;S[x].ch[sx^1]=y;
    return;
}

void Splay(int x)
{
    int stacktop=1;Stack[1]=x;
    int now=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Set2,S[now].fa);
        now=Find(Set2,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Set2,S[x].fa);int z=Find(Set2,S[y].fa);
        if (Isroot(y)==0)
            ((S[y].ch[0]==x)^(S[z].ch[0]==y))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;S[lastx].fa=x;
        lastx=x;x=Find(Set2,S[x].fa);
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

int Add_Edge(int u,int v)
{
    if (Find(Set1,u)!=Find(Set1,v))//若u，v还不在同一个联通块，则先联通
    {
        Set1[Find(Set1,u)]=Find(Set1,v);
        Link(u,v);
        return -1;
    }
    else
    {
        Makeroot(u);Access(v);Splay(v);//否则找出u,v的路径，并把整个环的信息压缩到v上
        dfs(v,v);
        S[v].ch[0]=S[v].ch[1]=0;//这里就把整棵子树丢掉了
        return Size[v];
    }
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

void dfs(int now,int fa)//dfs fa的子树，把所有信息全部累加到fa中，完成缩点
{
    if (now!=fa) Size[fa]+=Size[now],Set2[now]=fa;
    if (S[now].ch[0]) dfs(S[now].ch[0],fa);
    if (S[now].ch[1]) dfs(S[now].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>354</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 22:41:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 14:41:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4998%e6%98%9f%e7%90%83%e8%81%94%e7%9b%9f%ef%bc%88lct%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[225]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4530/LOJ2230][Bjoi2014]大融合（LCT）</title>
		<link>http://sycstudio.com/archives/356</link>
		<pubDate>Mon, 22 Jan 2018 08:29:08 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=356</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小强要在 N个孤立的星球上建立起一套通信系统。这套通信系统就是连接 N 个点的一个树。这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。
<img src="http://sycstudio.com/bzojch/file/4530_0.png" alt="BZOJ4530" />
例如，在上图中，现在一共有了5条边。其中，(3,8)这条边的负载是6，因
为有六条简单路径2-3-8,2-3-8-7,3-8,3-8-7,4-3-8,4-3-8-7路过了(3,8)。
现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的
询问。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4530">BZOJ</a>
权限题，本站离线版本：<a href="http://sycstudio.com/bzojch/p/4530.html">bzojch</a>
<a href="https://loj.ac/problem/2230">LOJ</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

动态维护子树和

<h2>解决思路</h2>

根据乘法原理，就是动态求每一次两边的子树和。
那么由于&#92;(LCT&#92;)的&#92;(size&#92;)只能维护它实儿子的&#92;(size&#92;)之和，对于虚儿子没有办法处理，所以我们对于每一个点再记一个其虚儿子的大小记为&#92;(vsize&#92;)。那么修改这个虚儿子大小的地方就是&#92;(LCT&#92;)中修改边的虚实关系的时候，即&#92;(Link&#92;)操作和&#92;(Access&#92;)操作，在相应的地方修改即可

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size,vsize;
    int rev;
};

int n;
Splay_Data S[maxN];
int Stack[maxN];

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Split(int x,int y);
void Link(int x,int y);
void Cut(int x,int y);

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++) S[i].size=1,S[i].vsize=0;
    while (Q--)
    {
        char opt;cin&gt;&gt;opt;
        int x,y;scanf("%d%d",&amp;x,&amp;y);
        if (opt=='A') Link(x,y);
        if (opt=='Q')
        {
            Split(x,y);
            printf("%lld\n",1ll*(ll)(S[y].size-S[x].size)*(ll)S[x].size);
        }
    }
    return 0;
}

bool Isroot(int x)
{
    if ((S[S[x].fa].ch[0]==x)||(S[S[x].fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1+S[x].vsize;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;
    int stacktop=1;Stack[stacktop]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].vsize=S[x].vsize+S[S[x].ch[1]].size-S[lastx].size;//注意这里对vsize的操作
        S[x].ch[1]=lastx;S[lastx].fa=x;
        Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Split(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);//注意这里也要makeroot(y)
    S[x].fa=y;S[y].vsize+=S[x].size;
    Update(y);
    return;
}

void Cut(int x,int y)
{
    Split(x,y);
    if (S[y].ch[0]!=x) return;
    S[y].size-=S[x].size;
    S[x].fa=S[y].ch[0]=0;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>356</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 16:29:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 08:29:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4530-loj2230bjoi2014%e5%a4%a7%e8%9e%8d%e5%90%88%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="loj"><![CDATA[LOJ]]></category>
		<category domain="post_tag" nicename="loj"><![CDATA[LOJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[280]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-22 21:15:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-22 13:15:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[因为要把x连到y上面去，如果y不是y所在的splay的根，那么还要修改y的父亲，y的父亲的父亲....等等。那么为了方便起见，把y也转成它所在的splay的根，这样只需要修改y的值就可以了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>18</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[smyjr]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[smyjr@cnblogs.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://cnblogs.com/smyjr/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-22 19:23:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-22 11:23:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[请问博主，Link那里为什么要makeroot(y)啊?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2959]长跑（LCT，并查集）</title>
		<link>http://sycstudio.com/archives/360</link>
		<pubDate>Mon, 22 Jan 2018 12:40:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=360</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。
　　为了让同学们更好地监督自己，学校推行了刷卡机制。
　　学校中有n个地点，用1到n的整数表示，每个地点设有若干个刷卡机。
　　有以下三类事件：
　　1、修建了一条连接A地点和B地点的跑道。
　　2、A点的刷卡机台数变为了B。
　　3、进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下：
　　当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。
　　为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2959">BZOJ</a>

<h3>Tag</h3>

LCT，并查集

<h2>解决思路</h2>

算是<a href="http://sycstudio.com/archives/354">这题</a>的强化板。
先看题目中关于单向方向的设置，讲得那么复杂，其实就是要求不能走一条边再反向返回，那么说白了就是从&#92;(u&#92;)到&#92;(v&#92;)的话可以走环和直接路径，不能走到一棵子树中去再原路返回。
看到环一定是可以走的，所以我们可以把环缩成一个点，那么就直接动态求两点之间的路径点权和即可。
综上，并查集维护缩点，&#92;(LCT&#92;)维护动态路径点权和。
需要注意的是，第二个操作是修改某一个点上的机器数量，而我们缩点后并没有统计单个点的贡献，所以要在另外存一下原来每一个点的机器数，方便修改。
最后就是与<a href="http://sycstudio.com/archives/354">这题</a>一样需要注意，因为我们缩了点，所以在&#92;(LCT&#92;)中每一步都要&#92;(find&#92;)一下缩点后的编号

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=150010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int key,size;//key代表的是这个点上的机器数（包括缩点后id是它的点），size则是子树的
    int rev;
};

int n;
Splay_Data S[maxN];
int UFS[maxN],Id[maxN];//UFS是标记是否在同一联通块，ID是标记缩点后的编号，这两个都是并查集
int Stack[maxN];
int Mach[maxN];//存放每一个点机器数，注意这里不是缩点后的编号

int Find(int *f,int x);
bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
int Findroot(int x);
void Makeroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
void Add_Edge(int u,int v);
void dfs(int now,int fa);

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Mach[i]);
        S[i].key=S[i].size=Mach[i],UFS[i]=i,Id[i]=i;
    }
    while (Q--)
    {
        int opt,x,y;scanf("%d%d%d",&amp;opt,&amp;x,&amp;y);
        if (opt==1) Add_Edge(Find(Id,x),Find(Id,y));
        if (opt==2)
        {
            int xx=Find(Id,x);//注意这里，要先减去原来的机器数再加上现在的机器数
            Makeroot(xx);S[xx].key+=y-Mach[x];Update(xx);Mach[x]=y;
        }
        if (opt==3)
        {
            x=Find(Id,x);y=Find(Id,y);
            if (Find(UFS,x)!=Find(UFS,y)) printf("-1\n");
            else
            {
                Makeroot(x);Access(y);Splay(y);
                printf("%d\n",S[y].size);
            }
        }
    }
    return 0;
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

bool Isroot(int x)
{
    int fa=Find(Id,S[x].fa);
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+S[x].key;
    return;
}

void Rotate(int x)
{
    int y=Find(Id,S[x].fa),z=Find(Id,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;int stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Id,S[now].fa);
        now=Find(Id,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

void Access(int x)
{
    int lastx=0;
    while(x)
    {
        Splay(x);S[x].ch[1]=lastx;
        Update(x);lastx=x;x=Find(Id,S[x].fa);
    }
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;Update(y);
    return;
}

void Add_Edge(int u,int v)
{
    if (Find(UFS,u)!=Find(UFS,v))
    {
        UFS[Find(UFS,u)]=Find(UFS,v);
        Link(u,v);
        return;
    }
    else
    {
        Makeroot(u);Access(v);Splay(v);
        dfs(v,v);//把整棵v的所在的splay都缩到v上，把信息都压缩到v中
        S[v].ch[0]=S[v].ch[1]=0;
    }
    return;
}

void dfs(int now,int fa)
{
    if (now!=fa) S[fa].key+=S[now].key,Id[now]=fa;
    if (S[now].ch[0]) dfs(S[now].ch[0],fa);
    if (S[now].ch[1]) dfs(S[now].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>360</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 20:40:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 12:40:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2959%e9%95%bf%e8%b7%91%ef%bc%88lct%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[190]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1969/Luogu2542][Ahoi2005]LANE 航线规划（LCT，离线操作，并查集）</title>
		<link>http://sycstudio.com/archives/375</link>
		<pubDate>Mon, 22 Jan 2018 14:21:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=375</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

对Samuel星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了Samuel星球所在的星系——一个巨大的由千百万星球构成的Samuel星系。 星际空间站的Samuel II巨型计算机经过长期探测，已经锁定了Samuel星系中许多星球的空间坐标，并对这些星球从1开始编号1、2、3……。 一些先遣飞船已经出发，在星球之间开辟探险航线。 探险航线是双向的，例如从1号星球到3号星球开辟探险航线，那么从3号星球到1号星球也可以使用这条航线。 例如下图所示：
<img src="http://sycstudio.com/bzojch/file/1969_0.jpg" alt="BZOJ1969" />
在5个星球之间，有5条探险航线。 A、B两星球之间，如果某条航线不存在，就无法从A星球抵达B星球，我们则称这条航线为关键航线。 显然上图中，1号与5号星球之间的关键航线有1条：即为4-5航线。 然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时回复这些航线，可见两个星球之间的关键航线会越来越多。 假设在上图中，航线4-2（从4号星球到2号星球）被破坏。此时，1号与5号星球之间的关键航线就有3条：1-3，3-4，4-5。 小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1969">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2542">Luogu</a>

<h3>Tag</h3>

LCT，离线操作，并查集

<h2>解决思路</h2>

把询问倒过来，变成加边，那么就变成动态求图中两点之间桥的个数。而图中两点之间桥的个数，就是把图中的环全部缩点后，两点之间的距离。所以可以用LCT动态维护，遇到环则全部缩成一个点。
需要注意的是，由于有缩点操作，所以在&#92;(LCT&#92;)的每一步跳父亲的时候都要寻找一下缩点后的编号，这个可以用并查集维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=600010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size;
    int rev;
};

class Question//把询问离线下来
{
public:
    int c,u,v;
    int ans;
};

int n,m;
Splay_Data S[maxN];
int Id[maxN];
int Stack[maxN];
set&lt;int&gt; Exi[maxN];
Question Qn[maxN];

int Find(int *f,int x);
bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Add_Edge(int x,int y);
void dfs(int u,int fa);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) Id[i]=i;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        if (u&gt;v) swap(u,v);
        Exi[u].insert(v);
    }
    int Q=0;
    {
        int c,u,v;
        while (scanf("%d",&amp;c)!=EOF)
        {
            if (c==-1) break;
            scanf("%d%d",&amp;u,&amp;v);
            if (u&gt;v) swap(u,v);
            Q++;Qn[Q]=(Question){c,u,v};
            if (c==0) Exi[u].erase(v);
        }
    }
    for (int i=1;i&lt;=n;i++)
        for (set&lt;int&gt;::iterator j=Exi[i].begin();j!=Exi[i].end();j++)
            Add_Edge(i,*j);
    for (int i=Q;i&gt;=1;i--)
    {
        if (Qn[i].c==0) Add_Edge(Qn[i].u,Qn[i].v);
        if (Qn[i].c==1)
        {
            int u=Find(Id,Qn[i].u);
            int v=Find(Id,Qn[i].v);
            Makeroot(u);Access(v);Splay(v);
            Qn[i].ans=S[v].size-1;
        }
    }
    for (int i=1;i&lt;=Q;i++) if (Qn[i].c==1) printf("%d\n",Qn[i].ans);
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

bool Isroot(int x)
{
    int fa=Find(Id,S[x].fa);
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        S[lson].rev^=1;S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;
    int stacktop=1;Stack[1]=now;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Id,S[now].fa);
        now=Find(Id,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=Find(Id,S[x].fa);
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Add_Edge(int u,int v)
{
    u=Find(Id,u);v=Find(Id,v);
    if (Findroot(u)!=Findroot(v)) Link(u,v);
    else
    {
        Makeroot(u);Access(v);Splay(v);
        dfs(v,v);
        S[v].size=1;S[v].ch[0]=S[v].ch[1]=0;//剩下的点就不要啦
    }
    return;
}

void dfs(int u,int fa)//dfs把所有子树的点的编号修改为根
{
    if (u!=fa) Id[u]=fa;
    if (S[u].ch[0]) dfs(S[u].ch[0],fa);
    if (S[u].ch[1]) dfs(S[u].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>375</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 22:21:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 14:21:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1969-luogu2542ahoi2005lane-%e8%88%aa%e7%ba%bf%e8%a7%84%e5%88%92%ef%bc%88lct%ef%bc%8c%e7%a6%bb%e7%ba%bf%e6%93%8d%e4%bd%9c%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3"><![CDATA[重要思想]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[272]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5398] GCD Tree（LCT）</title>
		<link>http://sycstudio.com/archives/394</link>
		<pubDate>Wed, 24 Jan 2018 00:56:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=394</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Teacher Mai has a graph with n vertices numbered from 1 to n. For every edge(u,v), the weight is gcd(u,v). (gcd(u,v) means the greatest common divisor of number u and v).
You need to find a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is maximized. Print the total weight of these edges.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5398">HDU</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

给定一个&#92;(n&#92;)个点的完全图，两点之间的边的边权为两点的&#92;(gcd&#92;)，求最大生成树

<h2>解决思路</h2>

首先肯定是不能把边都建出来的，所以考虑动态加边。但有一些边是完全没有必要的，一个点只向它的因数连边，因为非因数的边不会更优，这样就把加边的数量降到&#92;(O(n\sqrt{n})&#92;)。
如何动态维护最大生成树呢？我们每加入一条边，它的两端点必然已经在树中有一条路径相连啦，那么找出这条路经上的最小边，如果这个最小边小于要加入的边权，那么删除着一条最小边而插入新的这一条边。
为了维护路径上的最小边编号，我们可以把边变成点插入&#92;(LCT&#92;)，这个点的点权即为边权，而真正的点的点权为无限大。在&#92;(LCT&#92;)中维护一个&#92;(mnid&#92;)，表示最小的边权的编号。那么每次找到这样的一个点代表的边，删掉这一条边即可。
但由于&#92;(LCT&#92;)中会变化点与点的位置关系，所以为了方便删除边，我们要在加边的时候记录它真实连着的是哪个点，这样就可以直接删除啦。
最后需要注意的是，因为边数有&#92;(On\sqrt{n})&#92;)，而实际上是开不了这么大的，但考虑到在任意时刻，生成树中最多只有&#92;(n-1&#92;)条，所以实际有用的边只有&#92;(O(n)&#92;)个，所以可以考虑重复使用，用一个栈作为垃圾栈，存放当期空出来的编号，每次新建点的时候，优先从这个栈中取即可。
请注意常数因子对程序时间效率的影响。另：由于只有合并操作，查找两个点是否在统一联通快可以用并查集，减少&#92;(findroot&#92;)的时间开销。在一些地方可以不&#92;(Update&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

const int maxNum=100000;
const int maxN=500010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int key;
    int mnid;
    int rev;
    int d1,d2;//如果这个点是边的话，记录下这条边原本连的点是哪两个
};

int n;
Splay_Data S[maxN];
int Stack[maxN];
int nodecnt=maxNum,Rubtop=0,Rub[maxN];//回收
int Ansmst=0;
int Ans[maxNum+10],Fact[maxN];
int UFS[maxN];

IL int GetMin(RG int a,RG int b);
IL bool Isroot(RG int x);
IL void Update(RG int x);
IL void PushDown(RG int x);
IL void Rotate(RG int x);
IL void Splay(RG int x);
IL void Access(RG int x);
IL void Makeroot(RG int x);
IL int Findroot(RG int x);
IL void Link(RG int x,RG int y);
IL void Cut(RG int x,RG int y);
IL int NewNode();
IL bool Delete(RG int u,RG int v,RG int w);
IL void Add_Edge(RG int u,RG int v);
IL int gcd(RG int u,RG int v);
IL void Outp();
int Find(int x);

int main()
{
    for (RG int i=0;i&lt;=maxNum;i++) S[i].key=maxNum+10,UFS[i]=i;
    for (RG int i=2;i&lt;=maxNum;i++)
    {
        RG int fcnt=0;
        for (RG int j=1;(ll)j*(ll)j&lt;=i;j++)
            if (i%j==0)
            {
                Fact[++fcnt]=j;
                if ((ll)j*(ll)j!=i) Fact[++fcnt]=i/j;
            }
        sort(&amp;Fact[1],&amp;Fact[fcnt+1]);
        for (RG int j=1;j&lt;=fcnt;j++) Add_Edge(i,Fact[j]);
        Ans[i]=Ansmst;
    }
    RG int n;
    while (scanf("%d",&amp;n)!=EOF)
        printf("%d\n",Ans[n]);
    return 0;
}

IL int GetMin(RG int a,RG int b)
{
    return ((S[a].key&lt;S[b].key)?(a):(b));
}

IL bool Isroot(RG int x)
{
    RG int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

IL void Update(RG int x)
{
    S[x].mnid=GetMin(x,GetMin(S[S[x].ch[0]].mnid,S[S[x].ch[1]].mnid));
    return;
}

IL void PushDown(RG int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        RG int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

IL void Rotate(RG int x)
{
    RG int y=S[x].fa,z=S[y].fa;
    RG int sx=(x==S[y].ch[1]);
    RG int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

IL void Splay(RG int x)
{
    RG int stacktop=1,now=x;
    Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (RG int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        RG int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

IL void Access(RG int x)
{
    RG int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;
        Update(x);lastx=x;x=S[x].fa;
    }
    return;
}

IL void Makeroot(RG int x)
{
    Access(x);Splay(x);S[x].rev^=1;
    swap(S[x].ch[0],S[x].ch[1]);
    return;
}

IL int Findroot(RG int x)
{
    Access(x);Splay(x);
    RG int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

IL void Link(RG int x,RG int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

IL void Cut(RG int x,RG int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;//Update(y);
    return;
}

IL int NewNode()
{
    RG int pos;
    if (Rubtop!=0) pos=Rub[Rubtop--];
    else pos=++nodecnt;
    S[pos].fa=S[pos].ch[0]=S[pos].ch[1]=0;
    return pos;
}

IL bool Delete(RG int u,RG int v,RG int w)
{
    Makeroot(u);Access(v);Splay(v);
    RG int eid=S[v].mnid;
    if (S[eid].key&gt;w) return 0;
    Ansmst-=S[eid].key;
    Cut(eid,S[eid].d1);Cut(eid,S[eid].d2);
    Rub[++Rubtop]=eid;
    return 1;
}

IL void Add_Edge(RG int u,RG int v)
{
    RG int w=gcd(u,v);
    if (Find(u)==Find(v))
        if (Delete(u,v,w)==0) return;
    UFS[Find(u)]=Find(v);
    RG int eid=NewNode();
    Makeroot(u);Makeroot(v);
    S[u].fa=S[v].fa=eid;
    S[eid].key=w;
    Ansmst+=w;
    S[eid].d1=u;S[eid].d2=v;
    return;
}

IL int gcd(RG int u,RG int v)
{
    RG int t;
    while (v) {t=u;u=v;v=t%v;}
    return u;
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

void Outp()
{
    printf("id fa ls rs mnid    key\n");
    for (int i=1;i&lt;=nodecnt;i++) printf("%2d%3d%3d%3d%5d [%6d]%12d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].mnid,S[S[i].mnid].key,S[i].key);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>394</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 08:56:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 00:56:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5398-gcd-tree%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[248]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3669/Luogu2387][Noi2014]魔法森林（LCT）</title>
		<link>http://sycstudio.com/archives/396</link>
		<pubDate>Wed, 24 Jan 2018 01:14:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个N节点M条边的无向图，节点标号为1..N，边标号为1..M。初始时小E同学在号节点1，隐士则住在号节点N。小E需要通过这一片魔法森林，才能够拜访到隐士。
魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。
只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边Ei包含两个权值Ai与Bi。若身上携带的A型守护精灵个数不少于Ai，且B型守护精灵个数不少于Bi，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。
由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3669">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2387">Luogu</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

求一条&#92;(1&#92;)到&#92;(n&#92;)的路径使得路径中最大的&#92;(a&#92;)和&#92;(b&#92;)之和最小

<h2>解决思路</h2>

把边权按照&#92;(a&#92;)排序，从小到大依此插入，动态维护最小生成树。
关于&#92;(LCT&#92;)维护最小生成树，可以参考<a href="http://sycstudio.com/archives/394">这里</a>

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010+100010;
const int maxM=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int key,mxid;
    int d1,d2;
};

class Edge
{
public:
    int u,v,a,b;
};

bool operator &lt; (Edge A,Edge B)
{
    return A.a&lt;B.a;
}

int n,m;
int nodecnt;
Splay_Data S[maxN];
int Stack[maxN];
int UFS[maxN];
Edge E[maxM];

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int GetMax(int a,int b);
int Find(int x);
void Add_Edge(int u,int v,int w);
bool Delete(int u,int v,int w);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    nodecnt=n+1;
    for (int i=1;i&lt;=n;i++) S[i].key=0,UFS[i]=i;
    for (int i=1;i&lt;=m;i++) scanf("%d%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].a,&amp;E[i].b);
    sort(&amp;E[1],&amp;E[m+1]);//排序边
    int Ans=inf;
    for (int i=1;i&lt;=m;i++)//依此插入边权
    {
        if (E[i].u==E[i].v) continue;
        Add_Edge(E[i].u,E[i].v,E[i].b);
        if (Find(1)==Find(n))
        {
            Makeroot(1);Access(n);Splay(n);
            Ans=min(Ans,E[i].a+S[S[n].mxid].key);
        }
    }
    if (Ans!=inf) printf("%d\n",Ans);
    else printf("-1\n");
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].mxid=GetMax(x,GetMax(S[S[x].ch[0]].mxid,S[S[x].ch[1]].mxid));
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[x].ch[sx^1]=y;S[y].fa=x;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[1])^(y==S[z].ch[1]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;
    swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[y].ch[0]=S[x].fa=0;
    return;
}

int GetMax(int a,int b)
{
    return (S[a].key&lt;S[b].key)?(b):(a);
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

bool Delete(int u,int v,int w)
{
    Makeroot(u);Access(v);Splay(v);
    int eid=S[v].mxid;
    if (S[eid].key&lt;=w) return 0;
    Cut(eid,S[eid].d1);Cut(eid,S[eid].d2);
    return 1;
}

void Add_Edge(int u,int v,int w)
{
    if (Find(u)==Find(v))
        if (Delete(u,v,w)==0) return;
    UFS[Find(u)]=Find(v);
    int eid=++nodecnt;
    Makeroot(u);Makeroot(v);
    S[u].fa=S[v].fa=eid;
    S[eid].d1=u;S[eid].d2=v;
    S[eid].key=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 09:14:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 01:14:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3669-luogu2387noi2014%e9%ad%94%e6%b3%95%e6%a3%ae%e6%9e%97%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[216]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2157/Luogu1505][国家集训队]旅游（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/400</link>
		<pubDate>Wed, 24 Jan 2018 09:40:06 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=400</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Ray 乐忠于旅游，这次他来到了T 城。T 城是一个水上城市，一共有 N 个景点，有些景点之间会用一座桥连接。为了方便游客到达每个景点但又为了节约成本，T 城的任意两个景点之间有且只有一条路径。换句话说， T 城中只有N − 1 座桥。
Ray 发现，有些桥上可以看到美丽的景色，让人心情愉悦，但有些桥狭窄泥泞，令人烦躁。于是，他给每座桥定义一个愉悦度w，也就是说，Ray 经过这座桥会增加w 的愉悦度，这或许是正的也可能是负的。有时，Ray 看待同一座桥的心情也会发生改变。
现在，Ray 想让你帮他计算从u 景点到v 景点能获得的总愉悦度。有时，他还想知道某段路上最美丽的桥所提供的最大愉悦度，或是某段路上最糟糕的一座桥提供的最低愉悦度。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2157">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1505">Luogu</a>

<h3>Tag</h3>

树链剖分，线段树

<h2>解决思路</h2>

把边权下放到它下面的点上维护，树链剖分后，线段树维护区间和、区间最大值、区间最小值，&#92;(Lazy&#92;)维护区间是否全部取负数。
思路不难，但代码量较大

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=30010;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int sum;
    int mn,mx;
    int mega;
};

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Fa[maxN],Size[maxN],Hson[maxN],Top[maxN],Faedge[maxN],Depth[maxN];
int idcnt=0,Id[maxN];
SegmentData S[maxN*6];

void Add_Edge(int u,int v,int w);
void _Add(int u,int v,int w);
void dfs1(int u);
void dfs2(int u,int top);
int QC_max(int u,int v);//查询路径最大值
int QC_min(int u,int v);//查询路径最小值
int QC_sum(int u,int v);//查询路径和
void QC_nega(int u,int v);//把路径上所有边权取负
void PushDown(int now);//线段树下放标记
void Update(int now);//线段树更新
void Modify(int now,int l,int r,int pos,int key);//线段树单点修改
void Makenega(int now,int l,int r,int ql,int qr);//线段树区间取负
int Query_max(int now,int l,int r,int ql,int qr);//线段树区间最大
int Query_min(int now,int l,int r,int ql,int qr);//线段树区间最小
int Query_sum(int now,int l,int r,int ql,int qr);//线段树区间求和

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u++;v++;
        Add_Edge(u,v,w);
    }
    Depth[1]=1;
    dfs1(1);
    dfs2(1,1);
    int Q;scanf("%d",&amp;Q);
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if (opt[0]=='C')
        {
            int pos,key;scanf("%d%d",&amp;pos,&amp;key);pos++;
            pos=Id[pos];
            Modify(1,1,n,pos,key);
        }
        if (opt[0]=='N')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            QC_nega(u,v);
        }
        if (opt[0]=='S')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_sum(u,v));
        }
        if (opt[1]=='A')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_max(u,v));
        }
        if (opt[1]=='I')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_min(u,v));
        }
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    _Add(u,v,w);_Add(v,u,w);return;
}

void _Add(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void dfs1(int u)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Fa[u])
        {
            Fa[V[i]]=u;Faedge[V[i]]=W[i];
            Depth[V[i]]=Depth[u]+1;
            dfs1(V[i]);
            Size[u]+=Size[V[i]];
            if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
        }
    return;
}

void dfs2(int u,int top)
{
    Id[u]=++idcnt;
    Modify(1,1,n,idcnt,Faedge[u]);
    Top[u]=top;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u])) dfs2(V[i],V[i]);
    return;
}

int QC_max(int u,int v)
{
    int ret=-inf;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=max(ret,Query_max(1,1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=max(ret,Query_max(1,1,n,Id[u]+1,Id[v]));
    return ret;
}

int QC_min(int u,int v)
{
    int ret=inf;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=min(ret,Query_min(1,1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=min(ret,Query_min(1,1,n,Id[u]+1,Id[v]));
    return ret;
}

int QC_sum(int u,int v)
{
    int ret=0;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=ret+Query_sum(1,1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=ret+Query_sum(1,1,n,Id[u]+1,Id[v]);
    return ret;
}

void QC_nega(int u,int v)
{
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        Makenega(1,1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) Makenega(1,1,n,Id[u]+1,Id[v]);
    return;
}

void PushDown(int now)
{
    if (S[now].mega)
    {
        S[now].mega=0;
        int lson=now*2,rson=now*2+1;
        swap(S[lson].mx,S[lson].mn);swap(S[rson].mx,S[rson].mn);
        S[lson].mx=-S[lson].mx;S[lson].mn=-S[lson].mn;
        S[rson].mx=-S[rson].mx;S[rson].mn=-S[rson].mn;
        S[lson].sum=-S[lson].sum;S[rson].sum=-S[rson].sum;
        S[lson].mega^=1;S[rson].mega^=1;
    }
    return;
}

void Update(int now)
{
    int lson=now*2,rson=now*2+1;
    S[now].mx=max(S[lson].mx,S[rson].mx);
    S[now].mn=min(S[lson].mn,S[rson].mn);
    S[now].sum=S[lson].sum+S[rson].sum;
    return;
}

void Modify(int now,int l,int r,int pos,int key)
{
    PushDown(now);
    if (l==r)
    {
        S[now].mx=S[now].mn=S[now].sum=key;
        return;
    }
    int mid=(l+r)/2;
    if (pos&lt;=mid) Modify(now*2,l,mid,pos,key);
    if (pos&gt;=mid+1) Modify(now*2+1,mid+1,r,pos,key);
    Update(now);return;
}

void Makenega(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr))
    {
        S[now].mega^=1;swap(S[now].mx,S[now].mn);
        S[now].mx=-S[now].mx;S[now].mn=-S[now].mn;
        S[now].sum=-S[now].sum;
        return;
    }
    int mid=(l+r)/2;
    if (qr&lt;=mid) Makenega(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Makenega(now*2+1,mid+1,r,ql,qr);
    else
    {
        Makenega(now*2,l,mid,ql,mid);Makenega(now*2+1,mid+1,r,mid+1,qr);
    }
    Update(now);return;
}

int Query_max(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mx;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_max(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_max(now*2+1,mid+1,r,ql,qr);
    else return max(Query_max(now*2,l,mid,ql,mid),Query_max(now*2+1,mid+1,r,mid+1,qr));
}

int Query_min(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mn;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_min(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_min(now*2+1,mid+1,r,ql,qr);
    else return min(Query_min(now*2,l,mid,ql,mid),Query_min(now*2+1,mid+1,r,mid+1,qr));
}

int Query_sum(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_sum(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_sum(now*2+1,mid+1,r,ql,qr);
    else return Query_sum(now*2,l,mid,ql,mid)+Query_sum(now*2+1,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>400</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 17:40:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 09:40:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2157-luogu1505%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e6%97%85%e6%b8%b8%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[202]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4825/Luogu3721][AH2017/HNOI2017]单旋（LCT）</title>
		<link>http://sycstudio.com/archives/405</link>
		<pubDate>Thu, 25 Jan 2018 02:00:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=405</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

H国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了H国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数”来企图毁灭H国。“卡”给H国的人洗脑说，splay如果写成单旋的，将会更快。“卡”称“单旋splay”为“spaly”。虽说他说的很没道理，但还是有H国的人相信了，小H就是其中之一，spaly马上成为他的信仰。而H国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由m（不超过10^5）个操作构成，他知道这样的数据肯定打垮spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作
所需要的实际代价的任务就交给你啦。数据中的操作分为5种：
插入操作：向当前非空spaly中插入一个关键码为key的新孤立节点。插入方法为，先让key和根比较，如果key比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，key比当前子树根x小，而x的左子树为空，那就让key成为x的左孩子；或者key比当前子树根x大，而x的右子树为空，那就让key成为x的右孩子。该操作的代价为：插入后，key的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度”的解释见末尾对spaly的描述。）
单旋最小值:将spaly中关键码最小的元素xmin单旋到根。操作代价为：单旋前xmin的深度。（对于单旋操作的解释见末尾对spaly的描述。）
单旋最大值:将spaly中关键码最大的元素xmax单旋到根。操作代价为：单旋前xmax的深度。
单旋删除最小值：先执行2号操作，然后把根删除。由于2号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同2号操作。
单旋删除最大值：先执行3号操作，然后把根删除。操作代价同3号操作。
对于不是H国的人，你可能需要了解一些spaly的知识，才能完成国王的任务：
spaly是一棵二叉树，满足对于任意一个节点x，它如果有左孩子lx，那么lx的关键码小于x的关键码。如果有右孩子rx，那么rx的关键码大于x的关键码。
  一个节点在spaly的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。
  单旋操作是对于一棵树上的节点x来说的。一开始，设f为x在树上的父亲。如果x为f的左孩子，那么执行zig(x)操作（如上图中，左边的树经过zig(x)变为了右边的树）,否则执行zag(x)操作（在上图中，将右边的树经过zag(f)就变成了左边的树）。每当执行一次zig(x)或者zag(x),x的深度减小1，如此反复，直到x为根。总之，单旋x就是通过反复执行zig和zag将x变为根。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4825">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3721">Luogu</a>

<h3>Tag</h3>

LCT

<h2>解决思路</h2>

肯定不能按照题目的意思写一棵&#92;(spaly&#92;)，那么我们观察题目的性质，发现每一次都只是修改最小值和最大值。以最小值为例，把最小值&#92;(x&#92;)旋转到根其实只会修改&#92;(x&#92;)、&#92;(x&#92;)的右儿子（如果存在）、&#92;(x&#92;)的父亲和根这四个点，所以直接用&#92;(LCT&#92;)在相应的地方&#92;(Link&#92;)和&#92;(Cut&#92;)即可。而每一次的代价就是这个点到根的距离，在&#92;(LCT&#92;)中&#92;(Split\ x&#92;)和&#92;(spaly&#92;)的根就可以得到啦。
为了方便操作，我们可以在每一个点上在维护&#92;(LCT&#92;)的信息的基础上，维护一下它在&#92;(spaly&#92;)中的左右儿子和父亲，这样就可以直接修改啦。
至于插入的话，因为每一次插入都是插入到&#92;(spaly&#92;)中它的前驱的右儿子或是后继的左儿子，并且可以保证这两个位置一定有一个是空的。那么寻找前驱后继可以用&#92;(Set&#92;)维护值，每一次二分查找出第一个比它大的值，再用&#92;(Map&#92;)维护每一个值对应在&#92;(LCT&#92;)中的编号。
需要注意的是，每一个操作都要特殊判断一下当前点是否为&#92;(spaly&#92;)的根，否则会出错

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size,rev;
    int sls,srs,sfa;//这三个值分别是spaly中的左右儿子和父亲
};

int root,nodecnt=0;//root记录当前spaly的根
Splay_Data S[maxN];
int Stack[maxN];
set&lt;int&gt; Set;//Set维护前驱后继
map&lt;int,int&gt; Map;//Map维护一个值key对应的点的编号是多少

bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Cut(int x,int y);
void Link(int x,int y);
void Insert(int key);
void Splay_min();
void Splay_max();
void Delete_min();
void Delete_max();

int main()
{
    int Q;scanf("%d",&amp;Q);
    while (Q--)
    {
        int c,key;scanf("%d",&amp;c);
        if (c==1) {scanf("%d",&amp;key);Insert(key);}
        if (c==2) Splay_min();
        if (c==3) Splay_max();
        if (c==4) Delete_min();
        if (c==5) Delete_max();
        //cout&lt;&lt;"finish!"&lt;&lt;endl;
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int ls=S[x].ch[0],rs=S[x].ch[1];
        swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
        if (ls) S[ls].rev^=1;
        if (rs) S[rs].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    if (S[y].ch[0]!=x) return;
    S[x].fa=S[y].ch[0]=0;
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Insert(int key)
{
    nodecnt++;S[nodecnt].size=1;Map[key]=nodecnt;
    if (Set.empty())//若set为空，说明树空，直接插入即可
    {
        Set.insert(key);root=nodecnt;printf("1\n");
        return;
    }
    set&lt;int&gt;::iterator pos=Set.lower_bound(key);//由于题目保证了关键码不重复，所以lower_bound找到的是第一个大于key的位置，即key的后继
    if ((pos==Set.end())||(S[Map[*pos]].sls!=0))//到了最后一个，或者是后继的左儿子非空，那么放到前驱的右儿子
    {
        pos--;//找到前驱
        S[Map[*pos]].srs=nodecnt;S[nodecnt].sfa=Map[*pos];
        Link(nodecnt,Map[*pos]);
    }
    else//否则放到后继的左儿子
    {
        S[Map[*pos]].sls=nodecnt;S[nodecnt].sfa=Map[*pos];
        Link(nodecnt,Map[*pos]);
    }
    Set.insert(key);
    Makeroot(nodecnt);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    return;
}

void Splay_min()
{
    int key=*Set.begin();//找到最小值
    int pos=Map[key];//找到最小值在LCT中的编号
    if (root==pos) {printf("1\n");return;}
    Makeroot(pos);Access(root);Splay(root);//查询代价
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].srs) Cut(pos,S[pos].srs);//把pos与pos的父亲、pos的右儿子断开
    Link(pos,root);if (S[pos].srs) Link(S[pos].sfa,S[pos].srs);//把pos与root连接，把pos的右儿子和pos的原父亲接上
    S[root].sfa=pos;//更新spaly中的信息
    S[S[pos].sfa].sls=S[pos].srs;if (S[pos].srs) S[S[pos].srs].sfa=S[pos].sfa;
    S[pos].sfa=0;S[pos].srs=root;
    root=pos;return;
}

void Splay_max()
{
    int key=*(--Set.end());
    int pos=Map[key];
    if (root==pos) {printf("1\n");return;}
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(S[pos].sfa,pos);if (S[pos].sls) Cut(S[pos].sls,pos);
    Link(pos,root);if (S[pos].sls) Link(S[pos].sfa,S[pos].sls);
    S[root].sfa=pos;
    S[S[pos].sfa].srs=S[pos].sls;if (S[pos].sls) S[S[pos].sls].sfa=S[pos].sfa;
    S[pos].sfa=0;S[pos].sls=root;
    root=pos;return;
}

void Delete_min()
{
    int key=*Set.begin();
    int pos=Map[key];
    Set.erase(Set.begin());
    if (pos==root)
    {
        printf("1\n");
        S[S[pos].srs].sfa=0;
        if (S[pos].srs) Cut(pos,S[pos].srs);
        root=S[pos].srs;
        return;
    }
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].srs) Cut(pos,S[pos].srs);
    if (S[pos].srs) Link(S[pos].sfa,S[pos].srs);
    S[S[pos].sfa].sls=S[pos].srs;if (S[pos].srs) S[S[pos].srs].sfa=S[pos].sfa;
    return;
}

void Delete_max()
{
    int key=*(--Set.end());
    int pos=Map[key];
    Set.erase(--Set.end());
    if (pos==root)
    {
        printf("1\n");
        S[S[pos].sls].sfa=0;
        if (S[pos].sls) Cut(pos,S[pos].sls);
        root=S[pos].sls;
        return;
    }
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].sls) Cut(pos,S[pos].sls);
    if (S[pos].sls) Link(S[pos].sls,S[pos].sfa);
    S[S[pos].sfa].srs=S[pos].sls;if (S[pos].sls) S[S[pos].sls].sfa=S[pos].sfa;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>405</wp:post_id>
		<wp:post_date><![CDATA[2018-01-25 10:00:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-25 02:00:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4825-luogu3721ah2017-hnoi2017%e5%8d%95%e6%97%8b%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[190]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>136</wp:comment_id>
			<wp:comment_author><![CDATA[xzy]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[347605798@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.cnblogs.com/xzyxzy/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-30 20:34:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-30 12:34:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[公式挂辣]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ4736/UOJ274]温暖会指引我们前行（LCT）</title>
		<link>http://sycstudio.com/archives/414</link>
		<pubDate>Thu, 25 Jan 2018 12:52:38 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=414</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

虽然小R住的宿舍楼早已来了暖气，但是由于某些原因，宿舍楼中的某些窗户仍然开着（例如厕所的窗户），这就使得宿舍楼中有一些路上的温度还是很低。

小R的宿舍楼中有nn个地点和一些路，一条路连接了两个地点，小R可以通过这条路从其中任意一个地点到达另外一个地点。但在刚开始，小R还不熟悉宿舍楼中的任何一条路，所以他会慢慢地发现这些路，他在发现一条路时还会知道这条路的温度和长度。每条路的温度都是互不相同的。
小R需要在宿舍楼中活动，每次他都需要从一个地点到达另一个地点。小R希望每次活动时经过一条最温暖的路径，最温暖的路径的定义为，将路径上各条路的温度从小到大排序后字典序最大。即温度最低的路温度尽量高，在满足该条件的情况下，温度第二低的路温度尽量高，以此类推。小R不会经过重复的路。由于每条路的温度互不相同，因此只存在一条最温暖的路径。
对于小R的每次活动，你需要求出小R需要走过的路径总长度。如果小R通过当前发现的路不能完成这次活动，则输出 −1−1。
注意本题中的字典序与传统意义上的字典序定义有所不同，对于两个序列a,b(a≠b)a,b(a≠b)，若aa是bb的前缀则aa的字典序较大，同时可以推出空串的字典序最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4736">BZOJ</a>
<a href="http://uoj.ac/problem/274">UOJ</a>

<h3>Tag</h3>

LCT

<h2>解决思路</h2>

题目中说的什么字典序最大。说白了就是要求温度的最大生成树，直接用&#92;(LCT&#92;)维护即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int len,sum,tem;//当前这个点代表的边的长度，路径总长，温度
    int mnid,d1,d2;
};

int n,nodecnt;
Splay_Data S[maxN];
int Stack[maxN],UFS[maxN];//并查集

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int GetMin(int id1,int id2);
int Find(int x);
void Add_Edge(int u,int v,int id,int ten,int len);
bool Delete(int u,int v,int tem);
void Outp();

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=0;i&lt;=n;i++) S[i].len=0,S[i].tem=inf,UFS[i]=i;
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if (opt[0]=='f')
        {
            int id,u,v,tem,len;scanf("%d%d%d%d%d",&amp;id,&amp;u,&amp;v,&amp;tem,&amp;len);u++;v++;
            Add_Edge(u,v,id,tem,len);
        }
        if (opt[0]=='m')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            if (Find(u)!=Find(v)) printf("-1\n");
            else
            {
                Makeroot(u);
                Access(v);Splay(v);
                printf("%d\n",S[v].sum);
            }
        }
        if (opt[0]=='c')
        {
            int id,len;scanf("%d%d",&amp;id,&amp;len);id=id+n+1;
            Makeroot(id);S[id].len=len;Update(id);
        }
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].sum=S[S[x].ch[0]].sum+S[S[x].ch[1]].sum+S[x].len;
    S[x].mnid=GetMin(x,GetMin(S[S[x].ch[0]].mnid,S[S[x].ch[1]].mnid));
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int ls=S[x].ch[0],rs=S[x].ch[1];
        swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
        if (ls) S[ls].rev^=1;
        if (rs) S[rs].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=now;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;
    return;
}

int GetMin(int id1,int id2)
{
    return (S[id1].tem&lt;S[id2].tem)?(id1):(id2);
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

void Add_Edge(int u,int v,int id,int tem,int len)
{
    id=id+n+1;
    if (Find(u)==Find(v))
        if (Delete(u,v,tem)==0) return;
    UFS[Find(u)]=Find(v);
    Makeroot(u);Makeroot(v);
    S[id].len=len;S[id].tem=tem;S[id].d1=u;S[id].d2=v;
    S[u].fa=id;S[v].fa=id;Update(id);
    return;
}

bool Delete(int u,int v,int tem)
{
    Makeroot(u);Access(v);Splay(v);
    if (S[S[v].mnid].tem&gt;tem) return 0;
    int mnid=S[v].mnid;
    Makeroot(mnid);
    Cut(mnid,S[mnid].d1);Cut(mnid,S[mnid].d2);
    S[mnid].fa=S[mnid].ch[0]=S[mnid].ch[1]=0;
    return 1;
}

void Outp()
{
    printf("id fa ls rs d1 d2 mnid len tem sum\n");
    for (int i=1;i&lt;=n+5;i++) printf("%2d%3d%3d%3d%3d%3d%5d%4d%4d%4d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].d1,S[i].d2,S[i].mnid,S[i].len,S[i].tem,S[i].sum);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>414</wp:post_id>
		<wp:post_date><![CDATA[2018-01-25 20:52:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-25 12:52:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4736-uoj274%e6%b8%a9%e6%9a%96%e4%bc%9a%e6%8c%87%e5%bc%95%e6%88%91%e4%bb%ac%e5%89%8d%e8%a1%8c%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="post_tag" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[296]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>67</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.53]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:35:34]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:35:34]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@zhoushuyu(an)：+1]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>63</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.52]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-27 19:56:16]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-27 11:56:16]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[从未见过萝卜写过如此短的题解，想必萝卜觉得此题不难]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>45</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 22:36:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 14:36:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[从未见过如此数形结合生动详细通俗易懂精妙无双的LCT题解！给博主好评！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>47</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.31.63]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-26 00:23:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 16:23:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你是有多无聊啊。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU2665]Kth number （主席树）</title>
		<link>http://sycstudio.com/archives/422</link>
		<pubDate>Fri, 26 Jan 2018 01:05:06 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=422</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Give you a sequence and ask you the kth big number of a inteval.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-2665">HDU</a>

<h3>Tag</h3>

主席树

<h2>题目大意</h2>

求区间第&#92;(K&#92;)大

<h2>解决思路</h2>

主席树练手题。
相当于建立出&#92;(n&#92;)棵权值线段树，第&#92;(i&#92;)棵权值线段树保存的是前&#92;(i&#92;)个点的信息，那么类似与前缀和的思想，求&#92;([l,r]&#92;)的线段树就用第&#92;(r&#92;)棵线段树减去第&#92;(l&#92;)棵线段树，在这课作差得到的线段树上查询即可。而主席树就是利用已知信息节约空间。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100110;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;//左右儿子
    int sum;
};

int n,m;
int nodecnt=0;
SegmentData S[maxN*20];
int root[maxN];//保存根节点
int Arr[maxN],Brr[maxN];

void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int now1,int now2,int l,int r,int kth);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]),Brr[i]=Arr[i];
        sort(&amp;Brr[1],&amp;Brr[n+1]);//读进来后先离散化
        for (int i=1;i&lt;=n;i++) Arr[i]=lower_bound(&amp;Brr[1],&amp;Brr[n+1],Arr[i])-Brr;
        Build(root[0],1,n);//初始化
        for (int i=1;i&lt;=n;i++) root[i]=root[i-1],Update(root[i],1,n,Arr[i]);//构造n棵主席树
        while (m--)
        {
            int l,r,kth;scanf("%d%d%d",&amp;l,&amp;r,&amp;kth);//查询第K大
            printf("%d\n",Brr[Query(root[l-1],root[r],1,n,kth)]);
        }
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)/2;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(int &amp;now,int l,int r,int num)
{
    S[++nodecnt]=S[now];
    S[now=nodecnt].sum++;
    if (l==r) return;
    int mid=(l+r)/2;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
    return;
}

int Query(int now1,int now2,int l,int r,int kth)
{
    if (l==r) return l;
    int lsize=S[S[now2].ls].sum-S[S[now1].ls].sum;
    int mid=(l+r)/2;
    if (lsize&gt;=kth) return Query(S[now1].ls,S[now2].ls,l,mid,kth);
    else return Query(S[now1].rs,S[now2].rs,mid+1,r,kth-lsize);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>422</wp:post_id>
		<wp:post_date><![CDATA[2018-01-26 09:05:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-26 01:05:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu2665kth-number-%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[197]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4417]Super Mario（主席树）</title>
		<link>http://sycstudio.com/archives/426</link>
		<pubDate>Fri, 26 Jan 2018 02:23:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=426</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Mario is world-famous plumber. His “burly” figure and amazing jumping ability reminded in our memory. Now the poor princess is in trouble again and Mario needs to save his lover. We regard the road to the boss’s castle as a line (the length is n), on every integer point i there is a brick on height hi. Now the question is how many bricks in [L, R] Mario can hit if the maximal height he can jump is H.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4417">HDU</a>

<h3>Tag</h3>

主席树

<h2>题目大意</h2>

求区间内小于给定的&#92;(K&#92;)的数的个数

<h2>解决思路</h2>

离散化并去重之后，用主席树维护权值线段树，类似前缀和地查询即可。
有点卡时，要手写二分+去重才行

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

const int maxN=100005;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    int sum;
};

int n,nodecnt=0,length;
int root[maxN];
SegmentData S[maxN*25];
int Arr[maxN];
int Brr[maxN];

int Find(int key);//二分
void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int now1,int now2,int l,int r,int qr);

int main()
{
    int T;scanf("%d",&amp;T);
    for (int ti=1;ti&lt;=T;ti++)
    {
        mem(S,0);
        mem(root,0);
        printf("Case %d:\n",ti);
        RG int Q;
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;Q);
        for (RG int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]),Brr[i]=Arr[i];
        sort(&amp;Brr[1],&amp;Brr[n+1]);length=unique(&amp;Brr[1],&amp;Brr[n+1])-Brr-1;//离散化+去重
        for (RG int i=1;i&lt;=n;i++) Arr[i]=Find(Arr[i]);
        Build(root[0],1,length);
        for (RG int i=1;i&lt;=n;i++) root[i]=root[i-1],Update(root[i],1,length,Arr[i]);
        while (Q--)
        {
            RG int l,r,h;scanf("%d%d%d",&amp;l,&amp;r,&amp;h);l++;r++;
            RG int hh=Find(h);
            if (hh==0) {printf("0\n");continue;}//注意特判0的情况
            printf("%d\n",Query(root[l-1],root[r],1,length,hh));
        }
    }
    return 0;
}

void Build(RG int &amp;now,RG int l,RG int r)
{
    now=++nodecnt;
    if (l==r) return;
    RG int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(RG int &amp;now,RG int l,RG int r,RG int num)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].sum++;
    if (l==r) return;
    RG int mid=(l+r)&gt;&gt;1;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
}

int Query(RG int now1,RG int now2,RG int l,RG int r,RG int qr)
{
    if (qr==r) return S[now2].sum-S[now1].sum;
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(S[now1].ls,S[now2].ls,l,mid,qr);
    else return Query(S[now1].ls,S[now2].ls,l,mid,mid)+Query(S[now1].rs,S[now2].rs,mid+1,r,qr);
}


int Find(int key)
{
    int l=1,r=length;
    int ret=0;
    while (l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if (Brr[mid]&lt;=key)
            ret=mid,l=mid+1;
        else r=mid-1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>426</wp:post_id>
		<wp:post_date><![CDATA[2018-01-26 10:23:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-26 02:23:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4417super-mario]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[193]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[CodeChef GERALD07/BZOJ3514]Codechef MARCH14 GERALD07[加强版]（LCT，主席树）</title>
		<link>http://sycstudio.com/archives/434</link>
		<pubDate>Sat, 27 Jan 2018 00:38:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=434</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

N个点M条边的无向图，询问保留图中编号在[l,r]的边的时候图中的联通块个数。

<h3>Http</h3>

<a href="https://vjudge.net/problem/CodeChef-GERALD07">Codechef</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3514">BZOJ</a>

<h3>Tag</h3>

LCT，主席树

<h2>解决思路</h2>

原题没有强制在线，加强版有，我们直接讨论加强版的做法。
考虑一条边&#92;(u->v&#92;)，若加入它之前&#92;(u,v&#92;)不连通，那么加入它之后，连通块个数减一；否则，连通块个数不变，但图中出现了一个环，此时，我们去掉这个环中最早加入的边，记&#92;(ntr[i]&#92;)表示加入&#92;(i&#92;)这条边时，去掉的那个最早的边的编号，特别的，若之前&#92;(u,v&#92;)不连通，&#92;(ntr[i]=0&#92;)，若为自环，&#92;(ntr[i]=i&#92;)。
求出这个&#92;(ntr&#92;)之后，对于询问&#92;(l,r&#92;)之间的边，我们计算&#92;(l,r&#92;)中&#92;(ntr&#92;)小于&#92;(l&#92;)的有多少个，用总点数&#92;(n&#92;)减去这个个数即为每一次的答案。
这么做为什么是对的呢？由于我们&#92;(ntr&#92;)中记录的是与这一条边形成环的最早的边的编号，那么如果这一条边的&#92;(ntr&#92;)小于&#92;(l&#92;)，那么也就是说它一定有减去一个连通块的贡献，否则，它的两个端点已经在一个连通块中了，把它加入不会影响答案。
那么，任务就变成了按照编号顺序依此加边，维护编号尽量大的一棵生成树，这个可以用&#92;(LCT&#92;)维护；至于查询&#92;(l,r&#92;)中&#92;(ntr&#92;)小于&#92;(l&#92;)的个数，可以插入到一棵主席树维护权值线段树。
注意，&#92;(Codechef&#92;)有多组数据，下面的代码是针对&#92;(BZOJ&#92;)的。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int inf=2147483647;

int n,m;

namespace LCT//LinkCutTree
{
    class Splay_Data
    {
    public:
        int fa,ch[2];
        int rev;
        int key;
        int mnid;//记录加入最早的边的编号
        int d1,d2;
    };

    int nodecnt=0;
    Splay_Data S[maxN*2];
    int Stack[maxN*2];

    bool Isroot(int x)
    {
        if ((S[S[x].fa].ch[0]==x)||(S[S[x].fa].ch[1]==x)) return 0;
        return 1;
    }

    void Update(int x)
    {
        S[x].mnid=x;
        if (S[S[S[x].ch[0]].mnid].key&lt;S[S[x].mnid].key) S[x].mnid=S[S[x].ch[0]].mnid;
        if (S[S[S[x].ch[1]].mnid].key&lt;S[S[x].mnid].key) S[x].mnid=S[S[x].ch[1]].mnid;
        return;
    }

    void PushDown(int x)
    {
        if (S[x].rev)
        {
            S[x].rev=0;int ls=S[x].ch[0],rs=S[x].ch[1];
            swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
            if (ls) S[ls].rev^=1;
            if (rs) S[rs].rev^=1;
        }
        return;
    }

    void Rotate(int x)
    {
        int y=S[x].fa,z=S[y].fa;
        int sx=(x==S[y].ch[1]);
        int sy=(y==S[z].ch[1]);
        S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
        S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
        S[y].fa=x;S[x].ch[sx^1]=y;
        Update(y);return;
    }

    void Splay(int x)
    {
        int now=x,stacktop=1;Stack[1]=x;
        while (Isroot(now)==0)
        {
            Stack[++stacktop]=S[now].fa;now=S[now].fa;
        }
        for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
        while (Isroot(x)==0)
        {
            int y=S[x].fa,z=S[y].fa;
            if (Isroot(y)==0)
                ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
            Rotate(x);
        }
        Update(x);return;
    }

    void Access(int x)
    {
        int lastx=0;
        while (x)
        {
            Splay(x);S[x].ch[1]=lastx;Update(x);
            lastx=x;x=S[x].fa;
        }
        return;
    }

    void Makeroot(int x)
    {
        Access(x);Splay(x);S[x].rev^=1;
        swap(S[x].ch[0],S[x].ch[1]);
        return;
    }

    int Findroot(int x)
    {
        Access(x);Splay(x);
        while (S[x].ch[0]) x=S[x].ch[0];
        return x;
    }

    void Link(int x,int y)
    {
        Makeroot(x);S[x].fa=y;
        return;
    }

    void Cut(int x,int y)
    {
        Makeroot(x);Access(y);Splay(y);
        S[x].fa=S[y].ch[0]=0;
        return;
    }
    void Add_Edge(int u,int v,int id)
    {
        Makeroot(u);Makeroot(v);
        ++nodecnt;
        S[nodecnt].key=id;
        S[u].fa=nodecnt;S[v].fa=nodecnt;
        S[nodecnt].d1=u;S[nodecnt].d2=v;
        return;
    }
};

namespace Seg//主席树
{
    class SegmentData
    {
    public:
        int ls,rs;
        int sum;
    };

    int nodecnt=0;
    int root[maxN];
    SegmentData S[maxN*30];
    void Build(int &amp;now,int l,int r)
    {
        now=++nodecnt;
        if (l==r) return;
        int mid=(l+r)&gt;&gt;1;
        Build(S[now].ls,l,mid);
        Build(S[now].rs,mid+1,r);
        return;
    }

    void Update(int &amp;now,int l,int r,int num)
    {
        S[++nodecnt]=S[now];now=nodecnt;
        S[nodecnt].sum++;
        if (l==r) return;
        int mid=(l+r)&gt;&gt;1;
        if (num&lt;=mid) Update(S[now].ls,l,mid,num);
        else Update(S[now].rs,mid+1,r,num);
        return;
    }

    int Query(int now1,int now2,int l,int r,int ql,int qr)
    {
        if ((l==ql)&amp;&amp;(r==qr)) return S[now2].sum-S[now1].sum;
        int mid=(l+r)/2;
        if (qr&lt;=mid) return Query(S[now1].ls,S[now2].ls,l,mid,ql,qr);
        else if (ql&gt;=mid+1) return Query(S[now1].rs,S[now2].rs,mid+1,r,ql,qr);
        return Query(S[now1].ls,S[now2].ls,l,mid,ql,mid)+Query(S[now1].rs,S[now2].rs,mid+1,r,mid+1,qr);
    }
};

int K,type;
int ntr[maxN];

int main()
{
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;type);
    for (int i=0;i&lt;=n;i++) LCT::S[i].key=inf;
    LCT::nodecnt=n;
    for (int i=1;i&lt;=m;i++)//依此加入边，维护生成树
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        if (u==v) {ntr[i]=i;continue;}//自环
        if (LCT::Findroot(u)!=LCT::Findroot(v))
            LCT::Add_Edge(u,v,i);
        else
        {
            LCT::Makeroot(u);LCT::Access(v);LCT::Splay(v);
            int mnid=LCT::S[v].mnid;
            ntr[i]=LCT::S[mnid].key;
            LCT::Cut(LCT::S[mnid].d1,LCT::S[mnid].d2);
            LCT::Add_Edge(u,v,i);
        }
    }
    Seg::Build(Seg::root[0],0,m);
    for (int i=1;i&lt;=m;i++)//把ntr插入到主席树中方便查询
    {
        Seg::root[i]=Seg::root[i-1];
        Seg::Update(Seg::root[i],0,m,ntr[i]);
    }
    int ans=0;
    while (K--)
    {
        int l,r;scanf("%d%d",&amp;l,&amp;r);
        if (type) l^=ans,r^=ans;
        ans=n-Seg::Query(Seg::root[l-1],Seg::root[r],0,m,0,l-1);
        printf("%d\n",ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>434</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 08:38:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 00:38:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[codechef-gerald07-bzoj3514codechef-march14-gerald07%e5%8a%a0%e5%bc%ba%e7%89%88%ef%bc%88lct%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="codechef"><![CDATA[Codechef]]></category>
		<category domain="post_tag" nicename="codechef"><![CDATA[Codechef]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[286]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ COT/BZOJ 2588]COT - Count on a tree（主席树，LCA，离散化）</title>
		<link>http://sycstudio.com/archives/436</link>
		<pubDate>Sat, 27 Jan 2018 01:58:28 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=436</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

You are given a tree with N nodes. The tree nodes are numbered from 1 to N. Each node has an integer weight.
We will ask you to perform the following operation:
u v k : ask for the kth minimum weight on the path from node u to node v

<h3>Http</h3>

<a href="http://www.spoj.com/problems/COT/">SPOJ</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2588">BZOJ</a>

<h3>Tag</h3>

主席树，LCA，离散化

<h2>题目大意</h2>

给出一棵点权树，求两点之间路径上的第&#92;(K&#92;)大的点权

<h2>解决思路</h2>

以&#92;(1&#92;)为根，变成有根树，那么现在就是查询&#92;(u&#92;)到&#92;(lca&#92;)并上&#92;(v&#92;)到&#92;(lca&#92;)路径上的第&#92;(K&#92;)大。考虑用主席树给每一个&#92;(i&#92;)到根的路径维护一棵权值线段树，那么可以用类似前缀和的思想，利用&#92;(u,v,lca,fa[lca]&#92;)这四个点加减构造出路径的权值线段树。
因为树是静态的，所以这里采用倍增的方式求出&#92;(lca&#92;)
注意离散化。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    int sum;
};

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int NodeW[maxN],Num[maxN];
int Fa[maxN][25],Depth[maxN];
int nodecnt=0,root[maxN];
SegmentData S[maxN*30];

void dfs1(int u,int fa);
void dfs2(int u);
int LCA(int u,int v);
void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int n1,int n2,int n3,int n4,int l,int r,int kth);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;NodeW[i]),Num[i]=NodeW[i];
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    }
    Depth[1]=1;
    dfs1(1,0);//倍增lca预处理
    for (int j=1;j&lt;25;j++)
        for (int i=1;i&lt;=n;i++)
            if (Fa[i][j-1]!=0) Fa[i][j]=Fa[Fa[i][j-1]][j-1];
    sort(&amp;Num[1],&amp;Num[n+1]);//点权离散化
    for (int i=1;i&lt;=n;i++) NodeW[i]=lower_bound(&amp;Num[1],&amp;Num[n+1],NodeW[i])-Num;
    Build(root[0],1,n);//初始化主席树
    dfs2(1);//构造主席树
    int ans=0;
    for (int ti=1;ti&lt;=m;ti++)
    {
        int u,v,kth;scanf("%d%d%d",&amp;u,&amp;v,&amp;kth);u^=ans;
        int lca=LCA(u,v);
        ans=Num[Query(root[u],root[v],root[lca],root[Fa[lca][0]],1,n,kth)];
        printf("%d",ans);
        if (ti!=m) printf("\n");
    }
    return 0;
}

void dfs1(int u,int fa)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Depth[V[i]]=Depth[u]+1;
            Fa[V[i]][0]=u;
            dfs1(V[i],u);
        }
    return;
}

void dfs2(int u)
{
    root[u]=root[Fa[u][0]];
    Update(root[u],1,n,NodeW[u]);
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Fa[u][0])
            dfs2(V[i]);
    return;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(int &amp;now,int l,int r,int num)
{
    S[++nodecnt]=S[now];
    now=nodecnt;S[now].sum++;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
    return;
}

int Query(int n1,int n2,int n3,int n4,int l,int r,int kth)
{
    if (l==r) return l;
    int lsize=S[S[n1].ls].sum+S[S[n2].ls].sum-S[S[n3].ls].sum-S[S[n4].ls].sum;
    int mid=(l+r)&gt;&gt;1;
    if (lsize&gt;=kth) return Query(S[n1].ls,S[n2].ls,S[n3].ls,S[n4].ls,l,mid,kth);
    else return Query(S[n1].rs,S[n2].rs,S[n3].rs,S[n4].rs,mid+1,r,kth-lsize);
}

int LCA(int u,int v)
{
    if ((u==1)||(v==1)) return 1;
    if (Depth[v]&gt;Depth[u]) swap(u,v);
    for (int i=24;i&gt;=0;i--) if ((Fa[u][i])&amp;&amp;(Depth[Fa[u][i]]&gt;=Depth[v])) u=Fa[u][i];
    if (u==v) return u;
    for (int i=24;i&gt;=0;i--) if ((Fa[u][i])&amp;&amp;(Fa[v][i])&amp;&amp;(Fa[u][i]!=Fa[v][i])) u=Fa[u][i],v=Fa[v][i];
    return Fa[u][0];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>436</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 09:58:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 01:58:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-cot-bzoj-2588cot-count-on-a-tree%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%8clca%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="post_tag" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[273]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3932/Luogu3168][CQOI2015]任务查询系统（主席树，差分，离散化）</title>
		<link>http://sycstudio.com/archives/439</link>
		<pubDate>Sat, 27 Jan 2018 07:34:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=439</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。超级计算机中的任务用三元组(Si,Ei,Pi)描述，(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束（第Si秒和Ei秒任务也在运行），其优先级为Pi。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。调度系统会经常向查询系统询问，第Xi秒正在运行的任务中，优先级最小的Ki个任务（即将任务按照优先级从小到大排序后取前Ki个）的优先级之和是多少。特别的，如果Ki大于第Xi秒正在运行的任务总数，则直接回答第Xi秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在1到n之间（包含1和n）。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3932">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3168">Luogu</a>

<h3>Tag</h3>

主席树，差分，离散化

<h2>解决思路</h2>

我们考虑对于一个任务&#92;(s->e&#92;)，考虑差分在&#92;(s&#92;)加入，在&#92;(t+1&#92;)减去。为了维护区间第&#92;(K&#92;)的相关问题，用主席树维护前缀和即可。
注意离散化

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=210010;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    ll cnt,sum;
    int tim;//时间戳
};

class Edge
{
public:
    int s,e,p;
};

int n,m;
int nodecnt=0,root[maxN];
int nowtim;
vector&lt;int&gt; E[maxN];
Edge Input[maxN];
SegmentData S[maxN*30];
int Num[maxN];

void Build(int &amp;now,int l,int r);
void Update(int n1,int &amp;n2,int l,int r,int id,ll key);
ll Query(int now,int l,int r,int kth);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d%d",&amp;Input[i].s,&amp;Input[i].e,&amp;Input[i].p);
        Num[i]=Input[i].p;
    }
    sort(&amp;Num[1],&amp;Num[n+1]);
    for (int i=1;i&lt;=n;i++)
    {
        Input[i].p=lower_bound(&amp;Num[1],&amp;Num[n+1],Input[i].p)-Num;
        E[Input[i].s].push_back(Input[i].p);E[Input[i].e+1].push_back(-Input[i].p);
    }
    Build(root[0],1,m+1);
    for (int i=1;i&lt;=m+1;i++)
    {
        root[i]=root[i-1];nowtim=i;
        for (int j=0;j&lt;E[i].size();j++)
            if (E[i][j]&gt;0) Update(root[i],root[i],1,m+1,E[i][j],Num[E[i][j]]);
            else Update(root[i],root[i],1,m+1,-E[i][j],-Num[-E[i][j]]);
    }
    ll ans=1;
    for (int i=1;i&lt;=m;i++)
    {
        int x,a,b,c;scanf("%d%d%d%d",&amp;x,&amp;a,&amp;b,&amp;c);
        int kth=((ll)a*(ll)ans%c+b%c)%c+1;
        if (S[root[x]].cnt&lt;=kth) printf("%lld\n",ans=S[root[x]].sum);
        else printf("%lld\n",ans=Query(root[x],1,m+1,kth));
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    return;
}

void Update(int n1,int &amp;n2,int l,int r,int id,ll key)
{
    //cout&lt;&lt;id&lt;&lt;" "&lt;&lt;key&lt;&lt;endl;
    if (S[n1].tim!=nowtim)
    {
        S[++nodecnt]=S[n1];n2=nodecnt;
        S[n2].tim=nowtim;
    }
    if (key&gt;0) S[n2].cnt++;else S[n2].cnt--;
    S[n2].sum=(ll)S[n2].sum+(ll)key;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (id&lt;=mid) Update(S[n1].ls,S[n2].ls,l,mid,id,key);
    else Update(S[n1].rs,S[n2].rs,mid+1,r,id,key);
    return;
}

ll Query(int now,int l,int r,int kth)
{
    if (l==r) return (ll)Num[l]*(ll)kth;
    int mid=(l+r)&gt;&gt;1;
    if (S[S[now].ls].cnt&gt;=kth) return Query(S[now].ls,l,mid,kth);
    else return Query(S[now].rs,mid+1,r,kth-S[S[now].ls].cnt)+S[S[now].ls].sum;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>439</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 15:34:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 07:34:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3932-luogu3186cqoi2015%e4%bb%bb%e5%8a%a1%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%8c%e5%b7%ae%e5%88%86%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[199]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[51Nod1814]Clarke and string(回文树) by dsl</title>
		<link>http://sycstudio.com/archives/443</link>
		<pubDate>Sun, 28 Jan 2018 07:48:38 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=443</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

克拉克是一名人格分裂患者.有一天克拉克分裂成 &#92;(n&#92;) 个人.<br />
每个克拉克手里有一个由小写字母组成字符串 &#92;(&#95;i&#92;) .克拉克们还有&#92;(q&#92;),第&#92;(i&#92;)次询问,克拉克们想知道有多少个回文串同时出现在&#92;(a&#95;{xi}&#92;)和&#92;(a&#95;{yi}&#92;)中.<br />
一个字符串称为回文串当且仅当这个串前后反转后与这个串相同。

&#92;(n, q, \sum a_i \leqslant 100000&#92;)

<h1>Solution</h1>

upd:
不想写代码了，口胡一下好了：
用回文树求出每个串本质不同的回文子串。然后用&#92;(hash+set&#92;)存储。
每次在set里询问即可。
时间复杂度&#92;(O(n \sqrt n \log n)&#92;)

<hr />

对于每组询问，暴力构出两个串的回文树，然后在较短的串中查询即可。为了加快速度，为每组询问加上记忆化。

然后就AC啦？！

让我们证明一下这样做的正确性，即时间复杂度为&#92;(O(n\sqrt n)&#92;)：
设每组询问的串为&#92;(x,y&#92;)

<ol>
<li>设&#92;(|s_x|&#92;leqslant &#92;sqrt n&#92;)或&#92;(|s_y|\leqslant \sqrt n&#92;)，由于时间复杂度与较短的串有关，所以复杂度显然正确。</p></li>
<li><p>否则&#92;(|s_x|\geqslant\sqrt n&#92;)的串最多有&#92;(\sqrt n&#92;)个,&#92;(|s_x|\geqslant \sqrt n&#92;)且&#92;(|s_y|\geqslant \sqrt n&#92;)最多只有&#92;(n&#92;)种询问，加
上记忆化后显然正确。</p></li>
</ol>

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int n, q;
vector&lt;char&gt; s[maxn];

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

map&lt;pair&lt;int, int&gt;, int&gt; f;

struct palindromic_tree 
{
    pair&lt;int, int&gt; ch[maxn][26];
    int cnt, tot, ans, len[maxn], fail[maxn], last;

    inline void clear()
    {
        last = 1; len[tot = 1] = -1; fail[0] = fail[1] = 1; ++cnt;
    }

    inline void add(int t, int c, int n)
    {
        int x = last;
        while(s[t][n - len[x] - 1] != s[t][n]) x = fail[x];
        if(ch[x][c].second != cnt) {
            int v = ++tot, k = fail[x];
            while(s[t][n - len[k] - 1] != s[t][n]) k = fail[k];
            fail[v] = ch[k][c].second == cnt ? ch[k][c].first : 0; len[v] = len[x] + 2; ch[x][c] = make_pair(v, cnt);
        }
        last = ch[x][c].first;
    }   
}t1, t2;

int l, r, que1[maxn], que2[maxn];
inline int bfs(int s)
{
    l = 0; r = 1; que1[r] = que2[r] = s;
    do {
        ++l; int u = que1[l], v = que2[l];
        for(int i = 0; i &lt; 26; ++i)
            if(t1.ch[u][i].second == t1.cnt &amp;&amp; t2.ch[v][i].second == t2.cnt) {
                ++r; que1[r] = t1.ch[u][i].first; que2[r] = t2.ch[v][i].first;
            }
    }while(l &lt; r);
    return r - 1;
}

inline int solve(int x, int y)
{
    if(f.count(make_pair(x, y))) return f[make_pair(x, y)];
    if(s[x].size() &gt; s[y].size()) swap(x, y);
    t1.clear(); t2.clear();
    register int n, i;
    for(n = s[x].size(), i = 0; i &lt; n; ++i) t1.add(x, s[x][i] - 'a', i);
    for(n = s[y].size(), i = 0; i &lt; n; ++i) t2.add(y, s[y][i] - 'a', i);
    return f[make_pair(x, y)] = bfs(0) + bfs(1);
}

int main()
{
    scanf("%d\n", &amp;n);
    for(int i = 1; i &lt;= n; ++i) {
        char c = getchar(); s[i].push_back(0);
        while('a' &lt;= c &amp;&amp; c &lt;= 'z') s[i].push_back(c), c = getchar();
    }
    scanf("%d\n", &amp;q);
    for(int lastans = 0, i = 1, x, y; i &lt;= q; ++i) {
        x = gi() ^ lastans; y = gi() ^ lastans;
        printf("%d\n", lastans = solve(x, y));
    }
    return 0;
}
</code></pre>

<p>我的代码常数有点(非常?)大，下面是laofu的代码

```c++11
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;unordered_set&gt;

#define pb push_back
#define mp make_pair

using namespace std;

template&lt;typename T&gt;inline void upmin(T &amp;x,T y) { y&lt;x?x=y:0; }
template&lt;typename T&gt;inline void upmax(T &amp;x,T y) { x&lt;y?x=y:0; }

typedef unsigned int u32;
typedef long long LL;
typedef unsigned long long ULL;
typedef long double lod;
typedef pair&lt;int,int&gt; PR;
typedef vector&lt;int&gt; VI;

const lod pi=acos(-1);
const int oo=1&lt;&lt;30;
const LL OO=1e18;

const int N=2e5+100;

int gi() {
    int w=0;bool q=1;char c=getchar();
    while ((c&lt;&#039;0&#039;||c&gt;&#039;9&#039;) &amp;&amp; c!=&#039;-&#039;) c=getchar();
    if (c==&#039;-&#039;) q=0,c=getchar();
    while (c&gt;=&#039;0&#039;&amp;&amp;c &lt;= &#039;9&#039;) w=w*10+c-&#039;0&#039;,c=getchar();
    return q? w:-w;
}

char str[N];

int son[N][26],fail[N],len[N],tot,last;
bool vis[N];

inline int getfail(int k,int n) {
    while (str[n-len[k]-1]!=str[n]) k=fail[k];
    return k;
}
inline int add(int k,int n) {
    k=getfail(k,n);
    if (!son[k][str[n]-&#039;a&#039;]) {
        len[++tot]=len[k]+2;
        fail[tot]=son[getfail(fail[k],n)][str[n]-&#039;a&#039;];
        son[k][str[n]-&#039;a&#039;]=tot;
    }
    k=son[k][str[n]-&#039;a&#039;];
    return k;
}
unordered_set&lt;ULL&gt;H[N];
const ULL seed=19260817;
ULL key[26];
map&lt;PR,int&gt;ans;
ULL pre[N],num[N];
int main()
{
#ifndef ONLINE_JUDGE
    freopen(&quot;D.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;D.out&quot;,&quot;w&quot;,stdout);
#endif
    int n=gi(),m,i,j,l,a,b;
    for (i=0;i&lt;26;i++) key[i]=rand();
    for (i=num[0]=1;i&lt;=1e5;i++) num[i]=num[i-1]&lt;em&gt;seed;
    for (i=1;i&lt;=n;i++) {
        len[1]=-1;fail[0]=1;
        last=tot=1;
        scanf(&quot;%s&quot;,str+1);str[0]=&#039;#&#039;;
        l=strlen(str+1);
        vis[0]=vis[1]=true;
        for (j=1;j&lt;=l;j++) {
            pre[j]=pre[j-1]&lt;/em&gt;seed+key[str[j]-&#039;a&#039;];
            last=add(last,j);
            if (!vis[last])
                H[i].insert(pre[j]-pre[j-len[last]]&lt;em&gt;num[len[last]]);
        }
        memset(vis,0,(tot+1));
        memset(len,0,(tot+1)&lt;/em&gt;4);
        memset(fail,0,(tot+1)&lt;em&gt;4);
        memset(son,0,sizeof(son[0])&lt;/em&gt;(tot+1));
    }
    m=gi();
    last=0;
    while (m--) {
        a=gi()^last,b=gi()^last;
        if (H[a].size()&lt;H[b].size())
            swap(a,b);
        if (ans.find(mp(a,b))==ans.end()) {
            int res=0;
            for (ULL t:H[b])
                res+=H[a].find(t)!=H[a].end();
            ans[mp(a,b)]=res;
        }
        printf(&quot;%d\n&quot;,last=ans[mp(a,b)]);
    }
    return 0;
}
```

<h2>FAQ:</h2>

Q:你怎么来sycstudio.com写文章了？
A:因为csdn广告太多，cnblogs不想配置，自己的博客还没搭好，所以就来蹭博客了。
Q:你的代码常数有多大？
A:AC中我跑得最慢。
Q:数学公式为什么出锅了？
A:我不会用这个编辑器的公式，我也很无奈好心的萝卜帮我改改吧。
My question：为什么我不能添加分类？？数学公式到底要用什么？萝卜不能改改这个东西吗？]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>443</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 15:48:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 07:48:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[51nod1814clarke-and-string%e5%9b%9e%e6%96%87%e6%a0%91-by-dsl]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="51nod"><![CDATA[51nod]]></category>
		<category domain="category" nicename="51nod"><![CDATA[51nod]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91"><![CDATA[回文树]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[316]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>70</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.46]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 22:19:57]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 14:19:57]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[很抱歉，我的是个假算法，真算法大概将于冬令营后更新]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>64</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 15:49:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 07:49:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已经更正所有数学公式并添加分类。
upt:删除线也改好了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ4012/Luogu3241][HNOI2015]开店（树链剖分，主席树）</title>
		<link>http://sycstudio.com/archives/447</link>
		<pubDate>Sun, 28 Jan 2018 08:05:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=447</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

风见幽香有一个好朋友叫八云紫，她们经常一起看星星看月亮从诗词歌赋谈到人生哲学。最近她们灵机一动，打算在幻想乡开一家小店来做生意赚点钱。这样的想法当然非常好啦，但是她们也发现她们面临着一个问题，那就是店开在哪里，面向什么样的人群。很神奇的是，幻想乡的地图是一个树形结构，幻想乡一共有 n个地方，编号为 1 到 n，被 n-1 条带权的边连接起来。每个地方都住着一个妖怪，其中第 i 个地方的妖怪年龄是 x_i。妖怪都是些比较喜欢安静的家伙，所以它们并不希望和很多妖怪相邻。所以这个树所有顶点的度数都小于或等于 3。妖怪和人一样，兴趣点随着年龄的变化自然就会变化，比如我们的 18 岁少女幽香和八云紫就比较喜欢可爱的东西。幽香通过研究发现，基本上妖怪的兴趣只跟年龄有关，所以幽香打算选择一个地方 u（u为编号），然后在 u开一家面向年龄在 L到R 之间（即年龄大于等于 L、小于等于 R）的妖怪的店。也有可能 u这个地方离这些妖怪比较远，于是幽香就想要知道所有年龄在 L 到 R 之间的妖怪，到点 u 的距离的和是多少（妖怪到 u 的距离是该妖怪所在地方到 u 的路径上的边的权之和） ，幽香把这个称为这个开店方案的方便值。幽香她们还没有决定要把店开在哪里，八云紫倒是准备了很多方案，于是幽香想要知道，对于每个方案，方便值是多少呢。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4012">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3241">Luogu</a>

<h3>Tag</h3>

树链剖分，主席树

<h2>解决思路</h2>

先不考虑年龄的限制，考虑其它点&#92;(x&#92;)到一个指定点&#92;(u&#92;)的距离，设&#92;(dis[i]&#92;)表示点&#92;(i&#92;)到根（默认是&#92;(1&#92;)）的距离，那么就是&#92;(\sum dis[u]+dis[x]-2&#42;dis[lca(u,x)]&#92;)，这个式子的前两项都比较好处理，一个直接用&#92;(dis[u]&#92;)乘以点数，另一个可以用前缀和维护，那么关键是&#92;(dis[lca(u,x)]&#92;)这一项怎么求。
这个的求法可以参考<a href="http://sycstudio.com/archives/328">这一道题</a>，类似的，我们用树链剖分+线段树的方法，对点&#92;(x&#92;)到根的路径的边都+1，这样查询&#92;(u&#92;)到根的路径和就可以得到&#92;(dis[lca(u,x)]&#92;)了。
最后把年龄的限制加上去，我们把妖怪按照年龄排序后，以此以树链剖分的形式插入主席树，这样就可以实现对年龄区间的查询。注意要标记永久化。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=150100;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    ll sum;
    ll lazy;//懒标记，注意这里要永久化，不能下放
};

class Edge
{
public:
    ll v,w;
};

class Monster//妖怪
{
public:
    int id,age;
};

bool operator &lt; (Monster A,Monster B)
{
    return A.age&lt;B.age;
}

int n,m,Q,A;
Monster M[maxN];
int edgecnt=0,Head[maxN],Next[maxM];
Edge E[maxM];
int Dis[maxN],Size[maxN],Hson[maxN],Fa[maxN],Top[maxN];
int idcnt=0,Id[maxN];
int nodecnt=0,Root[maxN];
ll Dissum[maxN],Edgesum[maxN];//Dissum是每一个点到根的距离dis的前缀和，而Edgesum则是把一条边下放到它下面的那个点上的前缀和，后面这个是树链剖分要用到的
SegmentData S[maxN*130];

void dfs1(int u,int fa);
void dfs2(int u,int top);//两个树链剖分的dfs
void Build(int &amp;now,int l,int r);
void Modify(int &amp;now,int l,int r,int ql,int qr);//线段树区间修改
ll Query(int n1,int n2,int l,int r,int ql,int qr,ll lazy);//线段树区间查询

int main()
{
    mem(Head,-1);
    scanf("%d%d%d",&amp;n,&amp;Q,&amp;A);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;M[i].age),M[i].id=i;
    sort(&amp;M[1],&amp;M[n+1]);//将妖怪按照年龄排序
    for (int i=1;i&lt;n;i++)//建树
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt]=(Edge){v,w};
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt]=(Edge){u,w};
    }
    Dis[1]=0;//树链剖分初始化
    dfs1(1,0);
    dfs2(1,1);
    for (int i=1;i&lt;=n;i++) Edgesum[i]+=Edgesum[i-1],Dissum[i]=Dissum[i-1]+Dis[M[i].id];//构造前缀和
    Build(Root[0],1,n);//主席树初始化
    for (int i=1;i&lt;=n;i++)
    {
        int u=M[i].id;Root[i]=Root[i-1];
        while (Top[u]!=1) Modify(Root[i],1,n,Id[Top[u]],Id[u]),u=Fa[Top[u]];
        Modify(Root[i],1,n,1,Id[u]);
    }
    ll ans=0;
    while (Q--)//回答询问
    {
        int u,a,b;scanf("%d%d%d",&amp;u,&amp;a,&amp;b);
        int L=(a+ans)%A,R=(b+ans)%A;if (L&gt;R) swap(L,R);
        L=lower_bound(&amp;M[1],&amp;M[n+1],(Monster){0,L})-M;
        R=upper_bound(&amp;M[1],&amp;M[n+1],(Monster){0,R})-M-1;
        ll ret=0,uu=u;
        while (Top[uu]!=1)
            ret=ret+Query(Root[L-1],Root[R],1,n,Id[Top[uu]],Id[uu],0),uu=Fa[Top[uu]];
        ret=ret+Query(Root[L-1],Root[R],1,n,1,Id[uu],0);
        ans=(ll)(R-L+1)*Dis[u]+Dissum[R]-Dissum[L-1]-2*ret;
        printf("%lld\n",ans);
    }
    return 0;
}

void dfs1(int u,int fa)
{
    Size[u]=1;Fa[u]=fa;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (E[i].v!=fa)
        {
            Dis[E[i].v]=Dis[u]+E[i].w;
            dfs1(E[i].v,u);
            Size[u]+=Size[E[i].v];
            if (Size[E[i].v]&gt;Size[Hson[u]]) Hson[u]=E[i].v;
        }
    return;
}

void dfs2(int u,int top)
{
    Id[u]=++idcnt;Top[u]=top;
    Edgesum[idcnt]=Dis[u]-Dis[Fa[u]];
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((E[i].v!=Fa[u])&amp;&amp;(E[i].v!=Hson[u]))
            dfs2(E[i].v,E[i].v);
    return;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    return;
}

void Modify(int &amp;now,int l,int r,int ql,int qr)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].sum+=Edgesum[qr]-Edgesum[ql-1];//更新当前区间
    if ((l==ql)&amp;&amp;(r==qr))//若正好是当前区间，则更新懒标记
    {
        S[now].lazy++;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Modify(S[now].rs,mid+1,r,ql,qr);
    else
    {
        Modify(S[now].ls,l,mid,ql,mid);Modify(S[now].rs,mid+1,r,mid+1,qr);
    }
    return;
}

ll Query(int n1,int n2,int l,int r,int ql,int qr,ll lazy)//注意这里最后一项是一路下来时累加的懒标记
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[n2].sum-S[n1].sum+lazy*(Edgesum[r]-Edgesum[l-1]);
    int mid=(l+r)&gt;&gt;1;
    lazy=lazy+S[n2].lazy-S[n1].lazy;//把这一次的懒标记加上
    if (qr&lt;=mid) return Query(S[n1].ls,S[n2].ls,l,mid,ql,qr,lazy);
    else if (ql&gt;=mid+1) return Query(S[n1].rs,S[n2].rs,mid+1,r,ql,qr,lazy);
    else return Query(S[n1].ls,S[n2].ls,l,mid,ql,mid,lazy)+Query(S[n1].rs,S[n2].rs,mid+1,r,mid+1,qr,lazy);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>447</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 16:05:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 08:05:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4012-luogu3241hnoi2015%e5%bc%80%e5%ba%97%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[228]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2038/Luogu1494][2009国家集训队]小Z的袜子（莫队算法，离线）</title>
		<link>http://sycstudio.com/archives/450</link>
		<pubDate>Sun, 28 Jan 2018 12:55:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=450</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……
具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。
你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2120">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1494">Luogu</a>

<h3>Tag</h3>

莫队算法，离线

<h2>解决思路</h2>

早就想学莫队算法了，今天总算认真学了一次。
先来看看这一道题吧。
考虑区间[l,r],记&#92;(Sum[i]&#92;)表示这个范围内颜色&#92;(i&#92;)的个数。那么这个区间内的答案就是&#92;(\frac{\sum Sum[i]&#42;(Sum[i]-1)}{len&#42;(len-1)}&#92;)，其中&#92;(len&#92;)是区间长。化简一下得到&#92;(\frac{\sum Sum[i]^2-\sum Sum[i]}{len&#42;(len-1)}=\frac{\sum Sum[i]^2-len}{len&#42;(len-1)}&#92;)。那么关键就是求&#92;(Sum[i]^2&#92;)。
考虑按长度&#92;(\sqrt{n}&#92;)分块，若左端点在同一个块内，按右端点排序，否则按左端点排序。然后从前往后移动指针即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))

const int maxN=50010;
const int inf=2147483647;

class Data
{
public:
    int l,r,id;
    ll A,B;
};

int n,m,size;
ll Ans=0;
int Belong[maxN],Color[maxN],Sum[maxN];
Data Q[maxN];

bool cmp1(Data A,Data B);
bool cmp2(Data A,Data B);
void Move(ll pos,ll opt);
ll gcd(ll a,ll b);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);size=sqrt(n);//分块大小
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Color[i]),Belong[i]=(i-1)/size+1;//求出每一个点所属的块
    for (int i=1;i&lt;=m;i++) scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r),Q[i].id=i;
    sort(&amp;Q[1],&amp;Q[m+1],cmp1);
    int l=1,r=0;
    for (int i=1;i&lt;=m;i++)
    {
        //移动指针
        while (l&lt;Q[i].l) Move(l,-1),l++;
        while (l&gt;Q[i].l) Move(l-1,1),l--;
        while (r&lt;Q[i].r) Move(r+1,1),r++;
        while (r&gt;Q[i].r) Move(r,-1),r--;
        Q[i].A=(ll)Ans-(ll)(Q[i].r-Q[i].l+1);
        Q[i].B=(ll)(Q[i].r-Q[i].l+1)*(ll)(Q[i].r-Q[i].l);
    }
    sort(&amp;Q[1],&amp;Q[m+1],cmp2);
    for (int i=1;i&lt;=m;i++)
        if (Q[i].A==0) printf("0/1\n");
        else
        {
            ll g=gcd(Q[i].A,Q[i].B);
            printf("%lld/%lld\n",Q[i].A/g,Q[i].B/g);
        }
    return 0;
}

bool cmp1(Data A,Data B)
{
    if (Belong[A.l]==Belong[B.l]) return A.r&lt;B.r;
    else return A.l&lt;B.l;
}

bool cmp2(Data A,Data B)
{
    return A.id&lt;B.id;
}

void Move(ll pos,ll opt)
{
    Ans-=sqr(Sum[Color[pos]]);
    Sum[Color[pos]]+=opt;
    Ans+=sqr(Sum[Color[pos]]);
}

ll gcd(ll a,ll b)
{
    ll tmp;
    while (b) tmp=a,a=b,b=tmp%b;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>450</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 20:55:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 12:55:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2038-luogu14942009%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e5%b0%8fz%e7%9a%84%e8%a2%9c%e5%ad%90%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%8c%e7%a6%bb%e7%ba%bf%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[188]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1878/Luogu1972][SDOI2009]HH的项链（莫队算法，离线，分块）</title>
		<link>http://sycstudio.com/archives/453</link>
		<pubDate>Sun, 28 Jan 2018 14:42:45 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=453</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

HH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步 完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1878">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1972">Luogu</a>

<h3>Tag</h3>

莫队算法，离线，分块

<h2>解决思路</h2>

类似<a href="">这一题</a>的方法，分块排序后移动端点构造答案

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=200100;
const int maxColor=1000100;
const int inf=2147483647;

class Data
{
public:
    int l,r,id;
    int Ans;
};

int n,m,Ans;
int Belong[maxN];
Data Q[maxM];
int Color[maxN],Sum[maxColor];

bool cmp1(Data A,Data B);
bool cmp2(Data A,Data B);
void Move(int pos,int opt);

int main()
{
    scanf("%d",&amp;n);int size=sqrt(n);//这里块的大小取sqrt(n)为最佳
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Color[i]),Belong[i]=(i-1)/size+1;
    scanf("%d",&amp;m);
    for (int i=1;i&lt;=m;i++) scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r),Q[i].id=i;
    sort(&amp;Q[1],&amp;Q[m+1],cmp1);
    int l=1,r=0;
    for (int i=1;i&lt;=m;i++)
    {
        while (l&lt;Q[i].l) Move(l,-1),l++;
        while (l&gt;Q[i].l) Move(l-1,1),l--;
        while (r&lt;Q[i].r) Move(r+1,1),r++;
        while (r&gt;Q[i].r) Move(r,-1),r--;
        Q[i].Ans=Ans;
    }
    sort(&amp;Q[1],&amp;Q[m+1],cmp2);
    for (int i=1;i&lt;=m;i++) printf("%d\n",Q[i].Ans);
    return 0;
}

bool cmp1(Data A,Data B)
{
    if (Belong[A.l]==Belong[B.l]) return A.r&lt;B.r;
    return A.l&lt;B.l;
}


bool cmp2(Data A,Data B)
{
    return A.id&lt;B.id;
}

void Move(int pos,int opt)
{
    if (Sum[Color[pos]]) Ans--;
    Sum[Color[pos]]+=opt;
    if (Sum[Color[pos]]) Ans++;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>453</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 22:42:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 14:42:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1878-luogu1972sdoi2009hh%e7%9a%84%e9%a1%b9%e9%93%be%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%8c%e7%a6%bb%e7%ba%bf%ef%bc%8c%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[351]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>洛谷P4003 无限之环（infinityloop）（网络流，费用流）by hjt</title>
		<link>http://sycstudio.com/archives/457</link>
		<pubDate>Wed, 31 Jan 2018 11:48:09 +0000</pubDate>
		<dc:creator><![CDATA[flashhu]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=457</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="https://www.luogu.org/problemnew/show/4003">洛谷题目传送门</a>
（题目顺便附在了下方）

<h2>思路分析</h2>

<strong>表示这是一道思维神题</strong>。。。。。。

有人第一眼看上去觉得这要跑费用流吗？

然而只要会建图，剩下的就是套模板的事了。

我们这样来理解。对于每个方格上的水管的每一个支管，有且仅有一个其它方格上的支管与其相连，这样就不会漏水了。用网络流知识表述，就是每个支管<strong>容量只能为1</strong>，且全都要<strong>满流</strong>，于是跑<strong>最小费用可行流</strong>。

然而即使产生了最优情况，整个管网也不一定是一整个联通块，而可能被分成若干块。因此，怎样强制使每两个相邻的方格上都产生流量呢？就要把源汇点连到每个格子上。而且，还要对<strong>每个格点染色</strong>，相邻的两个格点，一个连源点，一个连汇点。具体的实现，就要利用格点<strong>行列坐标和的奇偶性</strong>来判断。

而产生的费用呢？当然是旋转造成的啦！真正的思维就体现在这里了。因为旋转还会造成接触点的变化，所以肯定是要<strong>拆点</strong>的，一个方格拆成五个点，上下左右中。。。。。。中间点连上源/汇点，并根据支管情况向四周连<strong>容量1，费用0</strong>的边。四周视作接触点，与对应相邻的另一个接触点连<strong>容量1，费用0</strong>的边。讨论相邻两个方格格因旋转而产生的有费用的连边，实在是太难了。。。。。。猛然发现，所有的情况，其实只需要在内部进行转化就好了。

所有的方格，我们大致分成以下几类进行讨论。

<h4>第一种：射线型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-3.png" alt="" />

这种好办。射线指向上面，那么就让左、下、右接触点直接连接上接触点。左，右连上去，表示只要转90度，所以<strong>费用为1</strong>。下面连上去<strong>费用为2</strong>。

<h4>第二种：直角型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-4.png" alt="" />

这种理解起来就有难度了。如果顺时针转90度，会变成这样

<img src="http://sycstudio.com/media/Luogu/4003-5.png" alt="" />

相当于原来连上接触点的支管连到了下面，那么上与下建一条<strong>容量为1，费用为1</strong>的边。同样的道理，逆时针转90度，左与右建一条<strong>容量为1，费用为1</strong>的边。再来讨论转180度，这时候，会通过已有的边由左、下直接转移到右、上，费用加起来正好是2，所以不用连更多边了。

<h4>第三种：T字型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-6.png" alt="" />

像前面一样讨论，也可以建边。从下向左、右各建一条<strong>容量为1，费用为1</strong>的边，向上建一条<strong>费用为2</strong>的边。这里就留给读者自己思考啦。

<hr />

以上三种情况，每一种都有4个形状，但连边方法都是一样的。
还有直线型，十字型和空的，要么不能转，要么转了没意义，就不用内部建边了。

下面贴代码

<pre><code class="">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
using namespace std;
#define R register int
#define UP(U) U+turn*sum
#define RI(U) U+((turn+1)&amp;3)*sum
#define DO(U) U+((turn+2)&amp;3)*sum
#define LE(U) U+((turn+3)&amp;3)*sum
#define MD(U) U+(sum&lt;&lt;2)//上面几个用来计算对应点的数组下标，上下左右中。。。
const int INF=2147483647,N=20009,M=200009;
int sum,P=1,S=0,T;//sum方格总数，P建图循环变量，S、T为源汇点
int he[N],ne[M],to[M],f[M],c[M];//f流量，c费用
int q[N],d[N],pre[N];//q队列，d距离，pre记录最短路
bool inq[N];//标记是否在队列中
inline void in(R&amp;z)//快读
{
    register char c=getchar();
    while(c&lt;'-')c=getchar();
    z=c&amp;15;c=getchar();
    while(c&gt;'-')z*=10,z+=c&amp;15,c=getchar();
}
inline void add(R u,R v,R flow,R cost,R tp)//建边，tp表示染色属性
{
    if(tp){tp=u;u=v;v=tp;}//如果是奇数点，所有的边都要反向，要流出去
    to[++P]=v;ne[P]=he[u];he[u]=P;c[P]=cost;f[P]=flow;
    to[++P]=u;ne[P]=he[v];he[v]=P;c[P]=-cost;
}
#define PB(X) q[t]=X;if(++t==N)t=0
#define PF(X) if(--h&lt;0)h=N-1;q[h]=v//手打了一下双向循环队列
inline bool spfa()//模板，加了两种优化
{
    R h=0,t=1,i,u,v,dn,cnt=1,sum=0;
    for(i=S+1;i&lt;=T;++i)d[i]=INF;
    q[0]=S;inq[0]=1;
    while(h!=t)
    {
        u=q[h];
        if(++h==N)h=0;
        if(d[u]*cnt&gt;sum){PB(u);continue;}//LLL优化
        --cnt;sum-=d[u];
        for(i=he[u];i;i=ne[i])
            if(f[i]&amp;&amp;d[v=to[i]]&gt;(dn=d[u]+c[i]))
            {
                if(inq[v])sum-=d[v];
                else
                {
                    inq[v]=1;++cnt;
                    if(d[v]&lt;d[q[h]]){PB(v);}
                    else{PF(v);}//SLF优化
                }
                pre[v]=i;
                sum+=(d[v]=dn);
            }
        inq[u]=0;
    }
    return d[T]!=INF;
}
int main()
{
    R n,m,i,j,k=1,t,shape,turn,totf=0,mf=0,mc=0;//totf总流量，mf最大可行流，mc总费用
    in(n);in(m);
    sum=n*m;T=sum*5+1;
    for(i=0;i&lt;n;++i)
        for(j=0;j&lt;m;++j,++k)
        {
            turn=0;//turn下面会用来翻转，将同类型的水管归类到一起
            t=(i+j)&amp;1;//t是染色属性，只要判断奇偶
            if(t)add(S,MD(k),INF,0,0);
            else add(MD(k),T,INF,0,0);
            if(i)add(DO(k-m),UP(k),1,0,t);
            if(j)add(RI(k-1),LE(k),1,0,t);
            in(shape);
            if(shape&amp;1)add(UP(k),MD(k),1,0,t),++totf;//统计总流量
            if(shape&amp;2)add(RI(k),MD(k),1,0,t),++totf;//因为每个流拆成了两段
            if(shape&amp;4)add(DO(k),MD(k),1,0,t),++totf;//所以最终结果会是实际的两倍
            if(shape&amp;8)add(LE(k),MD(k),1,0,t),++totf;//中点与四周点连边
            switch(shape)
            {
            case 8:++turn;//1000 ←
            case 4:++turn;//0100 ↓
            case 2:++turn;//0010 →
            case 1:       //0001 ↑
                add(RI(k),UP(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(LE(k),UP(k),1,1,t);
                break;//四种形状内部连边情况是一样的，转一下统一处理就方便些了，下面同理
            case 9:++turn; //1001 ┘
            case 12:++turn;//1100 ┐
            case 6:++turn; //0110 ┌
            case 3:        //0011 └
                add(DO(k),UP(k),1,1,t);
                add(LE(k),RI(k),1,1,t);
                break;
            case 13:++turn;//1101 ┤
            case 14:++turn;//1110 ┬
            case 7:++turn; //0111 ├
            case 11:       //1011 ┴
                add(DO(k),LE(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(DO(k),RI(k),1,1,t);
                break;
            }
        }
    while(spfa())
    {
        m=INF;//这里m记下流量
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            if(m&gt;f[k])m=f[k];
        }
        mf+=m;
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            f[k]-=m;f[k^1]+=m;
            mc+=m*c[k];
        }
    }
    printf("%d",totf==mf&lt;&lt;1?mc:-1);//注意如果没能流满就输-1
    return 0;
}
</code></pre>

<h2>附题目</h2>

<h3>题目描述</h3>

曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：
游戏在一个 n ∗ m 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格子某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 15 种形状：
<img src="http://sycstudio.com/media/Luogu/4003-1.png" alt="4003-1" />

游戏开始时，棋盘中水管可能存在漏水的地方。
形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。
玩家可以进行一种操作：选定一个含有<strong>非直线型水管</strong>的方格，将其中的水管绕方格中心顺时针或逆时针旋转 90 度。
直线型水管是指左图里中间一行的两种水管。
现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。

<h3>输入输出格式</h3>

<h4>输入格式：</h4>

第一行两个正整数 n， m，代表网格的大小。
接下来 n 行每行 m 个数，每个数是 [0,15] 中的一个，你可以将其看作一个 4 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。
特别地，如果这个数是 0 ，则意味着这个位置没有水管。
比如 3(0011(2)) 代表上和右有接头，也就是一个 L 型;
而 12(1100(2)) 代表下和左有接头，也就是将 L 型旋转 180 度。

<h4>输出格式：</h4>

输出共一行，表示最少操作次数。如果无法达成目标，输出-1.

<h3>输入输出样例</h3>

<h4>输入样例#1：</h4>

<pre><code class="language-txt ">2 3
3 14 12
3 11 12
</code></pre>

<h4>输出样例#1：</h4>

<pre><code class="language-txt ">2
</code></pre>

<h4>输入样例#2：</h4>

<pre><code class="">3 2
1 8
5 10
2 4
</code></pre>

<h4>输出样例#2：</h4>

<pre><code class="">-1
</code></pre>

<h4>输入样例#3：</h4>

<pre><code class="">3 3
9 11 3
13 15 7
12 14 6
</code></pre>

<h4>输出样例#3：</h4>

<pre><code class="">16
</code></pre>

<h3>说明</h3>

<h4>【样例 1 解释】</h4>

样例 1 棋盘如下
旋转方法很显然，先将左上角虚线方格内的水管顺时针转 90 度
<img src="http://sycstudio.com/media/Luogu/4003-2.png" alt="" />
然后右下角虚线方格内的水管逆时针旋转 90 度，这样就使得水管封闭了

<h4>【样例 2 解释】</h4>

样例 2 为题目描述中的第一张图片，无法达成目标。

<h4>【样例 3 解释】</h4>

样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 180 度即可。

<h3>闲话</h3>

小蒟蒻来SYCstudio.com签下到。。。。。。
对这里清爽的界面风格表示强烈资磁！！！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>457</wp:post_id>
		<wp:post_date><![CDATA[2018-01-31 19:48:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-31 11:48:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b4%9b%e8%b0%b7p4003-%e6%97%a0%e9%99%90%e4%b9%8b%e7%8e%af%ef%bc%88infinityloop%ef%bc%89%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e8%b4%b9%e7%94%a8%e6%b5%81%ef%bc%89-by-flashhu]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[463]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>71</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.31.193]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-31 23:59:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-31 15:59:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[欢迎欢迎。
不过以后发如果有图片的话请联系我在后台把图片加到本站，直接引用外链的话很容易挂掉的，已经人工修复啦！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>73</wp:comment_id>
			<wp:comment_author><![CDATA[flashhu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1258661899@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-01 15:02:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-01 07:02:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好的，感谢！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>71</wp:comment_parent>
			<wp:comment_user_id>11</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[UOJ207]共价大爷游长沙（LCT，随机化）</title>
		<link>http://sycstudio.com/archives/461</link>
		<pubDate>Wed, 31 Jan 2018 15:44:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=461</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

火车司机出秦川，跳蚤国王下江南，共价大爷游长沙。每个周末，勤劳的共价大爷都会开车游历长沙市。
长沙市的交通线路可以抽象成为一个 n 个点 n−1 条边的无向图，点编号为 1 到 n，任意两点间均存在恰好一条路径，显然两个点之间最多也只会有一条边相连。有一个包含一些点对 (x,y) 的可重集合S，共价大爷的旅行路线是这样确定的：每次他会选择 S 中的某一对点 (x,y)，并从 x 出发沿着唯一路径到达 y。
小L是共价大爷的脑残粉，为了见到共价大爷的尊容，小L决定守在这张图的某条边上等待共价大爷的到来。为了保证一定能见到他，显然小L必须选择共价大爷一定会经过的边——也就是所有共价大爷可能选择的路径都经过的边。
现在小L想知道，如果他守在某一条边，是否一定能见到共价大爷。
然而长沙市总是不断的施工，也就是说，可能某个时刻某条边会断开，同时这个时刻一定也有某条新边会出现，且任意时刻图都满足任意两点间均存在恰好一条路径的条件。注意断开的边有可能和加入的新边连接着相同的两个端点。共价大爷的兴趣也会不断变化，所以S也会不断加入新点对或者删除原有的点对。当然，小L也有可能在任何时候向你提出守在某一条边是否一定能见到共价大爷的问题。你能回答小L的所有问题吗？

<h3>Http</h3>

<a href="http://uoj.ac/problem/207">UOJ</a>

<h3>Tag</h3>

LCT，随机化

<h2>解决思路</h2>

<a href="http://blog.csdn.net/dsl_hn_2002">dsl</a>推荐的这道题，写了一晚上。两个人差不多想到了前面的大部分部分分，但仍然不知道到底怎么做。一看题解，真乃神题也。
考虑如果一个边&#92;(x,y&#92;)是共价大爷一定会经过的边，那么把&#92;(x&#92;)作为根，&#92;(S&#92;)中的每一对点中必然有一个出现在&#92;(y&#92;)的子树内。
这个怎么统计呢？总不能&#92;(bitset&#92;)吧。这时候看到随机化的标签，没错，可以给每一对点随机一个权值，求子树的异或和，若&#92;(y&#92;)的子树异或和与全局&#92;(S&#92;)中每一对点权值的异或和相等，那么就很有可能是对的。当权值区间取得&#92;(10^9&#92;)差不多就不会错了。
所以本题的思路是，对每一对点随机一个权值，&#92;(LCT&#92;)维护子树异或和，注意是子树，所以这里关系到虚子树的异或和，另外再记一个虚子树异或和即可，只在改变边的虚实关系的时候修改它。
最后需要注意的是，随机种子最好不要用常用的那些，容易被&#92;(hack&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=400100;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int key;
    int sum;//异或和（包括实虚子树）
    int vsum;//虚子树异或和
};

int n,m;
Splay_Data S[maxN];
int Stack[maxN];
int scnt=0,S1[maxN],S2[maxN],Sxor[maxN];

bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int make(int l,int r);//得到一个l到r区间内的随机数
void Outp();

int main()
{
    srand(141936+141905);
    scanf("%d",&amp;n);scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Link(u,v);
    }
    int xorsum=0;
    for (int i=1;i&lt;=m;i++)
    {
        int type;
        scanf("%d",&amp;type);
        if (type==1)
        {
            int x,y,u,v;scanf("%d%d%d%d",&amp;x,&amp;y,&amp;u,&amp;v);
            Cut(x,y);Link(u,v);
        }
        if (type==2)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            scnt++;S1[scnt]=x;S2[scnt]=y;Sxor[scnt]=make(1,1000000000);
            Makeroot(x);Splay(x);S[x].key^=Sxor[scnt];Update(x);
            Makeroot(y);Splay(y);S[y].key^=Sxor[scnt];Update(y);
            xorsum^=Sxor[scnt];
        }
        if (type==3)
        {
            int id;scanf("%d",&amp;id);
            int x=S1[id],y=S2[id];
            Makeroot(x);Splay(x);S[x].key^=Sxor[id];Update(x);
            Makeroot(y);Splay(y);S[y].key^=Sxor[id];Update(y);
            xorsum^=Sxor[id];
        }
        if (type==4)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            Makeroot(x);Access(y);Splay(y);
            if (S[x].sum==xorsum) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].sum=S[S[x].ch[0]].sum^S[S[x].ch[1]].sum^S[x].key^S[x].vsum;
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);Update(x);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):Rotate(y);
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].vsum^=S[lastx].sum^S[S[x].ch[1]].sum;
        S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);S[y].vsum^=S[x].sum;
    S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;Update(x);Update(y);
    return;
}

int make(int l,int r)
{
    double dou=1.0*rand()/RAND_MAX;
    return dou*(r-l+1)+l;
}

void Outp()
{
    printf("id fa ls rs       key        sum        vsum\n");
    for (int i=0;i&lt;=n;i++) printf("%2d%3d%3d%3d%10d%11d%12d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].key,S[i].sum,S[i].vsum);
    cout&lt;&lt;endl;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>461</wp:post_id>
		<wp:post_date><![CDATA[2018-01-31 23:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-31 15:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[uoj207%e5%85%b1%e4%bb%b7%e5%a4%a7%e7%88%b7%e6%b8%b8%e9%95%bf%e6%b2%99%ef%bc%88lct%ef%bc%8c%e9%9a%8f%e6%9c%ba%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="post_tag" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[247]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>72</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-01 14:16:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-01 06:16:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个种子很不错]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ1076/Luogu2743][SCOI2008]奖励关（动态规划，状态压缩）</title>
		<link>http://sycstudio.com/archives/465</link>
		<pubDate>Thu, 01 Feb 2018 07:37:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=465</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物，每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过一次，才能吃第i种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，Pi可以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。 假设你采取最优策略，平均情况你一共能在奖励关得到多少分值？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1076">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2473">Luogu</a>

<h3>Tag</h3>

动态规划，状态压缩

<h2>解决思路</h2>

一般而言，对于这种状态压缩动态规划都是设&#92;(F[i][S]&#92;)表示当前再第几次，当前选择过的宝物集合为&#92;(S&#92;)。枚举当前这一轮出来的宝物是哪一个，如果这个宝物要求的宝物都已经出现过了，那么就可以从选这个宝物和不选这个宝物两个地方转移过来，否则就只能从不选转移过来。
但是这么转移有问题，关键是不知道最终哪些状态是有用的哪些是没用的。那么我们可以倒着转移，从最后一个向前面转移，那么答案就在&#92;(F[1][0]&#92;)里面。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=15;
const int maxK=120;
const int inf=2147483647;

int n,K;
int P[maxN];
int Rely[maxN];//一个宝物要依赖于哪些宝物
ld F[maxK][(1&lt;&lt;maxN)+10];

int main()
{
    scanf("%d%d",&amp;K,&amp;n);
    for (int i=0;i&lt;n;i++)
    {
        scanf("%d",&amp;P[i]);
        int k;scanf("%d",&amp;k);
        while (k!=0)
        {
            Rely[i]|=1&lt;&lt;(k-1);
            scanf("%d",&amp;k);
        }
    }
    for (int i=K;i&gt;=1;i--)
        for (int j=0;j&lt;(1&lt;&lt;(n+1));j++)
        {
            for (int k=0;k&lt;n;k++)
                if ((j&amp;Rely[k])==Rely[k])
                    F[i][j]+=max(F[i+1][j],F[i+1][j|(1&lt;&lt;k)]+P[k]);
                else F[i][j]+=F[i+1][j];
            F[i][j]=F[i][j]/(ld)n;
        }
    printf("%.6LF\n",F[1][0]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>465</wp:post_id>
		<wp:post_date><![CDATA[2018-02-01 15:37:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-01 07:37:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1076-luogu2743scoi2008%e5%a5%96%e5%8a%b1%e5%85%b3%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[242]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>93</wp:comment_id>
			<wp:comment_author><![CDATA[xzy]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[347605798@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-09 17:25:47]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-09 09:25:47]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主我想了一下午，还是不知道为什么正着DP是错的。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>94</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.28.150]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-09 21:15:40]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-09 13:15:40]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个嘛，主要是在中间转移的时候不知道哪些状态是可以用于转移的。因为有一些宝物的得分是负数，所以中间转移出来有可能是0，这样就不知道哪些是可以转移或不可以转移的了。或许你可以试试再记一个bool数组表示该状态是否是可以用于转移的。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>93</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ3675/Luogu3648][Apio2014]序列分割（动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/466</link>
		<pubDate>Thu, 01 Feb 2018 11:16:42 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=466</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小H最近迷上了一个分隔序列的游戏。在这个游戏里，小H需要将一个长度为n的非负整数序列分割成k+1个非空的子序列。为了得到k+1个子序列，小H需要重复k次以下的步骤：
1.小H首先选择一个长度超过1的序列（一开始小H只有一个长度为n的序列——也就是一开始得到的整个序列）；
2.选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列。
每次进行上述步骤之后，小H将会得到一定的分数。这个分数为两个新序列中元素和的乘积。小H希望选择一种最佳的分割方式，使得k轮之后，小H的总得分最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3675">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3648">Luogu</a>

<h3>Tag</h3>

动态规划，斜率优化，单调队列

<h2>解决思路</h2>

首先需要知道的是，如果分割的位置是一定的，那么最后的和也是一定的。
比如说&#92;(ab|cd|e&#92;)，先分割前面和先分割后面是一样的，推广一下，分割成&#92;(K&#92;)个块的答案就是把每一个块求和再两两乘起来求和。
那么考虑&#92;(DP&#92;)，设&#92;(F[i][k]&#92;)表示前&#92;(i&#92;)个数分割&#92;(k&#92;)次最大的得分，那么枚举一个小于&#92;(i&#92;)的&#92;(j&#92;)就有
&#92;[F[i][k]=max(F[j][k]+Sum[j]&#42;(Sum[i]-Sum[j])&#92;]
其中&#92;(Sum[i]&#92;)是前&#92;(i&#92;)个数的前缀和。
这样的复杂度是&#92;(O(n^2k)&#92;)的。考虑斜率优化消去一维。
设&#92;(j&#95;1 &lt; j&#95;2&#92;)，并且&#92;(j&#95;2&#92;)的答案更优，那么有
&#92;[F[j&#95;1][k-1]+Sum[j&#95;1]&#42;Sum[i]-Sum[j&#95;1]^2 &lt; F[j&#95;2][k-1]-Sum[j&#95;2]&#42;Sum[i]-Sum[j&#95;2]^2&#92;]
&#92;[F[j&#95;1][k-1]-Sum[j&#95;1]^2-F[j&#95;2][k-1]+Sum[j&#95;2]^2 &lt; Sum[i]&#42;(Sum[j&#95;2]-Sum[j&#95;1])&#92;]
那么这样就可以用单调队列维护了。注意，因为数是非负整数，所以&#92;(Sum[j&#95;2]-Sum[j&#95;1]&#92;)可能是0，不能除过去。
&#92;(Luogu&#92;)需要输出方案，那么在转移的时候再记录一下从哪里分割转移过来即可。

<h2>代码</h2>

&#92;(BZOJ&#92;)

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))
#define Y(k,j1,j2) (F[j1][k&amp;1]-sqr(Sum[j1])-F[j2][k&amp;1]+sqr(Sum[j2]))
#define X(j1,j2) (Sum[j2]-Sum[j1])

const int maxN=100010;
const int maxK=210;
const int inf=2147483647;

int n,K;
ll Arr[maxN],Queue[maxN];
ll Sum[maxN];
ll F[maxN][2];

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Arr[i]);
    for (int i=1;i&lt;=n;i++) Sum[i]=Sum[i-1]+(ll)Arr[i];
    for (int j=1;j&lt;=K;j++)
    {
        int now=j&amp;1;
        int l=1,r=0;
        for (int i=1;i&lt;=n;i++)
        {
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[l],Queue[l+1])&lt;=Sum[i]*X(Queue[l],Queue[l+1]))) l++;//弹出队首
            F[i][now]=F[Queue[l]][now^1]+Sum[Queue[l]]*Sum[i]-sqr(Sum[Queue[l]]);
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[r-1],Queue[r])*X(Queue[r],i)&gt;=Y(j-1,Queue[r],i)*X(Queue[r-1],Queue[r]))) r--;//弹出队尾
            Queue[++r]=i;
        }
    }
    printf("%lld\n",F[n][K&amp;1]);
    return 0;
}
</code></pre>

&#92;(Luogu&#92;)

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))
#define Y(k,j1,j2) (F[j1][k&amp;1]-sqr(Sum[j1])-F[j2][k&amp;1]+sqr(Sum[j2]))
#define X(j1,j2) (Sum[j2]-Sum[j1])

const int maxN=100010;
const int maxK=210;
const int inf=2147483647;

int n,K;
ll Arr[maxN],Queue[maxN];
ll Sum[maxN];
ll F[maxN][2];
int Path[maxN][maxK];//记录方案

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Arr[i]);
    for (int i=1;i&lt;=n;i++) Sum[i]=Sum[i-1]+(ll)Arr[i];
    for (int j=1;j&lt;=K;j++)
    {
        int now=j&amp;1;
        int l=1,r=0;
        for (int i=1;i&lt;=n;i++)
        {
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[l],Queue[l+1])&lt;=Sum[i]*X(Queue[l],Queue[l+1]))) l++;
            F[i][now]=F[Queue[l]][now^1]+Sum[Queue[l]]*Sum[i]-sqr(Sum[Queue[l]]);
            Path[i][j]=Queue[l];//记录一下是分割哪里转移过来的
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[r-1],Queue[r])*X(Queue[r],i)&gt;=Y(j-1,Queue[r],i)*X(Queue[r-1],Queue[r]))) r--;
            Queue[++r]=i;
        }
    }
    printf("%lld\n",F[n][K&amp;1]);
    int now=n;
    for (int i=K;i&gt;=1;i--)//输出分割方案
    {
        printf("%d ",Path[now][i]);
        now=Path[now][i];
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>466</wp:post_id>
		<wp:post_date><![CDATA[2018-02-01 19:16:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-01 11:16:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3675-luogu3648apio2014%e5%ba%8f%e5%88%97%e5%88%86%e5%89%b2%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[208]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4518/Luogu4072][Sdoi2016]征途（动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/467</link>
		<pubDate>Fri, 02 Feb 2018 12:49:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=467</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Pine开始了从S地到T地的征途。
从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。
Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。
Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。
帮助Pine求出最小方差是多少。
设方差是v，可以证明，v×m^2是一个整数。为了避免精度误差，输出结果时输出v×m^2。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4518">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4072">Luogu</a>

<h3>Tag</h3>

动态规划，斜率优化

<h2>解决思路</h2>

先考虑答案是怎么算的，设&#92;(Sum[i]&#92;)表示前&#92;&#40;i&#92;)段路的前缀和。
&#92;[Ans=m^2&#42;\frac{\sum&#95;{i=1}^{m} (x&#95;i- \bar x)^2}{m} &#92;&#92; = m&#42;(\sum&#95;{i=1}^{m} x&#95;{i}^{2}+m&#42; {\bar x}^2-2&#42;\sum&#95;{i=1}^{m} x&#95;i &#42; \bar x) &#92;&#92; =m&#42;\sum&#95;{i=1}^{m} x&#95;{i}^2+Sum[n]^2-2&#42;Sum[i]^2 &#92;&#92; = m&#95;{i=1}^{m} x&#95;{i}^2-Sum[n]^2&#92;]
那么这个式子就只与前面&#92;(X&#95;{i}^2&#92;)这一项有关了，把这一项拿出来单独考虑。
设&#40;F[i][j]&#41;表示前&#92;(j&#92;)个数分成&#92;(i&#92;)组使得上面那个&#92;(X&#95;{i}^2&#92;)和最小，那么有下面的朴素转移方程
&#92;[F[i][j]=min(F[i-1][k]+(Sum[j]-Sum[j])^2)&#92;]
设&#92;(j1 &lt; j2&#92;)，且j2的答案更优，那么有
&#92;[F[i-1][j1]+(Sum[i]-Sum[j1])^2 &gt; F[i-1][j2]+(Sum[i]-Sum[j2])^2 &#92;&#92; F[i-1][j1]+Sum[j1]^2-F[i-1][j2]-Sum[j2]^2 &gt; 2&#42;Sum[i]&#42;(Sum[j1]-Sum[j2])&#92;]
这样就可以斜率优化了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*(x))
#define Y(k,j1,j2) ((ll)F[k][j1]-(ll)F[k][j2]+(ll)sqr(Sum[j1])-(ll)sqr(Sum[j2]))
#define X(j1,j2) ((ll)Sum[j1]-(ll)Sum[j2])

const int maxN=3010;
const int inf=2147483647;

ll n,m;
ll Length[maxN],Sum[maxN],Queue[maxN];
ll F[maxN][maxN];

int main()
{
    scanf("%lld%lld",&amp;n,&amp;m);mem(F,63);F[0][0]=0;
    for (ll i=1;i&lt;=n;i++) scanf("%lld",&amp;Length[i]),Sum[i]=Sum[i-1]+Length[i];
    for (ll i=1;i&lt;=m;i++)
    {
        ll l=0,r=0;
        for (ll j=1;j&lt;=n;j++)
        {
            while ((l&lt;r)&amp;&amp;(Y(i-1,Queue[l],Queue[l+1])&gt;2*Sum[j]*X(Queue[l],Queue[l+1]))) l++;
            F[i][j]=F[i-1][Queue[l]]+sqr(Sum[j]-Sum[Queue[l]]);
            while ((l&lt;r)&amp;&amp;(Y(i-1,Queue[r-1],Queue[r])*X(Queue[r],j)&gt;Y(i-1,Queue[r],j)*X(Queue[r-1],Queue[r]))) r--;
            Queue[++r]=j;
        }
    }
    printf("%lld\n",(ll)m*F[m][n]-sqr(Sum[n]));
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>467</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:49:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:49:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4518-luogu4072sdoi2016%e5%be%81%e9%80%94%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[198]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>回文树总结 by dsl</title>
		<link>http://sycstudio.com/archives/470</link>
		<pubDate>Fri, 02 Feb 2018 13:18:11 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=470</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>回文树总结</h1>

<h2>引入</h2>

对于一般的字符串问题，我们拥有处理它们的强大工具——后缀数组，后缀树，后缀自动机。
但对于一类特殊的关于回文串的字符串问题，我们也有一种强大的工具——回文树（由Mikhail Rubinchik发明，在Petrozavodsk Summer Camp 2014上首次提出来）。

<h2>回文树</h2>

安利我的博客<a href="http://blog.csdn.net/dsl_hn_2002/article/details/79175596" title="「学习笔记」回文树/回文自动机(Palindromic Tree)">「学习笔记」回文树/回文自动机(Palindromic Tree)</a>
和一篇论文国家集训队2017论文集《回文树及其应用》——翁文涛。

<h2>例题</h2>

<h3>A.[BZOJ2565]最长双回文串</h3>

<h4>Description</h4>

顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为“abc”，逆序为“cba”，不相同）。
输入长度为n的串S，求S的最长双回文子串T,即可将T分为两部分X，Y，（|X|,|Y|≥1）且X和Y都是回文串。

2≤|S|≤10^5

<h4>Solution</h4>

正反建两个回文树，同时计算出&#92;(s_{1..i}&#92;)的最长回文后缀和&#92;(s_{i+1..|s|}&#92;)的最长回文前缀。
取和的&#92;(max&#92;)即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
char s1[maxn], s2[maxn];
int n, len1[maxn], len2[maxn], ans;

struct Palindromic_Tree 
{
    int ch[maxn][26], tot, len[maxn], fail[maxn], last;

    Palindromic_Tree() 
    {
        len[tot = 1] = -1; fail[0] = fail[1] = 1;
    }

    int insert(int c, int n, char* s)
    {
        int x = last;
        while(s[n - len[x] - 1] != s[n]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[n - len[k] - 1] != s[n]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
        }
        last = ch[x][c];
        return len[ch[x][c]];
    }
}t1, t2;

int main()
{
    scanf("%s", s1 + 1);
    n = strlen(s1 + 1);
    for(int i = 1; i &lt;= n; ++i) s2[i] = s1[n - i + 1];

    for(int i = 1; i &lt;= n; ++i) 
        len1[i] = t1.insert(s1[i] - 'a', i, s1), len2[n - i + 1] = t2.insert(s2[i] - 'a', i, s2);
    for(int i = 1; i &lt; n; ++i) 
        ans = max(ans, len1[i] + len2[i + 1]);

    printf("%d\n", ans);

    return 0;
}
</code></pre>

<h3>B.[SHOI2011]双倍回文</h3>

<h3>Description</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2342" title="题面">题面</a>

<h3>Solution</h3>

直接构造出回文树,然后在&#92;(fail&#92;)树上dfs。一个回文串是双倍回文串的条件是长度是4且父亲中有长度为其一半的回文串即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 500005;
struct edge {
    int to, next;
}e[maxn * 2];
int n, h[maxn], cnt;
char s[maxn];

int ch[maxn][26], len[maxn], tot, fail[maxn], last, ans;

inline void link(int u, int v)
{
    e[++cnt] = (edge) {v, h[u]}; h[u] = cnt;
}

void add(int c, int n)
{
    int x = last;
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; ch[x][c] = v; len[v] = len[x] + 2;
        link(fail[v], v);
    }
    last = ch[x][c];
}

int vis[maxn];
void dfs(int u)
{
    if(len[u] % 4 == 0 &amp;&amp; vis[len[u] / 2]) ans = max(ans, len[u]);
    ++vis[len[u]];
    for(int i = h[u]; i; i = e[i].next) dfs(e[i].to);
    --vis[len[u]];
}

int main()
{
    scanf("%d", &amp;n);
    scanf("%s", s + 1);

    len[tot = 1] = -1; fail[0] = fail[1] = 1; link(1, 0);
    for(int i = 1; i &lt;= n; ++i)
        add(s[i] - 'a', i);

    dfs(1);
    printf("%d\n", ans);

    return 0;
}

</code></pre>

<h3>C.<a href="http://sycstudio.com/archives/443" title="[51nod]Clarke and string">[51nod]Clarke and string</a></h3>

<h3>D.[省队集训2013day7T1]str</h3>

<h4>Description</h4>

求一个串第&#92;(k&#92;)小的回文子串。

字符串比较方式如下(与一般的比较方式不完全相同)

<pre><code class="language-cpp ">int cmp(string a, string b)
{
    if (len(a) != len(b))
        return len(a) &lt; len(b);
    else
    {
        int i;
        for (i = 0; i &lt; len(a); ++i)
            if(a[i] != b[i])
                return a[i] &lt; b[i];
        return 0;
    }
}
</code></pre>

&#92;(|s|\leqslant 10^5&#92;)

<h4>Solution</h4>

方法1:

字符串比较的方式为先比较长度，然后比较字符。所以可以直接在回文树上bfs。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int n, k; long long p;
char s[maxn];

int ch[maxn][26], len[maxn], fail[maxn], v[maxn], last, tot;
pair&lt;int, int&gt; fa[maxn];

inline void add(int c, int n)
{
    int x = last;   
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v; fa[v] = make_pair(c, x);
    }
    ++v[last = ch[x][c]];
}

inline void print(int c, int u, int k)
{
    int cnt = 0; s[++cnt] = c + 'a';
    while(fa[u].second &gt; 1) {
        u = fa[u].second;
        s[++cnt] = fa[u].first + 'a';
    }   
    for(int i = 1; i &lt;= cnt; ++i) putchar(s[i]); 
    for(int i = cnt - k; i &gt;= 1; --i) putchar(s[i]);
}

int que1[maxn], que2[maxn];
inline void bfs()
{
    register int l1 = 0, l2 = 0, r1 = 1, r2 = 1, u;
    que1[r1] = 1; que2[r2] = 0;
    do {
        if(l1 &lt; r1) {
            int l = l1 + 1, r = r1;
            for(int j = 0; j &lt; 26; ++j)
                for(int i = l; i &lt;= r; ++i)
                    if(ch[u = que1[i]][j]) {
                        if(k &lt;= 1) {print(j, ch[u][j], 1); return ;}
                        --k; que1[++r1] = ch[u][j];
                    }
            l1 = r;
        }
        if(l2 &lt; r2) {
            int l = l2 + 1, r = r2;
            for(int j = 0; j &lt; 26; ++j)
                for(int i = l; i &lt;= r; ++i)
                    if(ch[u = que2[i]][j]) {
                        if(k &lt;= 1) {print(j, ch[u][j], 0); return ;}
                        --k; que2[++r2] = ch[u][j];
                    }
            l2 = r;
        }
    }while(k);
}

int main()
{
    freopen("str.in", "r", stdin);
    freopen("str.out", "w", stdout);

    scanf("%d%lld\n%s", &amp;n, &amp;p, s + 1); 
    len[tot = 1] = -1; fail[0] = fail[1] = 1;
    for(int i = 1; i &lt;= n; ++i) add(s[i] - 'a', i);
    printf("%d\n", tot - 1);
    k = p % (tot - 1) + 1;
    bfs();

    return 0;
}
</code></pre>

方法2(std):
<img src="http://sycstudio.com/wp-content/uploads/2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png" alt="Markdown" />

<pre><code class="language-cpp ">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
#include&lt;functional&gt;
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)&lt;=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=500000+10;
const int INF=1000000000;
const int Alpha=28;

int n;
LL k;
char str[MAX],a[MAX];

struct Node
{
    Node* ch[Alpha];
    Node* ne[Alpha];
    Node* p;
    int len;
    int maxs;
    int place;
    int help_for_dfs;
    Node()
    {
        memset(ch,0,sizeof ch);
        memset(ne,0,sizeof ne);
        p=0;
        len=0;
        maxs=0;
        help_for_dfs=-1;
    }
}tree[MAX*2],*Root,*place[MAX];
int cnt;

Node* add(Node* v,int id,int len)
{
    Node* u=tree+cnt++;
    u-&gt;len=len;
    for(;v &amp;&amp; !v-&gt;ch[id];v=v-&gt;p)
        v-&gt;ch[id]=u;
    if(!v)
        u-&gt;p=Root;
    else
    {
        Node* bro=v-&gt;ch[id];
        if(v-&gt;len+1==bro-&gt;len)
            u-&gt;p=bro;
        else
        {
            Node* nv=tree+cnt++;
            *nv=*bro;
            nv-&gt;len=v-&gt;len+1;
            u-&gt;p=nv;
            bro-&gt;p=nv;
            for(;v &amp;&amp; v-&gt;ch[id]==bro;v=v-&gt;p)
                v-&gt;ch[id]=nv;
        }
    }
    return u;
}

int maxs[MAX];
int num[MAX];

int cmp(int a,int b)
{
    return tree[a].len&gt;tree[b].len;
}

int toAdd[MAX];
LL ans[MAX];

int pa[MAX],num_pa;

void dfs(Node* S)
{
    Node* u=S;
    while(1)
    {
        int&amp; i=u-&gt;help_for_dfs;
        if(u-&gt;place==u-&gt;len &amp;&amp; u-&gt;len%2==0 &amp;&amp; i==-1)
            pa[++num_pa]=u-&gt;place;
        for(++i;i&lt;Alpha;++i)
            if(u-&gt;ne[i])
            {
                pa[++num_pa]=-u-&gt;len;
                u=u-&gt;ne[i];
                break;
            }
        if(i==Alpha)
        {
            if(u==S)
                break;
            u=u-&gt;p;
        }
    }
}

int getL(int a,int b)
{
    int dif=b/2-(a-1)/2;
    if(str[b]=='z'+1)//a到b中有多少奇数 b中的奇数个数是(b+1)/2
        return dif*2;
    else return dif*2-1;
}

int main()
{
    freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
    int i;
    scanf("%d",&amp;n);
    cin&gt;&gt;k;
    scanf("%s",a+1);
    int tmp=0;
    str[++tmp]='z'+1;
    REP(i,1,n)
    {
        str[++tmp]=a[i];
        str[++tmp]='z'+1;
    }
    str[tmp+1]='z'+2;
    n=tmp;
    Node* last=place[0]=Root=tree+cnt++;
    REP(i,1,n)
    {
        place[i]=last=add(last,str[i]-'a',i);
        place[i]-&gt;place=i;
    }
    int mm=1;
    maxs[1]=0;
    REP(i,1,n)
    {
        if(i&lt;=mm+maxs[mm])
            maxs[i]=min( maxs[2*mm-i] , mm+maxs[mm]-i ) ;
        for(;str[i-maxs[i]-1]==str[i+maxs[i]+1];++maxs[i])
            ;
        if(i+maxs[i]&gt;mm+maxs[mm])
            mm=i;
        place[i]-&gt;maxs=maxs[i];
    }
    REP2(i,0,cnt)
        num[i]=i;
    sort(num,num+cnt,cmp);
    REP2(i,0,cnt)
    {
        Node* u=tree+num[i];
        if(u-&gt;p)
        {
            u-&gt;p-&gt;maxs=max(u-&gt;p-&gt;maxs,u-&gt;maxs);
            if(!u-&gt;p-&gt;place)
                u-&gt;p-&gt;place=u-&gt;place;
            u-&gt;p-&gt;ne[ str[ u-&gt;place-u-&gt;p-&gt;len ] - 'a']=u;
            int l=u-&gt;p-&gt;len+1;
            int r=min(u-&gt;len,u-&gt;maxs+1);
            l=getL(u-&gt;place-l+1,u-&gt;place);
            r=getL(u-&gt;place-r+1,u-&gt;place);
            if(r&gt;=l)
            {
                toAdd[l]++;
                toAdd[r+2]--;
            }
        }
    }
    LL sum=0;
    LL now=0,all=1;
    for(i=1;i&lt;=n;i+=2)
    {
        sum+=toAdd[i];
        ans[i]=sum;
        all+=ans[i];
    }
    sum=0;
    for(i=0;i&lt;=n;i+=2)
    {
        sum+=toAdd[i];
        ans[i]=sum;
        all+=ans[i];
    }
    all-=2;
    k=k%all+1;
    cout&lt;&lt;all&lt;&lt;endl;
    now=0;
    int anslen=0;
    REP(i,1,n)
    {
        if(now&lt;k &amp;&amp; now+ans[i]&gt;=k)
        {
            k-=now;
            anslen=i;
            break;
        }
        now+=ans[i];
    }
    dfs(Root);
    int height=0;
    REP(i,1,num_pa)
    {
        int c=pa[i];
        if(c&lt;=0)
        {
            height=min(height,(-c+1)/2);
            continue;
        }
        int u=pa[i];
        if(u-anslen+1&gt;=1 &amp;&amp; maxs[u-anslen+1]+1&gt;=anslen &amp;&amp; height&lt;anslen)//这儿目测还有问题。。。
        {
            --k;
            if(!k)
            {
                for(int j=u;anslen;j-=2,anslen--)
                    cout&lt;&lt;str[j];
                cout&lt;&lt;endl;
                break;
            }
            height=INF;
        }
    }
    return 0;
}
</code></pre>

从这道题我们可以看出回文树在处理回文串的优越性。

<h3>E.[省队集训2015day1T1]字符串合成</h3>

<h4>Description</h4>

给定四种对字符串 S 的操作:
(1) push_back( P ):在 S 后连接一个字符串 P,即 S = S + P,代价为| P |;
(2) push_front( P ):在 S 前连接一个字符串 P,即 S = P + S,代价为| P |;
(3) symmetry_back( ):将 S 翻转后连接在 S 之后,即 S = S + rev(S),代价为 1;
(4) symmetry_front( ):将 S 翻转后连接在 S 之前,即 S = rev(S) + S,代价为 1;
给定一个目标串 S,要求你通过上述四种操作,用最少的代价合成出目标串。初始只有一个空串。

<h4>Solution</h4>

观察可以发现三个性质：

<ol>
<li>每次合成最终的串的方法一定是先合成一个回文串，然后两边的字符暴力添加。</li>
<li>一个偶数长度的回文串的合成方法一定是先合成一半的串，然后翻转。</li>
<li>合成一个偶数长度的回文串的左半边与右半边的步数相同。</li>
</ol>

考虑在回文树上DP，设&#92;(f(s)&#92;)为在合成回文串&#92;(s&#92;)的最小代价。
同时在回文树求出&#92;(fail_s&#92;)(&#92;(s&#92;)的最长回文前缀(后缀))，&#92;(fa_s&#92;)(&#92;(s&#92;)在回文树上的父亲，&#92;(half_s&#92;)(不超过s长度一半的最长回文前缀)。

<ul>
<li>如果&#92;(s&#92;)为奇数长度的回文串，则&#92;(f_s=min(f_{fa_s}+2,f_{fail_s}+|s|-|fail_s|&#92;)。因为&#92;(s&#92;)长度为奇数，所以不可能由翻转得出，只可能由首尾加字符得来。</li>
<li>如果&#92;(s&#92;)为偶数唱的回文串，则合成&#92;(s&#92;)的最后一步一定是翻转。而&#92;(s&#92;)的一半却不一定是回文串。所以考虑把转移合并。若翻转前在串首增加了字符，则&#92;(f_s=f_{fa_s}+1&#92;)表示&#92;(s_fa&#92;)在最后一步翻转前在首部增加了字符。若翻转加倍前未在尾部增加了字符则&#92;(f_s=f_{s_{half}}+\frac{s_{len}}{2}&#92;)表示先合成&#92;(s_{half}&#92;)然后在尾部添加字符合成&#92;(s&#92;)的一半。最后翻转加倍。</li>
</ul>

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int m, ans;
char s[maxn];

int ch[maxn][26], fail[maxn], len[maxn], half[maxn], fa[maxn], tot, last;
int f[maxn];

void add(int c, int n)
{
    int x = last;
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        memset(ch[v], 0, sizeof(ch[v]));
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; fa[v] = x;
        if((len[k = half[x]] + 2) * 2 &gt; len[v]) k = fail[k];
        while(s[n - len[k] - 1] != s[n]) k = fail[k]; if(ch[k][c]) k = ch[k][c];
        half[v] = k; ch[x][c] = v; 
        if(len[v] &amp; 1) f[v] = min(f[fa[v]] + 2, f[fail[v]] + len[v] - len[fail[v]]);
        else if(fa[v]) f[v] = min(f[fa[v]] + 1, f[half[v]] + len[v] / 2 - len[half[v]] + 1);
        else f[v] = 2;
        ans = min(ans, m - len[v] + f[v]); 
    }
    last = ch[x][c];
}

int main()
{
    freopen("synthesis.in", "r", stdin);
    freopen("synthesis.out", "w", stdout);

    int T; scanf("%d", &amp;T);
    while(T--) {
        scanf("%s\n", s + 1); ans = m = strlen(s + 1);
        memset(ch[0], 0, sizeof(ch[0])); memset(ch[1], 0, sizeof(ch[1]));
        len[tot = 1] = -1; fail[0] = fail[1] = half[0] = half[1] = 1; last = 1;
        for(int i = 1; i &lt;= m; ++i) add(s[i] - 'a', i);
        printf("%d\n", ans);
    }

    return 0;
}
</code></pre>

<h3>F.[省队集训2015day1T1]月宫的符卡序列</h3>

<h4>Description</h4>

<img src="http://sycstudio.com/wp-content/uploads/2018/02/6b76c88e1cb3223fed264246defc621f.png" alt="题意" title="题意" />

<h4>Solution</h4>

这道题我的做法是用Manacher建出一个类似回文树的东西。
对这个串进行Manacher的预处理，使得每个回文串的长度都为奇数。
现在考虑建出这棵回文树(明显，所有回文串都位于odd节点下方)
对于每个位置&#92;(i&#92;)，它对每个以它为中心的回文串贡献为&#92;(i&#92;)。设其最远的回文串延伸了&#92;(f_i&#92;),则相当于给串&#92;(s_{[i-f_i+1,i+f_i-1]}&#92;)到根异或上了i。
现在的问题是怎么建出这棵回文树：
在Manacher的算法过程中，设当前中心为i，当前节点为x，如果&#92;(s_{i-f_i}=s_{i+f_i}&#92;)，那么&#92;(x'=x→s_{i+f_i}&#92;),这样算法结束，这棵树也就建出来了。
至于每个位置在串中的位置的求法，可以自己yy或者看下代码。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 2000005;
int n;
char s[maxn];

int f[maxn], pos[maxn], ch[maxn][27], g[maxn][22], val[maxn], tot;

inline int getfa(int u, int dis)
{
    for(int i = 0; i &lt;= 20; ++i)
        if(dis &amp; (1 &lt;&lt; i)) u = g[u][i];
    return u;
}

inline int next(int u, int c)
{
    if(ch[u][c]) return ch[u][c];
    ch[u][c] = ++tot;
    memset(ch[tot], 0, sizeof(ch[tot]));
    val[tot] = 0; g[tot][0] = u;
    for(int i = 1; (1 &lt;&lt; i) &lt;= n; ++i)
        g[tot][i] = g[g[tot][i - 1]][i - 1];
    return tot;
}

int main()
{
    freopen("A.in", "r", stdin);
    freopen("A.out", "w", stdout);

    int T; scanf("%d\n", &amp;T);
    memset(s, -1, sizeof(s));
    while(T--) {
        s[n = 0] = 'a' + 26; char c = getchar();
        while('a' &lt;= c &amp;&amp; c &lt;= 'z') {
            s[++n] = c; s[++n] = 'a' + 26; c = getchar();
        }
        tot = 1; val[1] = 0;memset(ch[1], 0, sizeof(ch[1]));
        for(int i = 0, k = 0; i &lt;= n; ++i) {
            if(i == 68)
                i = 68;
            if(k + f[k] - 1 &gt;= i) {
                if(i + f[k - (i - k)] &lt;= k + f[k]) f[i] = f[k - (i - k)], pos[i] = pos[k - (i - k)];
                else f[i] = f[k] + k - i, pos[i] = getfa(pos[k - (i - k)], f[k - (i - k)] - f[i]);
            }else f[i] = 1, pos[i] = next(1, s[i] - 'a');
            while(i - f[i] &gt;= 0 &amp;&amp; i + f[i] &lt;= n &amp;&amp; s[i - f[i]] == s[i + f[i]]) 
                pos[i] = next(pos[i], s[i - f[i]] - 'a'), ++f[i];
            val[pos[i]] ^= (i - 1) / 2;
            if(i + f[i] &gt; k + f[k]) k = i;
        }
        int ans = 0;
        for(int i = tot; i &gt;= 2; --i) {
            if(i != ch[1][26]) ans = max(ans, val[i]);
            val[g[i][0]] ^= val[i];
        }
        printf("%d\n", ans);
    }
    return 0;
}
</code></pre>

这个是laofu的做法：
先建出回文树并求出&#92;(s_{1..i}&#92;)的最长回文后缀，然后跑Manacher，在Manacher的过程中求出f数组，然后暴跳&#92;(i+f_i&#92;)最长回文后缀的fail，直到len等于f_i为止。

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
#define inf 2147483647
#define fre(z) freopen(z".in","r",stdin),freopen(z".out","w",stdout)
#define my int
#define d "%d"
#define md double
using namespace std;
const int N=2e6+100;
int getint();
int n,n2;
char s[N];
int next[N][26],fail[N],len[N],sum[N],ans,tot,last,id[N],p[N];
inline int get_fail(int p,int n) {
    while (s[n]!=s[n-len[p]-1]) p=fail[p];
    return p;
}
inline void add(int c,int n) {
    int p=get_fail(last,n);
    if (!next[p][c]) {
        len[++tot]=len[p]+2;memset(next[tot],0,sizeof(next[tot]));sum[tot]=0;
        fail[tot]=next[get_fail(fail[p],n)][c];
        next[p][c]=tot;
    }
    last=next[p][c];
}
inline void work() {
    scanf("%s",s+1);n=strlen(s+1);ans=0;memset(next,0,sizeof(next[0])&lt;&lt;1);
    last=tot=1;len[0]=0,len[1]=-1,fail[0]=fail[1]=1;
    for (int i=1;i&lt;=n;i++)
        add(s[i]-'a',i),p[i]=last;
    for (int i=n;i;i--) s[i&lt;&lt;1]=s[i],s[(i&lt;&lt;1)-1]='*';s[0]='^';n2=n&lt;&lt;1;s[n2+1]='*';s[n2+2]='&amp;';
    for (int i=1,mx=0,cn;i&lt;=n2;i++) {
        id[i]=mx&gt;i?min(mx-i,id[(cn&lt;&lt;1)-i]):0;
        while (s[i-id[i]-1]==s[i+id[i]+1]) id[i]++;
        int &amp;j=p[(i+id[i])&gt;&gt;1];
        while(len[j]&gt;id[i]) j=fail[j];
        sum[j]^=(i&gt;&gt;1)-1;
        if (i+id[i]&gt;mx) mx=i+id[i],cn=i;
    }
    for (int i=tot;i!=1;i--) {
        for (int j=0;j&lt;26;j++) if (next[i][j]) sum[i]^=sum[next[i][j]];
        ans=max(ans,sum[i]);
    }
    printf("%d\n",ans);
}
int main()
{
    fre("A");
    for (int T=getint();T--;)
        work();
      return 0;
}
int getint()
{
      int w=0;
    bool q=1;
    char c=getchar();
    while ((c&lt;'0'||c&gt;'9') &amp;&amp; c!='-') c=getchar();
    if (c=='-') q=0,c=getchar();
      while (c&gt;='0'&amp;&amp;c &lt;= '9') w=w*10+c-'0',c=getchar();
    return q? w:-w;
}

</code></pre>

<h3>G.[省队集训2017day3T2]回文串</h3>

<h4>Description</h4>

<img src="http://sycstudio.com/wp-content/uploads/2018/02/9b271accda790e22924ce99052694f28.png" alt="Description" title="Description" />

<h4>Solution</h4>

可以看出题目所求的其实是&#92;(fail&#92;)树的一段路径和。
考虑离线建出最终的回文树，然后在求出每个位置最终的最长回文前缀与后缀。
每次询问实际上的值是&#92;(len_i*right_i&#92;)，其中right是字符串的出现次数。用动态树维护即可。
值得注意的是lca有时候不会被统计进答案，所以要特判。

感觉讲的好不清楚啊，不懂来问我吧，QAQ...

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 300005;
int n, m;

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

//动态树
struct link_cut_tree
{

    int ch[maxn][2], f[maxn], rev[maxn], val[maxn];
    lint sumv[maxn], suml[maxn], sum[maxn], addv[maxn];

    #define isroot(x) (ch[f[x]][0] != x &amp;&amp; ch[f[x]][1] != x)
    #define get(x) (ch[f[x]][1] == x)

    inline void update(int x)
    {
        suml[x] = suml[ch[x][0]] + suml[ch[x][1]] + val[x];
        sumv[x] = sumv[ch[x][0]] + sumv[ch[x][1]] + sum[x] + addv[x] * suml[x];
    }

    inline void rotate(int x)
    {
        int fa = f[x], gfa = f[fa], k = get(x);
        if(!isroot(fa)) ch[gfa][get(fa)] = x;
        ch[fa][k] = ch[x][k ^ 1]; f[ch[x][k ^ 1]] = fa;
        ch[x][k ^ 1] = fa; f[fa] = x;
        f[x] = gfa;
        update(fa); update(x);
    }

    inline void pushdown(int x)
    {
        if(addv[x]) {
            if(ch[x][0]) addv[ch[x][0]] += addv[x], sumv[ch[x][0]] += addv[x] * suml[ch[x][0]];
            if(ch[x][1]) addv[ch[x][1]] += addv[x], sumv[ch[x][1]] += addv[x] * suml[ch[x][1]];
            sum[x] += addv[x] * val[x];
            addv[x] = 0;
        }
        if(rev[x]) {
            rev[x] = 0;
            if(ch[x][0]) rev[ch[x][0]] ^= 1;
            if(ch[x][1]) rev[ch[x][1]] ^= 1;
            swap(ch[x][0], ch[x][1]);
        }
    }

    int stk[maxn], top;
    inline void splay(int x)
    {
        stk[top = 1] = x;
        while(!isroot(x)) stk[++top] = x = f[x];
        while(top) pushdown(stk[top--]);
        x = stk[1];
        while(!isroot(x)) {
            int fa = f[x];
            if(!isroot(fa))
                get(x) ^ get(fa) ? rotate(x) : rotate(fa);
            rotate(x);
        }
    }

    inline void access(int x)
    {
        for(int y = 0; x; y = x, x = f[x])
            splay(x), ch[x][1] = y, update(x);
    }

    inline void make_root(int x) {access(x); splay(x); rev[x] ^= 1;}

    inline void add(int u, int fa, int w) //添加新节点
    {
        if(!fa) fa = 1;
        val[u] = w; f[u] = fa;
        update(u);
    }

    inline lint query(int u, int v) //询问u,v之间的路径和
    {
        if(!u) u = 1; if(!v) v = 1;
        make_root(u); access(v); splay(v);
        return sumv[v];
    }

    inline void addright(int u) //u的right+1
    {
        make_root(1); access(u); splay(u);
        ++addv[u]; update(u);
    }

}lct;

//回文树
struct palindromic_tree
{

    int l, r, tot, s[maxn], ch[maxn][26], len[maxn], fail[maxn], pre[maxn], suf[maxn];
    int dep[maxn], f[maxn][20];

    inline void prepare() 
    {
        l = n; r = l - 1;
        len[tot = 1] = -1; fail[0] = fail[1] = 1;
        memset(s, -1, sizeof(s));
        pre[l] = pre[r] = suf[l] = suf[r] = 1;
    }

    inline void get_fa(int v)
    {
        f[v][0] = fail[v]; dep[v] = dep[fail[v]] + 1;
        for(int i = 1; i &lt;= 18; ++i) f[v][i] = f[f[v][i - 1]][i - 1];
        lct.add(v, fail[v], len[v]);
    }

    inline int addl(int c)
    {
        s[--l] = c;
        int x = pre[l + 1]; while(s[l + len[x] + 1] != s[l]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[l + len[k] + 1] != s[l]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
            get_fa(v);
        }
        return pre[l] = suf[l + len[ch[x][c]] - 1] = ch[x][c];
    }

    inline int addr(int c)
    {
        s[++r] = c;
        int x = suf[r - 1]; while(s[r - len[x] - 1] != s[r]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[r - len[k] - 1] != s[r]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
            get_fa(v);
        }
        return suf[r] = pre[r - len[ch[x][c]] + 1] = ch[x][c];
    }

    inline void rebuild()
    {
        for(int i = l; i &lt;= r; ++i) { //addr
            int x = suf[i - 1];
            while(s[i - len[x] - 1] != s[i]) x = fail[x];
            suf[i] = ch[x][s[i]];
        }
        for(int i = r; i &gt;= l; --i) { //addl
            int x = pre[i + 1];
            while(s[i + len[x] + 1] != s[i]) x = fail[x];
            pre[i] = ch[x][s[i]];
        }
    }

    inline int lca(int u, int v)
    {
        if(dep[u] &gt; dep[v]) swap(u, v);
        int p = dep[v] - dep[u];
        for(int i = 0; i &lt;= 18; ++i)
            if(p &amp; (1 &lt;&lt; i)) v = f[v][i];
        if(u == v) return u;
        for(int i = 18; i &gt;= 0; --i)
            if(f[u][i] != f[v][i]) {
                u = f[u][i]; v = f[v][i];
            }
        return f[u][0];
    }

    inline int jump(int u, int Maxlen)
    {
        for(int i = 18; i &gt;= 0; --i) if(len[f[u][i]] &gt;= Maxlen) u = f[u][i];
        return len[u] &lt;= Maxlen ? u : f[u][0];
    }

    inline lint calcl(int l1, int r1, int l2, int r2)
    {
        int u = suf[r1], v = suf[r2];
        int lenx = r1 - l1 + 1, leny = r2 - l2 + 1;
        u = jump(u, lenx); v = jump(v, leny);
        lint ret = lct.query(u, v);
        int w = lca(u, v);
        if(len[w] != lenx &amp;&amp; len[w] != leny &amp;&amp; s[r1 - len[w]] == s[r2 - len[w]])
            ret -= lct.query(w, w);
        return ret;
    }

    inline lint calcr(int l1, int r1, int l2, int r2)
    {
        int u = pre[l1], v = pre[l2];
        int lenx = r1 - l1 + 1, leny = r2 - l2 + 1;
        u = jump(u, lenx); v = jump(v, leny);
        lint ret = lct.query(u, v);
        int w = lca(u, v);
        if(len[w] != lenx &amp;&amp; len[w] != leny &amp;&amp; s[l1 + len[w]] == s[l2 + len[w]])
            ret -= lct.query(w, w);
        return ret;
    }

}pam;

struct query
{
    bool type;
    int l1, r1, l2, r2;
}q[maxn];

int main()
{
    freopen("string.in", "r", stdin);
    freopen("string.out", "w", stdout);

    n = gi(); m = gi(); pam.prepare();
    for(int c, i = 1; i &lt;= n; ++i) 
        c = gi(), lct.addright(pam.addr(c));

    char s[8];
    for(int x, l1, r1, l2, r2, i = 1; i &lt;= m; ++i) {
        scanf("%s", s);
        if (s[0] == 'a') {
            x = gi();
            if (s[3] == 'l') q[i] = (query) {0, 0, pam.addl(x)};
            else q[i] = (query) {0, 0, pam.addr(x)};
        } else {
            l1 = gi(); r1 = gi(); l2 = gi(); r2 = gi();
            q[i] = (query) {s[5] == 'r', l1 + pam.l - 1, r1 + pam.l - 1, l2 + pam.l - 1, r2 + pam.l - 1};
        }
    }

    pam.rebuild();

    for(int i = 1; i &lt;= m; ++i) {
        if (!q[i].l1) lct.addright(q[i].r1);
        else if (!q[i].type) printf("%lld\n", pam.calcl(q[i].l1, q[i].r1, q[i].l2, q[i].r2));
        else printf("%lld\n", pam.calcr(q[i].l1, q[i].r1, q[i].l2, q[i].r2));
    }

    return 0;
}
</code></pre>

完结撒花！
<img src="http://img.uoj.ac/utility/bear-applaud.gif" alt="鼓掌熊" />

感觉回文树很有趣的，大家都来学一下吧。

<img src="http://img.uoj.ac/utility/bear-flying.gif" alt="超人熊" />

最后声明一下：由于这篇文章包括了部分校内题，所以仅限会员查看。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>470</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 21:18:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 13:18:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[回文树/回文自动机]]></category>
		<category domain="post_tag" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[576]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>77</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.186.151]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-03 11:33:42]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-03 03:33:42]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[和谐。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-3]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>117</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.53]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-01 11:54:41]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-01 03:54:41]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[阅读破200祭]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>120</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.2.203]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-02 23:23:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-02 15:23:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[话说我突然觉得您这篇文章太长了，每次加载都好耗时间的，打算什么时候帮您分割一下？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>117</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>121</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-03 00:10:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-02 16:10:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[随意]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>120</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2748/Luogu1877][HAOI2012]音量调节（动态规划）</title>
		<link>http://sycstudio.com/archives/473</link>
		<pubDate>Fri, 02 Feb 2018 12:53:22 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=473</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都要改变一次音量。在演出开始之前，他已经做好了一个列表，里面写着在每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。
音量用一个整数描述。输入文件中给定整数beginLevel，代表吉他刚开始的音量，以及整数maxLevel，代表吉他的最大音量。音量不能小于0也不能大于maxLevel。输入文件中还给定了n个整数c1,c2,c3…..cn，表示在第i首歌开始之前吉他手想要改变的音量是多少。
吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2748">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1877">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

与其说是动态规划不如说是打标记？

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51;
const int maxL=1010;
const int inf=2147483647;

int n,st,mx;
int C[maxN];
bool F[maxN][maxL];

int main()
{
    scanf("%d%d%d",&amp;n,&amp;st,&amp;mx);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;C[i]);
    F[0][st]=1;
    for (int i=1;i&lt;=n;i++)
        for (int j=0;j&lt;=mx;j++)
        {
            if (j-C[i]&gt;=0) F[i][j]=F[i][j]|F[i-1][j-C[i]];
            if (j+C[i]&lt;=mx) F[i][j]=F[i][j]|F[i-1][j+C[i]];
        }
    int pos=-1;
    for (int i=mx;i&gt;=0;i--) if (F[n][i]) {pos=i;break;}
    printf("%d\n",pos);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>473</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:53:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:53:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2748-luogu1877haoi2012%e9%9f%b3%e9%87%8f%e8%b0%83%e8%8a%82%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[163]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1084/Luogu2331][SCOI2005]最大子矩阵（动态规划）</title>
		<link>http://sycstudio.com/archives/474</link>
		<pubDate>Fri, 02 Feb 2018 13:02:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=474</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

这里有一个n&#42;m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵
不能相互重叠。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1084">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2331">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

看到m的范围就知道是动态规划了。分&#92;(m=1&#92;)和&#92;(m=2&#92;)两种情况讨论。
先是&#92;(m=1&#92;)的。设&#92;(F[i][j]&#92;)表示前&#92;(j&#92;)个数中选出&#92;(i&#92;)个子矩阵的最大和，那么首先它可以从&#92;(F[i][j-1]&#92;)转移过来，这个的意思是取这一层这一次的最大，然后可以枚举一个&#92;(k&#92;)从&#92;(F[i-1][k]&#92;)转移过来。
对于&#92;(m=2&#92;)的则类似设&#92;(F[i][j][k]&#92;)表示第一列选到&#92;(j&#92;)，第二列选到&#92;(k&#92;)，选出&#92;(i&#92;)个子矩阵的最大和，那么类比&#92;(m=1&#92;)的转移，它首先可以从&#92;(F[i][j-1][k]&#92;)和&#92;(F[i][j][k-1]&#92;)中大的那个转移过来，再分别枚举&#92;(pos&#92;)小于&#92;(j&#92;)和小于&#92;(k&#92;)分别从前面转移过来，这个是表示选择其中的一列的子矩阵。最后若&#92;(j==k&#92;)，则还可以从同时选择两行转移过来。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101;
const int maxM=3;
const int maxK=11;
const int inf=2147483647;

int n,m,K;
int Mat[maxN][maxM],Sum[maxN][maxM];
int F1[maxK][maxN];
int F2[maxK][maxN][maxN];

void Do1();
void Do2();

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
    if (m==1) Do1();
    else Do2();
    return 0;
}

void Do1()
{
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Mat[i][1]),Sum[i][1]=Sum[i-1][1]+Mat[i][1];
    F1[0][0]=0;
    for (int i=1;i&lt;=K;i++)
        for (int j=1;j&lt;=n;j++)
        {
            F1[i][j]=F1[i][j-1];//这一步保证从前面取得最优值
            for (int k=0;k&lt;j;k++)
                F1[i][j]=max(F1[i][j],F1[i-1][k]+Sum[j][1]-Sum[k][1]);
        }
    printf("%d\n",F1[K][n]);
    return;
}

void Do2()
{
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",&amp;Mat[i][1],&amp;Mat[i][2]);
        Sum[i][1]=Sum[i-1][1]+Mat[i][1];
        Sum[i][2]=Sum[i-1][2]+Mat[i][2];
    }
    F2[0][0][0]=0;
    for (int i=1;i&lt;=K;i++)
        for (int j=1;j&lt;=n;j++)
            for (int k=1;k&lt;=n;k++)
            {
                F2[i][j][k]=max(F2[i][j-1][k],F2[i][j][k-1]);
                for (int pos=0;pos&lt;j;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][pos][k]+Sum[j][1]-Sum[pos][1]);
                for (int pos=0;pos&lt;k;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][j][pos]+Sum[k][2]-Sum[pos][2]);
                if (j==k)
                    for (int pos=0;pos&lt;j;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][pos][pos]+Sum[j][1]-Sum[pos][1]+Sum[k][2]-Sum[pos][2]);
            }
    printf("%d\n",F2[K][n][n]);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>474</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 21:02:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 13:02:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1084-luogu2331scoi2005%e6%9c%80%e5%a4%a7%e5%ad%90%e7%9f%a9%e9%98%b5%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[179]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1003/Luogu1772][ZJOI2006]物流运输（最短路径，动态规划）</title>
		<link>http://sycstudio.com/archives/477</link>
		<pubDate>Sat, 03 Feb 2018 03:32:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=477</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转
停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1003">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1772">Luogu</a>

<h3>Tag</h3>

最短路径，动态规划

<h2>解决思路</h2>

看到数据范围，我们可以预处理出&#92;(Cost[i][j]&#92;)表示从第&#92;(i&#92;)天到第&#92;(j&#92;)天每一天的最短花费，这个直接求最短路即可。
接下来动态转移，设&#92;(F[i]&#92;)表示前&#92;(i&#92;)天的最小花费，那么枚举前面的某一天转移即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxDay=110;
const int maxN=21;
const int maxM=maxN*maxN*2;
const int maxQueue=maxN*1000;
const int inf=21474836;

int Day,n,m,K;
int Cant[maxDay];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Cost[maxDay][maxDay];
int Queue[maxQueue],Dist[maxN];
bool inqueue[maxN];
int F[maxDay];

void Add_Edge(int u,int v,int w);
void _Add(int u,int v,int w);
int Spfa(int l,int r);

int main()
{
    mem(Head,-1);
    scanf("%d%d%d%d",&amp;Day,&amp;n,&amp;K,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u--;v--;
        Add_Edge(u,v,w);
    }
    int d;scanf("%d",&amp;d);
    for (int i=1;i&lt;=d;i++)
    {
        int P,l,r;scanf("%d%d%d",&amp;P,&amp;l,&amp;r);
        P--;
        for (int j=l;j&lt;=r;j++) Cant[j]|=(1&lt;&lt;P);
    }
    for (int i=1;i&lt;=Day;i++)
        for (int j=i;j&lt;=Day;j++)
            Cost[i][j]=Spfa(i,j);
    mem(F,63);F[0]=0;
    for (int i=1;i&lt;=Day;i++)
    {
        F[i]=Cost[1][i]*i;
        for (int j=0;j&lt;i;j++)
            F[i]=min(F[i],F[j]+(i-j)*Cost[j+1][i]+K);
    }
    printf("%d\n",F[Day]);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    _Add(u,v,w);_Add(v,u,w);
    return;
}

void _Add(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

int Spfa(int l,int r)
{
    int cant=0;
    for (int i=l;i&lt;=r;i++) cant|=Cant[i];
    mem(Dist,-1);Dist[0]=0;
    int h=1,t=0;Queue[1]=0;
    do
    {
        t++;if (t==maxQueue) t=0;
        int u=Queue[t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if (((1&lt;&lt;V[i])&amp;cant)==0)
                if ((Dist[V[i]]==-1)||(Dist[u]+W[i]&lt;Dist[V[i]]))
                {
                    Dist[V[i]]=Dist[u]+W[i];
                    if (inqueue[V[i]]==0)
                    {
                        h++;if (h==maxQueue) h=0;
                        inqueue[Queue[h]=V[i]]=1;
                    }
                }
        inqueue[u]=0;
    }
    while (t!=h);
    if (Dist[n-1]==-1) return inf;
    return Dist[n-1];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>477</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 11:32:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 03:32:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1003-luogu1772zjoi2006%e7%89%a9%e6%b5%81%e8%bf%90%e8%be%93%ef%bc%88%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[197]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2132/Luogu1935]圈地计划（网络流）</title>
		<link>http://sycstudio.com/archives/478</link>
		<pubDate>Sat, 03 Feb 2018 05:46:49 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=478</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近房地产商GDOI(Group of Dumbbells Or Idiots)从NOI(Nuts Old Idiots)手中得到了一块开发土地。据了解，这块土地是一块矩形的区域，可以纵横划分为N×M块小区域。GDOI要求将这些区域分为商业区和工业区来开发。根据不同的地形环境，每块小区域建造商业区和工业区能取得不同的经济价值。更具体点，对于第i行第j列的区域，建造商业区将得到Aij收益，建造工业区将得到Bij收益。另外不同的区域连在一起可以得到额外的收益，即如果区域(I,j)相邻（相邻是指两个格子有公共边）有K块（显然K不超过4）类型不同于(I,j)的区域，则这块区域能增加k×Cij收益。经过Tiger.S教授的勘察，收益矩阵A,B,C都已经知道了。你能帮GDOI求出一个收益最大的方案么？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2132">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1935">Luogu</a>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

最小割模型。
转化为把所有收益求和后算出最少损失，变成最小割模型。
一个格子建工业区还是商业区这个比较好处理，但若不同类型的格子相邻产生收益这不好处理。
一个格子与其相邻四个格子产生可能的收益，我们发现这个分类与黑白染色很像。
所以我们把格子黑白染色，假设白格子先选工业区，黑格子选商业区，那么相当于一开始所有的相邻不相同的收益都是可以得到的，然后再建图跑最大流。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=101;
const int maxN=maxMap*maxMap*2;
const int maxM=(maxMap*maxMap*6)*2;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m;
int S,T;
int A[maxMap][maxMap],B[maxMap][maxMap],C[maxMap][maxMap],Id[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow,int opt);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;A[i][j]);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;B[i][j]);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;C[i][j]);
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    S=idcnt+1;T=idcnt+2;
    int Ans=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
            if ((i+j)&amp;1)//分黑白两种格子讨论
            {
                Add_Edge(S,Id[i][j],A[i][j],0);
                Add_Edge(Id[i][j],T,B[i][j],0);//先连上源汇点
                Ans+=A[i][j]+B[i][j];
                //分别讨论四个方向相邻的格子
                if (i!=1) Add_Edge(Id[i][j],Id[i-1][j],C[i][j]+C[i-1][j],1),Ans+=C[i][j]+C[i-1][j];
                if (i!=n) Add_Edge(Id[i][j],Id[i+1][j],C[i][j]+C[i+1][j],1),Ans+=C[i][j]+C[i+1][j];
                if (j!=1) Add_Edge(Id[i][j],Id[i][j-1],C[i][j]+C[i][j-1],1),Ans+=C[i][j]+C[i][j-1];
                if (j!=m) Add_Edge(Id[i][j],Id[i][j+1],C[i][j]+C[i][j+1],1),Ans+=C[i][j]+C[i][j+1];
            }
            else
            {
                Add_Edge(S,Id[i][j],B[i][j],0);
                Add_Edge(Id[i][j],T,A[i][j],0);
                Ans+=A[i][j]+B[i][j];
            }
    while (Bfs())//求最小割
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans-=di;
    }
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow,int opt)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=opt*flow;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((Depth[E[i].v]==-1)&amp;&amp;(E[i].flow&gt;0))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>478</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 13:46:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 05:46:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2132-luogu1935%e5%9c%88%e5%9c%b0%e8%ae%a1%e5%88%92%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[139]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2127/Luogu1646]happiness（网络流）</title>
		<link>http://sycstudio.com/archives/479</link>
		<pubDate>Sat, 03 Feb 2018 07:37:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=479</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

高一一班的座位表是个n&#42;m的矩阵，经过一个学期的相处，每个同学和前后左右相邻的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而一对好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。作为计算机竞赛教练的scp大老板，想知道如何分配可以使得全班的喜悦值总和最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2127">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1646">Luogu</a>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/478">这一题</a>类似的，先把求最大收益转化为求最小损失，即先把所有的收益都加起来，然后求一个最小的损失即最小割。
一个人选文还是选理分别与源汇点连边，假设源点&#92;(S&#92;)表示选文，汇点&#92;(T&#92;)表示选理，这个比较好处理，但是，与旁边的人的选择就不好处理了，因为这里两人同时选文和同时选理的收益是不一样的。
怎么办呢？总共只有&#92;(4&#92;)种可能，所以我们把这四种情况列出来。
设&#92;(x->y&#92;)表示&#92;(x&#92;)到&#92;(y&#92;)这条边上的容量，设&#92;(u&#92;)表示两人同时选文的收益，&#92;(v&#92;)为两人同时选理的收益，则有：
若两人同时选文，则割掉的边是&#92;(x->T,y->T&#92;)，损失是&#92;(v&#92;)。
若两人同时选理，则割掉的边是&#92;(S->x,S->y&#92;)，损失是&#92;(u&#92;)
若&#92;(x&#92;)文&#92;(y&#92;)理，则割掉的边是&#92;(x->T,S->y,x->y&#92;)，损失是&#92;(u+v&#92;)
若&#92;(x&#92;)理&#92;(y&#92;)文，则割掉的边是&#92;(S->x,y->T,y->x&#92;)
综上，四个方程就是
&#92;((x->T)+(y->T)=v &#92;&#92; (S->x)+(S->y)=u &#92;&#92; (x->T)+(S->y)+(x->y)=u+v &#92;&#92; (S->x)+(y->T)+(y->x)=u+v&#92;)
但是这个方程是无法直接解的。考虑到实际上不管是哪一组解都是可以的，不妨设&#92;((x->T)==(y->T)==\frac{v}{2}&#92;)，同理有&#92;((S->x)==(S->y)==\frac{u}{2}&#92;)，那么就有&#92;((x->y)==(y->x)==\frac{u+v}{2}&#92;)
由于除以二会导致可能出现小数，所以考虑把所有的容量先乘以二变成整数，最后求出最小割再除以二即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=101;
const int maxN=maxMap*maxMap;
const int maxM=maxN*100;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
int Mat1[maxMap][maxMap],Mat2[maxMap][maxMap],Mat3[maxMap][maxMap],Mat4[maxMap][maxMap],Mat5[maxMap][maxMap],Mat6[maxMap][maxMap],Id[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow,int opt);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    int Ans=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat1[i][j]),Ans+=Mat1[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat2[i][j]),Ans+=Mat2[i][j];
    for (int i=1;i&lt;n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat3[i][j]),Ans+=Mat3[i][j];
    for (int i=1;i&lt;n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat4[i][j]),Ans+=Mat4[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;m;j++) scanf("%d",&amp;Mat5[i][j]),Ans+=Mat5[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;m;j++) scanf("%d",&amp;Mat6[i][j]),Ans+=Mat6[i][j];
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    S=idcnt+1;T=idcnt+2;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            Add_Edge(S,Id[i][j],Mat1[i][j]*2+Mat3[i][j]+Mat3[i-1][j]+Mat5[i][j]+Mat5[i][j-1],0);
            Add_Edge(Id[i][j],T,Mat2[i][j]*2+Mat4[i][j]+Mat4[i-1][j]+Mat6[i][j]+Mat6[i][j-1],0);
            if (i!=n) Add_Edge(Id[i][j],Id[i+1][j],Mat3[i][j]+Mat4[i][j],1);
            if (j!=m) Add_Edge(Id[i][j],Id[i][j+1],Mat5[i][j]+Mat6[i][j],1);
        }
    int mxflow=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) mxflow+=di;
    }
    printf("%d\n",Ans-mxflow/2);
    return 0;
}

void Add_Edge(int u,int v,int flow,int opt)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=opt*flow;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for(int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((Depth[E[i].v]==Depth[u]+1)&amp;&amp;(E[i].flow&gt;0))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>479</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 15:37:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 07:37:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2127-luogu1646happiness%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[146]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1189/Luogu3191][HNOI2007]紧急疏散evacuate（二分，网络流）</title>
		<link>http://sycstudio.com/archives/482</link>
		<pubDate>Sun, 04 Feb 2018 10:57:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=482</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

发生了火警，所有人员需要紧急疏散！假设每个房间是一个N M的矩形区域。每个格子如果是'.'，那么表示这是一块空地；如果是'X'，那么表示这是一面墙，如果是'D'，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1189">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3191">Luogu</a>

<h3>Tag</h3>

二分，网络流

<h2>解决思路</h2>

二分时间，转化成判定问题。考虑如何限制每一个门在同一时刻只能出去一个人，若当前二分的时间为&#92;(tim&#92;)，则把门拆成&#92;(tim&#92;)个点，每一个点只与汇点连容量为一的边。对于每一个点，练到它能到的门的那个时刻的点，求最大流判断是否为人数。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=23;
const int maxN=maxMap*maxMap*maxMap;
const int maxM=maxN*10*2;
const int F1[4]={0,0,1,-1};
const int F2[4]={1,-1,0,0};
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T,doorcnt,pcnt;
char Input[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],Id[maxMap][maxMap],cur[maxN];

bool Check(int mid);
void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%s",Input[i]+1);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) {if (Input[i][j]=='D') doorcnt++;if (Input[i][j]=='.') pcnt++;}
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    int l=1,r=n*m+2;
    int Ans=-1;
    do
    {
        int mid=(l+r)/2;
        if (Check(mid)) Ans=mid,r=mid-1;
        else l=mid+1;
    }
    while (l&lt;=r);
    if (Ans!=-1) printf("%d\n",Ans);
    else printf("impossible\n");
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

int Queue1[maxN],Queue2[maxN],Len[maxMap][maxMap],Tag[maxMap][maxMap];

bool Check(int mid)//判定
{
    edgecnt=-1;mem(Head,-1);mem(Tag,0);//Tag用来标记某一个点当前最后一个能到的门的编号，这样可以省去每一次memset的花费
    int nodecnt=n*m;
    S=n*m+mid*doorcnt+1;
    T=n*m+mid*doorcnt+2;
    int dcnt=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='X') continue;
            if (Input[i][j]=='.') Add_Edge(S,Id[i][j],1);
            if (Input[i][j]=='D')//每找到一个门，则从这个门开始bfs求出能到这个门的点
            {
                int h=1,t=0;
                Queue1[1]=i;Queue2[1]=j;Len[i][j]=0;
                dcnt++;
                Tag[i][j]=dcnt;
                for (int de=1;de&lt;=mid;de++)
                {
                    Add_Edge(nodecnt+de,T,1);
                    if (de!=mid) Add_Edge(nodecnt+de,nodecnt+de+1,inf);
                }
                do
                {
                    t++;int x=Queue1[t],y=Queue2[t];
                    if (Len[x][y]&gt;mid) continue;
                    Add_Edge(Id[x][y],nodecnt+Len[x][y],1);
                    for (int o=0;o&lt;4;o++)
                        if ((Input[x+F1[o]][y+F2[o]]=='.')&amp;&amp;(Tag[x+F1[o]][y+F2[o]]!=dcnt))
                        {
                            Tag[x+F1[o]][y+F2[o]]=dcnt;
                            Len[x+F1[o]][y+F2[o]]=Len[x][y]+1;
                            h++;Queue1[h]=x+F1[o];Queue2[h]=y+F2[o];
                        }
                }
                while (t!=h);
                nodecnt+=mid;
            }
        }
    int ret=0;//求解最大流
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) ret+=di;
    }
    if (ret==pcnt) return 1;
    return 0;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>482</wp:post_id>
		<wp:post_date><![CDATA[2018-02-04 18:57:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-04 10:57:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1189-luogu3191hnoi2007%e7%b4%a7%e6%80%a5%e7%96%8f%e6%95%a3evacuate%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%8c%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[201]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3531/Luogu3313][Sdoi2014]旅行（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/483</link>
		<pubDate>Sun, 04 Feb 2018 12:31:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=483</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

S国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，  S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。
在S国的历史上常会发生以下几种事件：
”CC x c”：城市x的居民全体改信了c教；
”CW x w”：城市x的评级调整为w;
”QS x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和；
”QM x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过
的城市的评级最大值。
由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3531">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3313">Luogu</a>

<h3>Tag</h3>

树链剖分，线段树

<h2>解决思路</h2>

比价好想的就是树链剖分后对每一种宗教单独开一棵线段树维护，这样的话就可以直接对每一种宗教查询了。
但空间是开不下的，考虑到其实我们只要用到其中的部分空间，所以可以动态地开线段树的点，这样就可以了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class SegData
{
public:
    int ls,rs;
    ll sum,mx;
};

int n,Q,nodecnt;
int Color[maxN],root[maxN],Val[maxN];
SegData S[maxN*100];
int Fa[maxN],Depth[maxN],Top[maxN],Hson[maxN],Size[maxN];
int idcnt=0,Id[maxN];
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];

void dfs1(int u,int fa);//树链剖分
void dfs2(int u,int top);
void Update(int now);
void Modify(int &amp;now,int l,int r,int pos,int val);//线段树单点修改
ll QSum(int u,int v);//路径查询
ll QMax(int u,int v);
ll SSum(int now,int l,int r,int ql,int qr);//线段树查询
ll SMax(int now,int l,int r,int ql,int qr);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++) scanf("%d%d",&amp;Val[i],&amp;Color[i]);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    }
    Depth[1]=1;
    dfs1(1,1);
    dfs2(1,1);
    for (int i=1;i&lt;=n;i++) Modify(root[Color[i]],1,n,Id[i],Val[i]);
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if ((opt[0]=='C')&amp;&amp;(opt[1]=='C'))
        {
            int city,col;scanf("%d%d",&amp;city,&amp;col);
            Modify(root[Color[city]],1,n,Id[city],0);
            Modify(root[col],1,n,Id[city],Val[city]);
            Color[city]=col;
        }
        if ((opt[0]=='C')&amp;&amp;(opt[1]=='W'))
        {
            int city,val;scanf("%d%d",&amp;city,&amp;val);
            Val[city]=val;
            Modify(root[Color[city]],1,n,Id[city],val);
        }
        if ((opt[0]=='Q')&amp;&amp;(opt[1]=='S'))
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            printf("%lld\n",QSum(u,v));
        }
        if ((opt[0]=='Q')&amp;&amp;(opt[1]=='M'))
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            printf("%lld\n",QMax(u,v));
        }
    }
    return 0;
}

void dfs1(int u,int fa)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[V[i]]=u;Depth[V[i]]=Depth[u]+1;
            dfs1(V[i],u);
            if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
            Size[u]+=Size[V[i]];
        }
    return;
}

void dfs2(int u,int top)
{
    Top[u]=top;
    Id[u]=++idcnt;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u]))
            dfs2(V[i],V[i]);
    return;
}

void Update(int now)
{
    int ls=S[now].ls,rs=S[now].rs;
    S[now].sum=S[ls].sum+S[rs].sum;
    S[now].mx=max(S[ls].mx,S[rs].mx);
    return;
}

void Modify(int &amp;now,int l,int r,int pos,int val)
{
    if (now==0) now=++nodecnt;
    if (l==r)
    {
        S[now].sum=S[now].mx=val;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(S[now].ls,l,mid,pos,val);
    else Modify(S[now].rs,mid+1,r,pos,val);
    Update(now);
    return;
}

ll QSum(int u,int v)
{
    ll ret=0,col=Color[v];
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=ret+SSum(root[col],1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    ret=ret+SSum(root[col],1,n,Id[u],Id[v]);
    return ret;
}

ll QMax(int u,int v)
{
    ll ret=0,col=Color[v];
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=max(ret,SMax(root[col],1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    ret=max(ret,SMax(root[col],1,n,Id[u],Id[v]));
    return ret;
}

ll SSum(int now,int l,int r,int ql,int qr)
{
    if (now==0) return 0;
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return SSum(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return SSum(S[now].rs,mid+1,r,ql,qr);
    else return SSum(S[now].ls,l,mid,ql,mid)+SSum(S[now].rs,mid+1,r,mid+1,qr);
}

ll SMax(int now,int l,int r,int ql,int qr)
{
    if (now==0) return 0;
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mx;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return SMax(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return SMax(S[now].rs,mid+1,r,ql,qr);
    else return max(SMax(S[now].ls,l,mid,ql,mid),SMax(S[now].rs,mid+1,r,mid+1,qr));
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>483</wp:post_id>
		<wp:post_date><![CDATA[2018-02-04 20:31:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-04 12:31:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3531-luogu3313sdoi2014%e6%97%85%e8%a1%8c%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[194]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2120/Luogu1903]数颜色（莫队算法）</title>
		<link>http://sycstudio.com/archives/485</link>
		<pubDate>Mon, 05 Feb 2018 03:28:37 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=485</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2120">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1903">Luogu</a>

<h3>Tag</h3>

莫队算法，离线

<h2>解决思路</h2>

莫队算法把询问离线下来，排序后移动左右指针得到答案。
但这里有修改操作，怎么办呢？
可以在把询问左右区间离线下来的同时记录时间，记录是第一个修改操作后的，那么回答询问的时候再移动时间指针，把要修改的修改掉，不要修改的改回去。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=5001000;
const int inf=2147483647;

class Question//询问
{
public:
    int l,r,tim,id;
};

class Modify//修改
{
public:
    int pos,before,col;
};

int n,m,nowans=0;
int L,R,Tim;
int Col[maxN],InitCol[maxN],Sum[maxN],Belong[maxN];
Question Q[maxN];
Modify M[maxN];
int Ans[maxN];

bool cmp(Question A,Question B);
void TimeMove(int pos,int col);
void PosMove(int col,int opt);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    int size=pow(n,0.66666666);
    for (int i=1;i&lt;=n;i++) Belong[i]=(i-1)/size+1;
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Col[i]),InitCol[i]=Col[i];
    int mcnt=0,qcnt=0;
    for (int i=1;i&lt;=m;i++)
    {
        char opt;cin&gt;&gt;opt;
        if (opt=='Q')
        {
            int l,r;scanf("%d%d",&amp;l,&amp;r);
            Q[++qcnt]=(Question){l,r,mcnt,qcnt};
        }
        else
        {
            int pos,col;scanf("%d%d",&amp;pos,&amp;col);
            M[++mcnt]=(Modify){pos,Col[pos],col};
            Col[pos]=col;
        }
    }
    for (int i=1;i&lt;=n;i++) Col[i]=InitCol[i];
    L=1,R=0;Tim=0;
    sort(&amp;Q[1],&amp;Q[qcnt+1],cmp);
    for (int i=1;i&lt;=qcnt;i++)
    {
        while (Tim&lt;Q[i].tim) TimeMove(M[Tim+1].pos,M[Tim+1].col),Tim++;
        while (Tim&gt;Q[i].tim) TimeMove(M[Tim].pos,M[Tim].before),Tim--;
        while (L&lt;Q[i].l) PosMove(Col[L],-1),L++;
        while (L&gt;Q[i].l) PosMove(Col[L-1],1),L--;
        while (R&gt;Q[i].r) PosMove(Col[R],-1),R--;
        while (R&lt;Q[i].r) PosMove(Col[R+1],1),R++;
        Ans[Q[i].id]=nowans;
    }
    for (int i=1;i&lt;=qcnt;i++) printf("%d\n",Ans[i]);
    return 0;
}

bool cmp(Question A,Question B)
{
    return (Belong[A.l]!=Belong[B.l])?(A.l&lt;B.l):((Belong[A.r]!=Belong[B.r])?(A.r&lt;B.r):(A.tim&lt;B.tim));
}

void TimeMove(int pos,int col)//移动时间
{
    if ((pos&gt;=L)&amp;&amp;(pos&lt;=R)) PosMove(Col[pos],-1),PosMove(col,1);
    Col[pos]=col;
    return;
}

void PosMove(int col,int opt)//移动位置
{
    nowans-=(Sum[col]&gt;0);
    Sum[col]+=opt;
    nowans+=(Sum[col]&gt;0);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>485</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 11:28:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 03:28:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2120-luogu1903%e6%95%b0%e9%a2%9c%e8%89%b2%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[200]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3506/Luogu3165][Cqoi2014]排序机械臂（平衡树）</title>
		<link>http://sycstudio.com/archives/487</link>
		<pubDate>Mon, 05 Feb 2018 15:36:11 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=487</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到摄低的物品的位置P1,并把左起第一个至P1间的物品反序；第二次找到第二低的物品的位置P2,并把左起第二个至P2间的物品反序...最终所有的物品都会被排好序。
上图给出<em>个示例，第</em>次操作前，菝低的物品在位置4,于是把第1至4的物品反序；第二次操作前，第二低的物品在位罝6,于是把第2至6的物品反序...
你的任务便是编写一个程序，确定一个操作序列，即每次操作前第i低的物品所在位置Pi,以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3506">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3165">Luogu</a>

<h3>Tag</h3>

平衡树

<h2>解决思路</h2>

记录下位置后平衡树维护区间翻转即可。
调了好久才发现为了方便直接把找后继的代码在&#92;(main&#92;)里面展开了，结果没有下放标记。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int inf=2147483647;

class SplayData
{
public:
    int key;
    int fa,ch[2];
    int rev,size;
};

class Data
{
public:
    int key,pos;
};

int n,root;
SplayData S[maxN];
int Stack[maxN];
Data D[maxN];

void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x,int goal);
void Outp(int now);
void Outp2(int now);
int Rank(int rth);
bool cmp(Data A,Data B);

int main()
{
    scanf("%d",&amp;n);
    S[1].key=-1;//设置1和n+2两个哨兵节点
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;S[i+1].key),D[i]=(Data){S[i+1].key,i+1};
    S[n+2].key=-1;
    S[1].fa=0;S[1].ch[1]=2;
    root=1;
    for (int i=2;i&lt;=n+1;i++) S[i].fa=i-1,S[i].ch[1]=i+1;//直接像一条链一样建树
    S[n+2].fa=n+1;
    Splay(n+2,0);
    sort(&amp;D[1],&amp;D[n+1],cmp);//排序
    for (int i=1;i&lt;=n;i++)
    {
        int l=Rank(i),r=D[i].pos;
        Splay(r,0);
        printf("%d ",S[S[r].ch[0]].size);
        r=S[r].ch[1];PushDown(r);while (S[r].ch[0]) r=S[r].ch[0],PushDown(r);//这里就是把找后继展开了，记得pushdown
        Splay(l,0);
        Splay(r,l);
        int node=S[r].ch[0];//区间翻转
        swap(S[node].ch[0],S[node].ch[1]);
        if (node) S[node].rev^=1;
    }
    return 0;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (z) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x,int goal)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (now!=root)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (S[x].fa!=goal)
    {
        int y=S[x].fa,z=S[y].fa;
        if (z!=goal)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    if (goal==0) root=x;
    Update(x);return;
}

int Rank(int kth)
{
    int now=root;
    do
    {
        PushDown(now);
        int lson=S[now].ch[0];
        if (S[lson].size+1==kth) return now;
        if (S[lson].size&gt;=kth) now=lson;
        else kth=kth-S[lson].size-1,now=S[now].ch[1];
    }
    while (1);
}

bool cmp(Data A,Data B)
{
    if (A.key!=B.key) return A.key&lt;B.key;
    else return A.pos&lt;B.pos;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>487</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 23:36:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 15:36:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3506-luogu3165cqoi2014%e6%8e%92%e5%ba%8f%e6%9c%ba%e6%a2%b0%e8%87%82%ef%bc%88%e5%b9%b3%e8%a1%a1%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[182]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1483/Luogu3201][HNOI2009]梦幻布丁（平衡树，启发式合并）</title>
		<link>http://sycstudio.com/archives/488</link>
		<pubDate>Mon, 05 Feb 2018 15:44:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=488</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.
例如颜色分别为1,2,2,1的四个布丁一共有3段颜色

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1483">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3201">Luogu</a>

<h3>Tag</h3>

平衡树，启发式合并

<h2>解决思路</h2>

震惊，某选手手写平衡树调一晚上没有调过，一怒之下竟然用&#92;(set&#92;)水过。
对每一种颜色维护一个平衡树存储有那些位置是这个颜色，那么把一种颜色改成另一种颜色的时候，就启发式地把两个合并。全局维护一个答案，若把这个点加入会少一些答案，那么直接减去即可。
但需要注意的是，题中明确说是把&#92;(x&#92;)合并到&#92;(y&#92;)，但我们启发式合并的时候可能是把&#92;(y&#92;)合并到&#92;(x&#92;)，这时候我们就把&#92;(x&#92;)与&#92;(y&#92;)的编号永久地交换一下，让以后找到&#92;(x&#92;)都相当于找到了&#92;(y&#92;)，&#92;(y&#92;)同理。
没错，这一题可以用&#92;(set&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n,Ans=0;
int Col[maxN],Colf[maxN];
set&lt;int&gt; S[maxN];

void Merge(int u,int v);

int main()
{
    int m;
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=1000000;i++) Colf[i]=i;//这个就是标记当前颜色真实对应到的颜色编号
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Col[i]);
        if (Col[i]!=Col[i-1]) Ans++;
        S[Col[i]].insert(i);
    }
    while (m--)
    {
        int opt;scanf("%d",&amp;opt);
        if (opt==1)
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            if (u==v) continue;//相等直接跳过
            if (S[Colf[u]].size()&gt;S[Colf[v]].size()) swap(Colf[u],Colf[v]);//保证启发式合并
            Merge(Colf[u],Colf[v]);
        }
        if (opt==2) printf("%d\n",Ans);
    }
    return 0;
}

void Merge(int u,int v)
{
    for (set&lt;int&gt;::iterator i=S[u].begin();i!=S[u].end();i++)
    {
        if (Col[*i-1]==v) Ans--;//当加入这个位置会减少答案，则减少
        if (Col[*i+1]==v) Ans--;
        S[v].insert(*i);
    }
    for (set&lt;int&gt;::iterator i=S[u].begin();i!=S[u].end();i++)//统一修改标记
        Col[*i]=v;
    S[u].clear();//清空
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>488</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 23:44:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 15:44:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1483-luogu3201hnoi2009%e6%a2%a6%e5%b9%bb%e5%b8%83%e4%b8%81%ef%bc%88%e5%b9%b3%e8%a1%a1%e6%a0%91%ef%bc%8c%e5%90%af%e5%8f%91%e5%bc%8f%e5%90%88%e5%b9%b6%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%90%af%e5%8f%91%e5%bc%8f"><![CDATA[启发式]]></category>
		<category domain="post_tag" nicename="%e5%90%af%e5%8f%91%e5%bc%8f"><![CDATA[启发式]]></category>
		<category domain="category" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[219]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3884/Luogu4219]上帝与集合的正确用法（扩展欧拉定理）</title>
		<link>http://sycstudio.com/archives/490</link>
		<pubDate>Tue, 06 Feb 2018 06:59:57 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=490</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

根据一些书上的记载，上帝的一次失败的创世经历是这样的：
第一天，    上帝创造了一个世界的基本元素，称做“元”。
第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。
第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。
第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。
如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。
然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……
然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。
至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？
上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。
你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。
一句话题意：
<img src="http://sycstudio.com/bzojch/file/3884_0.png" alt="BZOJ3884" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3884">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4139">Luogu</a>

<h3>Tag</h3>

扩展欧拉定理

<h2>解决思路</h2>

依照题意递归肯定是不行的（无线层诶）。首先想到的就是欧拉定理，即
&#92;[x^a \quad mod \quad p=x^{a \quad mod \quad \phi(p)} \quad mod \quad p&#92;]
当最后&#92;(\phi(i)==1&#92;)的时候，递归就结束了。
但这里给出的模数&#92;(p&#92;)并不一定是质数，所以这里要用到扩展欧拉定理，即
&#92;[x^a \quad mod \quad b=x^{a \quad mod \quad \phi(b)+\phi(b)} \quad mod \quad b&#92;]
那么根据这个求解即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

ll GetPhi(ll x);
ll Pow(ll cnt,ll Mod);
ll Calc(ll p);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int x;scanf("%d",&amp;x);
        printf("%lld\n",Calc(x));//递归求解
    }
}

ll GetPhi(ll x)
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x!=1) ret=ret/x*(x-1);
    return ret;
}

ll Pow(ll cnt,ll Mod)
{
    ll x=2,ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}

ll Calc(ll p)
{
    if (p==1) return 0;
    ll nowphi=GetPhi(p);
    return Pow(Calc(nowphi)+nowphi,p);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>490</wp:post_id>
		<wp:post_date><![CDATA[2018-02-06 14:59:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-06 06:59:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3884-luogu4219%e4%b8%8a%e5%b8%9d%e4%b8%8e%e9%9b%86%e5%90%88%e7%9a%84%e6%ad%a3%e7%a1%ae%e7%94%a8%e6%b3%95%ef%bc%88%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86"><![CDATA[欧拉定理/扩展欧拉定理]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86"><![CDATA[欧拉定理/扩展欧拉定理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[194]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4872/Luogu3750][Shoi2017]分手是祝愿（期望动态规划，逆元）</title>
		<link>http://sycstudio.com/archives/491</link>
		<pubDate>Tue, 06 Feb 2018 12:15:42 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=491</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Zeit und Raum trennen dich und mich.
时空将你我分开。B 君在玩一个游戏，这个游戏由 n 个灯和 n 个开关组成，给定这 n 个灯的初始状态，下标为从 1 到 n 的正整数。每个灯有两个状态亮和灭，我们用 1 来表示这个灯是亮的，用 0 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。但是当操作第 i 个开关时，所有编号为 i 的约数（包括 1 和 i）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。这个策略需要的操作次数很多， B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 k 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 k 步）操作这些开关。B 君想知道按照这个策略（也就是先随机操作，最后小于等于 k 步，使用操作次数最小的操作方法）的操作次数的期望。这个期望可能很大，但是 B 君发现这个期望乘以 n 的阶乘一定是整数，所以他只需要知道这个整数对 100003 取模之后的结果。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4872">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3750">Luogu</a>

<h3>Tag</h3>

期望动态规划，逆元

<h2>解决思路</h2>

首先考虑如何得到最少步数，由于更改一个灯的状态只会影响到比它小的灯，所以我们可以从大往小依次把灯的状态更改，&#92;(O\sqrt{n}&#92;)地枚举约数修改。可以证明其它的方法不会更优。
那么这样我们就知道有那些灯是一定会被关的，由于一盏灯被关多次是没有用的，所以这些应该被关掉的灯的顺序是与答案没有关系的。实际上，这些被关掉的灯的位置也是与计数无关的，我们只要知道需要关掉多少盏灯即可，因为最后的答案只与它有关。
那么问题转化为求在&#92;(n&#92;)个物品中，我们要选择确定的&#92;(tot&#92;)个（即要关掉的灯数），多选的其它物品可以花费一个回合丢掉（为什么是回合，没错我文明玩多了）。选择是随机的，每一次等概率选择一个物品或丢掉一个物品，而当剩下要求选的物品小于等于&#92;(K&#92;)时，直接选择这些物品。求期望步数。
那么首先有一个简单的想法，就是设&#92;(F[i]&#92;)表示还剩&#92;(i&#92;)个必选的物品没选的期望，则&#92;(F[i]&#92;)可以由&#92;(F[i+1],F[i-1]&#92;)分别转移过来，即&#92;(F[i]=\frac{i}{n}F[i+1]+\frac{n-i}{n}F[i+1]&#92;)，但这样不好解，需要通过&#92;(F[n]=F[n-1]+1&#92;)，一个一个方程地化。
我们换一个思路，考虑设&#92;(f[i]&#92;)表示从剩下了&#92;(i&#92;)个正确的物品没选到剩下了&#92;(i-1&#92;)个正确的物品没选的期望步数，那么首先对于小于等于&#92;(K&#92;)的&#92;(i&#92;)，有&#92;(f[i]=1&#92;)，&#92;(f[n]&#92;)也是&#92;(1&#92;)，因为&#92;(n&#92;)只能向&#92;(n-1&#92;)转移。
剩下的怎么转移呢？
考虑原来之前我们定义的&#92;(F&#92;)，其实就是&#92;(f&#92;)的前缀和，那么我们试着由前缀和的式子反推一下？
&#92;[F[i]=\sum&#95;{j=1}^{i}=\frac{i}{n} \sum&#95;{j=1}^{i-1} f[j]+\frac{n-i}{n} \sum&#95;{j=1}^{i+1} f[j]+1&#92;]
发现有很多可以抵掉的，化简后得
&#92;[f[i]=\frac{i}{n}+\frac{n-i}{n}(f[i+1]+f[i]+1)&#92;]
这样就只有两个变量了，移项得到
&#92;[f[i]=\frac{n+(n-i)f[i+1]}{i}&#92;]
这样就可以从后往前递推了，因为有除以&#92;(i&#92;)，所以可以提前递推求出逆元。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int Mod=100003;
const int inf=2147483647;

int n,K;
int Light[maxN];
ll Inv[maxN];
ll g[maxN];

int main()
{
    ll Fac=1;//阶乘
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Light[i]),Fac=Fac*i%Mod;
    int tot=0;
    for (int i=n;i&gt;=1;i--)
        if (Light[i])
        {
            for (int j=1;j*j&lt;=i;j++)
            {
                if (i%j==0) Light[j]^=1;
                if ((i%j==0)&amp;&amp;(j*j!=i)) Light[i/j]^=1;
            }
            tot++;
        }
    if (tot&lt;=K)//当tot&lt;=K时直接输出解
    {
        printf("%lld\n",tot*Fac%Mod);
        return 0;
    }
    //预处理逆元
    Inv[1]=1;for (int i=2;i&lt;=n;i++) Inv[i]=(ll)(Mod-Mod/i)*Inv[Mod%i]%Mod;
    //求解
    //先处理i&lt;=K的
    for (int i=1;i&lt;=K;i++) g[i]=1;
    g[n]=1;
    //再递推
    for (int i=n-1;i&gt;K;i--) g[i]=(ll)((n-i)*g[i+1]%Mod+n)%Mod*Inv[i]%Mod;
    ll Ans=0;
    for (int i=tot;i&gt;=1;i--) Ans=(Ans+g[i])%Mod;
    printf("%lld\n",Ans*Fac%Mod);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>491</wp:post_id>
		<wp:post_date><![CDATA[2018-02-06 20:15:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-06 12:15:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4872-luogu3750shoi2017%e5%88%86%e6%89%8b%e6%98%af%e7%a5%9d%e6%84%bf%ef%bc%88%e6%9c%9f%e6%9c%9b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e9%80%86%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<category domain="post_tag" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[182]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4554/Luogu2825][Tjoi2016&amp;Heoi2016]游戏（网络流，二分图）</title>
		<link>http://sycstudio.com/archives/492</link>
		<pubDate>Wed, 07 Feb 2018 12:21:31 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=492</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在2016年，佳缘姐姐喜欢上了一款游戏，叫做泡泡堂。简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小H想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。给定一张n&#42;m的网格地图:其中&#42;代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。x代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。#代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出1&#42;4的网格地图&#42;xx&#42;，这个地图上最多只能放置一个炸弹。给出另一个1&#42;4的网格地图&#42;x#&#42;，这个地图最多能放置两个炸弹。现在小H任意给出一张n&#42;m的网格地图，问你最多能放置多少炸弹

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4554">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2825">Luogu</a>

<h3>Tag</h3>

网络流，二分图

<h2>解决思路</h2>

若没有硬石头的限制，就是一个比较简单的二分图模型，对于每一行每一列连边求最大匹配即可。
但由于有了硬石头的限制，我们可以把每一行以硬石头为界分成若干块，每一列同理，相当于拆点，再按照二分图模型连边。
这里就用网络流了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=52;
const int maxN=maxMap*maxMap*2;
const int maxM=maxN*20;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
char Input[maxMap][maxMap];
int Idx[maxMap][maxMap],Idy[maxMap][maxMap];
int nodecnt=0,edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
bool Con[maxN];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%s",Input[i]+1);
    for (int i=1;i&lt;=n;i++)//接下来这两个循环分别把行和列分成若干快
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='#')
            {
                Idx[i][j]=-1;
                continue;
            }
            if ((j==1)||(Input[i][j-1]=='#'))
            {
                Idx[i][j]=++nodecnt;
                continue;
            }
            Idx[i][j]=nodecnt;
        }
    for (int j=1;j&lt;=m;j++)
        for (int i=1;i&lt;=n;i++)
        {
            if (Input[i][j]=='#')
            {
                Idy[i][j]=-1;
                continue;
            }
            if ((i==1)||(Input[i-1][j]=='#'))
            {
                Idy[i][j]=++nodecnt;
                continue;
            }
            Idy[i][j]=nodecnt;
        }
    S=nodecnt+1;T=nodecnt+2;
    for (int i=1;i&lt;=n;i++)//二分图连边
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='#') continue;
            if (Input[i][j]=='*') Add_Edge(Idx[i][j],Idy[i][j],1);
            if (Input[i][j]=='*')
            {
                if (Con[Idx[i][j]]==0)
                {
                    Con[Idx[i][j]]=1;
                    Add_Edge(S,Idx[i][j],1);
                }
                if (Con[Idy[i][j]]==0)
                {
                    Con[Idy[i][j]]=1;
                    Add_Edge(Idy[i][j],T,1);
                }
            }
        }
    int Ans=0;//求解最大流
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans+=di;
    }
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>492</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 20:21:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 12:21:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4554-luogu2825tjoi2016heoi2016%e6%b8%b8%e6%88%8f%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[189]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3993/Luogu3324][SDOI2015]星际战争（网络流，二分）</title>
		<link>http://sycstudio.com/archives/493</link>
		<pubDate>Wed, 07 Feb 2018 12:26:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=493</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

3333年，在银河系的某星球上，X军团和Y军团正在激烈地作战。在战斗的某一阶段，Y军团一共派遣了N个巨型机器人进攻X军团的阵地，其中第i个巨型机器人的装甲值为Ai。当一个巨型机器人的装甲值减少到0或者以下时，这个巨型机器人就被摧毁了。X军团有M个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人Bi的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y军团看到自己的巨型机器人被X军团一个一个消灭，他们急需下达更多的指令。为了这个目标，Y军团需要知道X军团最少需要用多长时间才能将Y军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3993">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3324">Luogu</a>

<h3>Tag</h3>

网络流，二分

<h2>解决思路</h2>

二分需要多少时间，转化成判定型问题。
网络流建模，从源点连到激光武器容量为这段时间武器总共的攻击输出（没错你没有看错容量是实数），从巨型机器人连到汇点连机器人的血量。求最大流看是否与血量之和相等。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=120;
const int maxM=maxN/2*maxN/2*10;
const ld eps=1e-5;
const int inf=500000;

class Edge
{
public:
    int v;ld flow;
};

int n,m,S,T;
int A[maxN],B[maxN];
int sumA;
int Atta[51][51];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,ld flow);
bool Check(ld tim);
bool Bfs();
ld dfs(int u,ld flow);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]),sumA+=A[i];
    for (int i=1;i&lt;=m;i++) scanf("%d",&amp;B[i]);
    S=n+m+1;T=n+m+2;
    for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) scanf("%d",&amp;Atta[i][j]);
    ld l=0,r=50100;
    ld Ans=0;
    do
    {
        ld mid=(l+r)/(ld)2;
        if (Check(mid)) Ans=mid,r=mid-eps;
        else l=mid+eps;
    }
    while (fabs(r-l)&gt;=eps);
    printf("%.6LF\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,ld flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Check(ld tim)//二分判定
{
    edgecnt=-1;mem(Head,-1);
    for (int i=1;i&lt;=n;i++) Add_Edge(i+m,T,(ld)A[i]);
    for (int i=1;i&lt;=m;i++) Add_Edge(S,i,(ld)B[i]*tim);
    for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) if (Atta[i][j]) Add_Edge(i,j+m,inf);
    ld mxflow=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (1)
        {
            ld di=dfs(S,inf);
            mxflow+=di;
            if (fabs(di)&lt;=eps) break;
        }
    }
    if (fabs(mxflow-sumA)&lt;=eps) return 1;
    return 0;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            if ((fabs(E[i].flow)&gt;=eps)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
        }
    }
    while (h!=t);
    if (Depth[T]==-1) return 0;
    return 1;
}

ld dfs(int u,ld flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((Depth[E[i].v]==Depth[u]+1)&amp;&amp;(fabs(E[i].flow)&gt;eps))
        {
            ld di=dfs(E[i].v,min(flow,E[i].flow));
            if (fabs(di)&gt;eps)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>493</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 20:26:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 12:26:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3993-luogu3324sdoi2015%e6%98%9f%e9%99%85%e6%88%98%e4%ba%89%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[181]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU1512/ZOJ2334/SCU3080/Luogu1456]Monkey King（左偏树，并查集）</title>
		<link>http://sycstudio.com/archives/494</link>
		<pubDate>Wed, 07 Feb 2018 13:40:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=494</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Once in a forest, there lived N aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can't avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.
Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, 10 will be reduced to 5 and 5 will be reduced to 2).
And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1512">HDU</a>
<a href="https://vjudge.net/problem/ZOJ-2334">ZOJ</a>
<a href="https://vjudge.net/problem/SCU-3080">SCU</a>
<a href="https://www.luogu.org/problemnew/show/P1456">Luogu</a>

<h3>Tag</h3>

左偏树，并查集

<h2>题目大意</h2>

有若干只猴子，开始互相都不认识，两只不认识的猴子会从让它们认识的猴子中最厉害的猴子来打一架，然后就互相认识了。打架的猴子厉害值除以二，求每一次打完架后这些刚刚认识的猴子中最厉害的。

<h2>解决思路</h2>

左偏树实现可并堆，每次取堆顶分离出来，除以二再加进去，合并堆。并查集维护一只猴子所在的堆的根方便查找。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class HeapData
{
public:
    int key;
    int ch[2],dis;
    void init()
        {
            ch[0]=ch[1]=dis=0;
            return;
        }
};

int n,m;
int UFS[maxN];//并查集
HeapData H[maxN];

int Merge(int x,int y);//左偏树合并
void Div(int x);//把x(保证是一棵左偏树的根)的值除以二再放回去
int Find(int x);

int main()
{
    while (scanf("%d",&amp;n)!=EOF)
    {
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;H[i].key),H[i].init(),UFS[i]=i;
        int m;scanf("%d",&amp;m);
        while (m--)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            if (Find(x)==Find(y))
            {
                printf("-1\n");
                continue;
            }
            x=Find(x);y=Find(y);
            if (H[x].key&lt;H[y].key) swap(x,y);
            Div(x);Div(y);x=Find(x);y=Find(y);//堆顶除以二后再找到新的堆顶
            int nrt=Merge(x,y);//合并
            UFS[x]=UFS[y]=nrt;
            printf("%d\n",H[nrt].key);
        }
    }
}

int Merge(int x,int y)
{
    if (x==0) return y;
    if (y==0) return x;
    if (H[x].key&lt;H[y].key) swap(x,y);
    H[x].ch[1]=Merge(H[x].ch[1],y);
    if (H[H[x].ch[0]].dis&lt;H[H[x].ch[1]].dis) swap(H[x].ch[0],H[x].ch[1]);
    if (H[x].ch[1]) H[x].dis=H[H[x].ch[1]].dis+1;
    else H[x].dis=0;
    return x;
}

void Div(int x)
{
    if ((H[x].ch[0]==0)&amp;&amp;(H[x].ch[1]==0))//特判只有一个元素的情况
    {
        H[x].key/=2;
        return;
    }
    int nrt=Merge(H[x].ch[0],H[x].ch[1]);//先把左右子树合并
    UFS[nrt]=nrt;UFS[x]=x;//修改并查集
    if (nrt==H[x].ch[0]) if (H[x].ch[1]) UFS[H[x].ch[1]]=nrt;
    if (nrt==H[x].ch[1]) if (H[x].ch[0]) UFS[H[x].ch[0]]=nrt;
    H[x].init();H[x].key/=2;//分离出来后，处理根
    int nnrt=Merge(x,nrt);//再把根合并回去
    UFS[nrt]=UFS[x]=nnrt;//再修改并查集关系
    return;
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>494</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 21:40:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 13:40:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu1512-zoj2334-scu3080-luogu1456monkey-king%ef%bc%88%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="scu"><![CDATA[SCU]]></category>
		<category domain="post_tag" nicename="scu"><![CDATA[SCU]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[151]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SNMOJ280]Atom-wwt by dsl</title>
		<link>http://sycstudio.com/archives/500</link>
		<pubDate>Sat, 10 Feb 2018 14:55:31 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=500</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

<a href="http://sycstudio.com/prob" title="题面">题面</a>

<h1>Solution</h1>

考虑到一个串是一个子串的情况只可能是他在 &#92;(fail&#92;) 树上的祖先或者是回文树上的祖先。

所以把回文树和&#92;(fail&#92;)树拼在一起，每次二分最大权值，跑最长反链覆盖，判断覆盖数是否大于等于 &#92;(k&#92;) 即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
const int maxn = 100005, Maxn = 1000005, Inf = 1 &lt;&lt; 30;

struct edge {
    int nt, to, flow, cap; 
} g[3000005];
struct Edge{
    int u,v; 
} e[1000005];

int head[maxn], q[maxn], d[maxn], a[maxn], S, T, n, k, cnt, num, ans;
char s[maxn];

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

int len[maxn], fail[maxn], ch[maxn][26], mxl[maxn], tot, last;

inline void add(int n, int c)
{
    int x = last; 
    while (s[n - len[x] - 1] != s[n]) x = fail[x];
    if (!ch[x][c]) {
        int v = ++tot, k = fail[x]; 
        while (s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
    }
    last = ch[x][c]; return;
}

inline void insert(int from, int to, int cap)
{
    g[++num] = (edge) {head[from], to, 0, cap}; head[from] = num;
    g[++num] = (edge) {head[to], from, 0, 0}; head[to] = num;
}

int bfs(int S, int T)
{
    memset(d, 0, sizeof(int) * (T + 1));
    int h = 0, t = 1; q[t] = S; d[S] = 1;
    while (h &lt; t) {
        int x = q[++h], v;
        for (int i = head[x]; i; i = g[i].nt) {
            v = g[i].to;
            if (!d[v] &amp;&amp; g[i].cap &gt; g[i].flow) {
                d[v] = d[x] + 1; q[++t] = v;
                if (v==T) return 1;
            }
        }
    }
    return d[T];
}

inline int dfs(int x, int T, int a)
{
    if (!a || x == T) return a; 
    int f, flow = 0;
    for(int i =head[x], v; i; i = g[i].nt) 
        if (d[v = g[i].to] == d[x] + 1 &amp;&amp; g[i].cap &gt; g[i].flow) {
            f = dfs(v, T, min(a, g[i].cap - g[i].flow));
            if (!f) {d[v] = -1; continue;}
            g[i].flow += f; g[i ^ 1].flow -= f;
            flow += f; a -= f; if (!a) return flow;
        }
    return flow;
}

inline bool check(int key)
{
    memset(head, 0, sizeof(head));
    num = 1; S = 2 * tot + 1; T = S + 1; 
    int sum = 0;
    for (int i = 2; i &lt;= tot; ++i) {
        if (mxl[i] &gt;= key) ++sum, insert(S, i, 1), insert(i + tot, T, 1);
        insert(i + tot, i, Inf);
    }
    for (int i = 1; i &lt;= cnt; ++i) insert(e[i].u, e[i].v + tot, 1);
    int flow = 0; 
    while (bfs(S, T)) flow += dfs(S, T, Inf);
    return sum - flow &gt;= k;
}

#define mid ((l + r) &gt;&gt; 1)
int main()
{
    freopen("atom.in", "r", stdin);
    freopen("atom.out", "w", stdout);
    n=gi(); k=gi(); scanf("%s", s + 1);
    for (int i = 1; i &lt;= n; ++i) a[i] = gi();
    len[fail[0] = tot = 1] = -1;
    for (int i = 1; i &lt;= n; ++i)
        add(i, s[i] - 'a'), mxl[last] = max(mxl[last], a[i]);

    for (int i=tot;i;--i)
        mxl[fail[i]]=max(mxl[fail[i]],mxl[i]);

    for(int i = tot; i; --i)
        mxl[fail[i]] = max(mxl[fail[i]], mxl[i]);

    for (int i = 2; i &lt;= tot; ++i)
        for (int j = 0; j &lt; 26; ++j)
            if (ch[i][j]) e[++cnt] = (Edge) {i, ch[i][j]};

    for (int i = tot; i; --i) if (fail[i]) e[++cnt] = (Edge) {fail[i], i};
    sort(a + 1, a + n + 1), n = unique(a + 1, a + n + 1) -  a - 1; 
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        if (check(a[mid])) ans = a[mid], l = mid + 1; 
        else r = mid - 1;
    }

    if (ans) printf("%d\n", ans);
    else puts("NEGATIVE"); 

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>500</wp:post_id>
		<wp:post_date><![CDATA[2018-02-10 22:55:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-10 14:55:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[snmoj280atom-wwt]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="snmoj"><![CDATA[SNMOJ]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[回文树/回文自动机]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[271]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1061/Luogu3980][Noi2008]志愿者招募（网络流，单纯型）</title>
		<link>http://sycstudio.com/archives/502</link>
		<pubDate>Sun, 11 Feb 2018 14:26:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=502</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti 天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1061">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3980">Luogu</a>

<h3>Tag</h3>

网络流，单纯型

<h2>解决思路</h2>

又是一道网络流神题。先看一个例子
假设总共&#92;(5&#92;)天，有四类志愿者，分别是&#92;(1-2,1-5,2-4,3-5&#92;)，设&#92;(P[i]&#92;)表示第&#92;(i&#92;)天需要的人数，&#92;(P[i]'&#92;)表示第&#92;(i&#92;)天实际的人数，&#92;(X[i]&#92;)表示第&#92;(i&#92;)类志愿者的人数，则有下列不等式组
&#92;[P[1]'=X[1]+X[2]>=P[1] &#92;&#92; P[2]'=X[1]+X[2]+X[3]>=P[2] &#92;&#92; P[3]'=X[2]+X[3]+X[4]>=P[3] &#92;&#92; P[4]'=X[2]+X[3]+X[4]>=P[4] &#92;&#92; P[5]'=X[2]+X[4]>=P[5]&#92;]
对每一个式子补充一个&#92;(Y[i]&#92;)把不等式变成等式
&#92;[P[1]'=X[1]+X[2]-Y[1]=P[1] &#92;&#92; P[2]'=X[1]+X[2]+X[3]-Y[2]=P[2] &#92;&#92; P[3]'=X[2]+X[3]+X[4]-Y[3]=P[3] &#92;&#92; P[4]'=X[2]+X[3]+X[4]-Y[4]=P[4] &#92;&#92; P[5]'=X[2]+X[4]-Y[5]=P[5]&#92;]
设有&#92;(P[0]=P[6]=0&#92;)，相邻两式相减，得到
&#92;[P[1]'-P[0]'=X[1]+X[2]-Y[1]=P[1] &#92;&#92; P[2]'-P[1]'=X[3]-Y[2]+Y[1]=P[2]-P[1] &#92;&#92; P[3]'-P[2]'=X[4]-Y[3]-X[1]+Y[2]=P[3]-P[2] &#92;&#92; P[4]'-P[3]'=-Y[4]+Y[3]=P[4]-P[3] &#92;&#92; P[5]'-P[4]'=-Y[5]-X[3]+Y[4]=P[5]-P[4] &#92;&#92; P[6]'-P[5]'=-X[2]-X[4]+Y[5]=-P[5] &#92;]
发现，每一个&#92;(X[i]&#92;)和每一个&#92;(Y[i]&#92;)都在这些式子中恰好出现了一次。并且这些式子的和为&#92;(0&#92;)，这里有没有想到与网络流的流量平衡有一些关系？
把左边去掉，留下中间的和右边的，移项得到
&#92;[P[1]-X[1]-X[2]+Y[1]=0 &#92;&#92; P[2]-P[1]-X[3]+Y[2]-Y[1]=0 &#92;&#92; P[3]-P[2]-X[4]+Y[3]+X[1]-Y[2]=0 &#92;&#92; P[4]-P[3]+Y[4]-Y[3]=0 &#92;&#92; P[5]-P[4]+Y[5]+X[3]-Y[4]=0 &#92;&#92; P[6]-P[5]+X[2]+X[4]-Y[5]=0&#92;]
这样，把每一个等式看作一个点，前面符号为&#92;(+&#92;)的为流入的流量，符号为&#92;(-&#92;)的为流出的流量，当出入平衡时，这个方程组就有解。而&#92;(P[i]-P[i-1]&#92;)的常数项就相当于与源汇点连的边，这个值为正则是从源点流出来的，否则则是流向汇点的。
观察到对于一类可以从第&#92;(i&#92;)天到第&#92;(j&#92;)天的志愿者，他对应的&#92;(X[]&#92;)在第&#92;(i&#92;)个等式中为负，在第&#92;(j+1&#92;)个等式中为正，那么就从&#92;(i&#92;)到&#92;(j+1&#92;)连一条容量为无穷大费用为志愿者费用的边。对于&#92;(Y[i]&#92;)则同理，只是此时是没有费用的。建完图后跑最小费用流即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxM=(10100+maxN*2)*2;
const int maxQueue=maxN*10;
const int inf=2147483647;
const ll INF=1e15;

class Edge
{
public:
    ll u,v,flow,w;
};

int n,m,S,T;
int Pl[maxN];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
ll Dist[maxN],inqueue[maxN],Queue[maxQueue];
ll Flow[maxN],Path[maxN];

void Add_Edge(int u,int v,int flow,int w);
bool spfa();

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);S=n+2;T=n+3;
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Pl[i]);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v+1,inf,w);//对于每一类志愿者分别连边
    }
    for (int i=1;i&lt;=n+1;i++)
    {
        int p=Pl[i]-Pl[i-1];//对于常数项，讨论正负性分别与源汇点连边
        if (p&gt;=0) Add_Edge(S,i,p,0);
        if (p&lt;0) Add_Edge(i,T,-p,0);
        if (i&gt;1) Add_Edge(i,i-1,inf,0);//这里连Y的边
    }
    ll Ans=0;
    while (spfa())
    {
        Ans=Ans+Dist[T]*Flow[T];
        int now=T;
        while (now!=S)
        {
            E[Path[now]].flow-=Flow[T];
            E[Path[now]^1].flow+=Flow[T];
            now=E[Path[now]].u;
        }
    }
    printf("%lld\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow,int w)
{
    //cout&lt;&lt;"Add:"&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;flow&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].u=u;E[edgecnt].v=v;E[edgecnt].w=w;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].u=v;E[edgecnt].v=u;E[edgecnt].w=-w;E[edgecnt].flow=0;
    return;
}

bool spfa()
{
    mem(inqueue,0);
    for (int i=1;i&lt;=T;i++) Dist[i]=INF;
    int h=1,t=0;Queue[1]=S;Dist[S]=0;inqueue[S]=1;Flow[S]=inf;
    do
    {
        t++;if (t&gt;=maxQueue) t=0;
        int u=Queue[t];
        //cout&lt;&lt;"u:"&lt;&lt;u&lt;&lt;endl;
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;E[i].v&lt;&lt;" "&lt;&lt;E[i].flow&lt;&lt;" "&lt;&lt;E[i].w&lt;&lt;endl;
            if ((E[i].flow&gt;0)&amp;&amp;(Dist[E[i].v]&gt;Dist[u]+E[i].w))
            {
                Dist[E[i].v]=Dist[u]+E[i].w;
                Path[E[i].v]=i;Flow[E[i].v]=min(Flow[u],E[i].flow);
                if (inqueue[E[i].v]==0)
                {
                    h++;if (h&gt;=maxQueue) h=0;
                    inqueue[Queue[h]=E[i].v]=1;
                }
            }
        }
        inqueue[u]=0;
    }
    while (t!=h);
    //for (int i=1;i&lt;=T;i++) cout&lt;&lt;Dist[i]&lt;&lt;" ";cout&lt;&lt;endl;
    if (Dist[T]==INF) return 0;
    return 1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>502</wp:post_id>
		<wp:post_date><![CDATA[2018-02-11 22:26:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-11 14:26:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1061-luogu3980noi2008%e5%bf%97%e6%84%bf%e8%80%85%e6%8b%9b%e5%8b%9f%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e5%8d%95%e7%ba%af%e5%9e%8b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[165]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3140/Luogu3231][Hnoi2013]消毒（二分图）</title>
		<link>http://sycstudio.com/archives/503</link>
		<pubDate>Sun, 11 Feb 2018 15:08:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=503</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近在生物实验室工作的小T遇到了大麻烦。
由于实验室最近升级的缘故，他的分格实验皿是一个长方体,其尺寸为a&#42;b&#42;c，a、b、c 均为正整数。为了实验的方便，它被划分为a&#42;b&#42;c个单位立方体区域，每个单位立方体尺寸为1&#42;1&#42;1。用(i,j,k)标识一个单位立方体，1 ≤i≤a，1≤j≤b，1≤k≤c。这个实验皿已经很久没有人用了，现在，小T被导师要求将其中一些单位立方体区域进 行消毒操作（每个区域可以被重复消毒）。而由于严格的实验要求，他被要求使用一种特定 的F试剂来进行消毒。 这种F试剂特别奇怪，每次对尺寸为x&#42;y&#42;z的长方体区域（它由x&#42;y&#42;z个单位立方体组 成）进行消毒时，只需要使用min{x,y,z}单位的F试剂。F试剂的价格不菲，这可难倒了小 T。现在请你告诉他，最少要用多少单位的F试剂。(注：min{x,y,z}表示x、y、z中的最小 者。)

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3140">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3231">Luogu</a>

<h3>Tag</h3>

二分图

<h2>解决思路</h2>

首先要知道，不需要消毒的地方也是可以消毒的！这是前提。
考虑如果某一维我们取&#92;(1&#92;)，那么剩下的两维取最大是最优的，那么也就是说我们可以一次消毒一层。
那么如果是两维，根据上面的贪心，我们每一次消掉一行或一列是最优的，那么这就变成了选择若干行或若干列使得所有需要消毒的格子都被包含进去。把行和列分别看作两个集合，对于需要消毒的格子&#92;(x,y&#92;)，从行的&#92;(x&#92;)连边到&#92;(y&#92;)，求最小点覆盖，即选出最少的点使得所有的边都至少有一个端点在点集中。在二分图中，最小点覆盖&#92;(=&#92;)最大匹配。所以对于二维的，直接匈牙利算法求解最大匹配。
但现在是三维，那么会出现的情况就是某几层可能是直接一层一层消去的，考虑到&#92;(a&#42;b&#42;c&#92;)最多只有&#92;(5000&#92;)，也就是说这三个数中最小的不会超过&#92;(17&#92;)，那么可以枚举最小这一维，枚举其中每一层是直接一层地消毒还是用另外两维来消。直接消的就统计层数即可，剩下的由于我们上面的贪心原则，可以把剩下的所有面全部压缩到一个平面上，这样就变成二维的情况了，运用匈牙利算法解决。
注意在应该&#92;(continue&#92;)的地方都要可行性剪枝。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=6000;
const int maxM=maxN*2;
const int inf=2147483647;

class Pos
{
public:
    int x,y,z;
};

int a,b,c,nodecnt,nowdepth=0;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int vis[maxN],Match[maxN];
Pos P[maxN];

void Add_Edge(int u,int v);
int dfs(int u);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        for (int i=1;i&lt;=a;i++) for (int j=1;j&lt;=b;j++) for (int k=1;k&lt;=c;k++)
                                                      {
                                                          int opt;scanf("%d",&amp;opt);
                                                          if (opt==1) P[++nodecnt]=(Pos){i,j,k};
                                                      }
        //这里是为了保证a&lt;b&lt;c，方便后面的枚举
        if (a&gt;b){
            swap(a,b);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].x,P[i].y);
        }
        if (a&gt;c){
            swap(a,c);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].x,P[i].z);
        }
        if (b&gt;c){
            swap(b,c);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].y,P[i].z);
        }
        int Ans=inf;
        for (int S=0;S&lt;(1&lt;&lt;a);S++)//枚举哪些层直接整层消毒
        {
            edgecnt=0;for (int i=1;i&lt;=c;i++) Head[i]=Match[i]=-1;
            int ret=0;
            for (int i=1;i&lt;=a;i++) if ((S&amp;(1&lt;&lt;(i-1)))!=0) ret++;//直接消毒的，每一层的代价都是1
            if (ret&gt;=Ans) continue;
            for (int i=1;i&lt;=nodecnt;i++) if ((S&amp;(1&lt;&lt;(P[i].x-1)))==0) Add_Edge(P[i].y,P[i].z);//建二分图
            for (int i=1;i&lt;=c;i++)//匈牙利算法
            {
                nowdepth++;
                ret+=dfs(i);
                if (ret&gt;=Ans) break;
            }
            Ans=min(Ans,ret);
        }
        printf("%d\n",Ans);
    }
    return 0;
}

int dfs(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]!=nowdepth)
        {
            vis[V[i]]=nowdepth;
            if ((Match[V[i]]==-1)||(dfs(Match[V[i]])))
            {
                Match[V[i]]=u;return 1;
            }
        }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>503</wp:post_id>
		<wp:post_date><![CDATA[2018-02-11 23:08:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-11 15:08:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3140-luogu3231hnoi2013%e6%b6%88%e6%af%92%ef%bc%88%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[145]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>后缀自动机的一点点理解 by yyb</title>
		<link>http://sycstudio.com/archives/505</link>
		<pubDate>Tue, 13 Feb 2018 03:04:19 +0000</pubDate>
		<dc:creator><![CDATA[yyb]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=505</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>后缀自动机的一点点理解</h1>

<a href="http://www.cnblogs.com/cjyyb/p/8446205.html">潜在可能格式挂了，yyb博客地址</a>

<h2>前言</h2>

最近心血来潮，想学学SAM，于是花了一晚上+一上午
勉强打了出来（但是还是不理解）
虽说张口就讲我做不到
但是一些其他的东西还是有所感触的
索性，乱口胡点东西，谢谢关于SAM的一些简单的理解

<h2>资料</h2>

<a href="https://max.book118.com/html/2016/1007/57498384.shtm">丽洁姐WC PPT</a>
<a href="http://hihocoder.com/problemset/problem/1441">hihocoder上的后缀自动机</a>

<h2>一些概念</h2>

这些概念都不读懂，接下来真的是步履维艰

本来我们要的是一个能够处理所有后缀的数据结构
但是我们发现，如果对于每一个后缀都要插入进Trie树
空间复杂度完全背不动（$$O(n^2)$$级别）
于是，后缀自动机出现了
后缀自动机相比于Trie树
在空间上有了很大的改善，他的空间复杂度是$$O(n)$$级别的
（详见丽洁姐的PPT）

杂七杂八的没有什么太多写的必要，网上一找一大堆
写写一些概念

<h3>right/endpos</h3>

hihocoder上写的是$$endpos$$集合
其他的大部分地方写的是$$right$$集合
这就是最基础的概念了
叫做$$endpos$$的话应该很好理解，所以我就写$$endpos$$吧
$$endpos$$就是一个子串结束位置组成的集合
对于所有结束位置相同的子串
也就是$$endpos$$相同的两个子串
他们一个一定是另一个的后缀

至于证明，简单的想一下，如果一个子串出现在了若干个位置
那么他的后缀也一定出现在了这些位置（只可能出现在更多未知，不可能更少）

同时，得到了一个推论：
两个字符串如果有一个是另一个的后缀，
那么，较长串的$$endpos$$一定是较短串的$$endpos$$的子集
（就是上面写的，只可能多，不可能少）
同样的，如果没有后缀的关系，那么它们的$$endpos$$的交集一定是空集

而后缀自动机的每个节点就是依照$$endpos$$来划分
对于$$endpos$$相同的子串，我们可以划分在一起
我们不难得出一点，对于一堆$$endpos$$相同的子串
他们一定互为后缀，并且他们长度连续

首先证明互为后缀，那就是上面的那个推论，
如果不是互为后缀的话，$$endpos$$就不可能相等
而长度连续？
既然互为后缀，那就一定有一个最长的串，不妨记为$$longest$$
那么，所有的其他串一定是他的后缀
随着后缀长度的减小，
那么从某一个后缀开始，就可能出现在了更多的位置
那么，这个后缀以及比它更短的后缀的$$endpos$$一定会变大
此时他们就会分到别的节点去了
因此，具有相同$$endpos$$的子串一定长度连续，互为后缀
另外一个简单的结论，确定了$$endpos$$和长度$$len$$就能确定唯一的子串

<h3>trans</h3>

$$trans$$不难理解是转移的意思
设$$trans(s,c)$$表示当前在$$s$$状态，接受一个字符$$c$$之后所到达的状态
一个状态$$s$$表示若干$$endpos$$相同的连续子串
那么，此时相当于在后面加上了一个字符$$c$$
那么，我们对于任意一个串直接加上一个字符$$c$$之后
组成的串的$$endpos$$还是相同的
所以$$trans(s,c)$$就会指向这个状态
换句话说，随便在当前状态$$s$$中找一个串（比如$$longest$$）
然后在后面接上一个$$c$$
那么，就指向包含这个新字符串的状态

<h3>Parent/Suffix Links</h3>

本质上也是一个东西，不同的地方写的不一样而已
不妨设一个状态中包含的最短的串叫做$$shortest$$
那么，我们就知道$$shortest$$的任意一个非自己的后缀一定就会出现在了更多位置
他的最长的那个后缀，也就是减去了第一个字符后的串
就会出现在另外一个状态里面，并且是那个状态的$$longest$$
为什么？因为出现在了更多的位置，我们还是知道他是连续的子串
如果存在一个更长的串
那么，只可能是当前状态的$$shortest$$，
但是$$shortest$$属于当前状态，而没有出现在更多的位置
因此，$$longest$$一定是当前状态的$$shortest$$减去最前面字符形成的串

那么，当前位置的$$parent$$就会指向那个状态

当然，还是有几个很有趣的性质
假设当状态是$$s$$
$$s.shortest.len=parent.longest.len+1$$
这个就是前面所说的东西，所以，对于每个状态，就没有必要记录$$shortest$$
因为你只要知道$$parent$$就可以算出来了

其次，$$s$$的$$endpos$$是$$parent$$的子集
这个不难证明，因为$$parent$$包含了更多的位置

如果$$trans(s,c)\neq NULL$$
那么，$$trans(parent,c)\neq NULL$$
因为如果$$trans(s,c)$$存在这个状态
那么$$parent$$的串加上$$c$$之后，一定还是$$s+c$$后的后缀
所以也一定存在$$trans(parent,c)$$
所以，你可以认为$$parent$$是一个完全包含了$$s$$的状态
也正因为如此，$$parent$$的$$endpos$$就是所有儿子$$endpos$$的并集

将所有的$$parent$$反过来，我们就得到了$$parent$$树
如果要处理什么，就需要$$parent$$树的拓扑序
（因为$$parent$$相当于包含了所有的他的子树，都需要更新上去）
其实不需要拓扑排序
我们知道$$s$$的$$endpos$$完全被$$parent$$的$$endpos$$包含
$$s.longest$$一定长于$$parent.longest$$
所以，一个状态的$$longest$$越长，它一定要被更先访问
所以，按照$$longest$$的长度进行桶排序就可以解决拓扑序了

<h3>extend</h3>

对于一个$$SAM$$的构造
我们当然在线了（因为我只会这个）
我们依次加入字符$$c$$，来进行构造

假设原来的字符串是$$T$$
首先，一定会有一个新节点
因为新加入了一个字符后，一定出现了这个新的字符串$$T+c$$
此时$$endpos$$一定是新的位置
同时，原来的$$T$$的最后一个位置也可以通过$$+c$$变到这个新位置
设原来的最后一个位置的状态是$$last$$，新的状态是$$np$$
所以$$trans(last,c)=np$$
根据前面的东西，我们知道$$last$$的祖先们一定也会有这个$$trans$$
我们要怎么解决他呀

令$$p=last$$
一直沿着$$parent$$往前跳，也就是不断令$$p=p.parent$$
所以$$p$$代表的，就是越来越短的$$T$$的后缀
因为要更新的是最后的位置，
只有当存在$$T$$的最后一个位置时才能更新

如果$$trans(p,c)=NULL$$，直接令$$trans(p,c)=np$$
很显然是可以直接在后面添加一个$$c$$到达$$np$$的
如果跳完后发现没有$$parent$$了，直接把$$np.parent$$指向$$1$$
也就是空串所代表的状态

如果某个$$trans(p,c)$$不为$$NULL$$
那么，设$$q=trans(p,c)$$
如果有$$longest(p)+1=longest(q)$$
什么意思？
在$$p$$的串后面添上一个$$c$$之后就是$$q$$状态
没有任何问题，直接在作为$$T$$的后缀的那一个子串上
直接添加一个$$c$$显然也可以到达$$q$$状态
又因为$$np$$所代表的$$endpos$$更小，
所以$$np.parent=q$$

在否则的话
也就是$$longest(q)>longest(p)+1$$
具体的反例看丽洁姐PPT第$$35$$页
如果直接插入的话（也就是$$np.parent=q$$）
相当于给$$q$$的$$endpos$$强行插入一个$$q$$
但是，我们发现，如果强行插入进去
这个$$T+c$$的后缀会出现在更多的位置，应该属于另外一个状态
然后就$$GG$$了
此时，我们新建一个点$$nq$$
相当于把$$q$$拆成两部分：
一部分是$$T+c$$的那个后缀，一个是$$longest(p)+c$$
也就是$$longest(nq)=longest(p)+1$$
显然$$T+c$$的后缀是包含了状态较少的，
拆分出来的一部分$$q$$是长度较长的
所以$$q.parent=np.parent=nq$$
同时，继续沿着$$p$$的$$parent$$往上走
把所有的$$q$$都替换成$$nq$$

看起来很有道理，但是我也是似懂非懂的感觉

<h2>End</h2>

这就是我自己的一些没有什么用的总结了
我觉得题目才能真正反映SAM的作用
到时候再补点题目上去

补一份后缀自动机$$extend$$的代码

<pre><code class="language-cpp ">int tot=1,last=1;
struct Node
{
    int son[26];
    int ff,len;
}t[MAX&lt;&lt;1];
void extend(int c)
{
    int p=last,np=++tot;last=np;
    t[np].len=t[p].len+1;
    while(p&amp;&amp;!t[p].son[c])t[p].son[c]=np,p=t[p].ff;
    if(!p)t[np].ff=1;
    else
    {
        int q=t[p].son[c];
        if(t[p].len+1==t[q].len)t[np].ff=q;
        else
        {
            int nq=++tot;
            t[nq]=t[q];t[nq].len=t[p].len+1;
            t[q].ff=t[np].ff=nq;
            while(p&amp;&amp;t[p].son[c]==q)t[p].son[c]=nq,p=t[p].ff;
        }
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>505</wp:post_id>
		<wp:post_date><![CDATA[2018-02-13 11:04:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-13 03:04:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba%e7%9a%84%e4%b8%80%e7%82%b9%e7%82%b9%e7%90%86%e8%a7%a3-by-yyb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[后缀自动机]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[508]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>95</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.61.45]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 14:57:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 06:57:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你跑到这里占萝卜坑干嘛]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>96</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.180.93]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 14:59:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 06:59:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是您查水表的理由]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>95</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>97</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[222.240.92.29]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 22:08:38]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 14:08:38]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[强！！向yyb学习]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>98</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.121.69.85]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 22:09:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 14:09:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是掩盖您是大佬的理由]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>97</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>99</wp:comment_id>
			<wp:comment_author><![CDATA[xzz_233]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xuzhouzi@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.55.67]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-14 22:57:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-14 14:57:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[为什么我自己不膜拜我自己这个巨♂佬]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>98</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>102</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 21:07:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 13:07:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[难道称赞同学都不行吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>99</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ4003/Luogu3261][JLOI2015]城池攻占（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/507</link>
		<pubDate>Fri, 16 Feb 2018 05:12:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=507</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小铭铭最近获得了一副新的桌游，游戏中需要用 m 个骑士攻占 n 个城池。
这 n 个城池用 1 到 n 的整数表示。除 1 号城池外，城池 i 会受到另一座城池 fi 的管辖，其中 fi  i。也就是说，所有城池构成了一棵有根树。这 m 个骑士用 1 到 m 的整数表示，其中第 i 个骑士的初始战斗力为 si，第一个攻击的城池为 ci。每个城池有一个防御值 hi，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 1 号城池，或牺牲为止。除 1 号城池外，每个城池 i 会给出一个战斗力变化参数 ai;vi。若 ai =0，攻占城池 i 以后骑士战斗力会增加 vi；若 ai =1，攻占城池 i 以后，战斗力会乘以 vi。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4003">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3261">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>解决思路</h2>

考虑到每一个骑士是单独算的，那么我们可以用堆来维护到达每一个点的骑士的攻击值，弹出那些不能攻占的，剩下的打上乘或加的标记。
那么考虑到有把堆合并的操作，这里采用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=300100;
const int inf=2147483647;

class Heap//左偏树
{
public:
    ll key,plus,mul;//plus加标记，mul乘标记
    int ch[2],dis;
    Heap()
        {
            plus=0;mul=1;
            return;
        }
};

int n,m;
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];
int Id[maxN];//这里用Id表示树上某个点对应的堆的根节点
ll Def[maxN],Opt[maxN],Val[maxN],Depth[maxN];
int St[maxN],Ed[maxN],Fail[maxN];//St记录每一个骑士出发的点，Ed记录每一个骑士牺牲的点，两点深度之差就是骑士攻占的城市个数，Fail记录在某城市牺牲的骑士个数
Heap H[maxN];

int Merge(int r1,int r2);
void PushDown(int rt);//标记下放
void Mark(int rt,ll plus,ll mul);//标记
void dfs(int u);//dfs从下到上合并

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Def[i]);
    for (int i=2;i&lt;=n;i++)
    {
        int fa;scanf("%d%lld%lld",&amp;fa,&amp;Opt[i],&amp;Val[i]);
        edgecnt++;Next[edgecnt]=Head[fa];Head[fa]=edgecnt;V[edgecnt]=i;
    }
    for (int i=1;i&lt;=m;i++)
    {
        scanf("%lld%d",&amp;H[i].key,&amp;St[i]);
        if (Id[St[i]]==0) Id[St[i]]=i;
        else Id[St[i]]=Merge(Id[St[i]],i);
    }
    Depth[1]=1;dfs(1);
    for (int i=1;i&lt;=n;i++) printf("%d\n",Fail[i]);
    for (int i=1;i&lt;=m;i++) printf("%lld\n",Depth[St[i]]-Depth[Ed[i]]);
    return 0;
}

int Merge(int r1,int r2)//左偏树合并核心操作
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    PushDown(r1);PushDown(r2);
    if (H[r1].key&gt;H[r2].key) swap(r1,r2);
    H[r1].ch[1]=Merge(H[r1].ch[1],r2);
    if (H[H[r1].ch[0]].dis&lt;H[H[r1].ch[1]].dis) swap(H[r1].ch[0],H[r1].ch[1]);
    if (H[r1].ch[1]) H[r1].dis=H[H[r1].ch[1]].dis+1;
    else H[r1].dis=0;
    return r1;
}

void PushDown(int rt)
{
    if (H[rt].ch[0]) Mark(H[rt].ch[0],H[rt].plus,H[rt].mul);
    if (H[rt].ch[1]) Mark(H[rt].ch[1],H[rt].plus,H[rt].mul);
    H[rt].mul=1;H[rt].plus=0;return;
}

void Mark(int rt,ll plus,ll mul)
{
    H[rt].key=H[rt].key*mul+plus;
    H[rt].plus=H[rt].plus*mul+plus;
    H[rt].mul=H[rt].mul*mul;
    return;
}

void dfs(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        Depth[V[i]]=Depth[u]+1,dfs(V[i]);
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        if (Id[V[i]]==0) continue;
        if (Id[u]==0) Id[u]=Id[V[i]];
        else Id[u]=Merge(Id[u],Id[V[i]]);
    }
    while ((Id[u])&amp;&amp;(H[Id[u]].key&lt;Def[u]))
    {
        Fail[u]++;Ed[Id[u]]=u;
        PushDown(Id[u]);Id[u]=Merge(H[Id[u]].ch[0],H[Id[u]].ch[1]);
    }
    if (Id[u])
    {
        if (Opt[u]==0) Mark(Id[u],Val[u],1);
        if (Opt[u]==1) Mark(Id[u],0,Val[u]);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>507</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:12:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:12:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4003-luogu3261jloi2015%e5%9f%8e%e6%b1%a0%e6%94%bb%e5%8d%a0%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[194]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1087/Luogu1896][SCOI2005]互不侵犯King（动态规划，状态压缩）</title>
		<link>http://sycstudio.com/archives/508</link>
		<pubDate>Fri, 16 Feb 2018 05:24:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=508</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上
左下右上右下八个方向上附近的各一个格子，共8个格子。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1087">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1896">Luogu</a>

<h3>Tag</h3>

动态规划，状态压缩

<h2>解决思路</h2>

设&#92;(F[i][j][S]&#92;)表示处理到第&#92;(i&#92;)行，当前摆放了&#92;(j&#92;)个国王，当前行状态为&#92;(S&#92;)的方案数，枚举上一行的合法方案累加转移即可。
为了方便，可以先预处理出某一行每一种拜访方式是否合法，以及有几个国王。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10;
const int inf=2147483647;

int n,K;
ll F[maxN][maxN*maxN][1&lt;&lt;maxN];
bool Put[1&lt;&lt;maxN];//标记某一种状态是否可行
int Num[1&lt;&lt;maxN];//某一状态摆了多少个王

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=0;i&lt;(1&lt;&lt;n);i++)//预处理
        if ((i&amp;(i&lt;&lt;1))==0)
        {
            Put[i]=1;
            for (int j=0;j&lt;n;j++) if (((1&lt;&lt;j)&amp;i)!=0) Num[i]++;
            F[1][Num[i]][i]=1;
        }
    for (int i=2;i&lt;=n;i++)
        for (int j=0;j&lt;=K;j++)
            for (int S=0;S&lt;(1&lt;&lt;n);S++)//枚举当前行状态
                if (Put[S]==1)
                    for (int S2=0;S2&lt;(1&lt;&lt;n);S2++)//枚举上一行状态
                        if ((Put[S2]==1)&amp;&amp;((S&amp;S2)==0)&amp;&amp;(j-Num[S]&gt;=0)&amp;&amp;((S&amp;(S2&lt;&lt;1))==0)&amp;&amp;(((S&lt;&lt;1)&amp;S2)==0))
                            F[i][j][S]=(F[i][j][S]+F[i-1][j-Num[S]][S2]);
    ll Ans=0;
    for (int i=0;i&lt;(1&lt;&lt;n);i++) Ans=Ans+F[n][K][i];
    printf("%lld\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>508</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:24:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:24:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1087-luogu1896scoi2005%e4%ba%92%e4%b8%8d%e4%be%b5%e7%8a%afking%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[状态压缩动态规划]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[167]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1801/Luogu2051][Ahoi2009]chess 中国象棋（动态规划）</title>
		<link>http://sycstudio.com/archives/509</link>
		<pubDate>Fri, 16 Feb 2018 05:33:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=509</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在N行M列的棋盘上，放若干个炮可以是0个，使得没有任何一个炮可以攻击另一个炮。 请问有多少种放置方法，中国像棋中炮的行走方式大家应该很清楚吧.

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1801">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2051">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

考虑中国象棋中炮的攻击方式，发现其实就是要求任意一行或任意一列不能摆放超过两个炮。并且我们发现，每一个炮具体摆的位置不影响最后的结果，只贡献组合数。那么我们枚举行，考虑列。
设&#92;(F[i][j][k]&#92;)表示当前处理到第&#92;(i&#92;)行，前&#92;(i&#92;)行中，一个炮都没有的列有&#92;(j&#92;)个，只有一个炮的列有&#92;(k&#92;)个，分别转移。
首先，这一行可以什么也不摆，那就直接转移到&#92;(F[i+1][j][k]&#92;)。
可以选择摆一个炮，那么这个炮可以摆在原来一个炮都没有的某一列，转移到&#92;(F[i+1][j-1]&#92;[k+1]&#92;)，并乘上方案数&#92;(j&#92;)；同理，这一个炮也可以摆在原来已经有一个炮的某一列上，转移到&#92;(F[i+1][j][k-1]&#92;)，并乘上方案数&#92;(k&#92;)。
那么摆两个炮的也是同理，分为两个都摆在原来一个炮丢没有的列上、两个都摆在原来已经有一个的列上和一个在没有一个在已经有一个的列上，这三种情况讨论，乘上对应的系数。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101;
const int Mod=9999973;
const int inf=2147483647;

int n,m;
ll F[maxN][maxN][maxN];

ll QPow(ll x,ll cnt);

int main()
{
    int inv2=QPow(2,Mod-2);
    scanf("%d%d",&amp;n,&amp;m);
    F[0][m][0]=1;
    for (ll i=0;i&lt;n;i++)
        for (ll p1=0;p1&lt;=m;p1++)
            for (ll p2=0;p1+p2&lt;=m;p2++)
            {
                if (F[i][p1][p2]==0) continue;
                F[i+1][p1][p2]=(F[i+1][p1][p2]+F[i][p1][p2])%Mod;//什么都不放
                if (p1&gt;=1) F[i+1][p1-1][p2+1]=(F[i+1][p1-1][p2+1]+F[i][p1][p2]*(ll)p1%Mod)%Mod;//在空的某一列摆上一个
                if (p2&gt;=1) F[i+1][p1][p2-1]=(F[i+1][p1][p2-1]+F[i][p1][p2]*(ll)p2%Mod)%Mod;//在有一个的某一列摆上一个
                if (p1&gt;=2) F[i+1][p1-2][p2+2]=(F[i+1][p1-2][p2+2]+1ll*F[i][p1][p2]*p1%Mod*(p1-1ll)%Mod*inv2%Mod)%Mod;//在两列空的上面分别摆上一个
                if (p2&gt;=2) F[i+1][p1][p2-2]=(F[i+1][p1][p2-2]+1ll*F[i][p1][p2]*p2%Mod*(p2-1ll)%Mod*inv2%Mod)%Mod;//在两个已经摆了一个的上面再分别摆一个
                if ((p1&gt;=1)&amp;&amp;(p2&gt;=1)) F[i+1][p1-1][p2]=(F[i+1][p1-1][p2]+1ll*F[i][p1][p2]*p1%Mod*p2%Mod)%Mod;//在空列和摆了一个的一列摆上一个
            }
    int Ans=0;
    for (int p1=0;p1&lt;=m;p1++)
        for (int p2=0;p1+p2&lt;=m;p2++)
            Ans=(Ans+F[n][p1][p2])%Mod;
    printf("%d\n",Ans);
    return 0;
}

ll QPow(ll x,ll cnt)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>509</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:33:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:33:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1801-luogu2051ahoi2009chess-%e4%b8%ad%e5%9b%bd%e8%b1%a1%e6%a3%8b%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[213]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2809/Luogu1552][Apio2012]dispatching（可并堆，左偏树，贪心）</title>
		<link>http://sycstudio.com/archives/511</link>
		<pubDate>Sat, 17 Feb 2018 12:31:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=511</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。
在这个帮派里，有一名忍者被称之为Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。
现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。
写一个程序，给定每一个忍者i的上级Bi，薪水Ci，领导力Li，以及支付给忍者们的薪水总预算M，输出在预算内满足上述要求时顾客满意度的最大值。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2809">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1552">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树，贪心

<h2>解决思路</h2>

由于满意度是派遣的忍者总数&#42;管理者的领导水平，并且管理者可以不被派遣，那么得到一个贪心的做法，就是从大往小删去尽量少的忍者，这样就可以保证数量最大。
为了方便取大，可以用堆来实现。又是树的结构，那么就可以用可并堆来实现从儿子向父亲的合并，这里用左偏树实现。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class Heap
{
public:
    ll key;
    int ch[2],dis;
};

int n,M,root;
int Id[maxN];//Id记录树上编号为i的点对应此时在左偏树中的根
ll Ans,Sum[maxN],Mast[maxN],Size[maxN];//Sum记录和，Size记录忍者数量
Heap H[maxN];
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];

void dfs(int u);
int Merge(int r1,int r2);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;M);
    for (int i=1;i&lt;=n;i++)
    {
        Id[i]=i;
        int fa;scanf("%d%lld%lld",&amp;fa,&amp;H[i].key,&amp;Mast[i]);
        if (fa==0){//初始化
            root=i;continue;
        }
        edgecnt++;Next[edgecnt]=Head[fa];Head[fa]=edgecnt;V[edgecnt]=i;
    }
    dfs(root);
    printf("%lld\n",Ans);
    return 0;
}

void dfs(int u)//dfs从下往上求解
{
    Sum[u]=H[u].key;Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        dfs(V[i]);
        Sum[u]+=Sum[V[i]];Size[u]+=Size[V[i]];
    }
    for (int i=Head[u];i!=-1;i=Next[i])//合并
        Id[u]=Merge(Id[u],Id[V[i]]);
    while (Sum[u]&gt;M)//删去大的
    {
        Sum[u]-=H[Id[u]].key;Size[u]--;
        Id[u]=Merge(H[Id[u]].ch[0],H[Id[u]].ch[1]);
    }
    Ans=max(Ans,Size[u]*Mast[u]);
    return;
}

int Merge(int r1,int r2)
{
    if (r2==0) return r1;
    if (r1==0) return r2;
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].ch[1]=Merge(H[r1].ch[1],r2);
    if (H[H[r1].ch[0]].dis&lt;H[H[r1].ch[1]].ch[1]) swap(H[r1].ch[0],H[r1].ch[1]);
    if (H[r1].ch[1]) H[r1].dis=H[H[r1].ch[1]].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>511</wp:post_id>
		<wp:post_date><![CDATA[2018-02-17 20:31:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-17 12:31:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2809-luogu1552apio2012dispatching%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%8c%e8%b4%aa%e5%bf%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[159]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4071/Luogu3644][Apio2015]巴邻旁之桥 （线段树，数论，离散化）</title>
		<link>http://sycstudio.com/archives/512</link>
		<pubDate>Sat, 17 Feb 2018 13:14:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=512</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 A 和区域 B。
每一块区域沿着河岸都建了恰好 1000000001 栋的建筑，每条岸边的建筑都从 0 编号到 1000000000。相邻的每对建筑相隔 1 个单位距离，河的宽度也是 1 个单位长度。区域 A 中的 i 号建筑物恰好与区域 B 中的 i 号建筑物隔河相对。
城市中有 N 个居民。第 i 个居民的房子在区域 Pi 的 Si 号建筑上，同时他的办公室坐落在 Qi 区域的 Ti 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 K 座横跨河流的大桥。
由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。当政府建造最多 K 座桥之后，设 Di 表示第 i 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 D1+D2+⋯+DN 最小。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4071">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3644">Luogu</a>

<h3>Tag</h3>

线段树，数论，离散化

<h2>解决思路</h2>

看到&#92;(K&#92;)的数据范围，要根据&#92;(K==1&#92;)和&#92;(K==2&#92;)分别讨论。
先把只在一边的单独算掉，排除在外。
首先&#92;(K==1&#92;)的情况，只有一座桥，那么就是所有人都要经过这个桥，假设这个桥的位置是pos，那么式子就是&#92;(\sum (|A[i]-pos|+|B[i]-pos|)&#92;)，直接把&#92;(A[i]&#92;)和&#92;(B[i]&#92;)放在一起排序求出中位数即可。
然后是&#92;(K==2&#92;)的情况。有了前面的例子，我们可以知道，一个人一定是走离自己两边位置的中位数更近的那一座桥，那么可以把人按照中位数排序，枚举分割成两部分，两部分分别按照&#92;(K==1&#92;)的方式来算。
那么接下来的问题就是动态求中位数，这里用权值线段树的方式来求，具体来说就是找到中间的&#92;(rank&#92;)，分割查看左边的大小与当前要查询的&#92;(rank&#92;)作比较，如果左边大于&#92;(rank&#92;)则走左边，否则走右边，类似于平衡树中求第&#92;(K&#92;)大。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500100;
const int inf=2147483647;
const ll INF=1e18;

ll size,Num[maxN];//离散化并排序去重后的值域

class Segment//权值线段树
{
public:
    ll S[maxN*4];//记录区间数量和
    ll Sum[maxN*4];//记录区间权值和
    Segment()
        {
            mem(S,0);
        }
    void Modify(int now,int l,int r,int pos,ll opt)//单点修改
        {
            if (l==r){
                S[now]+=opt;Sum[now]+=opt*Num[l];return;
            }
            int mid=(l+r)&gt;&gt;1;
            if (pos&lt;=mid) Modify(now*2,l,mid,pos,opt);
            if (pos&gt;=mid+1) Modify(now*2+1,mid+1,r,pos,opt);
            S[now]=S[now*2]+S[now*2+1];Sum[now]=Sum[now*2]+Sum[now*2+1];
            return;
        }
    int GetMid()//得到中位数
        {
            return Querymid(1,1,size,S[1]/2);
        }
    int Querymid(int now,int l,int r,int q)//查询中位数
        {
            if (l==r) return l;
            int mid=(l+r)&gt;&gt;1;
            if (S[now*2]&gt;=q) return Querymid(now*2,l,mid,q);
            else return Querymid(now*2+1,mid+1,r,q-S[now*2]);
        }
    ll Querysum(int now,int l,int r,int ql,int qr)//查询区间和
        {
            if ((l==ql)&amp;&amp;(r==qr)) return Sum[now];
            int mid=(l+r)&gt;&gt;1;
            if (qr&lt;=mid) return Querysum(now*2,l,mid,ql,qr);
            if (ql&gt;=mid+1) return Querysum(now*2+1,mid+1,r,ql,qr);
            return Querysum(now*2,l,mid,ql,mid)+Querysum(now*2+1,mid+1,r,mid+1,qr);
        }
    ll Querycnt(int now,int l,int r,int ql,int qr)//查询区间数字个数
        {
            if ((l==ql)&amp;&amp;(r==qr)) return S[now];
            int mid=(l+r)&gt;&gt;1;
            if (qr&lt;=mid) return Querycnt(now*2,l,mid,ql,qr);
            if (ql&gt;=mid+1) return Querycnt(now*2+1,mid+1,r,ql,qr);
            return Querycnt(now*2,l,mid,ql,mid)+Querycnt(now*2+1,mid+1,r,mid+1,qr);
        }
};

class RANGE
{
public:
    ll l,r;
};

bool operator &lt; (RANGE A,RANGE B){//定义排序规则为按照中位数排序
    return A.l+A.r&lt;B.l+B.r;
}

ll n,pl,K;
ll Ans=0;
ll L[maxN],R[maxN];
Segment S1,S2;
RANGE Range[maxN];

int Find(int key);

int main()
{
    ios::sync_with_stdio(false);//这一题输入如果用scanf好像有奇怪的错误，似乎是因为交替输入了字符和数字，所以这里用cin
    cin&gt;&gt;K&gt;&gt;n;
    for (int i=1;i&lt;=n;i++)
    {
        char opt1,opt2;ll a,b;
        cin&gt;&gt;opt1&gt;&gt;a&gt;&gt;opt2&gt;&gt;b;
        if (opt1==opt2) Ans=Ans+abs(a-b);//在同一边的就直接加
        else
        {
            if (a&gt;b) swap(a,b);
            pl++;L[pl]=a;R[pl]=b;
        }
    }
    if (K==1)//k=1直接排序处理
    {
        for (int i=pl+1;i&lt;=pl+pl;i++) L[i]=R[i-pl];
        sort(&amp;L[1],&amp;L[pl+pl+1]);
        int pos=L[pl];
        for (int i=1;i&lt;=pl+pl;i++) Ans=Ans+abs(L[i]-pos);
        printf("%lld\n",Ans+1ll*pl);
    }
    if (K==2)
    {
        if (pl==0){//特判剩余没有人的情况
            printf("%lld\n",Ans);
            return 0;
        }
        for (int i=1;i&lt;=pl;i++){
            Num[i]=L[i];Num[i+pl]=R[i];
            Range[i].l=L[i];Range[i].r=R[i];
        }
        sort(&amp;Num[1],&amp;Num[pl+pl+1]);size=unique(&amp;Num[1],&amp;Num[pl+pl+1])-Num-1;sort(&amp;Range[1],&amp;Range[pl+1]);//离散化，同时将人排序

        for (int i=1;i&lt;=pl;i++) S2.Modify(1,1,size,Find(Range[i].l),1),S2.Modify(1,1,size,Find(Range[i].r),1);//先把所有人都丢入第二棵线段树

        ll Ans2;int mid=S2.GetMid();//得到只建一座桥的答案
        Ans2=Num[mid]*S2.Querycnt(1,1,size,1,mid)-S2.Querysum(1,1,size,1,mid)+S2.Querysum(1,1,size,mid,size)-Num[mid]*S2.Querycnt(1,1,size,mid,size);

        for (int i=1;i&lt;=pl;i++)
        {
            S1.Modify(1,1,size,Find(Range[i].l),1);S1.Modify(1,1,size,Find(Range[i].r),1);
            S2.Modify(1,1,size,Find(Range[i].l),-1);S2.Modify(1,1,size,Find(Range[i].r),-1);
            int md1=S1.GetMid(),md2=S2.GetMid();
            ll nowans
                =Num[md1]*S1.Querycnt(1,1,size,1,md1)-S1.Querysum(1,1,size,1,md1)+S1.Querysum(1,1,size,md1,size)-Num[md1]*S1.Querycnt(1,1,size,md1,size)
                +Num[md2]*S2.Querycnt(1,1,size,1,md2)-S2.Querysum(1,1,size,1,md2)+S2.Querysum(1,1,size,md2,size)-Num[md2]*S2.Querycnt(1,1,size,md2,size);
            Ans2=min(Ans2,nowans);
        }
        printf("%lld\n",Ans+Ans2+pl);
    }
    return 0;
}

int Find(int key)
{
    int l=1,r=size,ret=0;
    do
    {
        int mid=(l+r)&gt;&gt;1;
        if (Num[mid]&lt;=key) ret=mid,l=mid+1;
        else r=mid-1;
    }
    while (l&lt;=r);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>512</wp:post_id>
		<wp:post_date><![CDATA[2018-02-17 21:14:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-17 13:14:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4071-luogu3644apio2015%e5%b7%b4%e9%82%bb%e6%97%81%e4%b9%8b%e6%a1%a5-%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e6%95%b0%e8%ae%ba%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[165]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5709]Claris Loves Painting（线段树合并，主席树）</title>
		<link>http://sycstudio.com/archives/513</link>
		<pubDate>Sun, 18 Feb 2018 09:07:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=513</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Claris loves painting very much, so he painted a tree with beautiful colors.
The tree is a rooted tree with n nodes which are conveniently labeled by 1,2,...,n. Its root is the 1-st node, and the i-th node is painted with color ci. If ci=cj, then we think these two nodes have the same color.
We define depthi as the distance between the i-th node and the root, and simply, the distance between two adjacent nodes is always 1.
Standing in front of this beautiful tree, Claris comes up with m questions.
In each question, there are two integers x and d, which means that Claris wants to know the number of different kinds of colors occur in S, where S={v|v in x′s subtree and depthv≤depthx+d}.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5709">HDU</a>

<h3>Tag</h3>

线段树合并，主席树

<h2>题目大意</h2>

一棵有根树，树上每一个点有可能相同的颜色，现在要求回答若干个询问，求在&#92;(u&#92;)的子树内与&#92;(u&#92;)相距不超过&#92;(d&#92;)的点有多少种颜色。强制在线。

<h2>解决思路</h2>

先不考虑颜色的限制，假设问题是询问在一个点的子树中与&#92;(u&#92;)相距不超过&#92;(d&#92;)的节点个数，那么这个可以用线段树来维护。具体来说，对于每一个点维护一棵线段树，线段树维护的区间&#92;([l,r]&#92;)表示深度在&#92;([l,r]&#92;)内的节点个数。这个可以直接从儿子线段树合并转移过来。
再考虑加上颜色的限制。由于一种颜色只算一次，不妨我们对于每一种颜色就只算深度最浅的那个，那么我们对于每一个点再维护一棵线段树，这个树中的第&#92;(i&#92;)号位置维护在这棵子树内颜色为&#92;(i&#92;)的最浅的点的深度，那么，合并的时候就取两者中更浅的那个点作为当前的值，然后由于这时颜色有了冲突，于是再修改第一棵线段树中的值，具体来说就是在第一棵线段树中把更深的那个减掉，因为如果我们依次合并的话一次只会有一个冲突。
直接这么做是会爆空间的，考虑到实际从下往上合并的时候，实际用到的空间并不多，并且还有很多重复，所以可以借助主席树的思想，动态开点并重复利用已知信息。
另外，由于题目中给出了一个点的父亲编号小于自己的编号，所以树&#92;(dfs&#92;)可以直接用&#92;(for&#92;)代替。
少用&#92;(memset&#92;)。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class SegmentData
{
public:
    int key,ls,rs;
};

int n,m,nodecnt;
int Fa[maxN],Col[maxN],Depth[maxN];//父节点，颜色，深度
SegmentData S[maxN*110];//线段树
int T1[maxN],T2[maxN];//分别对应两棵线段树的根

int Modify(int rt,int l,int r,int pos,int opt);//修改
int Merge1(int r1,int r2,int l,int r);//合并第一棵线段树
int Merge2(int r1,int r2,int l,int r,int u);//合并第二棵线段树
int Query(int now,int l,int r,int d);//查询深度小于d的颜种数

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Col[i]);
        for (int i=2;i&lt;=n;i++) scanf("%d",&amp;Fa[i]);
        Depth[1]=1;for (int i=2;i&lt;=n;i++) Depth[i]=Depth[Fa[i]]+1;//得到深度
        for (int i=1;i&lt;=n;i++)//初始化每一棵线段树
        {
            T1[i]=Modify(0,1,n,Depth[i],1);//注意这里的0
            T2[i]=Modify(0,1,n,Col[i],Depth[i]);
        }
        for (int i=n;i&gt;=2;i--)//把子树信息合并
        {
            T1[Fa[i]]=Merge1(T1[Fa[i]],T1[i],1,n);
            T2[Fa[i]]=Merge2(T2[Fa[i]],T2[i],1,n,Fa[i]);
        }
        int lastans=0;
        for (int i=1;i&lt;=m;i++)
        {
            int u,dep;scanf("%d%d",&amp;u,&amp;dep);
            u^=lastans;dep^=lastans;
            printf("%d\n",lastans=Query(T1[u],1,n,min(Depth[u]+dep,n)));
        }
    }
    return 0;
}

int Modify(int rt,int l,int r,int pos,int opt)
{
    int nrt=++nodecnt;S[nrt].key=S[rt].key+opt;
    if (l==r) return nrt;
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) S[nrt].ls=Modify(S[rt].ls,l,mid,pos,opt),S[nrt].rs=S[rt].rs;
    else S[nrt].ls=S[rt].ls,S[nrt].rs=Modify(S[rt].rs,mid+1,r,pos,opt);
    return nrt;
}

int Merge1(int r1,int r2,int l,int r)
{
    if ((r1==0)||(r2==0)) return r1+r2;
    int nrt=++nodecnt;S[nrt].key=S[r1].key+S[r2].key;
    if (l==r) return nrt;
    int mid=(l+r)&gt;&gt;1;
    S[nrt].ls=Merge1(S[r1].ls,S[r2].ls,l,mid);
    S[nrt].rs=Merge1(S[r1].rs,S[r2].rs,mid+1,r);
    return nrt;
}

int Merge2(int r1,int r2,int l,int r,int u)
{
    if ((r1==0)||(r2==0)) return r1+r2;
    int nrt=++nodecnt;
    if (l==r)
    {
        if (S[r1].key&gt;S[r2].key){
            S[nrt].key=S[r2].key;T1[u]=Modify(T1[u],1,n,S[r1].key,-1);
        }
        else{
            S[nrt].key=S[r1].key;T1[u]=Modify(T1[u],1,n,S[r2].key,-1);
        }
        return nrt;
    }
    int mid=(l+r)&gt;&gt;1;
    S[nrt].ls=Merge2(S[r1].ls,S[r2].ls,l,mid,u);
    S[nrt].rs=Merge2(S[r1].rs,S[r2].rs,mid+1,r,u);
    return nrt;
}

int Query(int now,int l,int r,int d)
{
    if (now==0) return 0;
    if (r&lt;=d) return S[now].key;
    int mid=(l+r)&gt;&gt;1;
    int ret=Query(S[now].ls,l,mid,d);
    if (d&gt;=mid+1) ret+=Query(S[now].rs,mid+1,r,d);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>513</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 17:07:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 09:07:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5709claris-loves-painting%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6"><![CDATA[线段树合并]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6"><![CDATA[线段树合并]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[484]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5818]Joint Stacks（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/514</link>
		<pubDate>Sun, 18 Feb 2018 13:31:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=514</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

A stack is a data structure in which all insertions and deletions of entries are made at one end, called the "top" of the stack. The last entry which is inserted is the first one that will be removed. In another word, the operations perform in a Last-In-First-Out (LIFO) manner.
A mergeable stack is a stack with "merge" operation. There are three kinds of operation as follows:
- push A x: insert x into stack A
- pop A: remove the top element of stack A
- merge A B: merge stack A and B

After an operation "merge A B", stack A will obtain all elements that A and B contained before, and B will become empty. The elements in the new stack are rearranged according to the time when they were pushed, just like repeating their "push" operations in one stack. See the sample input/output for further explanation.
Given two mergeable stacks A and B, implement operations mentioned above.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5818">HDU</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>题目大意</h2>

维护一个“可并栈”，要求支持弹入、弹出和合并的操作，合并两个栈后，新栈的元素排列按照原来两个栈中的时间戳从大往小排列。

<h2>解决思路</h2>

看到合并两个栈的方式，发现就是按照时间戳排序，直接用可并堆维护即可，堆中用于比较大小的是时间戳。
这里使用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int inf=2147483647;

class Heap
{
public:
    int key,wth;//值，时间戳
    int ls,rs,dis;
    void init(){
            ls=rs=dis=0;return;
        }
};

int n;
Heap H[maxN];

int Merge(int r1,int r2);

int main()
{
    int cas=0;
    ios::sync_with_stdio(false);
    while (scanf("%d",&amp;n))
    {
        if (n==0) break;
        printf("Case #%d:\n",++cas);
        int rt[3],nodecnt=0,tim=0;
        rt[1]=rt[2]=0;//初始化
        char opt[20];
        while (n--)
        {
            cin&gt;&gt;opt;
            if ((opt[0]=='p')&amp;&amp;(opt[1]=='u'))//加入一个元素
            {
                char hp;int key;cin&gt;&gt;hp&gt;&gt;key;hp=hp-'A'+1;
                tim++;nodecnt++;
                H[nodecnt].init();
                H[nodecnt].key=key;H[nodecnt].wth=tim;
                rt[hp]=Merge(rt[hp],nodecnt);
            }
            if ((opt[0]=='p')&amp;&amp;(opt[1]=='o'))//弹出
            {
                char hp;cin&gt;&gt;hp;hp=hp-'A'+1;
                printf("%d\n",H[rt[hp]].key);
                rt[hp]=Merge(H[rt[hp]].ls,H[rt[hp]].rs);
            }
            if (opt[0]=='m')//合并
            {
                char hp1,hp2;cin&gt;&gt;hp1&gt;&gt;hp2;
                hp1=hp1-'A'+1;hp2=hp2-'A'+1;
                rt[hp1]=Merge(rt[hp1],rt[hp2]);
                rt[hp2]=0;
            }
        }
    }
    return 0;
}

int Merge(int r1,int r2)
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    if (H[r1].wth&lt;H[r2].wth) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>514</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 21:31:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 13:31:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5818joint-stacks%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[221]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU3031]To Be Or Not To Be（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/515</link>
		<pubDate>Sun, 18 Feb 2018 13:46:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=515</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

That's a question. Now Happy (Xi Yangyang) has been caught by Wolffy (Hui Tailang). As Wolffy is busy preparing the big meal, a good idea comes to Happy. He proposes a game that only Wolffy had won, he can eat Happy. Wolffy always believes he is the cleverest one, so they reach a consensus. And they both agree with Wolnie (Hong Tailang) when the referee. A theater will be beat to die by Wolnie's pan. 
<img src="http://sycstudio.com/media/HDU/HDU3031-1.jpeg" alt="HDU3031-1" />
The game is defined as follow.
There are multiple test cases.
In each case there are R (R &lt; 10) rounds of the game, R is an odd number to guarantee that there must be a winner in the end.
In each round: There is a pile of n (10 &lt;= n &lt;= 200) Special-cards and m (1 &lt;= m &lt;= 100) piles of Point-card on the table. The Point-card piles are ordered from 1 to m. Wolffy and Happy take turns to get one card from the top of Special-cards pile. Wolffy always takes first in the game. When all the Special-cards have been taken, the round is over and the one with more cards in the hands gains one point. If there is a tie, Wolffy gains one point.(Wolffty and Happy both have 0 point before the game).
There are 5 kinds of Special-cards besides the Point-card in the game.
0) Point-card: a card with a point X (1 &lt;= X &lt;= 2000000).
1) Challenge-card: no matter who takes this card, they both take one card with the maximum point from their own hands. After a comparison, if Happy's card has a larger point, He takes all the Wolffy's in-hands cards, vice versa; If there is a tie no more operation.
2) Loss-card: the one who takes this card, He must throw a card with the maximum point.
3) Add-card: a card with P point, the one who gets this card will make the card with maximum point P point larger, i.e. if a Point-card with X point is the maximum, its point will change to X + P. An Add-card can only work on one Point-card.
4) Exchange-card: a card with Q point. The one who gets this card must change one maximum-point card's point to Q.
5) Take-card: a card with a integer K, indicates one can get the all the cards of Kth Point-card pile. In one round no two Take-card have the same K.
You can assume that when one gets the Loss-card, Add-card, Exchange-card, He has at least one card in the hands, when one gets a Challenge-card, they both have at least one card in the hands.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-3031">HDU</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>题目大意</h2>

若干轮，每一轮给出&#92;(n&#92;)张特殊卡牌和&#92;(m&#92;)堆分值卡牌。两人轮流操作，每一次从特殊卡牌中抽出一张，使用完后丢弃。特殊卡牌有一下几种
&#92;(Challenge-card&#92;)，不管是谁抽到这一张，将两人分别数值最大的卡牌比较，分值大的一方获得另一方的所有卡牌。
&#92;(Loss-card&#92;)，抽到这一张卡牌的人要弃掉他分值最大的卡牌。
&#92;(Add-card&#92;)，抽到这一张卡牌的人将他分值最大的卡牌加上&#92;(Add-card&#92;)上对应的数值。
&#92;(Exchange-card&#92;)，抽到这一张卡牌的人将他分值最大的卡牌的分值变成&#92;(Exchange-card&#92;)上对应的分值。
&#92;(Take-card&#92;)，抽到这一张卡牌的人获得&#92;(Take-card&#92;)上数值对应的第几堆分值卡牌。
每一轮后，统计两人手中有的分值卡牌的个数，多的人得一分。
最后得分高的人胜。

<h2>解决思路</h2>

看到所有的卡牌操作，发现所有的操作都与取&#92;(max&#92;)有关，那么就想到用堆来维护两人分别的手牌。由于涉及到合并操作，那么就可以用可并堆来实现合并操作。
有部分细节需要注意。
这里使用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100*10000+100;
const int inf=2147483647;

class Heap
{
public:
    int key;
    int ls,rs,dis;
    void init(){
            ls=rs=dis=0;return;
        }
};

int R;
int n,m,Pile[maxN],Pnum[maxN];//Pile维护第i堆分值卡牌对应在可并堆中的堆顶，Pnum维护第i堆分值卡牌中卡牌的数量。
Heap H[maxN];//左偏树

int Merge(int r1,int r2);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;R)
    {
        int hap=0,wof=0;//统计两人的得分
        while (R--)
        {
            int nodecnt=0;mem(Pile,0);
            cin&gt;&gt;n&gt;&gt;m;
            for (int i=1;i&lt;=m;i++) cin&gt;&gt;Pnum[i];//输入，并把每一堆初始分值卡牌构造成堆的形式
            for (int i=1;i&lt;=m;i++)
                for (int j=1;j&lt;=Pnum[i];j++)
                {
                    ++nodecnt;H[nodecnt].init();
                    cin&gt;&gt;H[nodecnt].key;
                    Pile[i]=Merge(Pile[i],nodecnt);
                }
            int Id[3];Id[1]=Id[2]=0;//记录两个人当前手中牌的堆顶
            int Size[3];Size[1]=Size[2]=0;//记录两人手中当前牌的数量
            for (int now=1;now&lt;=n;now++)
            {
                int pl=(now-1)%2+1;//当前操作的人
                char opt;cin&gt;&gt;opt;
                if (opt=='T')//Take-card
                {
                    int kth;cin&gt;&gt;kth;
                    Id[pl]=Merge(Id[pl],Pile[kth]);
                    Size[pl]+=Pnum[kth];
                }
                if (opt=='C')//Challenge-card
                {
                    if (H[Id[2]].key&gt;H[Id[1]].key){
                        Id[2]=Merge(Id[1],Id[2]);Id[1]=0;
                        Size[2]+=Size[1];Size[1]=0;
                    }
                    else if (H[Id[1]].key&gt;H[Id[2]].key){
                        Id[1]=Merge(Id[1],Id[2]);Id[2]=0;
                        Size[1]+=Size[2];Size[2]=0;
                    }
                }
                if (opt=='L'){//Lost-card
                    Id[pl]=Merge(H[Id[pl]].ls,H[Id[pl]].rs);Size[pl]--;
                }
                if (opt=='A'){//Add-card
                    int key;cin&gt;&gt;key;H[Id[pl]].key+=key;
                }
                if (opt=='E')//Exchange-card
                {
                    int key;cin&gt;&gt;key;
                    int id=Id[pl];Id[pl]=Merge(H[Id[pl]].ls,H[Id[pl]].rs);
                    H[id].key=key;Id[pl]=Merge(Id[pl],id);
                }
            }
            printf("%d:%d\n",Size[1],Size[2]);
            if (Size[1]&gt;=Size[2]) wof++;
            else hap++;
        }
        if (wof&gt;hap) printf("Hahaha...I win!!\n");
        else printf("I will be back!!\n");
    }
    return 0;
}

int Merge(int r1,int r2)
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>515</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 21:46:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 13:46:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu3031to-be-or-not-to-be%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[242]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU1358/UVA1328/SPOJ PERIDO/POJ1961/ZOJ2177]Period（KMP）</title>
		<link>http://sycstudio.com/archives/516</link>
		<pubDate>Tue, 20 Feb 2018 01:50:44 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=516</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

For each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 &lt;= i &lt;= N) we want to know the largest K > 1 (if there is one) such that the prefix of S with length i can be written as A K , that is A concatenated K times, for some string A. Of course, we also want to know the period K.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1358">HDU</a>
<a href="https://vjudge.net/problem/UVA-1328">UVA</a>
<a href="https://vjudge.net/problem/SPOJ-PERIOD">SPOJ</a>
<a href="https://vjudge.net/problem/POJ-1961">POJ</a>
<a href="https://vjudge.net/problem/ZOJ-2177">ZOJ</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个字符串，求所有能表示成若干循环串的前缀以及这些前缀的循环节个数。

<h2>解决思路</h2>

我们知道&#92;(KMP&#92;)算法求出的&#92;(Next&#92;)数组表示的是这个前缀的最长相同前缀后缀，那么，如果i是&#92;(i-Next[i]&#92;)的非&#92;(1&#92;)整数倍，就说明以&#92;(i&#92;)结尾的这个前缀是一个循环串，循环节长度为&#92;(i-Next[i]&#92;)，循环节个数就为&#92;(\frac{i}{i-Next[i]}&#92;)。
为什么这样是对的呢？比如下面这个前缀
<img src="http://sycstudio.com/media/HDU/HDU1358-1.png" alt="HDU-1358-1" />
根据&#92;(Next[i]&#92;)的定义，那么前面长度为&#92;(L'&#92;)的前缀&#92;([1,L']&#92;)一定与&#92;([L'+1,2L']&#92;)这一段相同，就是下面紫色和黄色的段。
<img src="http://sycstudio.com/media/HDU/HDU1358-2.png" alt="HDU-1358-1" />
那么同理又有&#92;([2L'+1,3L']&#92;)相同，即下面黄色与橙色段。
<img src="http://sycstudio.com/media/HDU/HDU1358-3.png" alt="HDU-1358-1" />
依次类推，可知如果&#92;(L&#92;)是&#92;(L'&#92;)的倍数，那么这个前缀就一定是循环的。

<pre><code class="language-cpp ">## 代码
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n;
char str[maxN];
int F[maxN];

int main()
{
    int cas=0;
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n)
    {
        if (n==0) break;
        cin&gt;&gt;(str+1);
        F[1]=0;F[0]=-1;
        for (int i=2;i&lt;=n;i++)//得到Next数组
        {
            int j=F[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=F[j];
            if (str[j+1]==str[i]) F[i]=j+1;
            else F[i]=0;
        }
        printf("Test case #%d\n",++cas);
        for (int i=2;i&lt;=n;i++)
            if ((F[i]!=0)&amp;&amp;(i%(i-F[i])==0)) printf("%d %d\n",i,i/(i-F[i]));
        printf("\n");
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>516</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 09:50:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 01:50:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu1358-uva1328-spoj-perido-poj1961-zoj2177period%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="category" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="post_tag" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[249]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>111</wp:comment_id>
			<wp:comment_author><![CDATA[WHZ0325]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wuhaozhong0325@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://whzstudio.coding.me</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[123.160.94.7]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-08 22:25:44]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-08 14:25:44]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[图画的很清楚，感谢～～]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU6153]A Secret（KMP）</title>
		<link>http://sycstudio.com/archives/517</link>
		<pubDate>Tue, 20 Feb 2018 02:21:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=517</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Today is the birthday of SF,so VS gives two strings S1,S2 to SF as a present,which have a big secret.SF is interested in this secret and ask VS how to get it.There are the things that VS tell:
  Suffix(S2,i) = S2[i...len].Ni is the times that Suffix(S2,i) occurs in S1 and Li is the length of Suffix(S2,i).Then the secret is the sum of the product of Ni and Li.
  Now SF wants you to help him find the secret.The answer may be very large, so the answer should mod 1000000007.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-6153">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出两个串，求第二个串的每一个后缀在第一个串中出现的次数。

<h2>解决思路</h2>

首先把两个串都翻过来变成处理前缀，因为&#92;(KMP&#92;)就是处理前缀的嘛。
首先考虑一个稍微暴力一点的办法，那就是对于每一个&#92;(B&#92;)串的前缀，我们都与&#92;(A&#92;)串作一次匹配。这样的复杂度是&#92;(O(n^2)&#92;)。
复杂度为什么会这么高呢？考虑我们算了哪些重复的东西，比如若前缀&#92;(abbcdefg&#92;)在&#92;(A&#92;)串中出现了，那么&#92;(a,ab,abc,abcd,abcde,abcdef&#92;)这些都出现了，而且我们每个都算了一遍。
怎么去掉这些重复计算的呢？我们把每一个前缀出现的次数拆开，转化成算&#92;(A&#92;)串中的某一个位置对于&#92;(B&#92;)串的哪些位置有贡献，有多少贡献。
但这样还是不好算，这时借助&#92;(KMP&#92;)中&#92;(Next&#92;)的性质，即&#92;(Next[i]&#92;)表示以&#92;(i&#92;)结尾的后缀的最长相同前缀后缀，那么一定就有若&#92;(A&#92;)串中的位置&#92;(pos&#92;)能匹配&#92;(B&#92;)串以&#92;(i&#92;)结尾的前缀，那一定也能匹配以&#92;(Next[i]&#92;)结尾的前缀，依次类推，也能匹配&#92;(Next[Next[i]]&#92;)，&#92;(Next[Next[Next[i]]]&#92;)，……
所以我们只要求出&#92;(A&#92;)串的每一个位置对哪个&#92;(B&#92;)串的<strong>最长前缀</strong>有贡献。注意这里是<strong>对B串求Next</strong>然后<strong>在B串中匹配A串</strong>。求完之后，再倒过来循环把上面包含关系的贡献加上，具体来说就是记&#92;(Cnt[i]&#92;)表示前缀&#92;(i&#92;)出现的次数，那么倒着循环&#92;(i&#92;)，&#92;(Cnt[Next[i]]+=Cnt[i]&#92;)。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int Mod=1e9+7;
const int inf=2147483647;

int n1,n2;
char str1[maxN],str2[maxN];
int F[maxN];
ll Cnt[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str1+1)&gt;&gt;(str2+1);
        n1=strlen(str1+1);n2=strlen(str2+1);
        //翻转两个串
        for (int i=1;(i&lt;=n1)&amp;&amp;(i&lt;(n1-i+1));i++) swap(str1[i],str1[n1-i+1]);
        for (int i=1;(i&lt;=n2)&amp;&amp;(i&lt;(n2-i+1));i++) swap(str2[i],str2[n2-i+1]);
        F[0]=-1;F[1]=0;//求出Next数组
        for (int i=2;i&lt;=n2;i++)
        {
            int j=F[i-1];
            while ((j!=0)&amp;&amp;(str2[j+1]!=str2[i])) j=F[j];
            if (str2[j+1]==str2[i]) F[i]=j+1;
            else F[i]=0;
        }
        mem(Cnt,0);//在第二个串中匹配第一个串，同时记录贡献数
        for (int i=1,j=0;i&lt;=n1;i++)
        {
            while ((j!=0)&amp;&amp;(str2[j+1]!=str1[i])) j=F[j];
            if (str2[j+1]==str1[i]) j++,Cnt[j]++;
        }
        for (int i=n2;i&gt;=1;i--) Cnt[F[i]]+=Cnt[i];//把有包含关系的贡献数加上
        ll Ans=0;
        for (ll i=n2;i&gt;=1;i--) Ans=(Ans+Cnt[i]*i%Mod)%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>517</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 10:21:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 02:21:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu6153a-secret%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[168]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1064/Luogu1477][Noi2008]假面舞会（图论，gcd）</title>
		<link>http://sycstudio.com/archives/518</link>
		<pubDate>Tue, 20 Feb 2018 13:46:17 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=518</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为k (k≥3)类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第i 类面具的人才能看到戴第i+1 类面具的人的编号，戴第k 类面具的人能看到戴第1 类面具的人的编号。 参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。 栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第2号面具的人看到了第5 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了k≥3，所以你必须将这条信息也考虑进去。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1064">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1477">Luogu</a>

<h3>Tag</h3>

图论，gcd

<h2>解决思路</h2>

大致的思路就是找出图中所有的环，对所有的环长取&#92;(gcd&#92;)。但由于是有向图，不好直接找出所有的环及环长。那么把有向图变成带权无向图，原来&#92;(u->v&#92;)的这样一条边拆成两条边，&#92;(u->v&#92;)权值为&#92;(1&#92;)，&#92;(v->u&#92;)权值为&#92;(-1&#92;)，这样从原来某一个"联通块"的任意一点出发就可以遍历整个联通块，加上权值就可以得到每一个点对应的"深度"，这个"深度"是相对的，因为有可能有负数。那么当我们从某一个点出发碰到了一个已经存在深度的点，说明我们碰到了一个"环"，直接求&#92;(gcd&#92;)即可。由于深度可能为负，所以需要取&#92;(abs&#92;)。
最后需要注意的是，如果整张图中都不存在任意一个"环"，那么此时的答案应该是每一个联通块的最长链之和。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxM=1001000*2;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
bool vis[maxN];
int Depth[maxN],Queue[maxN],Fa[maxN];

void Add_Edge(int u,int v,int w);
int gcd(int a,int b);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int a,b;scanf("%d%d",&amp;a,&amp;b);
        Add_Edge(a,b,1);Add_Edge(b,a,-1);//添加正反两条边
    }
    int length=0,chain=0;//length记录当前所有环长的gcd，chain记录每一个联通块的最长链之和
    for (int i=1;i&lt;=n;i++)
        if (vis[i]==0)//对每一个联通块Bfs求解
        {
            Depth[i]=0;
            int h=1,t=0;Queue[1]=i;vis[i]=1;
            int mx=-inf,mn=inf;//mx和mn分别记录深度的最大值和最小值
            do
            {
                int u=Queue[++t];mx=max(mx,Depth[u]),mn=min(mn,Depth[u]);
                for (int i=Head[u];i!=-1;i=Next[i])
                {
                    if (V[i]==Fa[u]) continue;
                    if (vis[V[i]]==0) vis[Queue[++h]=V[i]]=1,Depth[V[i]]=Depth[u]+W[i],Fa[V[i]]=u;//当这个点还没有被访问，则访问
                    else//否则，说明找到了一个环，更新答案
                    {
                        if (length==0) length=abs(Depth[u]-Depth[V[i]]+W[i]);
                        else length=gcd(length,abs(Depth[u]-Depth[V[i]]+W[i]));
                    }
                }
            }
            while (h!=t);
            chain=chain+mx-mn+1;
        }
    if (length==0)//整图无环
    {
        if (chain&lt;3) printf("-1 -1\n");
        else printf("%d 3\n",chain);
    }
    else//有环
    {
        if (length&lt;3) printf("-1 -1\n");
        else
        {
            printf("%d ",length);//最大值就为环长gcd
            for (int i=3;i&lt;=length;i++) if (length%i==0) {length=i;break;}
            printf("%d\n",length);//最小值为环长的最小因数
        }
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

int gcd(int a,int b)
{
    int tmp;
    while (b) tmp=b,b=a%b,a=tmp;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>518</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 21:46:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 13:46:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1064-luogu1477noi2008%e5%81%87%e9%9d%a2%e8%88%9e%e4%bc%9a%ef%bc%88%e5%9b%be%e8%ae%ba%ef%bc%8cgcd%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[183]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1924/Luogu2403][Sdoi2010]所驼门王的宝藏（Tarjan，动态规划）</title>
		<link>http://sycstudio.com/archives/519</link>
		<pubDate>Tue, 20 Feb 2018 14:00:13 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=519</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的Alpaca L. Sotomon是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天Henry Curtis故事的起点。Henry是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。
整座宫殿呈矩阵状，由R×C间矩形宫室组成，其中有N间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这N间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：
“横天门”：由该门可以传送到同行的任一宫室；
“纵寰门”：由该门可以传送到同列的任一宫室；
“自由门”：由该门可以传送到以该门所在宫室为中心周围8格中任一宫室（如果目标宫室存在的话）。
深谋远虑的Henry当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。
现在Henry已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉Henry这条路线最多行经不同藏宝宫室的数目。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1924">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2403">Luogu</a>

<h3>Tag</h3>

Tarjan，动态规划

<h2>题目大意</h2>

在有向图上求一条可以经过重复点的经过点最多的路径。

<h2>解决思路</h2>

思路比较简单，首先&#92;(Tarjan&#92;)缩点后记录每一个缩的点的位置，然后按&#92;(Top&#92;)序在&#92;(DAG&#92;)上动态规划求出最长链。
至于实现，开始建图可以用&#92;(Map&#92;)的方式存下所有有用的点，对行和列分别建立虚点，前两种门就分别只与对应行和列的虚点连边，第三种门直接扫描周围八个点是否存在进行连边。这样做的话，&#92;(Tarjan&#92;)缩点的时候就要注意不要把虚点统计进&#92;(Size&#92;)，需要判断一下。
然后在新图上建边，注意这里最好用&#92;(Set&#92;)标记一下，以防建太多的重复边。

<h2>代码</h2>

<pre><code class="language-cpp ">//这份代码在Luogu上有三个点MLE，暂未改出
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100001*3;
const int maxMap=1000001;
const int maxM=maxN*8;
const int F1[9]={0,-1,-1,-1,0,1,1,1,0};
const int F2[9]={0,-1,0,1,1,1,0,-1,-1};
const int inf=2147483647;

int n,R,C;
int Ans=0;
int nodecnt=0,nnodecnt;
int edgecnt=-1,Head[maxN],Next[maxM],V[maxM];
map&lt;int,int&gt; Map[maxMap],Opt[maxMap];
int dfncnt=0,dfn[maxN],low[maxN],Id[maxN];

int idcnt=0,Size[maxN];
int stacktop=0,Stack[maxN];
bool instack[maxN];
int edgecnt2=0,Head2[maxN],Next2[maxN*2],V2[maxN*2],Indegree[maxN*2];
int Queue[maxN],F[maxN];
int Hang[maxMap],Lie[maxMap];
set&lt;int&gt; Set[maxN];

void Add_Edge(int u,int v);
void Add_Edge2(int u,int v);
void dfs(int u,int fa);
int GetHang(int h);
int GetLie(int l);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);mem(Head2,-1);
    cin&gt;&gt;n&gt;&gt;R&gt;&gt;C;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y,opt;cin&gt;&gt;x&gt;&gt;y&gt;&gt;opt;
        Map[x][y]=++nodecnt;Opt[x][y]=opt;//Opt记录这个宫室的类型
    }
    nnodecnt=nodecnt;
    for (int i=1;i&lt;=R;i++)
        for (map&lt;int,int&gt;::iterator j=Map[i].begin();j!=Map[i].end();j++)//建图
        {
            Add_Edge(GetHang(i),j-&gt;second);Add_Edge(GetLie(j-&gt;first),j-&gt;second);//首先从对应的行和列连边过来
            if (Opt[i][j-&gt;first]==1) Add_Edge(j-&gt;second,GetHang(i));//第一种门
            else if (Opt[i][j-&gt;first]==2) Add_Edge(j-&gt;second,GetLie(j-&gt;first));//第二种门
            else for (int f=1;f&lt;=8;f++) if (Map[i+F1[f]].count(j-&gt;first+F2[f])!=0) Add_Edge(j-&gt;second,Map[i+F1[f]][j-&gt;first+F2[f]]);//第三种门
        }
    for (int i=1;i&lt;=nodecnt;i++)//Tarjan缩点
        if (dfn[i]==0) dfs(i,i);
    for (int i=1;i&lt;=nodecnt;i++)//建立缩完点后的新图
        for (int j=Head[i];j!=-1;j=Next[j])
            if ((Id[i]!=Id[V[j]])&amp;&amp;(Set[i].count(V[j])==0))
                Add_Edge2(Id[i],Id[V[j]]),Set[i].insert(V[j]);
    int h=0,t=0;//Top序动态规划求最长链
    for (int i=1;i&lt;=idcnt;i++) if (Indegree[i]==0) Queue[++h]=i;
    do
    {
        int u=Queue[++t];
        for (int i=Head2[u];i!=-1;i=Next2[i])
        {
            F[V2[i]]=max(F[V2[i]],F[u]+Size[u]);
            Indegree[V2[i]]--;if (Indegree[V2[i]]==0) Queue[++h]=V2[i];
        }
    }
    while (t!=h);
    for (int i=1;i&lt;=idcnt;i++) Ans=max(Ans,F[i]+Size[i]);//取最优解
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void Add_Edge2(int u,int v)
{
    edgecnt2++;Next2[edgecnt2]=Head2[u];Head2[u]=edgecnt2;V2[edgecnt2]=v;
    Indegree[v]++;
    return;
}

void dfs(int u,int fa)//Tarjan
{
    dfn[u]=low[u]=++dfncnt;
    Stack[++stacktop]=u;instack[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        if (dfn[V[i]]==0){
            dfs(V[i],u);low[u]=min(low[u],low[V[i]]);
        }
        else if (instack[V[i]]) low[u]=min(low[u],dfn[V[i]]);
    }
    if (dfn[u]==low[u]){
        int size=0,v;idcnt++;
        do{
            v=Stack[stacktop--];Id[v]=idcnt;instack[v]=0;if (v&lt;=nnodecnt) size++;//注意这里if一句，是保证只有实点才被统计进Size中
        }
        while (u!=v);
        Size[idcnt]=size;
    }
    return;
}

int GetHang(int h)
{
    if (Hang[h]==0) Hang[h]=++nodecnt;
    return Hang[h];
}

int GetLie(int l)
{
    if (Lie[l]==0) Lie[l]=++nodecnt;
    return Lie[l];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>519</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 22:00:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 14:00:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1924-luogu2403sdoi2010%e6%89%80%e9%a9%bc%e9%97%a8%e7%8e%8b%e7%9a%84%e5%ae%9d%e8%97%8f%ef%bc%88tarjan%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="post_tag" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%9b%be%e4%b8%8a%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[图上动态规划]]></category>
		<category domain="category" nicename="%e5%be%85%e5%a1%ab%e5%9d%91-%e5%be%85%e6%9b%b4%e6%96%b0"><![CDATA[待填坑/待更新]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[204]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1143][CTSC2008]祭祀river（二分图）</title>
		<link>http://sycstudio.com/archives/520</link>
		<pubDate>Tue, 20 Feb 2018 14:52:57 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=520</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在遥远的东方，有一个神秘的民族，自称Y族。他们世代居住在水面上，奉龙王为神。每逢重大庆典， Y族都会在水面上举办盛大的祭祀活动。我们可以把Y族居住地水系看成一个由岔口和河道组成的网络。每条河道连接着两个岔口，并且水在河道内按照一个固定的方向流动。显然，水系中不会有环流。由于人数众多的原因，Y族的祭祀活动会在多个岔口上同时举行。出于对龙王的尊重，这些祭祀地点的选择必须非常慎重。准确地说，Y族人认为，如果水流可以从一个祭祀点流到另外一个祭祀点，那么祭祀就会失去它神圣的意义。族长希望在保持祭祀神圣性的基础上，选择尽可能多的祭祀的地点。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1143">BZOJ</a>

<h3>Tag</h3>

二分图

<h2>题目大意</h2>

给定一个&#92;(DAG&#92;)求最长反链。

<h2>解决思路</h2>

首先给出定义，&#92;(DAG&#92;)上的链指的是一个点的集合，这个点的集合满足其中任意两个点&#92;(u,v&#92;)，要么&#92;(u&#92;)能到&#92;(v&#92;)，要么&#92;(v&#92;)能到&#92;(u&#92;)。
那么反链就是指的一个点集使得其中任意两个点&#92;(u,v&#92;)都不能互相可达。
最长反链=最小链覆盖，最小链覆盖就是用最少的链使得图中每一个点都遍历到。这个证明可以参考<a href="http://vfleaking.blog.163.com/blog/static/1748076342012918105514527/">vfk的博客</a>。
那么怎么求最小链覆盖呢？最小链覆盖就是可以重复经过点的最小路径覆盖，而最小路径覆盖可以通过二分图建模的方式解决。
具体来说，对于原图的一个点&#92;(i&#92;)，拆成两个点&#92;(i,i'&#92;)，对于原图的一条边&#92;(u->v&#92;)，变成边&#92;(u->v'&#92;)，这样构成二分图。那么，总点数-最大匹配就是最小路径覆盖。为什么呢？可以想象开始的时候有&#92;(n&#92;)个点，就有&#92;(n&#92;)条路径来覆盖，每在二分图中选择了一条边&#92;(u->v'&#92;)，相当于把以&#92;(u&#92;)结尾的路径和与&#92;(v&#92;)开头的两条路径合并，又因为是最大匹配，所以不可能有路径相交，所以最大匹配数就是合并次数，总点数-合并次数就是最小路径覆盖。
那么如何从最小路径覆盖变成最小链覆盖呢？我们观察发现，用路径覆盖图的时候，有可能一条路径把另一条切断了，那么为了实现链覆盖，我们需要有一条在这条链上的边"跨过"这一条路径。没错，就是对每一个点求出它能到的点和能到它的点。这个就是传递闭包，可以用&#92;(Floyed&#92;)实现。
所以，为了把链覆盖转化为求路径覆盖，可以传递闭包后再在新图上求二分图最大匹配。
这里用匈牙利算法求二分图最大匹配。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=111;
const int maxM=1011;
const int inf=2147483647;

int n,m,dep;
int Map[maxN][maxN];
int edgecnt=0,Head[maxN*2],Next[maxN*maxN*2],V[maxN*maxN*2];
int Match[maxN*2];
int vis[maxN*2];

void Add_Edge(int u,int v);
bool Hungary(int u);//匈牙利算法求二分图最大匹配

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++){
        int u,v;cin&gt;&gt;u&gt;&gt;v;Map[u][v]=1;
    }
    for (int k=1;k&lt;=n;k++)//Floyed传递闭包
        for (int i=1;i&lt;=n;i++)
            if (Map[i][k])
                for (int j=1;j&lt;=n;j++)
                    if (Map[k][j])
                        Map[i][j]|=(Map[i][k]&amp;Map[k][j]);
    mem(Match,-1);mem(Head,-1);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (Map[i][j]) Add_Edge(i,j+n);//构造二分图
    int cnt=0;
    for (int i=1;i&lt;=n;i++) dep++,cnt+=Hungary(i);
    printf("%d\n",n-cnt);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

bool Hungary(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]!=dep)
        {
            vis[V[i]]=dep;
            if ((Match[V[i]]==-1)||(Hungary(Match[V[i]])))
            {
                Match[V[i]]=u;return 1;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>520</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 22:52:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 14:52:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1143ctsc2008%e7%a5%ad%e7%a5%80river%ef%bc%88%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="post_tag" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[189]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4763]Theme Section（KMP）</title>
		<link>http://sycstudio.com/archives/522</link>
		<pubDate>Wed, 21 Feb 2018 06:45:25 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=522</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

It's time for music! A lot of popular musicians are invited to join us in the music festival. Each of them will play one of their representative songs. To make the programs more interesting and challenging, the hosts are going to add some constraints to the rhythm of the songs, i.e., each song is required to have a 'theme section'. The theme section shall be played at the beginning, the middle, and the end of each song. More specifically, given a theme section E, the song will be in the format of 'EAEBE', where section A and section B could have arbitrary number of notes. Note that there are 26 types of notes, denoted by lower case letters 'a' - 'z'.
To get well prepared for the festival, the hosts want to know the maximum possible length of the theme section of each song. Can you help us?

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4763">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个字符串，求最长的满足&#92;(ABACA&#92;)形式的串&#92;(A&#92;)的长度

<h2>解决思路</h2>

由于要求首尾都是&#92;(A&#92;)，那么必然要满足前后缀相同，&#92;(KMP&#92;)求出&#92;(Next&#92;)数组后，由于要满足结尾，那么可以从结尾开始跳&#92;(Next&#92;)，标记出所有与结尾后缀相同的所有前缀，同时注意，这些标记出来的子串长度不能超过&#92;(\frac{n}{2}&#92;)，要不然就会有重复了。再从这些标记了的前缀出发，寻找某一个它能包含的前缀，并满足长度不会使三个字符串重叠。这样就找到了一组三个不重叠的相同子串。取最大长度即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
bool GoLast[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        mem(GoLast,0);
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Next[0]=-1;Next[1]=0;
        for (int i=2;i&lt;=n;i++)//求Next
        {
            int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
        }
        int Ans=0;
        for (int i=n;i!=0;i=Next[i]) if (i+i&lt;=n) GoLast[i]=1;//给能与结尾匹配上的前缀打上标记
        for (int i=n-1;i&gt;=1;i--)
        {
            int now=i;
            while (now)//寻找合法前缀
            {
                if ((GoLast[now])&amp;&amp;(now+now&lt;=i)&amp;&amp;(now+i&lt;=n)){
                    Ans=max(Ans,now);break;//更新最大值
                }
                now=Next[now];
            }
        }
        printf("%d\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>522</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 14:45:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 06:45:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4763theme-section%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[156]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3670/Luogu2375][Noi2014]动物园（KMP）</title>
		<link>http://sycstudio.com/archives/523</link>
		<pubDate>Wed, 21 Feb 2018 07:11:45 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=523</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。
某天，园长给动物们讲解KMP算法。
园长：“对于一个字符串S，它的长度为L。我们可以在O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？”
熊猫：“对于字符串S的前i个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]。”
园长：“非常好！那你能举个例子吗？”
熊猫：“例S为abcababc，则next[5]=2。因为S的前5个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0，next[4] = next[6] = 1，next[7] = 2，next[8] = 3。”
园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)的时间内求出next数组。
下课前，园长提出了一个问题：“KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。例如S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2。”
最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出num数组呢？
特别地，为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出所有num[i]的乘积，对1,000,000,007取模的结果即可。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3670">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2375">Luogu</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给定一个字符串，求每一个前缀中不重叠的相同前后缀个数。

<h2>解决思路</h2>

考虑一个暴力一点的算法，&#92;(KMP&#92;)求出&#92;(Next&#92;)数组后，对于每一个位置我们都暴力地跳&#92;(Next&#92;)遍历它包含的所有前缀，而这些前缀中长度小于当前位置的二分之一的就是要统计进&#92;(Num&#92;)的。
优化一下，对于每一个位置，我们再记录一个&#92;(Cnt[i]&#92;)表示它包含的前缀个数（包括它自己），那么我们再跳的时候一旦跳到一个长度小于当前前缀长度/2的就停止，直接从这个地方累加&#92;(Cnt&#92;)过来。
再优化一下，前面跳的过程可以用倍增来实现，这样，复杂度就降到&#92;(O(nlogn)&#92;)，大力卡常是可以过的。
当然这样的算法不够优美。我们考虑我们把复杂度浪费在了哪里呢？没错，就是每次倍增的复杂度。每一次都倍增求一次位置很耗时间，所以我们考虑用&#92;(pos&#92;)记录上一次找到的合法位置，设当前需要计算的位是&#92;(i&#92;)，类似&#92;(KMP&#92;)中移动&#92;(j&#92;)指针寻找与&#92;(str[i]&#92;)匹配的&#92;(str[j+1]&#92;)，我们跳&#92;(pos&#92;)指针找到第一个与&#92;(str[i]&#92;)匹配的&#92;(str[pos+1]&#92;)，在找到之后，再判断&#92;(2&#42;pos&#92;)是不是小于&#92;(i&#92;)，如果不小于，则还要跳&#92;(Next[pos]&#92;)直到满足小于关系。
这样，寻找合法位置的复杂度就与&#92;(KMP&#92;)同阶了。

<h2>代码</h2>

倍增算法，最慢&#92;(0.9s+&#92;)

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register

const int maxN=1000010;
const int Mod=1e9+7;
const int maxBit=20;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxBit+1][maxN],Size[maxBit+1][maxN];//Next是原KMP中Next的跳转，Size记录跳转中实际经过了几个点
int Num[maxN],Tot[maxN];

int main()
{
    ios::sync_with_stdio(false);
    RG int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        mem(Next[0],0);mem(Size[0],0);
        Next[0][0]=-1;Next[0][1]=0;
        for (RG int i=2;i&lt;=n;++i)//构造Next
        {
            RG int j=Next[0][i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[0][j];
            if (str[j+1]==str[i]) Next[0][i]=j+1;
            else Next[0][i]=0;
            Size[0][i]=1;
        }
        //初始化倍增
        for (RG int i=1;i&lt;=maxBit;++i)
            for (RG int j=1;j&lt;=n;++j)
                Next[i][j]=Next[i-1][Next[i-1][j]],Size[i][j]=Size[i-1][j]+Size[i-1][Next[i-1][j]];
        mem(Num,0);mem(Tot,0);Num[0]=-1;
        for (RG int i=1;i&lt;=n;++i)//求解Num
        {
            RG int now=i;//倍增求出i对应的合法位置
            for (RG int j=maxBit;j&gt;=0;--j) if (Next[j][now]*2&gt;i) now=Next[j][now],Tot[i]=Tot[i]+Size[j][now];
            now=Next[0][now];
            Tot[i]+=Tot[now]+1;//Tot记录前缀i包含多少个前缀
            Num[i]=Tot[now];
        }
        RG ll Ans=1;
        for (RG int i=1;i&lt;=n;++i) Ans=Ans*(ll)(Num[i]+1)%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>

类&#92;(KMP&#92;)的&#92;(pos&#92;)跳转，最慢&#92;(0.040s&#92;)

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register

const int maxN=1000100;
const int Mod=1e9+7;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
int Cnt[maxN];

int main()
{
    ios::sync_with_stdio(false);
    RG int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Cnt[1]=1;
        RG int pos=0;
        RG ll Ans=1;
        for (RG int i=2;i&lt;=n;i++)//求解Next的同时跳转pos
        {
            RG int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
            Cnt[i]=Cnt[Next[i]]+1;//Cnt记录前缀i包含多少个前缀
            while ((pos!=0)&amp;&amp;(str[pos+1]!=str[i])) pos=Next[pos];
            if (str[pos+1]==str[i]) pos++;//将pos跳转到一个匹配的位置
            while (pos*2&gt;i) pos=Next[pos];//再跳转到一个合法的位置
            Ans=Ans*(ll)(Cnt[pos]+1)%Mod;
        }
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>523</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 15:11:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 07:11:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3670-luogu2375noi2014%e5%8a%a8%e7%89%a9%e5%9b%ad%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[196]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2753/Luogu2573][SCOI2012]滑雪与时间胶囊（生成树）</title>
		<link>http://sycstudio.com/archives/524</link>
		<pubDate>Wed, 21 Feb 2018 07:27:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=524</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

a180285非常喜欢滑雪。他来到一座雪山，这里分布着M条供滑行的轨道和N个轨道之间的交点（同时也是景点），而且每个景点都有一编号i（1&lt;=i&lt;=N）和一高度Hi。a180285能从景点i 滑到景点j 当且仅当存在一条i 和j 之间的边，且i 的高度不小于j。 与其他滑雪爱好者不同，a180285喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是a180285拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是a180285 滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在1号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2753">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2573">Luogu</a>

<h3>Tag</h3>

生成树

<h2>题目大意</h2>

给定一个有特殊性质的有向图，求最小树形图。

<h2>解决思路</h2>

直接把求最小树形图的朱刘算法拿过来是不行的，时间复杂度太高。
注意到这一道题中有向图的特殊性质，边总是从高的向低的走的，可以想象是按高度从高到低分成若干段来考虑。这个对于贪心很有帮助。
首先考虑为什么无向图的最小生成树算法不能直接照搬到有向图中。以&#92;(Prim&#92;)为例，无向图的生成树算法基于贪心原理，即若选当前距离最短的点进来不会差。但这个贪心在有向图中是不成立的，因为边有向。
放到这个题，由于边总是从高的连向低的，那么<strong>先考虑高的点不会更差</strong>，因为海拔更低的点不会更新高的点，所以我们可以类似从高到低地来考虑。又因为海拔相同的点，边相当于是无向的。所以就可以直接用无向图的最小生成树来解。
这里选择用&#92;(Prim&#92;)算法实现最小生成树，那么与常规的算法不一样的是，这里的比较就要优先比较海拔，再比较距离，这样才能满足上面的贪心。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxM=1000100*2;
const int inf=2147483647;

class Queue_Data
{
public:
    int u;
    ll dis;
};

ll Height[maxN];

bool operator &lt; (Queue_Data A,Queue_Data B){//定义比较函数，注意先比较海拔
    if (Height[A.u]!=Height[B.u]) return Height[A.u]&lt;Height[B.u];
    else return A.dis&gt;B.dis;
}

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM];
ll Dis[maxN];
bool vis[maxN];
priority_queue&lt;Queue_Data&gt; Q;

void Add_Edge(int u,int v,int w);

int main()
{
    mem(Head,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Height[i];
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;//从高海拔向低海拔连比
        if (Height[u]&gt;=Height[v]) Add_Edge(u,v,w);
        if (Height[v]&gt;=Height[u]) Add_Edge(v,u,w);
    }
    mem(Dis,-1);Dis[1]=0;
    Q.push((Queue_Data){1,0});
    ll Ans=0,Sum=0;
    do//堆优化求解最小生成树
    {
        Queue_Data u=Q.top();Q.pop();
        if (vis[u.u]) continue;
        vis[u.u]=1;
        Ans++;Sum=Sum+(ll)Dis[u.u];
        for (int i=Head[u.u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;((Dis[V[i]]==-1)||(Dis[V[i]]&gt;W[i]))){
                Dis[V[i]]=W[i];Q.push((Queue_Data){V[i],Dis[V[i]]});
            }
    }
    while (!Q.empty());
    printf("%lld %lld\n",Ans,Sum);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>524</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 15:27:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 07:27:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2753-luogu2573scoi2012%e6%bb%91%e9%9b%aa%e4%b8%8e%e6%97%b6%e9%97%b4%e8%83%b6%e5%9b%8a%ef%bc%88%e7%94%9f%e6%88%90%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[229]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>100</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 17:16:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 09:16:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[泥萌又在切我要讲的题]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>101</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 17:34:04]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 09:34:04]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你要讲这道？
这道题我是在某一次找生成树的题目时找到的。真是巧了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>100</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU3746]Cyclic Nacklace（KMP）</title>
		<link>http://sycstudio.com/archives/532</link>
		<pubDate>Thu, 22 Feb 2018 09:24:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=532</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

CC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of "HDU CakeMan", he wants to sell some little things to make money. Of course, this is not an easy task.
As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl's fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls' lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet's cycle is 9 and its cyclic count is 2:
Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden.
CC is satisfied with his ideas and ask you for help.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-3746">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个串，求在这个串的两侧添加最少的字符使得它成为一个完整的循环串。

<h2>解决思路</h2>

首先知道，在串的两边加字符与只在一边加效果是一样的，因为是循环串，那么问题转化为在一个字符串后面加上若干个字符使得整个字符串成为一个循环串。
那么先来看这个循环串需要满足的条件，它的循环节的前缀一定是整个原字符串的后缀，因为可以将原字符串看作若干个循环节后面接上一个不完整的循环节的前缀。所以可以从最后一个字符开始跳&#92;(Next&#92;)，这样就可以标记出所有包含原串后缀的所有前缀，即能匹配上。
然后我们从前往后枚举循环节的长度。首先判断是不是真的是循环的。由于已经知道了长度，那么我们就可以求出这个循环节完整的最后一次结束的位置，假设这个位置是&#92;(pos&#92;)，当前循环节的长度为&#92;(i&#92;)，那么若&#92;(\frac{pos}{pos-Next[pos]}&#92;)为整数并且&#92;(pos-Next[pos]==i&#92;)，则这个循环节是合法的（证明可以参考<a href="http://sycstudio.com/archives/516">这里</a>）。接着判断剩下的&#92;(n-pos&#92;)位是否能构成合法一个残缺的循环节（即剩下的&#92;(n-pos&#92;)位能匹配循环节的前&#92;(n-pos&#92;)位），这个直接看原串的第&#92;(n-pos&#92;)位在我们的第一步中是否被标记即可。最后需要注意的是，当枚举循环节长度枚举到最后一位时，要特殊判断整个原串是否本身就是循环的，此时答案为&#92;(0&#92;)。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
bool Pre[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Next[0]=-1;Next[1]=0;
        for (int i=2;i&lt;=n;i++)//构造Next
        {
            int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
        }
        mem(Pre,0);Pre[0]=1;//标记出所有合法前缀
        for (int i=n;i!=0;i=Next[i]) Pre[i]=1;
        int mn=n;//记录最短补全长度
        for (int i=1;i&lt;=n;i++)
        {
            int cnt=n/i,pos=cnt*i;//cnt求出循环多少次，pos求出最后一个完整的循环节结束的位置
            if ((pos%(pos-Next[pos])!=0)||(pos-Next[pos]!=i)) continue;//判断这个循环节是否真的是循环的
            if (Pre[n-pos]==0) continue;//判断后面剩下的几位是否能匹配
            cnt=pos/(pos-Next[pos]);//求出循环次数
            if ((pos==n)&amp;&amp;(cnt&gt;1)) mn=0;//特判原串就是
            mn=min(mn,pos+i-n);
        }
        printf("%d\n",mn);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>532</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 17:24:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 09:24:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu3746cyclic-nacklace%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[146]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ1741]Tree（点分治）</title>
		<link>http://sycstudio.com/archives/533</link>
		<pubDate>Thu, 22 Feb 2018 11:07:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Give a tree with n vertices,each edge has a length(positive integer less than 1001).
Define dist(u,v)=The min distance between node u and v.
Give an integer k,for every pair (u,v) of vertices is called valid if and only if dist(u,v) not exceed k.
Write a program that will count how many pairs which are valid for a given tree.

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-1741">HDU</a>

<h3>Tag</h3>

点分治

<h2>题目大意</h2>

给出一棵树，求其中路径长度不超过一个给定的数&#92;(K&#92;)的点对个数

<h2>解决思路</h2>

考虑点分治，每一层从当前根出发&#92;(bfs&#92;)求出深度，然后组合出所有不超过&#92;(K&#92;)的方案。但这样就会有不合法的情况，所以要减去不经过当前根的答案，再递归求解。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10100;
const int maxM=maxN*2;
const int inf=2147483647;

int n,K,Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int root,Size[maxN],mxSon[maxN],nowsum;
bool vis[maxN];
int Depth[maxN],scnt,SortData[maxN];
int Queue[maxN],Fa[maxN];

void Add_Edge(int u,int v,int w);
void GetRoot(int u,int fa);
void Solve(int u);
int Calc(int u,int dep);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n&gt;&gt;K)
    {
        if ((n==0)&amp;&amp;(K==0)) break;
        edgecnt=0;Ans=0;mem(Head,-1);mem(vis,0);
        for (int i=1;i&lt;n;i++)
        {
            int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
            Add_Edge(u,v,w);Add_Edge(v,u,w);
        }
        mxSon[0]=inf;
        root=0;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        printf("%d\n",Ans);
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void GetRoot(int u,int fa)//求重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],W[i]);nowsum=Size[V[i]];
            root=0;GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

int Calc(int u,int dep)//计算答案
{
    Depth[u]=dep;scnt=0;Fa[u]=0;
    int h=1,t=0;Queue[1]=u;
    do
    {
        int u=Queue[++t];
        SortData[++scnt]=Depth[u];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(V[i]!=Fa[u]))
            {
                Fa[V[i]]=u;Depth[V[i]]=Depth[u]+W[i];
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    sort(&amp;SortData[1],&amp;SortData[scnt+1]);
    int l=1,r=scnt,ret=0;
    while (l&lt;r)
    {
        if (SortData[l]+SortData[r]&lt;=K) ret=ret+r-l,l++;
        else r--;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 19:07:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 11:07:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[poj1741tree%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[185]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2152/Luogu2634]聪聪可可（点分治）</title>
		<link>http://sycstudio.com/archives/534</link>
		<pubDate>Thu, 22 Feb 2018 11:14:10 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=534</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2152">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2634">Luogu</a>

<h3>Tag</h3>

点分治

<h2>题目大意</h2>

给出一棵边带权的树，求所有路径长度是三的倍数的路径数量。

<h2>解决思路</h2>

点分治求解，对于每一次找到的重心，&#92;(bfs&#92;)求点的深度，分别统计深度除三余零、一、二的数的个数，组合答案，再减去不经过重心的答案，然后递归求解。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=20100;
const int maxM=maxN*2;
const int inf=2147483647;

int n,root,nowsum,Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Size[maxN],mxSon[maxN];
int histcnt=0,Hist[maxN],Depth[maxN],Queue[maxN];
bool vis[maxN];

void Add_Edge(int u,int v,int w);
void GetRoot(int u,int fa);
void Solve(int u);
int Calc(int u,int dep);
int gcd(int a,int b);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);
    cin&gt;&gt;n;
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;w=w%3;
        Add_Edge(u,v,w);Add_Edge(v,u,w);
    }
    mxSon[0]=inf;root=0;nowsum=n;
    GetRoot(1,0);
    Solve(root);
    int Sum=n*n;
    int g=gcd(Ans,Sum);
    printf("%d/%d\n",Ans/g,Sum/g);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],W[i]);
            nowsum=Size[V[i]];root=0;
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

int Calc(int u,int dep)//计算答案
{
    Depth[u]=dep;histcnt++;Hist[u]=histcnt;
    int h=1,t=0;Queue[1]=u;
    int Cnt[4]={0,0,0,0};
    do
    {
        int u=Queue[++t];Cnt[Depth[u]%3]++;
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(Hist[V[i]]!=histcnt))
            {
                Hist[V[i]]=histcnt;Depth[V[i]]=(Depth[u]+W[i]);
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    return Cnt[0]+Cnt[0]*(Cnt[0]-1)+Cnt[1]*Cnt[2]*2;
}

int gcd(int a,int b)
{
    int tmp;
    while (b) tmp=a,a=b,b=tmp%b;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>534</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 19:14:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 11:14:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2152-luogu2634%e8%81%aa%e8%81%aa%e5%8f%af%e5%8f%af%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[169]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ TLE]Time Limit Exceeded（数位DP，计数DP，高维前缀和）</title>
		<link>http://sycstudio.com/archives/535</link>
		<pubDate>Thu, 22 Feb 2018 12:25:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=535</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given integers N (1 ≤ N ≤ 50) and M (1 ≤ M ≤ 15), compute the number of sequences a1, ..., aN such that:
0 ≤ ai &lt; 2M
ai is not divisible by ci (0 &lt; ci ≤ 2M)
ai &amp; ai+1 = 0 (that is, ai and ai+1 have no common bits in their binary representation)

<h3>Http</h3>

<a href="http://www.spoj.com/problems/TLE/">SPOJ</a>

<h3>Tag</h3>

动态规划，高维前缀和

<h2>题目大意</h2>

给出一列数，要求求出满足条件的数列的方案数。

<h2>解决思路</h2>

由数据范围容易想到，设&#92;(F[i][j]&#92;)表示前&#92;(i&#92;)个数，第&#92;(i&#92;)个数是&#92;(j&#92;)的方案数，那么有转移方程
&#92;[ F[i][j]=\sum&#95;{k\&amp;j==0} F[i-1][k]&#92;]
不难发现，这里要求的&#92;(k&#92;)就是&#92;(j&#92;)的补集的子集，为了方便计算，我们可以记&#92;(Sum[S]&#92;)表示&#92;(S&#92;)及&#92;(S&#92;)子集的方案数总和，需要的时候直接赋值进去就好。
怎么求这个呢？这里用到一种叫做<strong>高维前缀和</strong>的科技，可以在&#92;(O(n&#42;2^n)&#92;)时间范围内求得子集之和。具体来说，是这样

<pre><code class="language-cpp ">for (int i=0;i&lt;m;i++)
    for (int j=0;j&lt;(1&lt;&lt;m);j++)
        if ((j&amp;(1&lt;&lt;i))!=0) Sum[j]+=Sum[j^(1&lt;&lt;i)];
</code></pre>

正确性暂不会证明。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51;
const int maxM=15;
const int Mod=1000000000;
const int inf=2147483647;

int n,m;
int C[maxN];
ll F[maxN][1&lt;&lt;(maxM+1)];
ll Sum[1&lt;&lt;(maxM+1)];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        for (int i=1;i&lt;=n;i++) cin&gt;&gt;C[i];
        mem(F,0);mem(Sum,0);
        //先把第一位的方案计算出来
        for (int i=0;i&lt;(1&lt;&lt;m);i++) if (i%C[1]!=0) F[1][i]=Sum[i]=1;
        for (int i=0;i&lt;m;i++)//高维前缀和
            for (int j=0;j&lt;(1&lt;&lt;m);j++)
                if ((j&amp;(1&lt;&lt;i))!=0) Sum[j]=(Sum[j]+Sum[j^(1&lt;&lt;i)])%Mod;
        for (int i=2;i&lt;=n;i++)
        {
            for (int j=0;j&lt;(1&lt;&lt;m);j++) if (j%C[i]!=0) F[i][j]=Sum[j^((1&lt;&lt;m)-1)];//转移
            mem(Sum,0);//准备统计新的一次的答案
            for (int j=0;j&lt;(1&lt;&lt;m);j++) Sum[j]=F[i][j];
            for (int j=0;j&lt;m;j++)//高维前缀和
                for (int k=0;k&lt;(1&lt;&lt;m);k++)
                    if ((k&amp;(1&lt;&lt;j))!=0) Sum[k]=(Sum[k]+Sum[k^(1&lt;&lt;j)])%Mod;
        }
        ll Ans=0;
        for (int i=0;i&lt;(1&lt;&lt;m);i++) if (i%C[n]!=0) Ans=(Ans+F[n][i])%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>535</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:25:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:25:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-tletime-limit-exceeded%ef%bc%88%e6%95%b0%e4%bd%8ddp%ef%bc%8c%e8%ae%a1%e6%95%b0dp%ef%bc%8c%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[数位动态规划]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<category domain="category" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[403]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5977]Garden of Eden（点分治，高维前缀和）</title>
		<link>http://sycstudio.com/archives/536</link>
		<pubDate>Thu, 22 Feb 2018 12:41:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=536</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

When God made the first man, he put him on a beautiful garden, the Garden of Eden. Here Adam lived with all animals. God gave Adam eternal life. But Adam was lonely in the garden, so God made Eve. When Adam was asleep one night, God took a rib from him and made Eve beside him. God said to them, “here in the Garden, you can do everything, but you cannot eat apples from the tree of knowledge.”
One day, Satan came to the garden. He changed into a snake and went to live in the tree of knowledge. When Eve came near the tree someday, the snake called her. He gave her an apple and persuaded her to eat it. Eve took a bite, and then she took the apple to Adam. And Adam ate it, too. Finally, they were driven out by God and began a hard journey of life.
The above is the story we are familiar with. But we imagine that Satan love knowledge more than doing bad things. In Garden of Eden, the tree of knowledge has n apples, and there are k varieties of apples on the tree. Satan wants to eat all kinds of apple to gets all kinds of knowledge.So he chooses a starting point in the tree,and starts walking along the edges of tree,and finally stops at a point in the tree(starting point and end point may be same).The same point can only be passed once.He wants to know how many different kinds of schemes he can choose to eat all kinds of apple. Two schemes are different when their starting points are different or ending points are different.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5977">HDU</a>

<h3>Tag</h3>

点分治，高维前缀和，状态压缩

<h2>题目大意</h2>

给出一棵树，这棵树上的每一个点有一个类别，求经过每一种类别的点至少一次的路径条数。

<h2>解决思路</h2>

点分治求解。考虑到&#92;(K&#92;)即种类数的范围只有&#92;(10&#92;)，所以可以对每一个点维护一个二进制状态表示它到当前点分治的根的路径上经过的点的种类集合。每一次计算出当前根的答案再减去不经过当前根的答案即可，递归求解。
这题的关键在于如何计算每一次的答案。一个点到根的路径上的点种类集合这个比较好求，直接&#92;(bfs&#92;)即可，关键是如何组合出经过所有类别的路径。根据题意我们可以得到一个计算公式。
记&#92;(nowAns&#92;)表示这一次的答案，&#92;(nown&#92;)表示这一次遍历的点的数量，&#92;(Path[u]&#92;)表示&#92;(u&#92;)这个点到当前根的路径上的点类型的集合，&#92;(Cnt[S]&#92;)表示到根的路径上点类型的集合为&#92;(S&#92;)的点有多少个，那么有
&#92;[nowAns=\sum&#95;{i=1}^{nown} \sum&#95;{S|Path[i]==(1 &lt; &lt; K)-1} Cnt[S]&#92;]
那么现在的问题就是如何统计一个集合&#92;(S&#92;)的超集之和。（超集，比如对于F[0101]，超集之和为F[0101]+F[1101]+F[0111]+F[1111]）。
这个可以用高维前缀和解决，具体来说可以这样求

<pre><code class="language-cpp ">for (int i=0;i&lt;K;i++)
    for (int j=0;j&lt;(1&lt;&lt;K);j++)
        if ((j&amp;(1&lt;&lt;i))==0) Cnt[j]+=Cnt[j|(1&lt;&lt;i)];
</code></pre>

正确性暂不会证。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=maxN*2;
const int maxBit=10;
const int inf=2147483647;

int n,K;
ll Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],NodeW[maxN];
int root,nowsum,Size[maxN],mxSon[maxN];
int histcnt,Hist[maxN];
int Queue[maxN],Path[maxN];
ll Cnt[1&lt;&lt;(maxBit+1)];
int Stack[maxN];
bool vis[maxN];

void Add_Edge(int u,int v);
void GetRoot(int u,int fa);
void Solve(int u);
ll Calc(int u,int init);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n&gt;&gt;K)
    {
        edgecnt=0;mem(Head,-1);mem(vis,0);Ans=0;
        for (int i=1;i&lt;=n;i++){
            cin&gt;&gt;NodeW[i];NodeW[i]=1&lt;&lt;(NodeW[i]-1);
        }
        for (int i=1;i&lt;n;i++)
        {
            int u,v;cin&gt;&gt;u&gt;&gt;v;
            Add_Edge(u,v);Add_Edge(v,u);
        }
        root=0;mxSon[0]=inf;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        printf("%lld\n",Ans);
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0)){
            GetRoot(V[i],u);Size[u]+=Size[V[i]];mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],NodeW[u]);
            nowsum=Size[V[i]];root=0;
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

ll Calc(int u,int init)
{
    mem(Cnt,0);
    histcnt++;Hist[u]=histcnt;
    Path[u]=init|NodeW[u];
    int h=1,t=0;Queue[1]=u;
    int stacktop=0;
    do//bfs求出每一个点到当前根的路径上的点类型的集合
    {
        int u=Queue[++t];Cnt[Path[u]]++;Stack[++stacktop]=Path[u];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(Hist[V[i]]!=histcnt))
            {
                Hist[V[i]]=histcnt;Path[V[i]]=Path[u]|NodeW[V[i]];
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    for (int i=0;i&lt;K;i++)//高维前缀和
        for (int j=0;j&lt;(1&lt;&lt;K);j++)
            if ((j&amp;(1&lt;&lt;i))==0) Cnt[j]+=Cnt[j|(1&lt;&lt;i)];
    ll ret=0;
    for (int i=1;i&lt;=stacktop;i++) ret=ret+Cnt[Stack[i]^((1&lt;&lt;K)-1)];//统计答案
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>536</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:41:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:41:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5977garden-of-eden%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[394]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>关于回文树的理解 by yyb</title>
		<link>http://sycstudio.com/archives/537</link>
		<pubDate>Thu, 22 Feb 2018 12:49:54 +0000</pubDate>
		<dc:creator><![CDATA[yyb]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=537</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

这段时间搞字符串上了瘾？
看起来是的
那就继续搞吧

<h2>Part1一些名词</h2>

<h3>回文串</h3>

不想解释什么意思

<h3>回文子串</h3>

一个串的子串，它是回文串，那么它就是回文子串

<h3>最长回文后缀</h3>

对于一个长度小于自己的后缀，如果它是回文串，并且不存在比它更长的回文后缀，那么它就是最长回文后缀

<h3>最长回文前缀</h3>

基本和上面一样

<h2>Part2 回文树的形态</h2>

<h3>长成啥样啊？</h3>

我们很容易知道，回文串有两种，一种长度是奇数，一种长度是偶数
而在回文树上走，我们肯定不是一次只在后面添加一个字符
显然是在前后各添加一个字符
所以我们不难得出一点，如果串可以变成另外一个回文串
那么它的长度一定加上了一个偶数
所以在回文树上，为了区分这两种不同的回文串
所以回文树相当于一个森林
有两棵树，一棵的代表长度为奇数的回文串，另一棵代表长度为偶数的回文串

就像后缀自动机，Trie树，AC自动机这些东西一样
每一个节点代表的都是一个（些）串
回文树的每个节点也是代表着一个串
对于每个点的转移，比如说
对于某个点代表的回文串"aba"
假如它有一个'c'的转移
那么，"aba"就会指向一个代表着"cabac"的串

同样的，类似于AC自动机有$$fail$$，后缀自动机有$$parent$$
当失配的时候回文树也有$$fail$$向上跳
那么，我们来考虑一些这个东西是什么？

假设当前加入的位置是$$r$$
如果之前已经匹配出了一个回文$$S_{l..r-1}$$
那么，如果有$$S_{l-1}=S_r$$就没有失配
如果失配了，因为$$r$$位置是不能变动的
所以挪动的只有$$l$$位置
而$$S_{l..r}$$显然也要是一个回文串
所以$$l$$挪动到的位置就是$$S_{l..r-1}$$的最长回文后缀的开始位置

<h3>一些小小的结论</h3>

综上所述，我们知道了两点：
<strong><em>1.对于回文树上的两个节点，如果存在字符c的连边，那么，就会从串x，变成cxc</em></strong>
<strong><em>2.对于回文树上的失配(fail)指针，指向这个点所代表的字符串的最长回文后缀所在的节点</em></strong>

<h3>一些小小的证明</h3>

接下来，我们还可以知道几点
<strong><em>1.对于任何一个串S，它的本质不同的回文串的个数不会超过|S|个</em></strong>
<strong><em>2.如果在串S后面加入一个字符，新增的本质不同的回文串的个数不会超过1个</em></strong>

怎么证明？

利用数学归纳法来证明

当$$|S|=1$$时，显然成立

如果我们知道$$|S|=x-1$$时成立，现在插入$$x$$位置，字符为$$c$$
如果以$$x$$位置结尾出现了两个新的本质不同的回文串
假设较长的从$$l1$$开始，较短的从$$l2$$开始
因为$$|S_{l1..r}|>|S_{l2..r}|$$
又根据回文串对称的性质
所以$$S_{l2..r}$$在$$S_{l1..l1+r-l2}$$必定出现过
所以不存在两个本质不同的回文串
所以最多新增一个本质不同的回文串
所以到$$x$$位置出现的本质不同的回文串的个数最多为$$x$$个

同时，我们也证明了每次插入一个新的字符，最多增加一个本质不同的回文子串

<h2>Part3 回文树的构造</h2>

看完了上面，应该就知道了回文树上的东西代表着什么
我们的构造采用增量法，也就是类似于后缀自动机的$$extend$$

假设前面已经构造出了$$1..x-1$$的回文树，现在要加入第$$x$$个字符$$c$$
因为要接在$$x-1$$的后面，我们又知道最多一个产生一个新的本质不同的回文串
也就是$$S_{1..x-1}$$中，最长的某个回文后缀$$S_{l..x-1}$$，
同时能够满足$$S_{l-1}=S_x$$
因为只需要不停地寻找最长回文后缀

根据回文树上的$$fail$$指针的含义
我们很容易知道知道，
只需要从上一个位置添加完之后的最后一个位置
（也就是以$$x-1$$为结束位置的最长回文子串）
所代表的节点开始，沿着$$fail$$一路上跳
检查是否满足$$S_{l-1}=S_x$$就行了

假设这样找到的一个位置是$$p$$
不难证明这个位置$$p$$一定存在（为啥？长度为1的回文串呀）
如果$$p.son[c]$$也就是连边$$c$$已经存在
那就什么都不用干，因为这个回文子串已经存在过
不需要重新建边
否则，重新建一个点表示这个回文子串,假设点是$$np$$吧
然后$$p.son[c]=np$$

现在我们要找$$np$$的$$fail$$啦
因为要找的是最长回文后缀，不能是自己
所以令$$k=p.fail$$
然后就像前面一样的，找到第一个满足$$S[l_k-1]=S[n]$$的点
让$$k$$沿着$$fail$$向上跳
然后$$np.fail=k$$，表示找到啦

这样，我们的回文树就利用增量法构建出来啦

当然，两棵树的根节点的长度分别是$$-1$$和$$0$$
然后为$$0$$的根节点的$$fail$$连向$$-1$$的根节点
$$-1$$个根节点的$$fail$$也连向自己
为啥？自己想
初始情况下的$$last=0,tot=1$$（代表什么可以参考程序）

这是一棵回文树

<pre><code class="language-cpp ">struct Palindromic_Tree
{
        struct Node
        {
                int son[26];
                int ff,len;
        }t[MAX];
        int last,tot;
        void init()
        {
                t[++tot].len=-1;
                t[0].ff=t[1].ff=1;
        }
        void extend(int c,int n)
        {
                int p=last;
                while(s[n-t[p].len-1]!=s[n])p=t[p].ff;
                if(!t[p].son[c])
                {
                        int v=++tot,k=t[p].ff;
                        t[v].len=t[p].len+2;
                        while(s[n-t[k].len-1]!=s[n])k=t[k].ff;
                        t[v].ff=t[k].son[c];
                        t[p].son[c]=v;
                }
                last=t[p].son[c];
                size[t[p].son[c]]++;
        }
};
</code></pre>

<h2>Part4 后记</h2>

这篇博客十分简短
因此肯定有很多很多不严谨的地方
更加详细的请参考
国家集训队$$2017$$年的论文

当然了，这些东西也只是我自己的理解
而回文树也有很多很神奇的用法，
等我做了一些题之后我会再回来写的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>537</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:49:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:49:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e5%9b%9e%e6%96%87%e6%a0%91%e7%9a%84%e7%90%86%e8%a7%a3-by-yyb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[274]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2333/Luogu3273][SCOI2011]棘手的操作（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/539</link>
		<pubDate>Fri, 23 Feb 2018 12:17:58 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=539</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有N个节点，标号从1到N，这N个节点一开始相互不连通。第i个节点的初始权值为a[i]，接下来有如下一些操作：
U x y: 加一条边，连接第x个节点和第y个节点
A1 x v: 将第x个节点的权值增加v
A2 x v: 将第x个节点所在的连通块的所有节点的权值都增加v
A3 v: 将所有节点的权值都增加v
F1 x: 输出第x个节点当前的权值
F2 x: 输出第x个节点所在的连通块中，权值最大的节点的权值
F3: 输出所有节点中，权值最大的节点的权值

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2333">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3273">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>解决思路</h2>

考虑到题目中所有的询问操作都是求最大值，再看到第一种操作只有合并没有分离，那么可以想到用可并堆来维护每一个联通块，至于整个连通块的修改可以用&#92;(lazy&#92;)标记来维护。下面依次具体来看每一个操作。
<strong>U x y: 加一条边，连接第x个节点和第y个节点</strong>，这个直接分别找到&#92;(x&#92;)和&#92;(y&#92;)所在的可并堆的根，若不在同一个可并堆则合并两个可并堆。注意，这里跳祖先不能用并查集，具体原因下面会说。时间复杂度&#92;(O(logn)&#92;)
<strong>A1 x v: 将第x个节点的权值增加v</strong>，在可并堆中分离出节点&#92;(x&#92;)，然后把&#92;(x&#92;)的权值修改了后再与&#92;(x&#92;)原来所在的可并堆合并。注意，由于有&#92;(lazy&#92;)标记，在分离之前要把从根到&#92;(x&#92;)路径上的所有&#92;(lazy&#92;)都下放。具体分离的步骤是先把&#92;(x&#92;)的两个儿子合并，然后把儿子合并后的新根连上原来&#92;(x&#92;)的父亲，同时修改父亲对应的儿子指针。时间复杂度&#92;(O(logn)&#92;)
<strong>A2 x v: 将第x个节点所在的连通块的所有节点的权值都增加v</strong>，跳到&#92;(x&#92;)所在可并堆的根，对根打上&#92;(lazy&#92;)标记。时间复杂度&#92;(O(logn)&#92;)
<strong>A3 v: 将所有节点的权值都增加v</strong>，在全局维护一个&#92;(allsum&#92;)表示所有&#92;(A3&#92;)操作之和，每一次要输出的时候再加上即可。时间复杂度&#92;(O(1)&#92;)
<strong>F1 x: 输出第x个节点当前的权值</strong>，类似的，要先从根向下下放所有的&#92;(lazy&#92;)标记再得到值。时间复杂度&#92;(O(logn)&#92;)
<strong>F2 x: 输出第x个节点所在的连通块中，权值最大的节点的权值</strong>，跳到根后输出根的值。时间复杂度&#92;(O(logn)&#92;)
<strong>F3: 输出所有节点中，权值最大的节点的权值</strong>，由于权值最大的值一定是可并堆的根，所以可以在全局再维护一个代删除的堆，每一次有对可并堆的堆顶的修改时就在这个全局的堆中进行修改，那么&#92;(F3&#92;)操作就直接输出这个堆顶即可。为了方便，可以用两个系统堆来实现带删除的堆的操作，具体来说，用一个堆表示实际的堆，另一个标记垃圾堆，每一次要删除实际堆中的元素时，把这个元素丢入垃圾堆中，当实际堆与垃圾堆的堆顶相同时，同时弹出两个堆的堆顶。时间复杂度&#92;(O(logn)&#92;)
至于为什么不能用路径压缩并查集来维护堆顶。由于这里再可并堆上有&#92;(lazy&#92;)标记用来下放，那么至少需要带权并查集来维护，又因为&#92;(lazy&#92;)是在不断下放的，那么可能并查集还没有更新到，&#92;(lazy&#92;)就已经下放了。再加上有分离出某一个点修改再丢回去的操作，这时候带权并查集的权就会更加混乱。所以不能路径压缩。
这里用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=300100;
const int inf=2147483647;

class Heap
{
public:
    int key;
    int ls,rs,dis,fa,lazy;
};

int n;
Heap H[maxN];
priority_queue&lt;int&gt; Q1,Q2;//Q1，Q2分别是全局的实际堆和垃圾堆

int Merge(int r1,int r2);
void PushDown(int r);
void Mark(int r,int lazy);
int GetRt(int x);//得到堆顶
void PushLazy(int x);//从堆顶下放所有lazy标记
void QPush(int x);//这三个操作是维护全局的堆顶的值的
void QDel(int x);
int QTop();

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++){
        cin&gt;&gt;H[i].key;QPush(H[i].key);
    }
    int Q;cin&gt;&gt;Q;
    char opt[5];
    int allsum=0;
    while (Q--)
    {
        cin&gt;&gt;opt;
        if (opt[0]=='U')
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            x=GetRt(x);y=GetRt(y);//走到堆顶
            if (x!=y){//若不在同一可并堆，则合并，同时注意要修改全局堆
                int t=Merge(x,y);
                if (t==x) QDel(H[y].key);
                else QDel(H[x].key);
            }
        }
        if (opt[0]=='A')
        {
            if (opt[1]=='1')//单点修改
            {
                int x,v;cin&gt;&gt;x&gt;&gt;v;
                PushLazy(x);QDel(H[GetRt(x)].key);//先把堆顶删除

                int nrt=Merge(H[x].ls,H[x].rs),fa=H[x].fa;//合并左右儿子

                if (H[fa].ls==x) H[fa].ls=nrt;//将父亲原来的儿子指针指向新的儿子
                else if (H[fa].rs==x) H[fa].rs=nrt;
                H[x].fa=H[x].ls=H[x].rs=0;H[x].key+=v;//更新该点权值
                H[nrt].fa=fa;//将新儿子指向父亲

                nrt=GetRt(nrt);//得到堆顶
                nrt=Merge(x,nrt);//把修改后的点放回去
                QPush(H[nrt].key);//把新的堆顶放入全局堆
            }
            if (opt[1]=='2')//整块修改
            {
                int x,v;cin&gt;&gt;x&gt;&gt;v;
                x=GetRt(x);QDel(H[x].key);//得到根，并在全局堆中删除
                Mark(x,v);QPush(H[x].key);//修改，并加入全局堆
            }
            if (opt[1]=='3')//全局修改
            {
                int v;cin&gt;&gt;v;allsum+=v;
            }
        }
        if (opt[0]=='F')
        {
            if (opt[1]=='1')//单点询问
            {
                int x;cin&gt;&gt;x;
                PushLazy(x);//下放lazy标记
                printf("%d\n",H[x].key+allsum);
            }
            if (opt[1]=='2')//连通块最值查询
            {
                int x;cin&gt;&gt;x;
                x=GetRt(x);
                printf("%d\n",H[x].key+allsum);
            }
            if (opt[1]=='3')//全局最值查询
            {
                printf("%d\n",QTop()+allsum);
            }
        }
    }
    return 0;
}

int Merge(int r1,int r2)//左偏树合并
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    PushDown(r1);PushDown(r2);
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    H[H[r1].rs].fa=r1;
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}

void PushDown(int r)//标记下放
{
    if (H[r].lazy==0) return;
    if (H[r].ls) Mark(H[r].ls,H[r].lazy);
    if (H[r].rs) Mark(H[r].rs,H[r].lazy);
    H[r].lazy=0;return;
}

void Mark(int r,int lazy)
{
    H[r].key+=lazy;H[r].lazy+=lazy;
    return;
}

int GetRt(int x)
{
    while (H[x].fa) x=H[x].fa;
    return x;
}

int Stack[maxN];

void PushLazy(int x)
{
    int stacktop=0;
    while (x){
        Stack[++stacktop]=x;x=H[x].fa;
    }
    while (stacktop) PushDown(Stack[stacktop--]);
    return;
}

void QPush(int x)
{
    Q1.push(x);return;
}

void QDel(int x)
{
    Q2.push(x);
    while ((!Q1.empty())&amp;&amp;(!Q2.empty())&amp;&amp;(Q1.top()==Q2.top())) Q1.pop(),Q2.pop();
    return;
}

int QTop()
{
    while ((!Q1.empty())&amp;&amp;(!Q2.empty())&amp;&amp;(Q1.top()==Q2.top())) Q1.pop(),Q2.pop();
    return Q1.top();
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>539</wp:post_id>
		<wp:post_date><![CDATA[2018-02-23 20:17:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-23 12:17:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2333-luogu3273scoi2011%e6%a3%98%e6%89%8b%e7%9a%84%e6%93%8d%e4%bd%9c%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[243]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1922/Luogu2446][Sdoi2010]大陆争霸（最短路）</title>
		<link>http://sycstudio.com/archives/542</link>
		<pubDate>Sun, 25 Feb 2018 02:03:54 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=542</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的 克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭 的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。 幻想历 8012年 1月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同 时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。 幻想历 8012年 3月2日，位于杰森国东部小镇神谕镇的克里斯国教徒发动 起义。 幻想历 8012年 3月7日，神谕镇的起义被杰森国大军以残酷手段镇压。 幻想历 8012年 3月8日，克里斯国对杰森国宣战。由数十万大军组成的克 里斯军团开至两国边境，与杰森军团对峙。 幻想历 8012年 4月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存 的克里斯国教徒得到解放。 战争随后进入胶着状态，旷日持久。战况惨烈，一时间枪林弹雨，硝烟弥漫， 民不聊生。 幻想历 8012年 5月12日深夜，斯普林·布拉泽降下神谕：“Trust me, earn eternal life.”克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机 会发动奇袭，一举击败杰森国。具体地说，杰森国有 N 个城市，由 M条单向道 路连接。神谕镇是城市 1而杰森国的首都是城市 N。你只需摧毁位于杰森国首都 的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。 为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困 难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个 城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个 城市，你就必须破坏掉维持这个城市结界的所有结界发生器。 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间 引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会 一起被破坏。你需要知道：摧毁杰森国所需的最短时间。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1922">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2446">Luogu</a>

<h3>Tag</h3>

最短路

<h2>题目大意</h2>

给出一张有向图，经过某一些点要求需要先经过一些其他的点，可以同时从源点出发多个人，求从源点到汇点的最短时间。

<h2>解决思路</h2>

考虑最短路变种。当处理到一个点的时候，由它向它连向的点松弛，那么若从这个点去更优，则直接修改，但此时不一定要先入队，因为可能这个点的需要先到达的点的条件还未满足，所以若未满足则先不入队。为了维护一个点的要求的点有没有都已经到达过，我们建另一张图，图中的边&#92;(u->v&#92;)表示，要经过点&#92;(v&#92;)需要先经过点&#92;(u&#92;)，那么如果当&#92;(u&#92;)从队中取出时，就修改从&#92;(u&#92;)出发的所有这类点，若发现所有需求都满足了，则放入队列。
为了满足从队中出来的顺序，用&#92;(Dijkstra&#92;)堆优化来实现。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=3010;
const int maxM=70010;
const int inf=2147483647;

class Edge
{
public:
    int v;
    ll w;
};

class Queue_Data
{
public:
    int u;ll w;
};

bool operator &lt; (Queue_Data A,Queue_Data B)
{
    return A.w&gt;B.w;
}

int n,m;
int edgecnt=0,Head[maxN],Next[maxM];
Edge E[maxM];
ll Dist[maxN];
int Degree[maxN],edgecnt2=0,Head2[maxN],Next2[maxM*10],V2[maxM*10];
bool vis[maxN];
priority_queue&lt;Queue_Data&gt; Q;

int main()
{
    mem(Head,-1);mem(Head2,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].w=w;
    }
    for (int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;Degree[i];//统计入度
        for (int j=1;j&lt;=Degree[i];j++)//在第二张图上建边
        {
            int u;cin&gt;&gt;u;
            edgecnt2++;Next2[edgecnt2]=Head2[u];Head2[u]=edgecnt2;V2[edgecnt2]=i;
        }
    }
    mem(Dist,-1);Dist[1]=0;Q.push((Queue_Data){1,0});
    do
    {
        Queue_Data u=Q.top();Q.pop();
        if (vis[u.u]) continue;
        vis[u.u]=1;
        for (int i=Head2[u.u];i!=-1;i=Next2[i])//首先更新第二张图中连向的边
        {
            Degree[V2[i]]--;
            if (Degree[V2[i]]==0)
                if (Dist[V2[i]]!=-1)//当一个点的所有依赖都满足并且这个点已经有值，则丢入堆中
                {
                    Dist[V2[i]]=max(Dist[V2[i]],Dist[u.u]);//注意要与这里次的时间取max
                    Q.push((Queue_Data){V2[i],Dist[V2[i]]});
                }
        }
        for (int i=Head[u.u];i!=-1;i=Next[i])//松弛
            if ((vis[E[i].v]==0)&amp;&amp;((Dist[E[i].v]==-1)||(Dist[E[i].v]&gt;Dist[u.u]+E[i].w)))
            {
                Dist[E[i].v]=Dist[u.u]+E[i].w;
                if (Degree[E[i].v]==0) Q.push((Queue_Data){E[i].v,Dist[E[i].v]});//当满足条件才入队
            }
    }
    while (!Q.empty());
    printf("%lld\n",Dist[n]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>542</wp:post_id>
		<wp:post_date><![CDATA[2018-02-25 10:03:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-25 02:03:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1922-luogu2446sdoi2010%e5%a4%a7%e9%99%86%e4%ba%89%e9%9c%b8%ef%bc%88%e6%9c%80%e7%9f%ad%e8%b7%af%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[178]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2007/Luogu2046][Noi2010]海拔（网络流，平面图对偶图，最短路）</title>
		<link>http://sycstudio.com/archives/543</link>
		<pubDate>Sun, 25 Feb 2018 02:17:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=543</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

YT市是一个规划良好的城市，城市被东西向和南北向的主干道划分为n×n个区域。简单起见，可以将YT市看作一个正方形，每一个区域也可看作一个正方形。从而，YT城市中包括(n+1)×(n+1)个交叉路口和2n×(n+1)条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。下图为一张YT市的地图(n = 2)，城市被划分为2×2个区域，包括3×3个交叉路口和12条双向道路。 小Z作为该市的市长，他根据统计信息得到了每天上班高峰期间YT市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数。每一个交叉路口都有不同的海拔高度值，YT市市民认为爬坡是一件非常累的事情，每向上爬h的高度，就需要消耗h的体力。如果是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为h(注意h可能是负数)，那么一个人经过这段路所消耗的体力是max{0, h}（这里max{a, b}表示取a, b两个值中的较大值）。 小Z还测量得到这个城市西北角的交叉路口海拔为0，东南角的交叉路口海拔为1(如上图所示)，但其它交叉路口的海拔高度都无法得知。小Z想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡所消耗的总体力和的最小值。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2007">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2046">Luogu</a>

<h3>Tag</h3>

网络流，平面图对偶图，最短路

<h2>解决思路</h2>

不要被题目输出要求什么四舍五入吓到了，看到左上角海拔为&#92;(0&#92;)，右下角海拔为&#92;(1&#92;)，那么可以贪心地猜想，图中每一个点的海拔分别是&#92;(0&#92;)或者是&#92;(1&#92;)，并且&#92;(0&#92;)和&#92;(1&#92;)一定是连成一块的。那么也就是说，贡献答案的部分就是&#92;(0&#92;)和&#92;(1&#92;)交界的地方。问题转化为最小割问题。
由于数据范围较大，不能直接用网络流解决，那么考虑到这个图是平面图，所以可以转成对偶图来求最短路。
转成最短路需要注意的是，由于原平面图中正反两个方向的边的容量是不一样的，所以在对偶图中正反边的权值也是不一样的。那么为了保证顺序不变，这里选择的建图方向是，原来西到东和北到南的边在对偶图中从源点方向指向汇点方向，而原来东到西和南到北的边则在对偶图中由汇点方向指向源点方向。这样求最短路即为原图的最小割。
这里用&#92;(Dijkstra&#92;)实现最短路。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=501;
const int maxN=maxMap*maxMap;
const int maxM=maxN*10;
const int inf=2147483647;

class Edge
{
public:
    int v;
    ll w;
};

class Queue_Data
{
public:
    int u;
    ll w;
};

bool operator &lt; (Queue_Data A,Queue_Data B)
{
    return A.w&gt;B.w;
}

int n,S,T;
int edgecnt=0,Head[maxN],Next[maxM],Id[maxMap][maxMap];
Edge E[maxM];
ll Dist[maxN];
priority_queue&lt;Queue_Data&gt; Q;
bool vis[maxN];

void Add_Edge(int u,int v,ll w);

int main()
{
    mem(Head,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) Id[i][j]=++idcnt;//为了方便后续操作，这里对于对偶图的每一个点先标号
    S=n*n+1;T=S+1;n++;//得到源点汇点编号
    for (int i=1;i&lt;=n;i++)//四个矩阵分别读入四个方向的边，同时在对偶图中建图
        for (int j=1;j&lt;n;j++)
        {
            ll w;cin&gt;&gt;w;
            if (i==1) Add_Edge(Id[i][j],T,w);
            else if (i==n) Add_Edge(S,Id[i-1][j],w);
            else Add_Edge(Id[i][j],Id[i-1][j],w);
        }
    for (int i=1;i&lt;n;i++)
        for (int j=1;j&lt;=n;j++)
        {
            ll w;cin&gt;&gt;w;
            if (j==1) Add_Edge(S,Id[i][j],w);
            else if (j==n) Add_Edge(Id[i][j-1],T,w);
            else Add_Edge(Id[i][j-1],Id[i][j],w);
        }
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;n;j++)
        {
            ll w;cin&gt;&gt;w;
            if (i==1) Add_Edge(T,Id[i][j],w);
            else if (i==n) Add_Edge(Id[i-1][j],S,w);
            else Add_Edge(Id[i-1][j],Id[i][j],w);
        }
    for (int i=1;i&lt;n;i++)
        for (int j=1;j&lt;=n;j++)
        {
            ll w;cin&gt;&gt;w;
            if (j==1) Add_Edge(Id[i][j],S,w);
            else if (j==n) Add_Edge(T,Id[i][j-1],w);
            else Add_Edge(Id[i][j],Id[i][j-1],w);
        }
    mem(Dist,-1);Dist[S]=0;//从源点开始求最短路
    Q.push((Queue_Data){S,0});
    do
    {
        Queue_Data u=Q.top();Q.pop();
        if (vis[u.u]) continue;
        vis[u.u]=1;
        for (int i=Head[u.u];i!=-1;i=Next[i])
            if ((vis[E[i].v]==0)&amp;&amp;((Dist[E[i].v]==-1)||(Dist[E[i].v]&gt;Dist[u.u]+E[i].w)))
            {
                Dist[E[i].v]=Dist[u.u]+E[i].w;
                Q.push((Queue_Data){E[i].v,Dist[E[i].v]});
            }
    }
    while (!Q.empty());
    printf("%lld\n",Dist[T]);
    return 0;
}

void Add_Edge(int u,int v,ll w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;
    E[edgecnt].v=v;E[edgecnt].w=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>543</wp:post_id>
		<wp:post_date><![CDATA[2018-02-25 10:17:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-25 02:17:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2007-luogu2046noi2010%e6%b5%b7%e6%8b%94%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be%ef%bc%8c%e6%9c%80%e7%9f%ad%e8%b7%af%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be"><![CDATA[平面图对偶图]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e9%9d%a2%e5%9b%be%e5%af%b9%e5%81%b6%e5%9b%be"><![CDATA[平面图对偶图]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[216]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2006/Luogu2048][NOI2010]超级钢琴（贪心，堆，主席树）</title>
		<link>http://sycstudio.com/archives/544</link>
		<pubDate>Sun, 25 Feb 2018 02:27:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=544</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Z是一个小有名气的钢琴家，最近C博士送给了小Z一架超级钢琴，小Z希望能够用这架钢琴创作出世界上最美妙的音乐。 这架超级钢琴可以弹奏出n个音符，编号为1至n。第i个音符的美妙度为Ai，其中Ai可正可负。 一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于L且不多于R。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。 小Z决定创作一首由k个超级和弦组成的乐曲，为了使得乐曲更加动听，小Z要求该乐曲由k个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小Z想知道他能够创作出来的乐曲美妙度最大值是多少。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2006">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2048">Luogu</a>

<h3>Tag</h3>

贪心，堆，主席树，离散化

<h2>解决思路</h2>

考虑到需要求区间和的问题，那么求完前缀和后转化为求两个值的差最大。那么可以枚举右端点，这时就要求左端点尽量小，而对于每一个右端点，能够作为它的左端点的位置是一个固定的区间，那么可以先把区间最小值求出来，放到堆里面，每一次取出堆顶，然后再把堆顶对应的这个区间接下来小的值（比如次小值）放进堆。那么为了求出区间第&#92;(k&#92;)大，可以使用主席树来维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500010;
const int inf=2147483647;

class Segment
{
public:
    int size;
    int ls,rs;
};

class Queue_Data
{
public:
    ll key;
    int r,kth;
};

bool operator &lt; (Queue_Data A,Queue_Data B)
{
    return A.key&lt;B.key;
}

int n,K,L,R;
int nodecnt=0,numcnt=0,Num[maxN];
int A[maxN],root[maxN];
Segment S[maxN*30];
priority_queue&lt;Queue_Data&gt; Q;

void Build(int &amp;now,int l,int r);
void Modify(int &amp;now,int l,int r,int pos,int key);
int Query(int r1,int r2,int l,int r,int kth);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;K&gt;&gt;L&gt;&gt;R;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;A[i+1];
    for (int i=2;i&lt;=n+1;i++) A[i]=A[i-1]+A[i],Num[i]=A[i];
    sort(&amp;Num[1],&amp;Num[n+2]);//离散化
    numcnt=unique(&amp;Num[1],&amp;Num[n+2])-Num-1;
    Build(root[0],1,n);//建树
    for (int i=1;i&lt;=n+1;i++)
    {
        root[i]=root[i-1];
        Modify(root[i],1,numcnt,lower_bound(&amp;Num[1],&amp;Num[numcnt+1],A[i])-Num,1);
    }
    for (int i=L+1;i&lt;=n+1;i++)//先把每一个合法的区间最小找到并丢入堆中
    {
        int pos=Query(root[max(0,i-R-1)],root[i-L],1,numcnt,1);
        Q.push((Queue_Data){A[i]-Num[pos],i,1});
    }
    ll Ans=0;
    int cnt=0;
    for (int tt=1;tt&lt;=K;tt++)//取出最大，并把区间的下一个丢入堆中
    {
        Queue_Data u=Q.top();Q.pop();
        Ans+=u.key;
        int r=u.r,kth=u.kth;
        if (kth&lt;(r-L)-max(0,r-R-1))
        {
            int pos=Query(root[max(0,r-R-1)],root[r-L],1,numcnt,kth+1);
            Q.push((Queue_Data){A[r]-Num[pos],r,kth+1});
        }
    }
    printf("%lld\n",Ans);
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Modify(int &amp;now,int l,int r,int pos,int key)
{
    S[++nodecnt]=S[now];now=nodecnt;
    if (l==r){
        S[now].size++;return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(S[now].ls,l,mid,pos,key);
    else Modify(S[now].rs,mid+1,r,pos,key);
    S[now].size=S[S[now].ls].size+S[S[now].rs].size;
    return;
}

int Query(int r1,int r2,int l,int r,int kth)
{
    if (l==r) return l;
    int mid=(l+r)&gt;&gt;1;
    int lsize=S[S[r2].ls].size-S[S[r1].ls].size;
    if (lsize&gt;=kth) Query(S[r1].ls,S[r2].ls,l,mid,kth);
    else return Query(S[r1].rs,S[r2].rs,mid+1,r,kth-lsize);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>544</wp:post_id>
		<wp:post_date><![CDATA[2018-02-25 10:27:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-25 02:27:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2006-luogu2048noi2010%e8%b6%85%e7%ba%a7%e9%92%a2%e7%90%b4%ef%bc%88%e8%b4%aa%e5%bf%83%ef%bc%8c%e5%a0%86%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[229]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2599/Luogu4149][IOI2011]Race（点分治）</title>
		<link>http://sycstudio.com/archives/545</link>
		<pubDate>Mon, 26 Feb 2018 03:42:49 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=545</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给一棵树，每条边有权。求一条简单路径，权值和等于 K ，且边的数量最小。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2599">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4149">Luogu</a>

<h3>Tag</h3>

点分治

<h2>解决思路</h2>

考虑点分治。对于一个重心，我们需要求出一条过重心的合法路径，那么可以考虑开桶，记&#92;(Min[i]&#92;)表示与重心距离&#92;(i&#92;)的经过的边最短的点的编号。那么，接下来的问题是如何不重不漏地找到解。
考虑到我们已经要求这条路径一定要经过当前重心，那么一条合法的路径要么就是直接从重心出发，要么是由两条不同子树的两条路径组合而成的。那么可以考虑计算当前子树答案的时候，先不用它取更新&#92;(Min&#92;)数组，这样可以保证当前答案一定从前面其他子树更新过来，遍历完这一子树后，再把这棵子树的去更新&#92;(Min&#92;)。
需要注意的是，为了保证时间效率高效，每一次初始化&#92;(Min&#92;)不要用&#92;(memset&#92;)。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int maxM=maxN*2;
const int maxNum=1000100;
const int inf=2147483647;

int n,K,root,nowsum;
ll Ans=inf;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM],Depth[maxN],Dist[maxN];
int Size[maxN],mxSon[maxN];
bool vis[maxN];
ll Min[maxNum];
int stacktop=0,Stack[maxN];

void Add_Edge(int u,int v,int w);
void GetRoot(int u,int fa);
void Solve(int u);
void GetAns(int u,int dep,int dis,int fa);

int main()
{
    mem(Head,-1);mem(Min,63);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;K;
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;u++;v++;
        Add_Edge(u,v,w);Add_Edge(v,u,w);
    }
    root=0;mxSon[0]=inf;nowsum=n;
    GetRoot(1,0);
    Solve(root);
    if (Ans==inf) printf("-1\n");
    else printf("%lld\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//点分治
{
    Min[0]=0;stacktop=0;//注意这里要把Min[0]置为0，因为直接从重心出发的路径也是合法的。
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            int lasttop=stacktop;//把这一次的点先放入栈中
            GetAns(V[i],1,W[i],u);
            for (int i=lasttop+1;i&lt;=stacktop;i++){//再更新Min
                int u=Stack[i];
                if ((Dist[u]&lt;=K)&amp;&amp;(Min[Dist[u]]&gt;Depth[u])) Min[Dist[u]]=Depth[u];
            }
        }
    for (int i=1;i&lt;=stacktop;i++) if (Dist[Stack[i]]&lt;=K) Min[Dist[Stack[i]]]=inf;//重新初始化Min，方便下一次计算
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            root=0;nowsum=Size[V[i]];
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

void GetAns(int u,int dep,int dis,int fa)
{
    Depth[u]=dep;Dist[u]=dis;Stack[++stacktop]=u;
    if (Dist[u]&lt;=K) Ans=min(Ans,dep+Min[K-Dist[u]]);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((vis[V[i]]==0)&amp;&amp;(V[i]!=fa))
            GetAns(V[i],dep+1,dis+W[i],u);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>545</wp:post_id>
		<wp:post_date><![CDATA[2018-02-26 11:42:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-26 03:42:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2599-luogu4149ioi2011race%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="ioi"><![CDATA[IOI]]></category>
		<category domain="post_tag" nicename="ioi"><![CDATA[IOI]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[214]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4812]D Tree（点分治，逆元）</title>
		<link>http://sycstudio.com/archives/546</link>
		<pubDate>Mon, 26 Feb 2018 06:15:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=546</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

There is a skyscraping tree standing on the playground of Nanjing University of Science and Technology. On each branch of the tree is an integer (The tree can be treated as a connected graph with N vertices, while each branch can be treated as a vertex). Today the students under the tree are considering a problem: Can we find such a chain on the tree so that the multiplication of all integers on the chain (mod 10 6 + 3) equals to K?
Can you help them in solving this problem?

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4812">HDU</a>

<h3>Tag</h3>

点分治，逆元

<h2>题目大意</h2>

给出一棵树，求一条起点终点字典序最小的点对，使得点对经过路径上点权之积在&#92;(mod 1e6+3&#92;)下等于给定的&#92;(K&#92;)

<h2>解决思路</h2>

考虑点分治。每一次从重心出发，求出所有点到重心的路径上除重心以外的点权之积。这里要去掉重心的原因是，我们在拼路径的时候，直接拼的话就会重复算一遍重心的点权。那么，类似<a href="http://sycstudio.com/archives/545">这一题</a>的方法，记录&#92;(Min[i]&#92;)表示到重心路径上除重心外的点权之积为&#92;(i&#92;)的编号最小的点，我们可以每一次遍历重心的一棵子树，用之前遍历过的其他子树的信息来与这一次的遍历构造答案。在这一次遍历完之后，再用这一次的信息来更新&#92;(Min&#92;)。
另外为了方便地求出比如已知&#92;(x&#92;)和&#92;(x&#42;y==z (mod p)&#92;)，先预处理出&#92;([1,Mod]&#92;)内所有数关于&#92;(Mod&#92;)的逆元。递推即可。
最后，题目明确指出了可能的爆栈风险，所以需要在提交的地方选择&#92;(C++&#92;)并在代码首部加入&#92;(pragma&#92;)一句以扩大栈空间。

<h2>代码</h2>

<pre><code class="language-cpp ">#pragma comment(linker,"/STACK:102400000,102400000")
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int maxM=maxN*2;
const int Mod=1e6+3;
const int inf=1061109567;

int n;
ll K;
int nowsum,root,Ans1=inf,Ans2=inf;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll Node[maxN];
int Size[maxN],mxSon[maxN];
ll Inv[Mod+10],Depth[maxN];
bool vis[maxN];
int stacktop=0,Stack[maxN];
int Min[Mod+10];

void Add_Edge(int x,int y);
void GetRoot(int u,int fa);
void Solve(int u);
void GetAns(int u,int fa,ll ret);
void Modify(int u,int v);

int main()
{
    ios::sync_with_stdio(false);
    Inv[1]=1;
    for (int i=2;i&lt;Mod;i++) Inv[i]=((ll)(Mod-Mod/i)*(ll)Inv[Mod%i]+Mod)%Mod;//预处理逆元
    while (cin&gt;&gt;n&gt;&gt;K)
    {
        edgecnt=0;Ans1=Ans2=inf;mem(vis,0);mem(Head,-1);mem(Min,63);
        for (int i=1;i&lt;=n;i++) cin&gt;&gt;Node[i];
        for (int i=1;i&lt;=n;i++) Node[i]=Node[i]%Mod;
        for (int i=1;i&lt;n;i++)
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            Add_Edge(x,y);Add_Edge(y,x);
        }
        mxSon[0]=inf;root=0;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        if ((Ans1==inf)||(Ans2==inf)) printf("No solution\n");
        else printf("%d %d\n",Ans1,Ans2);
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void GetRoot(int u,int fa)
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)
{
    stacktop=0;
    Min[Node[u]]=u;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            int lasttop=stacktop;
            GetAns(V[i],u,1);//先遍历构造解
            for (int j=lasttop+1;j&lt;=stacktop;j++)//再延迟更新信息
            {
                ll w=Depth[Stack[j]]*Node[u]%Mod;
                Min[w]=min(Min[w],Stack[j]);
            }
        }
    vis[u]=1;
    for (int i=1;i&lt;=stacktop;i++)
    {
        ll w=Depth[Stack[i]]*Node[u]%Mod;
        Min[w]=inf;
    }
    Min[Node[u]]=inf;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            root=0;nowsum=Size[V[i]];
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

void GetAns(int u,int fa,ll ret)//dfs当前子树，用之前得到的信息尝试构造解
{
    ret=ret*Node[u]%Mod;
    Depth[u]=ret;Stack[++stacktop]=u;
    Modify(u,Min[K*Inv[ret]%Mod]);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((vis[V[i]]==0)&amp;&amp;(V[i]!=fa))
            GetAns(V[i],u,ret);
    return;
}

void Modify(int u,int v)
{
    if (u&gt;v) swap(u,v);
    if (v==inf) return;
    if (Ans1&gt;u) {
        Ans1=u;Ans2=v;
    }
    else if ((Ans1==u)&amp;&amp;(Ans2&gt;v)) {
        Ans1=u;Ans2=v;
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>546</wp:post_id>
		<wp:post_date><![CDATA[2018-02-26 14:15:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-26 06:15:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4812d-tree%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e9%80%86%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<category domain="post_tag" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[179]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5909]Tree Cutting（点分治，计数动态规划）</title>
		<link>http://sycstudio.com/archives/549</link>
		<pubDate>Mon, 26 Feb 2018 06:36:42 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=549</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Byteasar has a tree T with n vertices conveniently labeled with 1,2,...,n. Each vertex of the tree has an integer value vi.
The value of a non-empty tree T is equal to v1⊕v2⊕...⊕vn, where ⊕ denotes bitwise-xor.
Now for every integer k from [0,m), please calculate the number of non-empty subtree of T which value are equal to k.
A subtree of T is a subgraph of T that is also a tree.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5909">HDU</a>

<h3>Tag</h3>

点分治，计数动态规划

<h2>题目大意</h2>

给出一棵树，定义树中连通块的权为连通块中所有点的点权的异或和。分别求权为&#92;([1,k]&#92;)的连通块个数。

<h2>解决思路</h2>

点分治，要求当前重心必选，那么就往下选的话，要么一定选择父亲，此时直接把父亲的计数往儿子传，要么父亲不选，此时儿子也不选，这就是连通块到父亲就结束的答案。
如何统计答案呢？我们记&#92;(F[i][j]&#92;)表示当&#92;(dfs&#92;)搜索到&#92;(i&#92;)这个点时，它所在的连通块异或和为&#92;(j&#92;)的方案数。这里我们还要求，&#92;(i&#92;)的答案只能从&#92;(i&#92;)的子树以及在遍历&#92;(i&#92;)的子树之前遍历的其他以当前重心为根的子树转移，要求这样转移顺序的目的是保证不会出现不合法情况和避免重复计算。那么，每向下递归&#92;(i&#92;)的儿子时，把&#92;(F[i][j]&#92;)的&#92;(j&#92;)异或上儿子的点权向下传递，递归回来之后，再把儿子的答案累加回来。这样做同样保证了枚举顺序。

<h2>代码</h2>

<pre><code class="language-cpp ">#pragma comment(linker,"/STACK:102400000,102400000")
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxNum=1030;
const int maxM=maxN*2;
const int Mod=1e9+7;
const int inf=2147483647;

int n,m;
int nowsum,root;
int Size[maxN],mxSon[maxN];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Node[maxN];
bool vis[maxN];
int F[maxN][maxNum],Ans[maxNum];

void Add_Edge(int u,int v);
void GetRoot(int u,int fa);
void Solve(int u);
void GetAns(int u,int fa);

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        edgecnt=0;mem(Head,-1);mem(vis,0);mem(Ans,0);
        cin&gt;&gt;n&gt;&gt;m;
        for (int i=1;i&lt;=n;i++) cin&gt;&gt;Node[i];
        for (int i=1;i&lt;n;i++)
        {
            int u,v;cin&gt;&gt;u&gt;&gt;v;
            Add_Edge(u,v);Add_Edge(v,u);
        }
        root=0;mxSon[0]=inf;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        for (int i=0;i&lt;m;i++){
            printf("%d",Ans[i]);
            if (i==m-1) printf("\n");
            else printf(" ");
        }
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((vis[V[i]]==0)&amp;&amp;(V[i]!=fa))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//分治
{
    for (int i=0;i&lt;m;i++) F[u][i]=0;//清空
    F[u][Node[u]]=1;vis[u]=1;//初始化
    GetAns(u,0);//dfs递归
    for (int i=0;i&lt;m;i++) Ans[i]=(Ans[i]+F[u][i])%Mod;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            root=0;nowsum=Size[V[i]];
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

void GetAns(int u,int fa)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            for (int j=0;j&lt;m;j++) F[V[i]][j]=0;//子节点初始化
            for (int j=0;j&lt;m;j++) F[V[i]][Node[V[i]]^j]=(F[V[i]][Node[V[i]]^j]+F[u][j])%Mod;//把值传给儿子
            GetAns(V[i],u);
            for (int j=0;j&lt;m;j++) F[u][j]=(F[u][j]+F[V[i]][j])%Mod;//再从儿子更新回来
        }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>549</wp:post_id>
		<wp:post_date><![CDATA[2018-02-26 14:36:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-26 06:36:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5909tree-cutting%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[356]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>110</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.29.217]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-08 12:49:42]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-08 04:49:42]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是啊，网上一堆fwt解的，那个好像是与集合有关的解法，我不会，所以就用点分治动态规划计数过去了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>108</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>108</wp:comment_id>
			<wp:comment_author><![CDATA[wfj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[653496492@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-06 17:45:56]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-06 09:45:56]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个题不是fwt吗。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU5469]Antonidas（点分治，字符串Hash）</title>
		<link>http://sycstudio.com/archives/551</link>
		<pubDate>Mon, 26 Feb 2018 12:41:11 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=551</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given a tree with N vertices and N−1 edges. Each vertex has a single letter Ci. Given a string S, you are to choose two vertices A and B, and make sure the letters catenated on the shortest path from A to B is exactly S. Now, would you mind telling me whether the path exists?

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5469">HDU</a>

<h3>Tag</h3>

点分治，字符串&#92;(Hash&#92;)

<h2>题目大意</h2>

给出一棵树，每一个点上有一个字符。现在给出一个字符串，求树上是否存在一条路径使得路径上的字符连起来可以得到给出的字符串。

<h2>解决思路</h2>

考虑点分治强制重心必选，那么就向子树中递归统计答案。为了方便处理字符串匹配，可以采用&#92;(Hash&#92;)的方式，将原字符串正着倒着分别求一遍&#92;(Hash&#92;)，得到所有前缀后缀的&#92;(Hash&#92;)，那么在点分治的时候，对于递归一棵子树，第一遍先不算重心，与之前的答案尝试组合，分别尝试组合前缀或后缀，第二遍算重心加入信息中以方便后面查询。
为了方便在树上向下递归的时候快速求出当前点到当前根的路径上的字符串的&#92;(hash&#92;)值，这里采用&#92;(BKDRHash&#92;)（是叫这个名字吧？）

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10010;
const int maxM=maxN*2;
const ll Hashbase=19491001;
const int Mod=1000003;
const int inf=2147483647;

int n,nowsum,root,len;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
char Node[maxN],S[maxN];
int Size[maxN],mxSon[maxN];
ll Hashpre[maxN],Hashsuf[maxN];//前缀和后缀分别的hash
bool vis[maxN];
int histcnt=0,Hpre[Mod+10],Hsuf[Mod+10];//histcnt标记当前是第几次，避免memset浪费时间，Hpre和Hsuf分别标记前缀和后缀是否在这一次solve中出现过，方便组合答案
ll Seedret[maxN];
bool is_get_ans;//当得到答案时，退出

void Add_Edge(int u,int v);
void GetRoot(int u,int fa);
void Solve(int u);
void GetAns(int u,int fa,ll nowhash,int depth);
void Modify(int u,int fa,ll nowhash,int depth);

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    Seedret[1]=1;
    for (int i=2;i&lt;maxN;i++) Seedret[i]=(ll)Seedret[i-1]*Hashbase%Mod;
    for (int tt=1;tt&lt;=T;tt++)
    {
        edgecnt=0;mem(Head,-1);mem(vis,0);is_get_ans=0;
        cin&gt;&gt;n;
        for (int i=1;i&lt;n;i++)
        {
            int u,v;cin&gt;&gt;u&gt;&gt;v;
            Add_Edge(u,v);Add_Edge(v,u);
        }
        cin&gt;&gt;(Node+1);cin&gt;&gt;(S+1);
        len=strlen(S+1);
        Hashpre[0]=0;//得到hash值
        for (int i=1;i&lt;=len;i++)
            Hashpre[i]=((ll)Hashpre[i-1]*Hashbase+S[i])%Mod;
        Hashsuf[len+1]=0;
        for (int i=len;i&gt;=1;i--)
            Hashsuf[i]=((ll)Hashsuf[i+1]*Hashbase+S[i])%Mod;
        root=0;mxSon[0]=inf;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        printf("Case #%d: ",tt);
        if (is_get_ans) printf("Find\n");
        else printf("Impossible\n");
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((vis[V[i]]==0)&amp;&amp;(V[i]!=fa))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//点分治求解
{
    vis[u]=1;
    histcnt++;
    if (Node[u]==S[1]) Hpre[1]=histcnt;//先把重心加入
    if (Node[u]==S[len]) Hsuf[len]=histcnt;
    if (((Node[u]==S[1])||(Node[u]==S[len]))&amp;&amp;(len==1)) is_get_ans=1;//特判字符串长度为1的情况
    for (int i=Head[u];(i!=-1)&amp;&amp;(is_get_ans==0);i=Next[i])
        if (vis[V[i]]==0)
        {
            GetAns(V[i],u,Node[V[i]],1);//先用前面的信息取组合，这时不能算重心
            Modify(V[i],u,((ll)Node[V[i]]*Hashbase%Mod+Node[u])%Mod,2);//再把这一次的加入信息中，以便后面查询，这时就要算重心
        }
    for (int i=Head[u];(i!=-1)&amp;&amp;(is_get_ans==0);i=Next[i])
        if (vis[V[i]]==0)
        {
            root=0;nowsum=Size[V[i]];
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

void GetAns(int u,int fa,ll nowhash,int depth)//nowhash记录当前到重心（不包括重心）的字符串hash值
{
    if ((nowhash==Hashpre[depth])&amp;&amp;(Hsuf[depth+1]==histcnt))//组合答案
    {
        is_get_ans=1;
        return;
    }
    if ((nowhash==Hashsuf[len-depth+1])&amp;&amp;(Hpre[len-depth]==histcnt))//组合答案
    {
        is_get_ans=1;
        return;
    }
    for (int i=Head[u];(i!=-1)&amp;&amp;(is_get_ans==0);i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
            GetAns(V[i],u,(Seedret[depth+1]*Node[V[i]]%Mod+nowhash)%Mod,depth+1);
    return;
}

void Modify(int u,int fa,ll nowhash,int depth)
{
    if (nowhash==Hashpre[depth])//当是一个合法前缀或后缀时，更新信息
        Hpre[depth]=histcnt;
    if (nowhash==Hashsuf[len-depth+1])
        Hsuf[len-depth+1]=histcnt;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
            Modify(V[i],u,(Seedret[depth+1]*Node[V[i]]%Mod+nowhash)%Mod,depth+1);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>551</wp:post_id>
		<wp:post_date><![CDATA[2018-02-26 20:41:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-26 12:41:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5469antonidas%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e5%ad%97%e7%ac%a6%e4%b8%b2hash%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bkdrhash"><![CDATA[BKDRHash]]></category>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[258]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>130</wp:comment_id>
			<wp:comment_author><![CDATA[xzy]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[347605798@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.cnblogs.com/xzyxzy/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-25 22:15:19]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-25 14:15:19]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主你的cpp出问题辣]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>131</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-25 22:26:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-25 14:26:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已修复]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>130</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ1305/Luogu3153][CQOI2009]dance跳舞（网络流）</title>
		<link>http://sycstudio.com/archives/552</link>
		<pubDate>Mon, 26 Feb 2018 14:10:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=552</guid>
		<description></description>
		<content:encoded><![CDATA[8###  Description
一次舞会有n个男孩和n个女孩。每首曲子开始时，所有男孩和女孩恰好配成n对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和k个不喜欢的女孩跳舞，而每个女孩也最多只愿意和k个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1305">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3153">Luogu</a>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

对于每一个人拆成两个点，一个点表示喜欢的，另一个点表示不喜欢的，若两个人互相喜欢，那么就连接两个表示的点，否则连接两个表示不喜欢的点。然后，由于要求一个人最多只与&#92;(k&#92;)个不喜欢的人跳，那么一个人拆成的两个点之间的容量就为&#92;(k&#92;)。那么接下来就是枚举轮数，每一次修改对应的从源点连出的边和到汇点的边。若当前最大流等于人数乘以轮数，则可以继续，否则轮数--

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51*4;
const int maxM=maxN*100;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,K,S,T;
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
char Input[maxN];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;K;S=n*4+1;T=S+1;//建图
    for (int i=1;i&lt;=n;i++) Add_Edge(S,i,0),Add_Edge(i,i+n+n,K);
    for (int i=1;i&lt;=n;i++) Add_Edge(i+n,T,0),Add_Edge(i+n+n+n,i+n,K);
    for (int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;(Input+1);
        for (int j=1;j&lt;=n;j++)
            if (Input[j]=='Y') Add_Edge(i,j+n,1);
            else Add_Edge(i+n+n,j+n+n+n,1);
    }
    int round=0,mxflow=0;
    do//枚举轮数
    {
        while (Bfs())//求最大流
        {
            for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
            while (int di=dfs(S,inf)) mxflow+=di;
        }
        if (mxflow!=round*n) break;
        round++;
        for (int i=Head[S];i!=-1;i=Next[i])
            if ((E[i].v&gt;=1)&amp;&amp;(E[i].v&lt;=n)) E[i].flow++;
        for (int i=Head[T];i!=-1;i=Next[i])
            if ((E[i].v&gt;=n+1)&amp;&amp;(E[i].v&lt;=n+n)) E[i^1].flow++;
    }
    while (1);
    printf("%d\n",round-1);
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;
    E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;
    E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((Depth[E[i].v]==-1)&amp;&amp;(E[i].flow&gt;0))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (h!=t);
    if (Depth[T]!=-1) return 1;
    return 0;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>552</wp:post_id>
		<wp:post_date><![CDATA[2018-02-26 22:10:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-26 14:10:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1305-luogu3153cqoi2009dance%e8%b7%b3%e8%88%9e%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[191]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1501/Luogu4205][NOI2005]智慧珠游戏（搜索）</title>
		<link>http://sycstudio.com/archives/553</link>
		<pubDate>Tue, 27 Feb 2018 15:57:28 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=553</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/media/BZOJ/BZOJ1501.jpg" alt="BZOJ1501-1" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1501">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4205">Luogu</a>

<h3>Tag</h3>

搜索

<h2>解决思路</h2>

把每一种状态的旋转和翻折全部找出来，大力搜索即可。注意开局可以判断一下合法情况，若出现连通数小于等于&#92;(2&#92;)的联通块，则直接无解。
（哈哈，代码没有超过200行）

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

class Pos
{
public:
    int x,y;
};

Pos operator + (Pos A,Pos B)
{
    return (Pos){A.x+B.x,A.y+B.y};
}

class Vector
{
public:
    int num;
    Pos P[5];
};

const int maxN=14;
const int mPos=10;
//下面Vec记录每一个合法摆放联通块的信息，每一行表示同一组，即通过旋转和翻折可以变成一样的零件
const Vector Vec[60]={(Vector){3,(Pos){0,0},(Pos){1,0},(Pos){0,1}},(Vector){3,(Pos){0,0},(Pos){0,1},(Pos){1,1}},(Vector){3,(Pos){0,0},(Pos){1,0},(Pos){1,1}},(Vector){3,(Pos){0,0},(Pos){1,0},(Pos){1,-1}},
                    (Vector){4,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){0,3}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){3,0}},
                    (Vector){4,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,0}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,1}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){1,-2}},(Vector){4,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){2,1}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){1,2}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){0,1}},(Vector){4,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,2}},(Vector){4,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,-1}},
                    (Vector){4,(Pos){0,0},(Pos){1,0},(Pos){0,1},(Pos){1,1}},
                    (Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,1},(Pos){2,2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,2},(Pos){2,2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,0},(Pos){2,0}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,-1},(Pos){2,-2}},
                      (Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){0,3},(Pos){1,1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){0,3},(Pos){1,2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){1,1},(Pos){1,2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-2},(Pos){1,-1},(Pos){1,1}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){3,0},(Pos){2,1}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,-1},(Pos){3,0}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){2,0},(Pos){3,0}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){2,0},(Pos){3,0}},
                    (Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){0,2},(Pos){1,2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){1,2},(Pos){0,2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){2,0},(Pos){2,1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){2,1},(Pos){2,0}},
                      (Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,1},(Pos){0,2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){0,2},(Pos){1,2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){2,0},(Pos){2,1}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){1,-1},(Pos){2,-1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,1},(Pos){1,2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,1},(Pos){1,-1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,1},(Pos){2,1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,1},(Pos){2,0}},
                    (Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,2},(Pos){1,3}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,-1},(Pos){3,-1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){1,2},(Pos){1,3}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){2,-1},(Pos){3,-1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,-1},(Pos){1,-2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){2,1},(Pos){3,1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){1,0},(Pos){1,-1}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){2,1},(Pos){3,1}},
                    (Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){1,1},(Pos){2,0}},
                      (Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){2,1},(Pos){2,2}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){2,-1},(Pos){2,-2}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){1,-1},(Pos){2,-1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){1,2},(Pos){2,2}},
                    (Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,-1},(Pos){1,-2},(Pos){1,-3}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){1,1},(Pos){1,2},(Pos){1,3}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){3,0},(Pos){3,-1}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){2,0},(Pos){3,0},(Pos){3,1}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){0,2},(Pos){0,3},(Pos){1,3}},(Vector){5,(Pos){0,0},(Pos){1,0},(Pos){0,1},(Pos){0,2},(Pos){0,3}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,0},(Pos){2,0},(Pos){3,0}},(Vector){5,(Pos){0,0},(Pos){0,1},(Pos){1,1},(Pos){2,1},(Pos){3,1}}};
const int F1[5]={0,1,-1,0,0};
const int F2[5]={0,0,0,-1,1};
const int inf=2147483647;

char Map[maxN][maxN];
char Opt[62]={"AAAABBCCCCCCCCDEEEEFFFFFFFFGGGGHHHHHHHHIIIIIIIIJKKKKLLLLLLLL"};
bool vis[100];
bool get_ans=0;
Pos Queue[maxN*maxN];

void dfs(int x,int y);
IL bool Check(RG int x,RG int y,RG int f);
IL void Cover(RG int x,RG int y,RG int f,RG char ch);
IL bool Bfs();

int main()
{
    ios::sync_with_stdio(false);
    for (RG int i=1;i&lt;=10;i++)
        for (RG int j=1;j&lt;=i;j++)
        {
            RG char opt;cin&gt;&gt;opt;
            Map[i][j]=opt;
            if (Map[i][j]!='.') vis[Map[i][j]]=1;
        }
    if (Bfs()==1) dfs(1,1);
    if (get_ans==0) printf("No solution\n");
    return 0;
}

void dfs(RG int x,RG int y)//搜索
{
    if (y&gt;x) x++,y=1;
    if (x==11)
    {
        for (RG int i=1;i&lt;=10;i++)
        {
            for (RG int j=1;j&lt;=i;j++) printf("%c",Map[i][j]);
            printf("\n");
        }
        fclose(stdin);fclose(stdout);
        get_ans=1;
        return;
    }
    if (Map[x][y]!='.') dfs(x,y+1);
    for (RG int i=0;(i&lt;=59)&amp;&amp;(get_ans==0);i++)//59种方式
        if (vis[Opt[i]]==0)
            if (Check(x,y,i))//检查这样摆放是否合法
            {
                vis[Opt[i]]=1;
                Cover(x,y,i,Opt[i]);//摆放
                dfs(x,y+1);
                Cover(x,y,i,'.');//修复回来
                vis[Opt[i]]=0;
            }
    return;
}

IL bool Check(RG int x,RG int y,RG int f)
{
    RG int x2,y2;
    for (RG int i=0;i&lt;Vec[f].num;i++)
    {
        x2=x+Vec[f].P[i].x;y2=y+Vec[f].P[i].y;
        if (Map[x2][y2]!='.') return 0;
    }
    return 1;
}

IL void Cover(RG int x,RG int y,RG int f,RG char ch)
{
    for (RG int i=0;i&lt;Vec[f].num;i++)
        Map[x+Vec[f].P[i].x][y+Vec[f].P[i].y]=ch;
    return;
}

int histcnt=0;
int inqueue[maxN][maxN];

IL bool Bfs()
{
    histcnt++;
    for (RG int i=1;i&lt;=10;i++)
        for (RG int j=1;j&lt;=i;j++)
            if ((inqueue[i][j]!=histcnt)&amp;&amp;(Map[i][j]=='.'))
            {
                RG int h=1,t=0;
                Queue[1]=(Pos){i,j};inqueue[i][j]=histcnt;
                do
                {
                    RG Pos u=Queue[++t];
                    for (int f=1;f&lt;=4;f++)
                        if ((u.x+F1[f]&gt;=1)&amp;&amp;(u.x+F1[f]&lt;=10)&amp;&amp;(u.y+F2[f]&gt;=1)&amp;&amp;(u.y+F2[f]&lt;=10)&amp;&amp;(Map[u.x+F1[f]][u.y+F2[f]]=='.')&amp;&amp;(inqueue[u.x+F1[f]][u.y+F2[f]]!=histcnt))
                        {
                            Queue[++h]=(Pos){u.x+F1[f],u.y+F2[f]};
                            inqueue[u.x+F1[f]][u.y+F2[f]]=histcnt;
                        }
                }
                while (t!=h);
                if (h&lt;=2) return 0;
            }
    return 1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>553</wp:post_id>
		<wp:post_date><![CDATA[2018-02-27 23:57:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-27 15:57:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1501-luogu4205noi2005%e6%99%ba%e6%85%a7%e7%8f%a0%e6%b8%b8%e6%88%8f%ef%bc%88%e6%90%9c%e7%b4%a2%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[216]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3931/Luogu3171][CQOI2015]网络吞吐量（网络流，最短路）</title>
		<link>http://sycstudio.com/archives/559</link>
		<pubDate>Tue, 20 Mar 2018 14:21:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=559</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

路由是指通过计算机网络把信息从源地址传输到目的地址的活动，也是计算机网络设计中的重点和难点。网络中实现路由转发的硬件设备称为路由器。为了使数据包最快的到达目的地，路由器需要选择最优的路径转发数据包。例如在常用的路由算法OSPF(开放式最短路径优先)中，路由器会使用经典的Dijkstra算法计算最短路径，然后尽量沿最短路径转发数据包。现在，若已知一个计算机网络中各路由器间的连接情况，以及各个路由器的最大吞吐量（即每秒能转发的数据包数量），假设所有数据包一定沿最短路径转发，试计算从路由器1到路由器n的网络的最大吞吐量。计算中忽略转发及传输的时间开销，不考虑链路的带宽限制，即认为数据包可以瞬间通过网络。路由器1到路由器n作为起点和终点，自身的吞吐量不用考虑，网络上也不存在将1和n直接相连的链路。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3931">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3171">Luogu</a>

<h3>Tag</h3>

网络流，最短路

<h2>解决思路</h2>

先走出最短路，求出最短路图，保证上面的每一条边的转移都是在最短路上转移，然后求最大流即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=510*2;
const int maxM=(100010+maxN)*10;
const ll INF=1e17;

class Edge
{
public:
    ll v,flow;
    ll w;
};

class Queue_Data
{
public:
    int u;
    ll dis;
};

bool operator &lt; (Queue_Data A,Queue_Data B)
{
    return A.dis&gt;B.dis;
}

int n,m,S,T;
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
ll Dist[maxN];
int Depth[maxN],Queue[maxN],cur[maxN];
priority_queue&lt;Queue_Data&gt; Q;
bool vis[maxN];

void Add_Edge(int u,int v,ll w,ll flow);
bool Bfs();
ll dfs(int u,ll flow);

int main()
{
    mem(Head,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;S=1;T=n+n;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;ll w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        if (u!=n) Add_Edge(u+n,v,w,INF);
        if (v!=n) Add_Edge(v+n,u,w,INF);
    }
    for (int i=1;i&lt;=n;i++)
    {
        ll w;cin&gt;&gt;w;
        Add_Edge(i,i+n,0,w);
    }
    Add_Edge(1,1+n,0,INF);Add_Edge(n,n+n,0,INF);
    mem(Dist,-1);Dist[S]=0;//先求最短路
    Q.push((Queue_Data){S,0});
    do
    {
        Queue_Data u=Q.top();Q.pop();
        if (vis[u.u]) continue;
        vis[u.u]=1;
        for (int i=Head[u.u];i!=-1;i=Next[i])
            if ((vis[E[i].v]==0)&amp;&amp;(E[i].flow&gt;0)&amp;&amp;((Dist[E[i].v]==-1)||(Dist[E[i].v]&gt;Dist[u.u]+E[i].w)))
            {
                Dist[E[i].v]=Dist[u.u]+E[i].w;
                Q.push((Queue_Data){E[i].v,Dist[E[i].v]});
            }
    }
    while (!Q.empty());
    ll mxflow=0;//在最短路上走最大流
    while (Bfs())
    {
        for (int i=S;i&lt;=T;i++) cur[i]=Head[i];
        while (ll di=dfs(S,INF)) mxflow=mxflow+di;
    }
    printf("%lld\n",mxflow);
    return 0;
}

void Add_Edge(int u,int v,ll w,ll flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;
    E[edgecnt].v=v;E[edgecnt].w=w;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;
    E[edgecnt].v=u;E[edgecnt].w=-w;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Dist[E[i].v]==Dist[u]+E[i].w)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

ll dfs(int u,ll flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Dist[E[i].v]==Dist[u]+E[i].w)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            ll di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>559</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 22:21:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 14:21:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3931-luogu3171cqoi2015%e7%bd%91%e7%bb%9c%e5%90%9e%e5%90%90%e9%87%8f%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e6%9c%80%e7%9f%ad%e8%b7%af%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[158]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[hihocoder1403]后缀数组一·重复旋律（后缀数组，单调队列）</title>
		<link>http://sycstudio.com/archives/560</link>
		<pubDate>Tue, 20 Mar 2018 14:32:35 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=560</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为长度为 N 的数构成的数列。

小Hi在练习过很多曲子以后发现很多作品自身包含一样的旋律。旋律是一段连续的数列，相似的旋律在原数列可重叠。比如在1 2 3 2 3 2 1 中 2 3 2 出现了两次。

小Hi想知道一段旋律中出现次数至少为K次的旋律最长是多少？

<h3>Tag</h3>

后缀数组

<h2>解决思路</h2>

提出所有的后缀后，相同旋律就是后缀中相同的前缀，那么出现次数为K就是要求重复了K次的相同前缀。
后缀数组求出Height后，问题转化为求连续的K个值的最小值中的最大值，这个可以用单调队列来维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=20010;
const int inf=2147483647;

int n,K;
int Arr[maxN];
int SA[maxN],Rank[maxN],Height[maxN];
int CntA[maxN],CntB[maxN],A[maxN],B[maxN],SAA[maxN];
int Queue[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;K;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Arr[i];
    //GetSA
    //初始化第一次排序的Rank
    mem(CntA,0);
    for (int i=1;i&lt;=n;i++) CntA[Arr[i]]++;
    for (int i=1;i&lt;=n;i++) CntA[i]+=CntA[i-1];
    for (int i=n;i&gt;=1;i--) SA[CntA[Arr[i]]--]=i;
    Rank[SA[1]]=1;
    //倍增求解SA
    for (int i=2;i&lt;=n;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (Arr[SA[i]]!=Arr[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[n]]&lt;n;l=l&lt;&lt;1)
    {
        for (int i=0;i&lt;=n;i++) CntA[i]=CntB[i]=0;
        for (int i=1;i&lt;=n;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=n)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;=n;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=n;i&gt;=0;i--) SAA[CntB[B[i]]--]=i;
        for (int i=n;i&gt;=0;i--) SA[CntA[A[SAA[i]]]--]=SAA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=n;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    //根据得到的SA和Rank构造出Height
    for (int i=1,j=0;i&lt;=n;i++)
    {
        if (j) j--;
        while (Arr[i+j]==Arr[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    int l=0,r=0;
    int Ans=0;
    for (int i=1;i&lt;=n;i++)
    {
        while ((l&lt;r)&amp;&amp;(Height[Queue[r]]&gt;Height[i])) r--;
        Queue[++r]=i;
        if (i&lt;=K-1) continue;
        while ((l&lt;r)&amp;&amp;(Queue[l]+K-2&lt;i)) l++;
        Ans=max(Ans,Height[Queue[l]]);
    }
    printf("%d\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>560</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 22:32:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 14:32:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hihocoder1403%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%e4%b8%80%c2%b7%e9%87%8d%e5%a4%8d%e6%97%8b%e5%be%8b%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%8c%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="post_tag" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[189]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[hihocoder1407]后缀数组二·重复旋律2（后缀数组，二分）</title>
		<link>http://sycstudio.com/archives/561</link>
		<pubDate>Tue, 20 Mar 2018 14:42:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=561</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为长度为 N 的数构成的数列。小Hi在练习过很多曲子以后发现很多作品自身包含一样的旋律。

旋律可以表示为一段连续的数列，相似的旋律在原数列不可重叠，比如在1 2 3 2 3 2 1 中 2 3 2 出现了一次，2 3 出现了两次，小Hi想知道一段旋律中出现次数至少为两次的旋律最长是多少？

<h3>Tag</h3>

后缀数组，二分

<h2>解决思路</h2>

在<a href="http://sycstudio.com/archives/560">这一题</a>的基础上，要求不能出现重叠。考虑到这个答案具有单调性，那么我们二分这个长度是多少，二分判定的时候，判断在连续的一段Height大于等于当前二分长度的后缀中，是否存在两者距离超过当前二分长度的。
需要注意在不连续的时候要更新当前的min和max。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int inf=2147483647;

int n;
int Arr[maxN];
int CntA[maxN+20],CntB[maxN+20],SAA[maxN];
int SA[maxN],Rank[maxN],Height[maxN];
int A[maxN],B[maxN];

bool Check(int mid);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    //后缀数组构造
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Arr[i];
    for (int i=1;i&lt;=n;i++) CntA[Arr[i]]++;
    for (int i=1;i&lt;=maxN;i++) CntA[i]+=CntA[i-1];
    for (int i=n;i&gt;=1;i--) SA[CntA[Arr[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=n;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (Arr[SA[i]]!=Arr[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[n]]&lt;n;l=l&lt;&lt;1)
    {
        for (int i=0;i&lt;=maxN;i++) CntA[i]=CntB[i]=0;
        for (int i=1;i&lt;=n;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=n)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;=maxN;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=n;i&gt;=0;i--) SAA[CntB[B[i]]--]=i;
        for (int i=n;i&gt;=0;i--) SA[CntA[A[SAA[i]]]--]=SAA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=n;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    for (int i=1,j=0;i&lt;=n;i++)
    {
        if (j) j--;
        while (Arr[i+j]==Arr[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    //二分判定
    int l=0,r=n;
    int Ans=0;
    do
    {
        int mid=(l+r)&gt;&gt;1;
        if (Check(mid)) Ans=mid,l=mid+1;
        else r=mid-1;
    }
    while (l&lt;=r);
    printf("%d\n",Ans);
    return 0;
}

bool Check(int mid)
{
    int mnsa=maxN,mxsa=0;
    for (int i=1;i&lt;=n;i++)
        if (Height[i]&gt;=mid)
        {
            mnsa=min(mnsa,SA[i]);
            mxsa=max(mxsa,SA[i]);
            if (mxsa-mnsa&gt;=mid) return 1;
        }
        else mnsa=mxsa=SA[i];
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>561</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 22:42:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 14:42:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hihocoder1407%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%e4%ba%8c%c2%b7%e9%87%8d%e5%a4%8d%e6%97%8b%e5%be%8b2%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="post_tag" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[165]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3620]似乎在梦中见过的样子（KMP）</title>
		<link>http://sycstudio.com/archives/562</link>
		<pubDate>Tue, 20 Mar 2018 14:47:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=562</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

“Madoka,不要相信 QB！”伴随着 Homura 的失望地喊叫,Madoka 与 QB 签订了契约.
这是 Modoka 的一个噩梦,也同时是上个轮回中所发生的事.为了使这一次 Madoka 不再与 QB签订契约,Homura 决定在刚到学校的第一天就解决 QB.然而,QB 也是有许多替身的(但在第八话中的剧情显示它也有可能是无限重生的),不过,意志坚定的 Homura 是不会放弃的——她决定
消灭所有可能是 QB 的东西.现在，她已感受到附近的状态,并且把它转化为一个长度为 n 的字符串交给了学 OI 的你.
现在你从她的话中知道 , 所有形似于 A+B+A 的字串都是 QB 或它的替身 , 且len(A)>=k,len(B)>=1 （位置不同其他性质相同的子串算不同子串,位置相同但拆分不同的子串算同一子串）,然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量.

<h3>Tag</h3>

KMP

<h2>解决思路</h2>

如果给定 ABA 中第一个 A 的起始位置,那么我们可以暴力枚举第二个 A 的位置,然后跳 Next 看能否找到一个满足条件的位置。
每一次都重新跳复杂度有点高。可以像上面动物园中的一样,记录一个上一次的位置,然后直接从上一次的位置开始寻找匹配。
由于这里有长度至少为 K 的限制,所以可以记录一个 Min[i] 表示 i 的最后一个满足长度大于等于 K 的位置,那么若这一次最后匹配的位置 now 满足 K 的限制,Min[i]=now,否则,Min[i]=Min[now]。
但是我们不知道第一个 A 的起始位置?枚举这个位置就可以了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memeset(Arr,x,sizeof(Arr))

const int maxN=15100;
const int inf=2147483647;

char str[maxN];
int L,K;
int Next[maxN];
int Min[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;(str+1);cin&gt;&gt;K;
    L=strlen(str+1);
    int Ans=0;
    for (int i=1;i+K+K&lt;=L;i++)//枚举每一个位置
    {
        int now;
        Next[i]=now=i-1;Min[i]=i;
        for (int j=i+1;j&lt;=L;j++)//一边构造Next数组，一边找到第一个能匹配的A的位置，若长度满足条件，则记录答案
        {
            while ((now!=i-1)&amp;&amp;(str[now+1]!=str[j])) now=Next[now];
            if (str[now+1]==str[j]) now++;
            Next[j]=now;
            if (now&lt;i+K-1) Min[j]=j;
            else Min[j]=Min[now];
            if (Min[j]&lt;(i+j)/2) Ans++;
        }
    }
    printf("%d\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>562</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 22:47:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 14:47:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3620%e4%bc%bc%e4%b9%8e%e5%9c%a8%e6%a2%a6%e4%b8%ad%e8%a7%81%e8%bf%87%e7%9a%84%e6%a0%b7%e5%ad%90%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[134]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2754/Luogu2336][SCOI2012]喵星球上的点名（AC自动机）</title>
		<link>http://sycstudio.com/archives/563</link>
		<pubDate>Tue, 20 Mar 2018 14:54:24 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=563</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

a180285幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。   假设课堂上有N个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择M个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 然而，由于喵星人的字码过于古怪，以至于不能用ASCII码来表示。为了方便描述，a180285决定用数串来表示喵星人的名字。
现在你能帮助a180285统计每次点名的时候有多少喵星人答到，以及M次点名结束后每个喵星人答到多少次吗？

<h3>Tag</h3>

AC自动机

<h2>解决思路</h2>

对点名串建立AC自动机，然后分别把每一个喵星人的姓和名放进去匹配。注意，同一个喵星人的姓和名都匹配的时候只算一次匹配。
另外不好处理的是，由于字符集比较大，也有可能有重复元素，所以要用map存子节点，用id编号标记同样的点名串，避免出现多次转移。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=52010*2;
const int maxTrie=140000;
const int inf=2147483647;

class TrieData
{
public:
    int id,fail,cnt;
    map&lt;int,int&gt; Son;
    TrieData()
        {
            id=cnt=0;return;
        }
};

int n,m;
int nodecnt=0;
TrieData T[maxTrie];
vector&lt;int&gt; FName[maxN],LName[maxN];
queue&lt;int&gt; Queue;
int idcnt=0,Ans1[maxN],Ans2[maxN];
int Hist[maxN];
int NodeId[maxN];
map&lt;int,int&gt;::iterator iii;

void Insert(int id);
void GetFail();
void AhoCorasick(vector&lt;int&gt; V,int id);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    //读入名字
    for (int i=1;i&lt;=n;i++)
    {
        int l;scanf("%d",&amp;l);
        for (int j=1;j&lt;=l;j++){
            int a;scanf("%d",&amp;a);
            FName[i].push_back(a);
        }
        scanf("%d",&amp;l);
        for (int j=1;j&lt;=l;j++){
            int a;scanf("%d",&amp;a);
            LName[i].push_back(a);
        }
    }
    //将点名串插入AC自动机中
    for (int i=1;i&lt;=m;i++) Insert(i);
    GetFail();//构建Fail指针
    for (int i=1;i&lt;=n;i++) AhoCorasick(FName[i],i),AhoCorasick(LName[i],i);//分别把名字和姓氏放进去匹配
    for (int i=1;i&lt;=m;i++) printf("%d\n",Ans1[NodeId[i]]);
    for (int i=1;i&lt;=n;i++)
    {
        printf("%d",Ans2[i]);
        if (i!=n) printf(" ");
    }
    return 0;
}

vector&lt;int&gt; Input;

void Insert(int id)
{
    Input.clear();
    int L;scanf("%d",&amp;L);
    for (int i=1;i&lt;=L;i++){
        int a;scanf("%d",&amp;a);
        Input.push_back(a);
    }
    int now=0;
    for (int i=0;i&lt;L;i++)
    {
        if (T[now].Son[Input[i]]==0) T[now].Son[Input[i]]=++nodecnt;
        now=T[now].Son[Input[i]];
    }
    if (T[now].id==0) T[now].id=++idcnt;
    NodeId[id]=T[now].id;T[now].cnt++;
    return;
}

void GetFail()
{
    int h=0,t=0;
    for (iii=T[0].Son.begin();iii!=T[0].Son.end();iii++) Queue.push(iii-&gt;second);
    while (!Queue.empty())
    {

        int u=Queue.front();Queue.pop();
        if (T[u].Son.size()==0) continue;
        for (iii=T[u].Son.begin();iii!=T[u].Son.end();iii++)
        {
            int key=iii-&gt;first,id=iii-&gt;second;
            int now=T[u].fail;
            while ((now!=0)&amp;&amp;(T[now].Son[key]==0)) now=T[now].fail;
            if (T[now].Son[key]!=0) T[id].fail=T[now].Son[key];
            Queue.push(id);
        }
    }
    return;
}

void AhoCorasick(vector&lt;int&gt; V,int id)
{
    int L=V.size();
    int now=0;
    for (int i=0;i&lt;L;i++)
    {
        if (T[now].Son[V[i]]!=0) now=T[now].Son[V[i]];
        else
        {
            while ((now!=0)&amp;&amp;(T[now].Son[V[i]]==0)) now=T[now].fail;
            if (T[now].Son[V[i]]!=0) now=T[now].Son[V[i]];
        }
        int p=now;
        while (p)
        {
            if (Hist[p]!=id)
            {
                Hist[p]=id;Ans2[id]+=T[p].cnt;Ans1[T[p].id]++;
            }
            p=T[p].fail;
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>563</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 22:54:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 14:54:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2754-luogu2336scoi2012%e5%96%b5%e6%98%9f%e7%90%83%e4%b8%8a%e7%9a%84%e7%82%b9%e5%90%8d%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[142]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3507/Luogu3167][CQOI2014]通配符匹配（Hash，动态规划）</title>
		<link>http://sycstudio.com/archives/564</link>
		<pubDate>Tue, 20 Mar 2018 15:05:49 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=564</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

几乎所有操作系统的命令行界面(CLI)中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号(“”’)，可以匹配0个及以上的任意字符：另一个是问号(“？”)，可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。

<h3>Tag</h3>

Hash，动态规划

<h2>解决思路</h2>

题意看起来很像一个“模糊”匹配的AC自动机，但是，由于直接模糊匹配需要同时在AC自动机上走若干个节点，复杂度无法保证。
分别处理每一个询问，把通配串中的所有通配符提取出来，设F[i][j]表示第i个通配符能否匹配字符串中的第j个字符。那么，若有F[i][j]，F[i+1][j+len]成立的条件是通配串中从第i个通配符到第i+1个通配符之间的字符能与需要匹配的字符串的从j开始对应长度的字符串相匹配（设这个长度为len），这个可以用字符串Hash来做。
而至于&#42;和?的分别处理，由于&#42;可以匹配从0开始的任意长度，所以转移到[j+len]，然后再一直向后转移；而?只能匹配一个，所以必须强制转移到[j+len+1]。
为了方便在最后统计处理，可以在通配串的最后加一个?，在询问串的最后加一个与字符集无关的字符#，这样就只要判断最后两个能否匹配了。
为了方便，这里使用自然溢出的Hash方法。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define ll long long
#define ull unsigned long long

const int maxN=100010;
const int Hashbase=1705;
const int inf=2147483647;

char str[maxN],SS[maxN];
ull Hash1[maxN],Hash2[maxN];
int pcnt=0,P[maxN];
ull Bret[maxN];
int F[13][maxN];

void InitHash(char *s,ull *hash);
ull GetHash(int l,int r,ull *hash);

int main()
{
    ios::sync_with_stdio(false);
    Bret[0]=1;for (int i=1;i&lt;maxN;i++) Bret[i]=Bret[i-1]*Hashbase;
    cin&gt;&gt;(str+1);
    InitHash(str,Hash1);//得到通配串的Hash
    int L=strlen(str+1);
    str[++L]='?';
    //找出所有的通配符
    for (int i=1;i&lt;=L;i++) if ((str[i]=='?')||(str[i]=='*')) P[++pcnt]=i;

    int Q;cin&gt;&gt;Q;
    while (Q--)//回答每一个询问
    {
        cin&gt;&gt;(SS+1);InitHash(SS,Hash2);
        mem(F,0);F[0][0]=1;
        int len=strlen(SS+1);SS[++len]='#';
        for (int i=0;i&lt;pcnt;i++)
        {
            if (str[P[i]]=='*')//对于是*的，向所有后面转移，因为可以不限制长度地匹配。
                for (int j=1;j&lt;=len;j++)
                    if (F[i][j-1]) F[i][j]=1;
            for (int j=0;j&lt;=len;j++)//
                if (F[i][j])
                    if (GetHash(P[i]+1,P[i+1]-1,Hash1)==GetHash(j+1,j+((P[i+1]-1)-(P[i]+1))+1,Hash2))//Hash判断是否能够匹配
                    {//对于两种通配符分别转移
                        if (str[P[i+1]]=='?') F[i+1][j+((P[i+1]-1)-(P[i]+1))+1+1]=1;
                        else F[i+1][j+((P[i+1]-1)-(P[i]+1))+1]=1;
                    }
        }
        if (F[pcnt][len]) cout&lt;&lt;"YES"&lt;&lt;endl;
        else cout&lt;&lt;"NO"&lt;&lt;endl;
    }
    return 0;
}

void InitHash(char *s,ull *hash)
{
    int len=strlen(s+1);
    hash[0]=0;
    for (int i=1;i&lt;=len;i++) hash[i]=hash[i-1]*Hashbase+s[i];
    return;
}

ull GetHash(int l,int r,ull *hash)
{
    if (r&lt;l) return -1;
    return hash[r]-hash[l-1]*Bret[r-l+1];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>564</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 23:05:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 15:05:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3507-luogu3167cqoi2014%e9%80%9a%e9%85%8d%e7%ac%a6%e5%8c%b9%e9%85%8d%ef%bc%88hash%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bkdrhash"><![CDATA[BKDRHash]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[199]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3172/Luogu3966][TJOI2013]单词（AC自动机）</title>
		<link>http://sycstudio.com/archives/565</link>
		<pubDate>Tue, 20 Mar 2018 15:13:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=565</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。

<h3>Tag</h3>

AC自动机

<h2>解决思路</h2>

考虑在AC自动机中如何处理一个问题，一个字符串x出现在另一个字符串y中的某一位置，当且仅当这个位置的结尾可以通过跳Fail跳到x的结尾。
把问题放到Fail树上考虑，就变成了统计Fail树上每一个点的子树大小，一遍dfs扫描。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=2000010;
const int maxM=maxN*2;
const int maxAlpha=27;
const int inf=2147483647;

class Trie
{
public:
    int fail,cnt;
    int son[maxAlpha];
};

int n,nodecnt;
char str[maxN],input[maxN];
Trie T[maxN];
int Id[maxN];
int Queue[maxN];

namespace TC
{
    int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
    int Size[maxN];
    void init()
    {
        mem(Head,-1);return;
    }

    void Add_Edge(int u,int v)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        return;
    }
    void dfs(int u,int fa)
    {
        Size[u]=T[u].cnt;
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            dfs(V[i],u);
            Size[u]+=Size[V[i]];
        }
        return;
    }
}

void Insert(char *str,int id);
void GetFail();
void dfs(int u);

int main()
{
    ios::sync_with_stdio(false);TC::init();
    cin&gt;&gt;n;
    int len=0;
    for (int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;(input+1);
        int l=strlen(input+1);
        Insert(input,i);
        str[++len]='z'+1;
        for (int j=1;j&lt;=l;j++) str[len+j]=input[j];
        len=len+l;
        Id[len]=i;
    }
    str[++len]='\0';
    //构建Fail
    GetFail();
    TC::dfs(0,0);//得到Fail树中每一个点的子树大小
    for (int i=1;i&lt;=n;i++) cout&lt;&lt;TC::Size[Id[i]]&lt;&lt;endl;
    return 0;
}

void Insert(char *str,int id)
{
    int len=strlen(str+1);
    int now=0;
    for (int i=1;i&lt;=len;i++)
    {
        if (T[now].son[str[i]-'a']==0) T[now].son[str[i]-'a']=++nodecnt;
        now=T[now].son[str[i]-'a'];
        T[now].cnt++;
    }
    Id[id]=now;
    return;
}

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;maxAlpha;i++) if (T[0].son[i]!=0) Queue[++h]=T[0].son[i];
    do
    {
        int u=Queue[++t];
        for (int i=0;i&lt;maxAlpha;i++)
        {
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                Queue[++h]=T[u].son[i];
            }
            else T[u].son[i]=T[T[u].fail].son[i];
        }
    }
    while (t!=h);
    //建立Fail树
    for (int i=1;i&lt;=nodecnt;i++) TC::Add_Edge(T[i].fail,i);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>565</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 23:13:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 15:13:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3172-luogu3966tjoi2013%e5%8d%95%e8%af%8d%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[162]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2434/Luogu2414][NOI2011]阿狸的打字机（AC自动机，dfs序，树状数组）</title>
		<link>http://sycstudio.com/archives/566</link>
		<pubDate>Tue, 20 Mar 2018 15:17:08 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=566</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有28个按键，分别印有26个小写英文字母和'B'、'P'两个字母。
经阿狸研究发现，这个打字机是这样工作的：
l 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。
l 按一下印有'B'的按键，打字机凹槽中最后一个字母会消失。
l 按一下印有'P'的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。
例如，阿狸输入aPaPBbP，纸上被打印的字符如下：
a
aa
ab
我们把纸上打印出来的字符串从1开始顺序编号，一直到n。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数(x,y)（其中1≤x,y≤n），打字机会显示第x个打印的字符串在第y个打印的字符串中出现了多少次。
阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？

<h3>Tag</h3>

AC自动机，dfs序，树状数组

<h2>解决思路</h2>

首先，给出的操作可以构造出一棵包含所有我们需要的字符串的Trie树，在这棵Trie上构建AC自动机，考虑如何统计答案。
考虑在 AC 自动机中如何求得一个字符串在另一个中的出现次数(注意两个字符串都是 AC 自动机中的串)。可以发现,从串 y 在 Trie 中的每一个节点出发,若能从一个节点一直跳 Fail 跳到 x 串的末尾,那么 x 就在 y 中出现了一次。这提示我们统计答案似乎与 Fail 树有关,所以我们不妨把 Fail 树提出来。
把 Fail 树提出来后有什么用呢?我们再来看一看这时答案变成了什么。
对于要求 x 在 y 中出现了多少次,那么在 Fail 树中就是 y 串有多少个节点在x 串末尾节点的 fail 树的子树内(想一想为什么)。
于是我们呢就得到了更优的算法,即对于每一个询问 x,y,我们标记出 y 串的每一个节点,然后统计有多少个节点在 x 末尾节点的子树内。子树统计可以用dfs 序做到 O(1) 地统计。
但是这样还是不够,所以我们考虑把询问离线下来,当我们扫到一个字符串末尾的时候,一起回答它的所有询问。那这个扫的顺序如何确定呢?不妨再把之前构 Trie 树的操作再做一边。
这样一边走一边在 dfs 序中单点修改一个值,遇到结尾则查询,回答所有询问。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lowbit(x) ((x)&amp;(-(x)))

const int maxN=400010;
const int maxM=maxN*2;
const int maxAlpha=27;
//const int inf=2147483647;

class Trie
{
public:
    int fail,fa;
    int son[maxAlpha];
};

int n,nodecnt,m;
char str[maxN];
Trie T[maxN];
int idcnt=0,Id[maxN];
int Ques[maxN],Ans[maxN];
int qcnt=0,QHead[maxN],QNext[maxM],QV[maxM];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Queue[maxN];
int dfncnt=0,Dfn[maxN],Last[maxN];
int BIT[maxN];

void GetFail();
void QAdd_Edge(int u,int v);
void Add_Edge(int u,int v);
void dfs(int u);
void Modify(int pos,int key);
int Query(int l,int r);
int Sum(int pos);

int main()
{
    mem(QHead,-1);mem(Head,-1);
    //输入并建树
    scanf("%s",str+1);
    int len=strlen(str+1);
    for (int i=1,now=0;i&lt;=len;i++)
    {
        if (str[i]=='B') now=T[now].fa;
        else if (str[i]=='P') Id[++idcnt]=now;
        else
        {
            if (T[now].son[str[i]-'a']==0)
            {
                T[now].son[str[i]-'a']=++nodecnt;
                T[nodecnt].fa=now;
            }
            now=T[now].son[str[i]-'a'];
        }
    }
    //把询问离线下来
    scanf("%d",&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int x,y;scanf("%d%d",&amp;x,&amp;y);
        QAdd_Edge(y,i);Ques[i]=x;
    }
    //构建Fail树，同时求好dfs序方便求子树和
    GetFail();
    dfs(0);
    //再做一遍构建Trie树的过程，同时在Fail树中回答询问
    for (int i=1,now=0,cnt=0;i&lt;=len;i++)
    {
        if (str[i]=='B'){
            Modify(Dfn[now],-1);now=T[now].fa;
        }
        else if (str[i]=='P')
        {
            cnt++;
            for (int q=QHead[cnt];q!=-1;q=QNext[q])
            {
                int id=QV[q];
                int v=Id[Ques[id]];
                Ans[id]=Query(Dfn[v],Last[v]);
            }
        }
        else
        {
            now=T[now].son[str[i]-'a'];
            Modify(Dfn[now],1);
        }
    }
    for (int i=1;i&lt;=m;i++) printf("%d\n",Ans[i]);
    return 0;
}

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;maxAlpha;i++) if (T[0].son[i]) Queue[++h]=T[0].son[i];
    while (t!=h)
    {
        int u=Queue[++t];
        for (int i=0;i&lt;maxAlpha;i++)
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                Queue[++h]=T[u].son[i];
            }
            else T[u].son[i]=T[T[u].fail].son[i];
    }
    for (int i=1;i&lt;=nodecnt;i++) Add_Edge(T[i].fail,i);
    return;
}

void QAdd_Edge(int u,int v)
{
    qcnt++;QNext[qcnt]=QHead[u];QHead[u]=qcnt;QV[qcnt]=v;
    return;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs(int u)
{
    Dfn[u]=++dfncnt;
    for (int i=Head[u];i!=-1;i=Next[i])
        dfs(V[i]);
    Last[u]=dfncnt;
    return;
}

void Modify(int pos,int key)
{
    while(pos&lt;=dfncnt){
        BIT[pos]+=key;pos+=lowbit(pos);
    }
    return;
}

int Query(int l,int r)
{
    return Sum(r)-Sum(l-1);
}

int Sum(int pos)
{
    int ret=0;
    while(pos){
        ret+=BIT[pos];pos-=lowbit(pos);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>566</wp:post_id>
		<wp:post_date><![CDATA[2018-03-20 23:17:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-20 15:17:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2434-luogu2414noi2011%e9%98%bf%e7%8b%b8%e7%9a%84%e6%89%93%e5%ad%97%e6%9c%ba%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8cdfs%e5%ba%8f%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="dfs%e5%ba%8f"><![CDATA[dfs序]]></category>
		<category domain="post_tag" nicename="dfs%e5%ba%8f"><![CDATA[dfs序]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[212]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1039/Luogu2603][ZJOI2008]无序运动Movement（AC自动机，计算几何）</title>
		<link>http://sycstudio.com/archives/568</link>
		<pubDate>Wed, 21 Mar 2018 14:57:30 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=568</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

D博士对物理有着深入的研究，经典物理、天体物理、量子物理都有着以他的名字命名的定理。最近D博士着迷于研究粒子运动的无规则性。对圣经深信不疑的他相信，上帝创造的任何事物必然是有序的、有理可循的，而不是无规则的、混沌的。 经过长时间的研究，D博士找到了很多出现相当频繁的轨迹片断，他把这些轨迹片断储存在一个很大的数据库内。他需要你帮助他写一个程序，对于一个给出的粒子运动轨迹，统计数据库中每个轨迹片断的出现的次数。 为清楚起见，我们定义一个粒子的轨迹为二维平面上的一个点列（P1, P2, … PN）。点列P的一个子列[i, j]定义为P中一段连续的子序列（Pi, Pi+1, … Pj）。点列P的一个子列[u, v]被称为点列Q = (Q1, Q2 …Qv-u+1)在P中的一次出现，当且仅当Q经过有限次的平移、旋转、翻转、放缩之后得到Q’满足Q’k = Pu+k-1（k = 1 … u – v + 1）。 对平面X-Y进行四种操作的解释平移 设平移向量为(dx, dy)，则任意点(x,y)平移后的结果为(x+dx, y+dy) 旋转 设旋转角为t，则任意点(x,y)旋转后的结果为 (x cos t – y sin t, x sin t + y cos t)翻转 任意点(x,y) 翻转后的结果为(x, -y) 放缩 设放缩比例为p (p ≠ 0)，则任意点(x,y)放缩后的结果为(px, py)

<h3>Tag</h3>

AC自动机，计算几何

<h2>解决思路</h2>

这题的关键其实不是在于 AC 自动机,而是如何把模型转化到 AC 自动机上。
考虑把一条折线不管怎么经过上述变换,哪些信息是不会变的。可以知道是相邻两向量的模长之比和夹角。
那么可以记录这些信息,并化为最简形式,然后就可以在 AC 自动机上进行匹配了。
为了避免精度问题,可以把记录模长之比改为记录模长的平方之比,而夹角的计算可以分别计算两向量的点积和叉积,它们之比就是tanθ,所以存下点积和叉积的约分后的形式即可。
需要注意的是，将一根直线翻折后如果还能匹配，会被匹配两次，所以要除以二。再就是对于共线和垂直的向量要特殊处理。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1600100;
const int inf=2147483647;

int gcd(int a,int b)
{
    int t;
    while (b) t=a,a=b,b=t%b;
    return a;
}

class Point
{
public:
    int x,y;
    Point(){
        x=y=0;return;
    }
    Point(int a,int b){
        x=a;y=b;return;
    }
    int len(){
        return x*x+y*y;
    }
};

Point operator + (Point A,Point B){
    return (Point){A.x+B.x,A.y+B.y};
}

Point operator - (Point A,Point B){
    return (Point){A.x-B.x,A.y-B.y};
}

int operator * (Point A,Point B){//点积
    return A.x*B.x+A.y*B.y;
}

int operator ^ (Point A,Point B){//叉积
    return A.x*B.y-A.y*B.x;
}

class Data//AC自动机中的元素
{
public:
    int len1,len2,dot,cross;//记录四种信息，两个向量的长度平方，点积，叉积
    Data(){
        len1=len2=dot=cross=0;
    }
    Data(int l1,int l2,int dt,int cs){
        int t=gcd(abs(l1),abs(l2));
        len1=l1/t;len2=l2/t;dot=dt;cross=cs;
        if (dt==0) cross=(cs&lt;0)?(-1):(1);//点积为0，说明两向量垂直
        else if (cs==0) dot=(dt&lt;0)?(-1):(1);//叉积为0，说明两向量共线
        else
        {
            t=gcd(abs(dt),abs(cs));
            dot=dt/t;cross=cs/t;
        }
        return;
    }
};
//因为要在AC自动机中匹配，所以定义好比较的方式
bool operator &lt; (Data A,Data B)
{
    if (A.len1!=B.len1) return A.len1&lt;B.len1;
    if (A.len2!=B.len2) return A.len2&lt;B.len2;
    if (A.dot!=B.dot) return A.dot&lt;B.dot;
    return A.cross&lt;B.cross;
}

bool operator == (Data A,Data B){
    return ((A.len1==B.len1)&amp;&amp;(A.len2==B.len2)&amp;&amp;(A.dot==B.dot)&amp;&amp;(A.cross==B.cross));
}

bool operator != (Data A,Data B){
    return !(A==B);
}

class Trie
{
public:
    int fail,id;
    Data D;
    map&lt;Data,int&gt; Son;
};

int n,m,nodecnt,pcnt;
int Len[maxN];
Data P[maxN];
Point Input[maxN];
Trie T[maxN];
bool Same[maxN];//标记某一个是否为一根直线
int idcnt=0,Id[maxN],Queue[maxN],Cnt[maxN];

void GetFail();
void AhoCorasick();

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)//输入数据库中的直线
    {
        scanf("%d",&amp;Len[i]);
        for (int j=1;j&lt;=Len[i];j++) scanf("%d%d",&amp;Input[j].x,&amp;Input[j].y);
        if (Len[i]&lt;=2) continue;//对于点数只有二及一下的折线，在后面可以直接得到答案
        Same[i]=1;
        for (int j=2;j&lt;Len[i];j++)
        {
            Point p1=Input[j]-Input[j-1],p2=Input[j+1]-Input[j];
            P[++pcnt]=Data(p1.len(),p2.len(),p1*p2,p1^p2);
            if ((p1^p2)!=0) Same[i]=0;
        }
    }
    //转化成AC自动机中的数据
    for (int i=1,p=1;i&lt;=m;i++)
        if (Len[i]&gt;2)
        {
            int now=0;
            for (int j=1;j&lt;=Len[i]-2;j++,p++)
            {
                if (T[now].Son.count(P[p])==0) T[now].Son[P[p]]=++nodecnt;
                now=T[now].Son[P[p]];
            }
            if (T[now].id==0) T[now].id=++idcnt;
            Id[i]=T[now].id;
        }
    //构建Fail指针
    GetFail();
//输入待匹配的串
    for (int i=1;i&lt;=n;i++) scanf("%d%d",&amp;Input[i].x,&amp;Input[i].y);
//将待匹配串构建成需要的形式
    pcnt=0;
    for (int i=2;i&lt;n;i++)
    {
        Point p1=Input[i]-Input[i-1],p2=Input[i+1]-Input[i];
        P[++pcnt]=Data(p1.len(),p2.len(),p1*p2,p1^p2);
    }
//先正着匹配一遍
    AhoCorasick();
    //再把直线上下翻折再匹配一遍
    for (int i=1;i&lt;=pcnt;i++) P[i].cross=-P[i].cross;
    AhoCorasick();

    for (int i=1;i&lt;=m;i++)
        if (Len[i]&lt;=2) printf("%d\n",n-Len[i]+1);
        else
        {
            if (Same[i]) printf("%d\n",Cnt[Id[i]]/2);//注意是直线的情况
            else printf("%d\n",Cnt[Id[i]]);
        }

    return 0;
}

void GetFail()
{
    int h=0,t=0;
    for (map&lt;Data,int&gt;::iterator i=T[0].Son.begin();i!=T[0].Son.end();i++) Queue[++h]=i-&gt;second;
    while (t!=h)
    {
        int u=Queue[++t];
        for (map&lt;Data,int&gt;::iterator i=T[u].Son.begin();i!=T[u].Son.end();i++)
        {
            Data key=i-&gt;first;int id=i-&gt;second;
            int p=T[u].fail;
            while ((p)&amp;&amp;(T[p].Son.count(key)==0)) p=T[p].fail;
            if (T[p].Son.count(key)!=0) T[id].fail=T[p].Son[key];
            Queue[++h]=id;
        }
    }
    return;
}

void AhoCorasick()
{
    int now=0;
    for (int i=1;i&lt;=pcnt;i++)
    {
        if (T[now].Son.count(P[i])!=0) now=T[now].Son[P[i]];
        else
        {
            while ((now)&amp;&amp;(T[now].Son.count(P[i])==0)) now=T[now].fail;
            if (T[now].Son.count(P[i])!=0) now=T[now].Son[P[i]];
        }
        int p=now;
        while (p)
        {
            Cnt[T[p].id]++;
            p=T[p].fail;
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>568</wp:post_id>
		<wp:post_date><![CDATA[2018-03-21 22:57:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-21 14:57:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1039-luogu2603zjoi2008%e6%97%a0%e5%ba%8f%e8%bf%90%e5%8a%a8movement%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%90%91%e9%87%8f%e7%82%b9%e7%a7%af-%e5%8f%89%e7%a7%af"><![CDATA[向量点积/叉积]]></category>
		<category domain="category" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<category domain="post_tag" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[198]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4974][Lydsy1708月赛]字符串大师（KMP）</title>
		<link>http://sycstudio.com/archives/570</link>
		<pubDate>Sat, 24 Mar 2018 03:54:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=570</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一个串T是S的循环节，当且仅当存在正整数k，使得S是T^k(即T重复k次)的前缀，比如abcd是abcdabcdab的循环节。给定一个长度为n的仅由小写字符构成的字符串S，请对于每个k(1&lt;=k&lt;=n)，求出S长度为k的前缀的最短循环节的长度per_i。字符串大师小Q觉得这个问题过于简单，于是花了一分钟将其AC了，他想检验你是否也是字符串大师。
小Q告诉你n以及per_1,per_2,...,per_n，请找到一个长度为n的小写字符串S，使得S能对应上per。

<h3>Tag</h3>

KMP

<h2>解决思路</h2>

把我们之前从 Next 推循环节长度的方式反过来。现在给出每一个前缀的最短循环节长度,就相当于给出了 Next。
接下来考虑用 Next 反构造出字典序最小的原串。
其实与构造 Next 的过程很像。向前走到第一个 j+1==Next[i] 的位置,然后就可以知道 str[i] 要与 str[j+1 ]相同。是不是与在构造 KMP 中要求str[j+1]==str[i] 类似?
当然要注意,可能会一直走都头都没有合法位置,那么此时就要找到第一个能够放的字符(字典序最小),为了找到这个字符,需要在跳 Next 的时候在不匹配的时候要标记这个位置不能放的字符。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int maxAlpha=26;
const int inf=2147483647;

int n;
int Next[maxN];
bool Alpha[maxAlpha][maxN];
char str[maxN];

int main()
{
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++)
    {
        int len;
        scanf("%d",&amp;len);//读入循环节，同时构造出Nexr数组
        Next[i]=i-len;
    }
    Next[0]=-1;//根据Next数组反推出原字符串的关系
    for (int i=1;i&lt;=n;i++)
    {
        int j=Next[i-1];
        while ((j!=-1)&amp;&amp;(Next[i]!=j+1))//失配，则继续向前跳Next，同时记录这个位置上不能放的字符
        {
            Alpha[str[j+1]-'a'][i]=1;
            j=Next[j];
        }
        if (j!=-1) str[i]=str[j+1];//若最终找到了，则与找到的位置匹配
        else
            for (int pos=0;pos&lt;maxAlpha;pos++)//否则，填上最小的在之前的失配过程中没有被标记为不能放的最小字符
                if (Alpha[pos][i]==0)
                {
                    str[i]=pos+'a';
                    break;
                }
    }
    for (int i=1;i&lt;=n;i++) printf("%c",str[i]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>570</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 11:54:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 03:54:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4974lydsy1708%e6%9c%88%e8%b5%9b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%a4%a7%e5%b8%88%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[193]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3530/Luogu3311][SDOI2014]数数（AC自动机，数位动态规划）</title>
		<link>http://sycstudio.com/archives/571</link>
		<pubDate>Sat, 24 Mar 2018 04:08:14 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=571</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

我们称一个正整数N是幸运数，当且仅当它的十进制表示中不包含数字串集合S中任意一个元素作为其子串。例如当S=(22，333，0233)时，233是幸运数，2333、20233、3223不是幸运数。
给定N和S，计算不大于N的幸运数个数

<h3>Tag</h3>

AC自动机，数位动态规划

<h2>解决思路</h2>

把数字串插入到AC自动机中，那么首先我们知道，在匹配构造的时候，是不能走到单词结尾的地方的。
然后我们先算位数小于 N 的位数的方案数。设 F[i][j] 表示构造到第 i 位当前在 AC 自动机的第 j 号点的方案数,那么向它的所有不是数字串结尾的儿子转移即可。
再考虑位数严格等于 N 的方案数,那么类似数位 DP 里的做法,设F[i][j][0/1] 其中 [0] 表示严格小于,[1] 表示严格等于的方案数。那么转移的时候严格等于的就只枚举到对应的 N 中的那一位转移,而小于的则可以在整个字符集中转移,分别讨论一下。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101;
const int maxTrie=1700;
const int maxAlpha=10;
const int Mod=1e9+7;
const int inf=2147483647;

class TrieData
{
public:
    int fail,end;
    int son[maxAlpha];
};

int nodecnt=0,Queue[maxTrie];
char N[maxTrie],str[maxTrie];
TrieData T[maxTrie];
ll F[maxTrie][maxTrie][2];

void Insert(char *s);
void GetFail();

int main()
{
    scanf("%s",N+1);
    int n;scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",str+1);
        Insert(str);
    }
    GetFail();//构建AC自动机
    int L=strlen(N+1);
    //先计算长度小于N的长度的方案，这时不需要考虑小于N的限制，因为一定小于
    F[0][0][0]=1;
    for (int i=0;i&lt;L;i++)
        for (int j=0;j&lt;=nodecnt;j++)
        {
            if (T[j].end!=0) continue;//单词结尾无转移
            if (F[i][j][0])
            {
                for (int c=(i==0)?(1):(0);c&lt;maxAlpha;c++)
                    if (T[T[j].son[c]].end==0)//向所有非单词结尾的儿子转移
                        F[i+1][T[j].son[c]][0]+=F[i][j][0],F[i+1][T[j].son[c]][0]%=Mod;
            }
        }
    ll Ans=0;//累加到答案中
    for (int i=1;i&lt;L;i++) for (int j=0;j&lt;=nodecnt;j++) if (T[j].end==0) Ans=(Ans+F[i][j][0])%Mod;
    mem(F,0);//然后开始计算长度等于N的长度的方案
    F[0][0][0]=1;//[0]危险态，[1]安全态
    for (int i=0;i&lt;L;i++)
    {
        for (int j=0;j&lt;=nodecnt;j++)
        {
            if (T[j].end!=0) continue;
            if (F[i][j][0])//危险态转移
            {
                for (int c=(i==0)?(1):(0);c&lt;N[i+1]-'0';c++)
                    if (T[T[j].son[c]].end==0) F[i+1][T[j].son[c]][1]+=F[i][j][0],F[i+1][T[j].son[c]][1]%=Mod;//危险态-&gt;安全态转移
                if (T[T[j].son[N[i+1]-'0']].end==0) F[i+1][T[j].son[N[i+1]-'0']][0]+=F[i][j][0],
                                                        F[i+1][T[j].son[N[i+1]-'0']][0]%=Mod;//危险态-&gt;危险态转移
            }
            if (F[i][j][1])
                for (int c=(i==0)?(1):(0);c&lt;maxAlpha;c++)
                    if (T[T[j].son[c]].end==0) F[i+1][T[j].son[c]][1]+=F[i][j][1],
                                                   F[i+1][T[j].son[c]][1]%=Mod;//安全态-&gt;安全态转移

        }
    //累加答案
    for (int i=0;i&lt;=nodecnt;i++) if (T[i].end==0) Ans+=F[L][i][0]+F[L][i][1],Ans%=Mod;
    printf("%lld\n",Ans);
    return 0;
}

void Insert(char *s)
{
    int len=strlen(s+1);
    int now=0;
    for (int i=1;i&lt;=len;i++)
    {
        if (T[now].son[s[i]-'0']==0) T[now].son[s[i]-'0']=++nodecnt;
        now=T[now].son[s[i]-'0'];
    }
    T[now].end=1;
    return;
}

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;maxAlpha;i++) if (T[0].son[i]) Queue[++h]=T[0].son[i];
    while (t!=h)
    {
        int u=Queue[++t];
        for (int i=0;i&lt;maxAlpha;i++)
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                T[T[u].son[i]].end|=T[T[T[u].fail].son[i]].end;
                Queue[++h]=T[u].son[i];
            }
            else T[u].son[i]=T[T[u].fail].son[i];
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>571</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:08:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:08:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3530-luogu3311sdoi2014%e6%95%b0%e6%95%b0%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[数位动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[149]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1444][JSOI2009]有趣的游戏（AC自动机，概率动态规划，矩阵快速幂）</title>
		<link>http://sycstudio.com/archives/572</link>
		<pubDate>Sat, 24 Mar 2018 04:16:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=572</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/media/BZOJ/BZOJ1444.gif" alt="BZOJ1444" />

<h3>Tag</h3>

AC自动机，矩阵快速幂

<h2>解决思路</h2>

把每一个人获胜的字符串构建出AC自动机。
设 F[i][j] 表示第 i 轮,当前在 AC 自动机的 j 号点的概率,那么按照对应概率向儿子分别转移。注意,当已经到达某一个任的字母序列尾时,此时标志某一个人胜利，那么就每一次只向自己转移。
转移多少次呢?很多很多次,只要精度小于两位即可。为了多次转移,可以矩阵快速幂优化,这样就不会有精度问题了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=510;
const int maxAlpha=510;
const int maxTrie=510;
const int inf=2147483647;

class TrieData
{
public:
    int end,fail;
    int son[maxAlpha];
};

int n,l,m,nodecnt;
TrieData T[maxTrie];
ld Gl[maxAlpha];
char Input[maxN];
int Id[maxN],Queue[maxTrie];

class Matrix
{
public:
    ld M[maxTrie][maxTrie];
    Matrix(){mem(M,0);}
    Matrix(ld arr[maxTrie][maxTrie]){
        for (int i=0;i&lt;maxTrie;i++)
            for (int j=0;j&lt;maxTrie;j++)
                M[i][j]=arr[i][j];
    }
};

Matrix Ret;

void Insert(char *str,int id);
void GetFail();
void Mul1();
void Mul2();

int main()
{

    scanf("%d%d%d",&amp;n,&amp;l,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int p,q;scanf("%d%d",&amp;p,&amp;q);
        Gl[i-1]=(ld)p/(ld)q;//得到每一种字母的出现概率
    }

    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",Input+1);
        Insert(Input,i);
    }
    GetFail();//构建AC自动机
    //构造初始矩阵
    for (int i=0;i&lt;=nodecnt;i++)
    {
        if (T[i].end) Ret.M[i][i]=1;//当是单词末尾时，此时该人胜利，那么就只向自己转移
        else for (int j=0;j&lt;m;j++) Ret.M[i][T[i].son[j]]+=Gl[j];//否则，向所有儿子依据概率转移
    }
    for(int i=100;i&gt;=0;i--){//矩阵快速幂
        Mul2();
    }
    for (int i=1;i&lt;=n;i++) printf("%.2lf\n",Ret.M[0][Id[i]]);
    return 0;
}

void Insert(char *str,int id)
{
    int now=0;
    for (int i=1;i&lt;=l;i++)
    {
        if (T[now].son[str[i]-'A']==0) T[now].son[str[i]-'A']=++nodecnt;
        now=T[now].son[str[i]-'A'];
    }
    Id[id]=now;T[now].end=1;return;
}

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;m;i++) if (T[0].son[i]) Queue[++h]=T[0].son[i];
    while (h!=t)
    {
        int u=Queue[++t];
        for (int i=0;i&lt;m;i++)
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                Queue[++h]=T[u].son[i];
                T[T[u].son[i]].end|=T[T[T[u].fail].son[i]].end;
            }
            else T[u].son[i]=T[T[u].fail].son[i];
    }
    return;
}

ld Backup[maxTrie][maxTrie];

void Mul2()
{
    for (int i=0;i&lt;=nodecnt;i++) for (int j=0;j&lt;=nodecnt;j++) Backup[i][j]=Ret.M[i][j],Ret.M[i][j]=0;
    for (int i=0;i&lt;=nodecnt;i++)
        for (int j=0;j&lt;=nodecnt;j++)
            for (int k=0;k&lt;=nodecnt;k++)
                Ret.M[i][j]=Ret.M[i][j]+Backup[i][k]*Backup[k][j];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>572</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:16:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:16:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1444jsoi2009%e6%9c%89%e8%b6%a3%e7%9a%84%e6%b8%b8%e6%88%8f%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%9f%a9%e9%98%b5%e5%bf%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[bzoj1444jsoi2009%e6%9c%89%e8%b6%a3%e7%9a%84%e6%b8%b8%e6%88%8f%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82%ef%bc%89]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[146]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3555][CTSC2014]企鹅QQ（Hash）</title>
		<link>http://sycstudio.com/archives/573</link>
		<pubDate>Sat, 24 Mar 2018 04:21:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=573</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

PenguinQQ是中国最大、最具影响力的SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。
小Q是PenguinQQ网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小Q发现同一个人注册的账户名称总是很相似的，例如Penguin1，Penguin2，Penguin3……于是小Q决定先对这种相似的情形进行统计。
小Q定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小Q想知道，在给定的 个账户名称中，有多少对是相似的。
为了简化你的工作，小Q给你的 个字符串长度均等于 ，且只包含大小写字母、数字、下划线以及‘@’共64种字符，而且不存在两个相同的账户名称。

<h3>Tag</h3>

Hash

<h2>解决思路</h2>

考虑枚举是哪一位不相同,然后找两边相同的,那么两边都相同的就是相似的。
快速判断两个字符串是否相同可以用Hash。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll ull
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=30010;
const int maxL=214;
const int base1=254;
const int base2=204;
const int inf=2147483647;

int n,L,Alpha;
char str[maxL];
ull Hashpre[maxN][maxL];
ull Hashsuf[maxN][maxL];
ull Get[maxN];

int main()
{
    scanf("%d%d%d",&amp;n,&amp;L,&amp;Alpha);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",str+1);//输入字符，同时求出前缀Hash和后缀hash
        for (int j=1;j&lt;=L;j++) Hashpre[i][j]=Hashpre[i][j-1]*149+str[j];
        for (int j=L;j&gt;=1;j--) Hashsuf[i][j]=Hashsuf[i][j+1]*137+str[j];
    }
    ll Ans=0;
    for (int i=1;i&lt;=L;i++)//枚举哪一个位置不同
    {
        for (int j=1;j&lt;=n;j++) Get[j]=Hashpre[j][i-1]*233+Hashsuf[j][i+1]*213;//得到每一个字符串删掉这一个位置后的hash值
        sort(&amp;Get[1],&amp;Get[n+1]);//排序，方便统计一样的hash值
        ll sum=1;
        for (int j=2;j&lt;=n;j++)
        {
            if (Get[j]==Get[j-1]){
                Ans=Ans+sum;sum++;
            }
            else sum=1;
        }
    }
    printf("%lld\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>573</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:21:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:21:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3555ctsc2014%e4%bc%81%e9%b9%85qq%ef%bc%88hash%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="post_tag" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[157]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1195/Luogu2322][HNOI2006]最短母串（AC自动机，状态压缩动态规划）</title>
		<link>http://sycstudio.com/archives/574</link>
		<pubDate>Sat, 24 Mar 2018 04:29:25 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=574</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定n个字符串（S1,S2,„,Sn），要求找到一个最短的字符串T，使得这n个字符串（S1,S2,„,Sn）都是T的子串。

<h3>Tag</h3>

AC自动机，状态压缩动态规划

<h2>解决思路</h2>

首先,被其它字符串包含的字符串是不需要考虑的,第一步先去掉这下被包含的字符串。然后考虑假设我们已经知道了剩下的串在构造的串中的出现顺序,
如何得到长度和方案呢?那么就是把每两个相邻的字符串,前面与后面相同的最长前后缀合并,每增加一个串增加的长度就是后一个的长度减去最长相同前后缀。
现在的问题变成了快速地求两个字符串的并,即前一个字符串的后缀和后一个字符串的前缀的最长相同前缀。
考虑在 AC 自动机上解决这个问题。x 串与 y 串的最长相同前后缀其实就是,从 y 串的每一个位置开始跳 fail,当跳到一个 x 串中的节点时,记录这个节点与 x 串末尾对应节点的深度之差,这就代表着从 y 的这个前缀能最长与 x 的这么长的后缀匹配。所有的深度之差中的最大值就是要找的最长匹配,后一个字符串的长度减去这个最长匹配就是加上这个字符串要增加的长度。
数据范围较小,所以你可以暴力地枚举两个字符串然后在 AC 自动机中标记、跳 fail,也可以像在 [NOI2011] 阿狸的打字机那样走一遍 Trie 树,一边走一边标记,一边计算。当然要注意,可能两个字符串根本就没有相同前后缀,这时的代价就是后一个串的长度。
此时,我们得到了任意一个字符串接在另一个任意字符串后面要增加的长度,于是题目转化为,给定两点之间的转移代价,求一条不重不漏经过所有点各一次的最短路径,起点任意。
那么就可以类似旅行商问题中的做法,设 F[i][S] 表示当前在点 i,经过的点集合为 S 的最短路,分别转移即可。注意同时要求字典序最小。
关于字典序最小，开始思路是在Trie树中重新分配一次编号，从小到大，但是由于前后两串有重叠的部分，所以这样出来的字典序不是最小，所以最好的办法还是在转移的时候实时记录当前构造出来的串。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=15;
const int maxM=maxN*maxN*8;
const int maxL=100;
const int maxAlpha=27;
const int inf=2147483647;

class TrieData
{
public:
    int end,fail,id,depth,input;
    int son[maxAlpha];
    int son2[maxAlpha];
};

class QueueData
{
public:
    int u,key;
};

int n,nodecnt,idcnt,Id[maxN];
bool path[maxN*maxL];
char str[maxN][maxL];
TrieData T[maxN*maxL];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Dist[maxN][1&lt;&lt;maxN];
string From[maxN][1&lt;&lt;maxN];
bool inqueue[maxN][1&lt;&lt;maxN];
int Map[maxN][maxN];
queue&lt;QueueData&gt; Q;

void Insert(char *str,int id);
void GetFail();
void dfs1(int u);
void dfs2(int u);
void Add_Edge(int u,int v,int w);
void Add(int u,int v,int w);

int main()
{
    mem(Head,-1);mem(Map,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",str[i]+1);
        Insert(str[i],i);//输入字符串并加入AC自动机
    }
    GetFail();//构建Fail指针
    dfs1(0);
    for (int i=1;i&lt;=idcnt;i++)
        for (int j=1;j&lt;=idcnt;j++)
            Map[i][j]=T[Id[j]].depth;//初始化长度
    dfs2(0);//得到任意两串之间的距离
    for (int i=1;i&lt;=idcnt;i++)
        for (int j=1;j&lt;=idcnt;j++)
            if (Map[i][j]!=-1) Add(i,j,Map[i][j]);
    mem(Dist,63);//初始化最短路
    for (int i=1;i&lt;=idcnt;i++)//加入最短路
    {
        Dist[i][1&lt;&lt;(i-1)]=T[Id[i]].depth;
        Q.push((QueueData){i,1&lt;&lt;(i-1)});
        inqueue[i][1&lt;&lt;(i-1)]=1;
        int l=strlen(str[T[Id[i]].input]+1);
        for (int j=1;j&lt;=l;j++) From[i][1&lt;&lt;(i-1)]+=str[T[Id[i]].input][j];
    }
    do//求解最短路，注意要求字典序最小
    {
        int u=Q.front().u,key=Q.front().key;Q.pop();
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            if (((1&lt;&lt;(V[i]-1))&amp;key)!=0) continue;
            int v=V[i],kk=key|(1&lt;&lt;(V[i]-1));
            int d=Dist[u][key]+W[i];
            string ss=From[u][key];
            int len=strlen(str[T[Id[V[i]]].input]+1);
            for (int j=len-W[i]+1;j&lt;=len;j++) ss+=str[T[Id[V[i]]].input][j];
            if ((Dist[v][kk]&gt;d)||((Dist[v][kk]==d)&amp;&amp;(ss&lt;From[v][kk])))
            {
                Dist[v][kk]=d;From[v][kk]=ss;
                if (inqueue[v][kk]==0)
                {
                    inqueue[v][kk]=1;
                    Q.push((QueueData){v,kk});
                }
            }
        }
        inqueue[u][key]=0;
    }
    while (!Q.empty());
    int Ans=inf;
    string ansstring;//求最小值
    for (int i=1;i&lt;=idcnt;i++)
        if ((Ans&gt;Dist[i][(1&lt;&lt;idcnt)-1])||((Ans==Dist[i][(1&lt;&lt;idcnt)-1])&amp;&amp;(ansstring&gt;From[i][(1&lt;&lt;idcnt)-1])))
        {
            Ans=Dist[i][(1&lt;&lt;idcnt)-1];
            ansstring=From[i][(1&lt;&lt;idcnt)-1];
        }
    int sz=ansstring.size();
    for (int i=0;i&lt;sz;i++) printf("%c",ansstring[i]);
    printf("\n");
    return 0;
}

void Insert(char *str,int id)
{
    int len=strlen(str+1);
    int now=0;
    for (int i=1;i&lt;=len;i++)
    {
        if (T[now].son[str[i]-'A']==0) T[now].son[str[i]-'A']=T[now].son2[str[i]-'A']=++nodecnt;
        now=T[now].son[str[i]-'A'];
    }
    T[now].end=1;T[now].input=id;
    return;
}

int Queue[maxN*maxL];

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;maxAlpha;i++) if (T[0].son[i]) Queue[++h]=T[0].son[i];
    while (t!=h)
    {
        int u=Queue[++t];
        for (int i=0;i&lt;maxAlpha;i++)
            if (T[u].son2[i])
            {
                T[T[u].son2[i]].fail=T[T[u].fail].son2[i];
                Queue[++h]=T[u].son2[i];
            }
            else T[u].son2[i]=T[T[u].fail].son2[i];
    }
    for (int i=nodecnt;i&gt;=0;i--) T[T[i].fail].end=0;
    return;
}

void dfs1(int u)
{
    if (T[u].end) T[u].id=++idcnt,Id[idcnt]=u;
    for (int i=0;i&lt;maxAlpha;i++) if (T[u].son[i]) T[T[u].son[i]].depth=T[u].depth+1,dfs1(T[u].son[i]);
    return;
}

void dfs2(int u)
{
    path[u]=1;
    if (T[u].end)
    {
        for (int i=1;i&lt;=idcnt;i++)
        {
            if (i==T[u].id) continue;
            int now=Id[i];
            while (now!=0)
            {
                if (path[now])
                {
                    Add_Edge(i,T[u].id,T[u].depth-T[now].depth);
                }
                now=T[now].fail;
            }
        }
    }
    for (int i=0;i&lt;maxAlpha;i++) if (T[T[u].son[i]].depth==T[u].depth+1) dfs2(T[u].son[i]);
    path[u]=0;
    return;
}

void Add_Edge(int u,int v,int w)//由于有大量重边，所以为了减少边的数量，这里先取最小值，最后再加边进去
{
    if ((Map[u][v]==-1)||(Map[u][v]&gt;w)) Map[u][v]=w;
    return;
}

void Add(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>574</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:29:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:29:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1195-luogu2322hnoi2006%e6%9c%80%e7%9f%ad%e6%af%8d%e4%b8%b2%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[状态压缩动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[378]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2553][BEIJING2011]禁忌（AC自动机，概率动态规划，矩阵快速幂）</title>
		<link>http://sycstudio.com/archives/575</link>
		<pubDate>Sat, 24 Mar 2018 04:38:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=575</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……
如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。
这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。
为了说明什么是禁忌魔法及其伤害，引入以下概念：
1．字母集A上的每个非空字符串对应了一个魔法。其中A是包含了前alphabet个小写字母的集合。
2．有一个集合T，包含了N个字母集A上的字符串T中的每一串称为一个禁忌串（Taboo string）
3．一个魔法，或等价地，其对应的串s因为包含禁忌而对使用者造成的伤害按以下方式确定：

<blockquote>
  把s分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。
</blockquote>

由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集A上所有长度为len的串。
但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。
你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。

<h3>Tag</h3>

AC自动机，概率动态规划，矩阵快速幂

<h2>解决思路</h2>

首先,如果一个串包含了其它的串,那么这个串的分割方式一定不会更优,所以先去掉这些包含了其它串的字符串。
然后怎么分割呢?其实就贪心地从头往后匹配,如果当前已经遇到一个完整的在字符集合中的字符串就权值 +1,然后重新开始匹配。由于我们已经去掉了包含关系,所以这样做是对的。
然后考虑如何转移。设 F[i][j] 表示生成到第 i 位,当前在 AC 自动机的第 j 位置,那么向它的每一个字符集内的儿子等概率转移,若儿子不是字符串集合末尾,则直接转移;否则,不向儿子转移转而向根节点 0 号转移,这意味着找到了一个匹配,所以要从头开始匹配,并且同时要把这个期望转移到答案中。
考虑到生成串的长度比较大而字符集大小和字符串总长都比较小,所以用矩阵快速幂优化转移。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10;
const int maxLen=20;
const int maxNode=maxN*maxLen;
const int maxAlpha=27;
const int inf=2147483647;

class Trie
{
public:
    int end,fail;
    int son[maxAlpha];
};

class Matrix
{
public:
    ld M[maxNode][maxNode];
};

int n,len,alpha,nodecnt;
char str[maxLen];
Trie T[maxNode];
int Queue[maxNode];
Matrix Ans,Ret;

void Insert(char *str);
void GetFail();
void Mul1();
void Mul2();

int main()
{
    scanf("%d%d%d",&amp;n,&amp;len,&amp;alpha);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",str+1);
        Insert(str);
    }
    GetFail();//构建AC自动机
    ld dx=(ld)1/(ld)alpha;//等概率转移
    for (int i=0;i&lt;=nodecnt;i++)
    {
        if (T[i].end) for (int j=0;j&lt;alpha;j++) T[i].son[j]=0;//当是单词末尾，则不需要转移
        if (T[i].end) continue;
        for (int j=0;j&lt;alpha;j++)
            {
                if (T[T[i].son[j]].end) Ret.M[i][0]+=dx,Ret.M[i][nodecnt+1]+=dx;//当儿子是单词末尾，则向根节点转移，同时转移到一个保存答案的地方
                else Ret.M[i][T[i].son[j]]+=dx;//否则，等概率转移
            }
    }
    Ret.M[nodecnt+1][nodecnt+1]=1;//这里用矩阵中的nodecnt+1这一位保存答案
    Ans.M[0][0]=1;//矩阵快速幂转移
    while (len)
    {
        if (len&amp;1) Mul1();
        Mul2();
        len=len&gt;&gt;1;
    }
    printf("%.10lf\n",(double)Ans.M[0][nodecnt+1]);//输出答案
    return 0;
}

void Insert(char *str)
{
    int len=strlen(str+1);
    int now=0;
    for (int i=1;i&lt;=len;i++)
    {
        if (T[now].son[str[i]-'a']==0) T[now].son[str[i]-'a']=++nodecnt;
        now=T[now].son[str[i]-'a'];
        if (T[now].end) break;
    }
    T[now].end=1;
    return;
}

void GetFail()
{
    int h=0,t=0;
    for (int i=0;i&lt;alpha;i++) if (T[0].son[i]) Queue[++h]=T[0].son[i];
    while (t!=h)
    {
        int u=Queue[++t];
        for (int i=0;i&lt;alpha;i++)
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                Queue[++h]=T[u].son[i];
                T[T[u].son[i]].end|=T[T[T[u].fail].son[i]].end;
            }
            else T[u].son[i]=T[T[u].fail].son[i];
    }
    return;
}

ld Baup[maxNode][maxNode];

void Mul1()
{
    int sz=nodecnt+1;
    for (int i=0;i&lt;=sz;i++) Baup[0][i]=Ans.M[0][i],Ans.M[0][i]=0;
    for (int j=0;j&lt;=sz;j++)
        for (int k=0;k&lt;=sz;k++)
            Ans.M[0][j]=Ans.M[0][j]+Baup[0][k]*Ret.M[k][j];
    return;
}

void Mul2()
{
    int sz=nodecnt+1;
    for (int i=0;i&lt;=sz;i++) for (int j=0;j&lt;=sz;j++) Baup[i][j]=Ret.M[i][j],Ret.M[i][j]=0;
    for (int i=0;i&lt;=sz;i++)
        for (int j=0;j&lt;=sz;j++)
            for (int k=0;k&lt;=sz;k++)
                Ret.M[i][j]=Ret.M[i][j]+Baup[i][k]*Baup[k][j];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>575</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:38:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:38:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2553beijing2011%e7%a6%81%e5%bf%8c%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[168]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2746][HEOI2012]旅行问题（AC自动机，树链剖分）</title>
		<link>http://sycstudio.com/archives/576</link>
		<pubDate>Sat, 24 Mar 2018 04:44:11 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=576</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

yz是Z国的领导人，他规定每个地区的名字只能为26个小写拉丁字母的一个。由于地 区数有可能超过26个，便产生了一个问题，如何辨别名字相同的地区？于是yz规定，一个 地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符 串。比如说，一个地区的名字为c，它的上级为b，b的上级为a，a没有上级，那么这个地 区就描述为abc。显然，这个描述同时包含了c的上级b和b的上级a的描述，分别为ab和a。 值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的 地区之间名字不同。现在，yz对外公布了n个地区的描述，这些描述中包含了Z国所有地区的描述，并让 你处理来访者的旅行问题。现有m对人访问这个国家，对于每对人，第一个人喜欢第i个描述中的第j个地区，设 这个地区描述为s1，第二个人喜欢第k个描述中的第l个地区，设这个地区描述为s2。他们为了统一行程，决定访问描述为s的地区（显然他们只关心地区的名字，并非是地区本身）， 设s的长度为t，s需要满足以下条件：
1：t&lt;=j, t&lt;=l;
1：s[1..t] = s1[j-t+1 … j], s[1..t] = s2[l-t+1 … l]；（即s为s1中1到k位 与s2中1到l位的公共后缀）
2：t最大化。
为了不使输出过大，你只需把这个字符串按照如下生成的26进制数转成10进制后mod 1000000007后输出:
a->0
b->1
.
.
.
z->25
比如地区cab被编码成2 *    26? + 0 * 26? + 1 * 26? = 1353。

<h3>Tag</h3>

AC自动机，树链剖分

<h2>解决思路</h2>

题目前面的部分其实就是告诉你这是一棵Trie树。
问题转化为给定若干个字符串,现在有若干组询问,对于询问 a,b,c,d,求第 a 个字符串长度为 b 的前缀,与第 c 个字符串长度为 d 的前缀的最长公共后缀,并且要求这个最长公共后缀是给出的字符串集中某一个字符串的前缀,输出对应的hash 值。
如果只是要求两个前缀的最长公共后缀,应该是可以用后缀数组解决的,转化为求两个后缀的最长公共前缀。但此题的问题在于,还要求这个公共后缀是字符串集中某一个字符串的前缀。
转化一下,既然这个公共后缀是某一个字符串的前缀,那么这两个后缀都应该能够匹配到这个前缀。
换句话说,如果是在 Fail 树中考虑这个问题,那么从这个两个后缀的结尾对应的节点开始跳 Fail 指针,要求都能跳到这个公共的前缀的结尾对应的节点。
所以,由于要求最长,问题就变成了在 Fail 树上求两点的 lca 了。这个可以用倍增、树链剖分等方式解决。
至于题目要求输出 hash 值,可以在插入 Trie 树的时候一并计算。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1000200;
const int maxAlpha=26;
const int Mod=1000000007;
const int hashbase=26;
const int inf=2147483647;

class TrieData
{
public:
    int fail;
    ll hash;
    int son[maxAlpha];
};

int n,nodecnt;
char str[maxN];
TrieData T[maxN];
vector&lt;int&gt; Pos[maxN];
int edgecnt=0,Head[maxN],Next[maxN],V[maxN];
int Hson[maxN],Size[maxN],Top[maxN],Fa[maxN],Depth[maxN];
queue&lt;int&gt; Queue;

void Insert(char *str,int id);
void GetFail();
void Add_Edge(int u,int v);
void dfs1(int u);
void dfs2(int u,int top);
int GetLCA(int u,int v);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%s",str+1);
        Insert(str,i);
    }
    GetFail();//构建AC自动机Fail指针，同时建出Fail树
    dfs1(0);dfs2(0,0);//在Fail树上树链剖分
    int m;
    scanf("%d",&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);
        int u=Pos[a][b],v=Pos[c][d];//得到lca
        int lca=GetLCA(u,v);
        printf("%lld\n",(T[lca].hash+Mod)%Mod);
    }
    return 0;
}

void Insert(char *str,int id)
{
    int len=strlen(str+1);
    int now=0;
    Pos[id].push_back(0);
    for (int i=1;i&lt;=len;i++)
    {
        if (T[now].son[str[i]-'a']==0) T[now].son[str[i]-'a']=++nodecnt,T[nodecnt].hash=((ll)T[now].hash*(ll)hashbase%Mod+str[i]-'a')%Mod;
        now=T[now].son[str[i]-'a'];
        Pos[id].push_back(now);
    }
    return;
}

void GetFail()
{
    for (int i=0;i&lt;maxAlpha;i++) if (T[0].son[i]) Queue.push(T[0].son[i]);
    while (!Queue.empty())
    {
        int u=Queue.front();Queue.pop();
        for (int i=0;i&lt;maxAlpha;i++)
            if (T[u].son[i])
            {
                T[T[u].son[i]].fail=T[T[u].fail].son[i];
                Queue.push(T[u].son[i]);
            }
            else T[u].son[i]=T[T[u].fail].son[i];
    }
    for (int i=1;i&lt;=nodecnt;i++) Add_Edge(T[i].fail,i);
    return;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u)
{
    Size[u]=1;Hson[u]=-1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        Fa[V[i]]=u;Depth[V[i]]=Depth[u]+1;dfs1(V[i]);
        Size[u]+=Size[V[i]];
        if ((Hson[u]==-1)||(Size[V[i]]&gt;Size[Hson[u]])) Hson[u]=V[i];
    }
    return;
}

void dfs2(int u,int top)
{
    Top[u]=top;
    if (Hson[u]==-1) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Hson[u]) dfs2(V[i],V[i]);
    return;
}

int GetLCA(int u,int v)
{
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    return u;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>576</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:44:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:44:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2746heoi2012%e6%97%85%e8%a1%8c%e9%97%ae%e9%a2%98%ef%bc%88ac%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%8c%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[146]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[hihocoder1415]后缀数组三·重复旋律3（后缀数组）</title>
		<link>http://sycstudio.com/archives/577</link>
		<pubDate>Sat, 24 Mar 2018 04:49:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=577</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为长度为 N 的数构成的数列。小Hi在练习过很多曲子以后发现很多作品中的旋律有共同的部分。
旋律是一段连续的数列，如果同一段旋律在作品A和作品B中同时出现过，这段旋律就是A和B共同的部分，比如在abab 在 bababab 和 cabacababc 中都出现过。小Hi想知道两部作品的共同旋律最长是多少？

<h3>Tag</h3>

后缀数组

<h2>解决思路</h2>

把两个字符串拼在一起求后缀数组，中间用一个其它的字符隔开。
构建出Height后，可以证明能够作为答案的一定是相邻两个后缀分属不同的字符串的答案，因为其它的分属不同字符串的后缀若要求lcp一定会跨越这些交界的Height，所以只需要求这些Height即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010*2;
const int inf=2147483647;

char Input1[maxN],Input2[maxN];
int str[maxN];
int SA[maxN],Rank[maxN],Height[maxN];
int Cnt1[maxN],Cnt2[maxN],A[maxN],B[maxN],SSA[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;(Input1+1);
    cin&gt;&gt;(Input2+1);
    int l1=strlen(Input1+1),l2=strlen(Input2+1);
    for (int i=1;i&lt;=l1;i++) str[i]=Input1[i]-'a'+1;
    str[l1+1]='z'+1;
    for (int i=1;i&lt;=l2;i++) str[i+l1+1]=Input2[i]-'a'+1;
    //构建SA
    int L=l1+l2+1;
    for (int i=1;i&lt;=L;i++) Cnt1[str[i]]++;
    for (int i=1;i&lt;maxN;i++) Cnt1[i]+=Cnt1[i-1];
    for (int i=L;i&gt;=0;i--) SA[Cnt1[str[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=L;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (str[SA[i]]!=str[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[L]]&lt;L;l=l&lt;&lt;1)
    {
        mem(Cnt1,0);mem(Cnt2,0);
        for (int i=1;i&lt;=L;i++)
        {
            Cnt1[A[i]=Rank[i]]++;
            Cnt2[B[i]=((i+l&lt;=L)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;maxN;i++) Cnt1[i]+=Cnt1[i-1],Cnt2[i]+=Cnt2[i-1];
        for (int i=L;i&gt;=0;i--) SSA[Cnt2[B[i]]--]=i;
        for (int i=L;i&gt;=0;i--) SA[Cnt1[A[SSA[i]]]--]=SSA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=L;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    //构建Height
    for (int i=1,j=0;i&lt;=L;i++)
    {
        if (j) j--;
        while (str[i+j]==str[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    int Ans=0;
    for (int i=2;i&lt;=L;i++)//统计跨越两个不同字符串后缀的Height的最大值
        if (((SA[i-1]&lt;=l1)&amp;&amp;(SA[i]&gt;=l1+1))||((SA[i-1]&gt;=l1+1)&amp;&amp;(SA[i]&lt;=l1))) Ans=max(Ans,Height[i]);
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>577</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 12:49:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 04:49:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hihocoder1415%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%e4%b8%89%c2%b7%e9%87%8d%e5%a4%8d%e6%97%8b%e5%be%8b3%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="post_tag" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[118]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[hihocoder1419]后缀数组四·重复旋律4（后缀数组，ST表）</title>
		<link>http://sycstudio.com/archives/578</link>
		<pubDate>Sat, 24 Mar 2018 05:01:53 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=578</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为长度为 N 的数构成的数列。小Hi在练习过很多曲子以后发现很多作品中的旋律有重复的部分。
我们把一段旋律称为(k,l)-重复的，如果它满足由一个长度为l的字符串重复了k次组成。 如旋律abaabaabaaba是(4,3)重复的，因为它由aba重复4次组成。
小Hi想知道一部作品中k最大的(k,l)-重复旋律。

<h3>Tag</h3>

后缀数组，ST表

<h2>解决思路</h2>

如果枚举长度l，再枚举一个位置pos，那么问题就变成询问两个后缀的lcp。这个可以在求出后缀数组后，求两个后缀对应之间的Height的最小值，而区间最小值可以用ST表求。
但如果枚举所有位置是不行的。考虑到循环重复串的性质，我们可以只枚举是l的倍数的地方的串查询lcp。
但这样若答案的开始的位置不在l的倍数的位置，就会有问题。但我们发现，在l的倍数的位置求出lcp能够帮助我们找到这个循环串的开头的位置，即当前位置-l+r%l，r为我们找到的lcp长度。那么在这个位置再求一次lcp即可。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxBit=18;
const int inf=2147483647;

char str[maxN];
int SA[maxN],Height[maxN],Rank[maxN];
int CntA[maxN],CntB[maxN],A[maxN],B[maxN],SSA[maxN];
int ST[maxN][maxBit];
int Log[maxN];

int Lcp(int p1,int p2);

int main()
{
    ios::sync_with_stdio(false);
    for (int i=1;i&lt;maxN;i++) Log[i]=log2(i);

    cin&gt;&gt;(str+1);
    int L=strlen(str+1);
    //构造SA
    for (int i=1;i&lt;=L;i++) CntA[str[i]]++;
    for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1];
    for (int i=L;i&gt;=1;i--) SA[CntA[str[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=L;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (str[SA[i]]!=str[SA[i-1]]) Rank[SA[i]]++;
    }

    for (int l=1;Rank[SA[L]]&lt;L;l=l&lt;&lt;1)
    {
        mem(CntA,0);mem(CntB,0);
        for (int i=1;i&lt;=L;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=L)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=L;i&gt;=1;i--) SSA[CntB[B[i]]--]=i;
        for (int i=L;i&gt;=1;i--) SA[CntA[A[SSA[i]]]--]=SSA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=L;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    for (int i=1,j=0;i&lt;=L;i++)
    {
        if (j) j--;
        while (str[i+j]==str[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    for (int i=1;i&lt;=L;i++) ST[i][0]=Height[i];
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=L;j++)
            if (j+(1&lt;&lt;i)&lt;=L)
                ST[j][i]=min(ST[j][i-1],ST[j+(1&lt;&lt;i)][i-1]);
    int Ans=0;
    for (int l=1;l&lt;=L;l++)//枚举长度
        for (int i=1;i+l&lt;=L;i+=l)//枚举位置
        {
            int r=Lcp(i,i+l);//先算直接从这一次位置开始的lcp
            Ans=max(Ans,r/l+1);
            //若能够向前移动到这一次重复串的实际开始，则在这个实际开始的位置再求一次
            if (i&gt;=l-r%l) Ans=max(Ans,Lcp(i-l+r%l,i+r%l)/l+1);
        }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

int Lcp(int p1,int p2)
{
    if (Rank[p1]&gt;Rank[p2]) swap(p1,p2);
    p1=Rank[p1];p2=Rank[p2];
    p1++;
    int l=Log[p2-p1+1];
    return min(ST[p1][l],ST[p2-(1&lt;&lt;l)+1][l]);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>578</wp:post_id>
		<wp:post_date><![CDATA[2018-03-24 13:01:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-24 05:01:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hihocoder1419%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%e5%9b%9b%c2%b7%e9%87%8d%e5%a4%8d%e6%97%8b%e5%be%8b4%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%8cst%e8%a1%a8%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="post_tag" nicename="hihocoder"><![CDATA[hihocoder]]></category>
		<category domain="category" nicename="st%e8%a1%a8"><![CDATA[ST表]]></category>
		<category domain="post_tag" nicename="st%e8%a1%a8"><![CDATA[ST表]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[192]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1717/Luogu2852][Usaco2006 Dec]Milk Patterns 产奶的模式（后缀数组，单调队列）</title>
		<link>http://sycstudio.com/archives/580</link>
		<pubDate>Sun, 25 Mar 2018 13:59:08 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=580</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

农夫John发现他的奶牛产奶的质量一直在变动。经过细致的调查，他发现：虽然他不能预见明天产奶的质量，但连续的若干天的质量有很多重叠。我们称之为一个“模式”。 John的牛奶按质量可以被赋予一个0到1000000之间的数。并且John记录了N(1&lt;=N&lt;=20000)天的牛奶质量值。他想知道最长的出现了至少K(2&lt;=K&lt;=N)次的模式的长度。比如1 2 3 2 3 2 3 1 中 2 3 2 3出现了两次。当K=2时，这个长度为4。

<h3>Tag</h3>

后缀数组，单调队列

<h2>题目大意</h2>

求出现次数大于K的最长子串

<h2>解决思路</h2>

后缀数组求出Height后，问题转化为求数列中连续长度为K的连续数列中最小值的最大值，这个可以用单调队列维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxNum=2000100;
const int inf=2147483647;

int n,K;
int Arr[maxN];
int SA[maxN],Rank[maxN],Height[maxN];
int Cnt[maxNum],CntA[maxN],CntB[maxN],A[maxN],B[maxN],SSA[maxN];
int Queue[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;K;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Arr[i];
    //GetSA
    for (int i=1;i&lt;=n;i++) Cnt[Arr[i]]++;
    for (int i=1;i&lt;maxNum;i++) Cnt[i]+=Cnt[i-1];
    for (int i=n;i&gt;=1;i--) SA[Cnt[Arr[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=n;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (Arr[SA[i]]!=Arr[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[n]]!=n;l=l&lt;&lt;1)
    {
        mem(CntA,0);mem(CntB,0);
        for (int i=1;i&lt;=n;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=n)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=n;i&gt;=1;i--) SSA[CntB[B[i]]--]=i;
        for (int i=n;i&gt;=1;i--) SA[CntA[A[SSA[i]]]--]=SSA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=n;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    for (int i=1,j=0;i&lt;=n;i++)
    {
        if (j) j--;
        while (Arr[i+j]==Arr[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    int Ans=0,l=0,r=0;
    K--;
    //单调队列维护长度为K的序列的最小值，每次取出队首即为当前的最小值，对这些最小值取最大值
    for (int i=1;i&lt;=n;i++)
    {
        while ((l&lt;r)&amp;&amp;(Height[i]&lt;Height[Queue[r]])) r--;
        Queue[++r]=i;
        if (i&lt;K) continue;//注意当i的长度小于K的时候，不应该加入答案
        while ((l&lt;r)&amp;&amp;(i-K+1&gt;Queue[l])) l++;
        Ans=max(Ans,Height[Queue[l]]);
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>580</wp:post_id>
		<wp:post_date><![CDATA[2018-03-25 21:59:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-25 13:59:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1717-luogu2852usaco2006-decmilk-patterns-%e4%ba%a7%e5%a5%b6%e7%9a%84%e6%a8%a1%e5%bc%8f%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%8c%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="post_tag" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[165]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2882/Luogu1368]工艺（后缀数组）</title>
		<link>http://sycstudio.com/archives/581</link>
		<pubDate>Sun, 25 Mar 2018 14:01:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=581</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小敏和小燕是一对好朋友。
他们正在玩一种神奇的游戏，叫Minecraft。
他们现在要做一个由方块构成的长条工艺品。但是方块现在是乱的，而且由于机器的要求，他们只能做到把这个工艺品最左边的方块放到最右边。
他们想，在仅这一个操作下，最漂亮的工艺品能多漂亮。
两个工艺品美观的比较方法是，从头开始比较，如果第i个位置上方块不一样那么谁的瑕疵度小，那么谁就更漂亮，如果一样那么继续比较第i+1个方块。如果全都一样，那么这两个工艺品就一样漂亮。

<h3>Tag</h3>

后缀数组

<h2>解决思路</h2>

把字符串复制一遍接在后面，问题转化为求长度大于等于原字符串长度的最小的后缀。后缀排序解决。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=300100*2;
const int inf=2147483647;

int n;
int Arr[maxN];
int SA[maxN],Rank[maxN];
int CntA[maxN],CntB[maxN],A[maxN],B[maxN],SSA[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++){
        cin&gt;&gt;Arr[i];Arr[i+n]=Arr[i];
    }
    n=n+n;
    for (int i=1;i&lt;=n;i++) CntA[Arr[i]]++;
    for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1];
    for (int i=n;i&gt;=1;i--) SA[CntA[Arr[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=n;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (Arr[SA[i]]!=Arr[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[n]]&lt;n;l=l&lt;&lt;1)
    {
        mem(CntA,0);mem(CntB,0);
        for (int i=1;i&lt;=n;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=n)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=n;i&gt;=1;i--) SSA[CntB[B[i]]--]=i;
        for (int i=n;i&gt;=1;i--) SA[CntA[A[SSA[i]]]--]=SSA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=n;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    int pos;
    for (int i=1;i&lt;=n;i++)
        if (SA[i]&lt;=n/2){
            pos=SA[i];break;
        }
    for (int i=1;i&lt;=n/2;i++) cout&lt;&lt;Arr[pos+i-1]&lt;&lt;" ";cout&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>581</wp:post_id>
		<wp:post_date><![CDATA[2018-03-25 22:01:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-25 14:01:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2882-luogu1368%e5%b7%a5%e8%89%ba%ef%bc%88%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[163]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4698/Luogu2463][SDOI2008]Sandy的卡片（差分，后缀数组，二分）</title>
		<link>http://sycstudio.com/archives/582</link>
		<pubDate>Sun, 25 Mar 2018 14:11:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=582</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Sandy和Sue的热衷于收集干脆面中的卡片。然而，Sue收集卡片是因为卡片上漂亮的人物形象，而Sandy则是为了积攒卡片兑换超炫的人物模型。每一张卡片都由一些数字进行标记，第i张卡片的序列长度为Mi，要想兑换人物模型，首先必须要集够N张卡片，对于这N张卡片，如果他们都有一个相同的子串长度为k，则可以兑换一个等级为k的人物模型。相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串。Sandy的卡片数远远小于要求的N，于是Sue决定在Sandy的生日将自己的卡片送给Sandy，在Sue的帮助下，Sandy终于集够了N张卡片，但是，Sandy并不清楚他可以兑换到哪个等级的人物模型，现在，请你帮助Sandy和Sue，看看他们最高能够得到哪个等级的人物模型。

<h3>Tag</h3>

后缀数组，二分

<h2>题目大意</h2>

求若干字符串的最长公共子串

<h2>解决思路</h2>

把每一个数列差分一下，那么，原来对于相同的定义现在就转化为数列的相同子串问题。
把所有的差分数组连接起来，每两个之间用不同的分隔符隔开，求出后缀数组和Height后，二分这个最长公共子串的长度，假设为k，对于连续一段height大于k的，看是否所有的原数列都出现了一次，如果确实都出现了，则说明这个k是可行的，上移下边界；否则，说明比答案大，下移上标记。
注意差分数组后，第一个可以是不一样的，所以最后的答案要加一。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int dpos=1000;
const int inf=2147483647;

int n,m;
int L,Arr[maxN];
int Belong[maxN];
int SA[maxN],Rank[maxN],Height[maxN];
int CntA[maxN],CntB[maxN],A[maxN],B[maxN],SSA[maxN];
bool Appear[maxN];

bool Check(int l);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++)
    {
        int m;cin&gt;&gt;m;
        int a;cin&gt;&gt;a;
        for (int j=2;j&lt;=m;j++)//转化为差分数组并连接起来
        {
            int b;cin&gt;&gt;b;
            Arr[++L]=b-a+dpos;Belong[L]=i;a=b;//Belong[i]记录在连接起来的数组中位置在i的所属的是第几个卡片，方便后面二分判断
        }
        Arr[++L]=i+1000+dpos;//设置分隔符
    }
    //GetSA
    for (int i=1;i&lt;=L;i++) CntA[Arr[i]]++;
    for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1];
    for (int i=L;i&gt;=1;i--) SA[CntA[Arr[i]]--]=i;
    Rank[SA[1]]=1;
    for (int i=2;i&lt;=L;i++)
    {
        Rank[SA[i]]=Rank[SA[i-1]];
        if (Arr[SA[i]]!=Arr[SA[i-1]]) Rank[SA[i]]++;
    }
    for (int l=1;Rank[SA[L]]&lt;L;l=l&lt;&lt;1)
    {
        mem(CntA,0);mem(CntB,0);
        for (int i=1;i&lt;=L;i++)
        {
            CntA[A[i]=Rank[i]]++;
            CntB[B[i]=((i+l&lt;=L)?(Rank[i+l]):(0))]++;
        }
        for (int i=1;i&lt;maxN;i++) CntA[i]+=CntA[i-1],CntB[i]+=CntB[i-1];
        for (int i=L;i&gt;=1;i--) SSA[CntB[B[i]]--]=i;
        for (int i=L;i&gt;=1;i--) SA[CntA[A[SSA[i]]]--]=SSA[i];
        Rank[SA[1]]=1;
        for (int i=2;i&lt;=L;i++)
        {
            Rank[SA[i]]=Rank[SA[i-1]];
            if ((A[SA[i]]!=A[SA[i-1]])||(B[SA[i]]!=B[SA[i-1]])) Rank[SA[i]]++;
        }
    }
    for (int i=1,j=0;i&lt;=L;i++)
    {
        if (j) j--;
        while (Arr[i+j]==Arr[SA[Rank[i]-1]+j]) j++;
        Height[Rank[i]]=j;
    }
    //二分最长公共子串长度
    int l=0,r=L;
    int Ans=0;
    do
    {
        int mid=(l+r)&gt;&gt;1;
        if (Check(mid)) Ans=mid,l=mid+1;
        else r=mid-1;
    }
    while (l&lt;=r);
    cout&lt;&lt;Ans+1&lt;&lt;endl;//由于是差分，所以最后要加一
    return 0;
}

bool Check(int l)
{
    mem(Appear,0);Appear[0]=1;//Appear记录每一个原序列是否都出现了
    for (int i=1,cnt=0;i&lt;=L;i++)
    {
        if (Height[i]&gt;=l)//只统计Height大于当前二分的长度的
        {
            if (Appear[Belong[SA[i]]]==0) Appear[Belong[SA[i]]]=1,cnt++;
            if (Appear[Belong[SA[i-1]]]==0) Appear[Belong[SA[i-1]]]=1,cnt++;
            if (cnt==n) return 1;
        }
        else
        {
            if (cnt!=0) mem(Appear,0);
            cnt=0;Appear[0]=1;
        }
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>582</wp:post_id>
		<wp:post_date><![CDATA[2018-03-25 22:11:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-25 14:11:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4698-luogu2463sdoi2008sandy%e7%9a%84%e5%8d%a1%e7%89%87%ef%bc%88%e5%b7%ae%e5%88%86%ef%bc%8c%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[235]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2324][ZJOI2011]营救皮卡丘（网络流，最短路）</title>
		<link>http://sycstudio.com/archives/583</link>
		<pubDate>Sun, 25 Mar 2018 14:34:25 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=583</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

皮卡丘被火箭队用邪恶的计谋抢走了！这三个坏家伙还给小智留下了赤果果的挑衅！为了皮卡丘，也为了正义，小智和他的朋友们义不容辞的踏上了营救皮卡丘的道路。
火箭队一共有N个据点，据点之间存在M条双向道路。据点分别从1到N标号。小智一行K人从真新镇出发，营救被困在N号据点的皮卡丘。为了方便起见，我们将真新镇视为0号据点，一开始K个人都在0号点。
由于火箭队的重重布防，要想摧毁K号据点，必须按照顺序先摧毁1到K-1号据点，并且，如果K-1号据点没有被摧毁，由于防御的连锁性，小智一行任何一个人进入据点K，都会被发现，并产生严重后果。因此，在K-1号据点被摧毁之前，任何人是不能够经过K号据点的。
为了简化问题，我们忽略战斗环节，小智一行任何一个人经过K号据点即认为K号据点被摧毁。被摧毁的据点依然是可以被经过的。
K个人是可以分头行动的，只要有任何一个人在K-1号据点被摧毁之后，经过K号据点，K号据点就被摧毁了。显然的，只要N号据点被摧毁，皮卡丘就得救了。
野外的道路是不安全的，因此小智一行希望在摧毁N号据点救出皮卡丘的同时，使得K个人所经过的道路的长度总和最少。
请你帮助小智设计一个最佳的营救方案吧！

<h3>Tag</h3>

网络流，二分图

<h2>解决思路</h2>

如果是DAG，那么问题就是求一个费用最小的用K条不相交，可以用拆点的方式解决。但是这里是可能有环的无向图，并且还要求必须先经过标号小的点才能经过标号大的点。
从标号小的走到标号大的？这似乎构成了DAG。我们先考虑一个人怎么走，他一定是依次沿着最短路从小标号走到大标号，并且从u->u+1时不会经过大于u+1的点。这个可以用Floyed最短路预处理出来。
至于多个人的话，其实与一个人是一样的，每一个人都只能向标号更大的地方走。（当然，中间可能经过标号小的，但每一阶段结束的时候一定是走到标号更大的）
所以我们把原图转化为一个只从标号小的走到标号大的的DAG，然后考虑在这个DAG上求覆盖所有点的最短的K条链。
对于每一个点拆成两个点分别叫做入点和出点，记作u和u'，从u到汇点连容量为1，费用为0的边，表示需要到达这个点；再从源点向u'连容量为1费用为0的边。第二条边可以看作是补充第一条边流走的流量的，你可以认为两条边是流量流入汇点再从源点流出，由于原图是连通的一定存在解，所以这样是对的。
再对于新DAG中的一条从小标号走到大标号的边u->v，连边u'->v，容量无穷，费用为其距离。
最后由于有K个人，所以从源点向0号点的出点连一条容量为K费用为0的边，你可以当做0的入点没有用。
然后在这个图上求最小费用最大流就可以得到最优解了。
为了方便处理，在代码中，我把每一个但点的标号都加了一，这样就不需要考虑0了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=160*2;
const int maxM=maxN*maxN*10;
const int inf=2147483647;

int n,m,K;

namespace Flow//最小费用最大流
{
    class Edge
    {
    public:
        int u,v,flow,w;
    };

    int S,T;
    int edgecnt=-1,Head[maxN],Next[maxM];
    Edge E[maxM];
    int Dist[maxN],Flow[maxN],Path[maxN];
    queue&lt;int&gt; Queue;
    bool inqueue[maxN];

    void Add(int u,int v,int flow,int w)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;
        E[edgecnt].u=u;E[edgecnt].v=v;E[edgecnt].w=w;E[edgecnt].flow=flow;
        return;
    }

    void Add_Edge(int u,int v,int flow,int w)
    {
        Add(u,v,flow,w);Add(v,u,0,-w);
        return;
    }

    bool Spfa()
    {
        mem(Dist,-1);
        Dist[S]=0;Flow[S]=inf;inqueue[S]=1;
        while (!Queue.empty()) Queue.pop();
        Queue.push(S);
        do
        {
            int u=Queue.front();Queue.pop();
            for (int i=Head[u];i!=-1;i=Next[i])
            {
                if ((E[i].flow&gt;0)&amp;&amp;((Dist[E[i].v]==-1)||(Dist[E[i].v]&gt;Dist[u]+E[i].w)))
                {
                    Dist[E[i].v]=Dist[u]+E[i].w;Path[E[i].v]=i;Flow[E[i].v]=min(Flow[u],E[i].flow);
                    if (inqueue[E[i].v]==0){
                        inqueue[E[i].v]=1;Queue.push(E[i].v);
                    }
                }
            }
            inqueue[u]=0;
        }
        while (!Queue.empty());
        if (Dist[T]==-1) return 0;
        return 1;
    }

    int MaxFlow()
    {
        int Ret=0;
        while (Spfa())
        {
            Ret+=Flow[T]*Dist[T];
            int now=T;
            while (now!=S)
            {
                E[Path[now]].flow-=Flow[T];
                E[Path[now]^1].flow+=Flow[T];
                now=E[Path[now]].u;
            }
        }
        return Ret;
    }
}

namespace Floyed//最短路
{
    int Dist[maxN][maxN];
    void Add_Edge(int u,int v,int w)
    {
        if ((Dist[u][v]==-1)||(Dist[u][v]&gt;w)) Dist[u][v]=Dist[v][u]=w;
        return;
    }
    void Floyed()//Floyed最短路
    {
        for (int k=1;k&lt;=n;k++)
        {
            for (int i=1;i&lt;=n;i++)
                if ((i!=k)&amp;&amp;(Dist[i][k]!=-1))
                    for (int j=1;j&lt;=n;j++)
                        if ((i!=j)&amp;&amp;(k!=j)&amp;&amp;(Dist[k][j]!=-1))
                            if ((Dist[i][j]==-1)||(Dist[i][j]&gt;Dist[i][k]+Dist[k][j]))
                                Dist[i][j]=Dist[j][i]=Dist[i][k]+Dist[k][j];
            for (int i=1;i&lt;k;i++) if (Dist[i][k]!=-1) Flow::Add_Edge(i+n,k,inf,Dist[i][k]);//由于有不能经过标号大于i的点的限制，所以在这里就要把边加到新图去。，
        }
        return;
    }
}

int main()
{
    mem(Floyed::Dist,-1);mem(Flow::Head,-1);
    scanf("%d%d%d",&amp;n,&amp;m,&amp;K);n++;
    for (int i=1;i&lt;=m;i++)//原图连边
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u++;v++;
        Floyed::Add_Edge(u,v,w);
    }
    Floyed::Floyed();//Floyed求有限制的最短路，同时在新的DAG中连边
    Flow::S=n*2+1;Flow::T=Flow::S+1;
    for (int i=2;i&lt;=n;i++) Flow::Add_Edge(i,Flow::T,1,0),Flow::Add_Edge(Flow::S,i+n,1,0);//添加与源汇点的边
    Flow::Add_Edge(Flow::S,n+1,K,0);//添加源点与起点的边
    printf("%d\n",Flow::MaxFlow());//最小费用最大流
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>583</wp:post_id>
		<wp:post_date><![CDATA[2018-03-25 22:34:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-25 14:34:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2324zjoi2011%e8%90%a5%e6%95%91%e7%9a%ae%e5%8d%a1%e4%b8%98%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e6%9c%80%e7%9f%ad%e8%b7%af%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[227]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>114</wp:comment_id>
			<wp:comment_author><![CDATA[1111]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[707114491@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[101.75.34.224]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-31 11:57:23]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-31 03:57:23]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[很想知道博主学的是什么]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>115</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-03-31 16:52:47]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-03-31 08:52:47]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[？？？什么意思？？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>114</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ3262/Luogu3810]陌上花开（CDQ分治，树状数组）</title>
		<link>http://sycstudio.com/archives/584</link>
		<pubDate>Mon, 26 Mar 2018 13:49:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=584</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，又三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花A比另一朵花B要美丽，当且仅当Sa>=Sb,Ca>=Cb,Ma>=Mb。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。

<h3>Tag</h3>

CDQ分治，树状数组

<h2>题目大意</h2>

求三维偏序。

<h2>解决思路</h2>

学习三维偏序。对于三维偏序(a,b,c)，首先在外面把第一维排序，这样，下面的过程就不需要考虑第一维的影响了。
然后我们二分区间，每一次只考虑左边对右边的贡献，那么因为在外面的时候a已经是有序的了，所以可以保证左边的a一定小于等于右边的a，所以相当于是按照第二维b来进行类似归并排序的操作，对于右边的bi，统计比它小的左边的bj对应的cj有多少不大于ci，那么这个值域的问题可以用树状数组来维护。
需要注意的是，由于有可能有重复的花，所以要先去重。另外，每一次清空树状数组会浪费大量的时间，所以可以用一个时间戳来标记。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lowbit(x) (x)&amp;(-(x))

const int maxN=100010;
const int maxNum=200010;
const int inf=2147483647;

class Data
{
public:
    int a,b,c,ans,cnt;//ans记录总共被贡献了多少答案，cnt记录这一种类的花有多少个
};

int n;
Data D[maxN],Backup[maxN];
int Bit[maxNum];
int histcnt=0,Hist[maxNum];
int Ans[maxN],Cnt[maxN];

bool cmp(Data A,Data B);
void Solve(int l,int r);
void Add(int pos,int key);
int Sum(int pos);

int main()
{
    ios::sync_with_stdio(false);

    int K;
    cin&gt;&gt;n&gt;&gt;K;
    for (int i=1;i&lt;=n;i++){
        cin&gt;&gt;D[i].a&gt;&gt;D[i].b&gt;&gt;D[i].c;
    }
    sort(&amp;D[1],&amp;D[n+1],cmp);//排序
    int p=0;//去重
    for (int i=1,j=0;i&lt;=n;i++)
    {
        j++;
        if ((D[i].a!=D[i+1].a)||(D[i].b!=D[i+1].b)||(D[i].c!=D[i+1].c)){
            D[++p]=D[i];D[p].cnt=j;j=0;
        }
    }

    Solve(1,p);

    for (int i=1;i&lt;=p;i++) Cnt[D[i].ans]+=D[i].cnt;
    for (int i=0;i&lt;n;i++) cout&lt;&lt;Cnt[i]&lt;&lt;endl;
    return 0;
}

bool cmp(Data A,Data B)
{
    if (A.a!=B.a) return A.a&lt;B.a;
    if (A.b!=B.b) return A.b&lt;B.b;
    return A.c&lt;B.c;
}

void Solve(int l,int r)
{
    if (l==r){
        D[l].ans=D[l].cnt-1;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Solve(l,mid);Solve(mid+1,r);
    histcnt++;
    int p1=l,p2=mid+1;
    for (int i=l;i&lt;=r;i++)//统计左边对右边的贡献，同时类似归并排序的，将b排序
        if ((p1&lt;=mid)&amp;&amp;((p2&gt;r)||(D[p1].b&lt;=D[p2].b))){
            Backup[i]=D[p1];Add(D[p1].c,D[p1].cnt);p1++;
        }
        else{
            D[p2].ans+=Sum(D[p2].c);Backup[i]=D[p2];p2++;
        }
    for (int i=l;i&lt;=r;i++) D[i]=Backup[i];
    return;
}

void Add(int pos,int key)
{
    while (pos&lt;maxNum)
    {
        if (Hist[pos]!=histcnt) Bit[pos]=key,Hist[pos]=histcnt;//若时间戳不相同，则说明这一次是直接覆盖
        else Bit[pos]+=key;//否则是正常的树状数组的累加
        pos+=lowbit(pos);
    }
    return;
}

int Sum(int pos)
{
    int ret=0;
    while (pos)
    {
        if (Hist[pos]==histcnt) ret+=Bit[pos];//当时间戳与当前时间标记相同时才加进去
        pos-=lowbit(pos);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>584</wp:post_id>
		<wp:post_date><![CDATA[2018-03-26 21:49:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-26 13:49:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3262-luogu3810%e9%99%8c%e4%b8%8a%e8%8a%b1%e5%bc%80%ef%bc%88%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86%ef%bc%8c%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[162]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4237]稻草人（CDQ分治，单调队列）</title>
		<link>http://sycstudio.com/archives/585</link>
		<pubDate>Mon, 26 Mar 2018 14:11:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=585</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

JOI村有一片荒地，上面竖着N个稻草人，村民们每年多次在稻草人们的周围举行祭典。
有一次，JOI村的村长听到了稻草人们的启示，计划在荒地中开垦一片田地。和启示中的一样，田地需要满足以下条件：
田地的形状是边平行于坐标轴的长方形；
左下角和右上角各有一个稻草人；
田地的内部(不包括边界)没有稻草人。
给出每个稻草人的坐标，请你求出有多少遵从启示的田地的个数

<h3>Tag</h3>

CDQ分治，单调队列

<h2>解决思路</h2>

排序后对横坐标，整体二分，考虑跨越当前分治中心的贡献。
其实只要考虑点怎么放会导致遮住一些点。我们发现，若按照y坐标从大到小考虑贡献，我们需要对左边部分维护一个y坐标从大到小，x坐标从大到小的单调队列；对右边维护一个y从大到小，x从小到大的单调队列。
每一次在左边加入一个点(x0,y0)，会弹出左边之前的若干个点，然后把右边y坐标大于y0的点加入单调队列，同样要保证单调性，然后在右边的单调队列中二分y坐标就可以得到这一次左边这个点与右边的组合得到的贡献了，二分的值域区间是当前枚举到的左点(x0,y0)的y0，到左单调队列的前一个元素的纵坐标。
算完这一次的贡献后，回归到上一层分治之前，因为要方便上一层按照y坐标从大到小加入，所以按y坐标归并排序。
需要注意二分的两端极限情况，这里采用的是临时设一个值和边界判断的方式，防止越界。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int inf=2147483647;

class Pos
{
public:
    int x,y;
};

int n;
ll Ans;
Pos P[maxN],Backup[maxN];
int Queue1[maxN],Queue2[maxN];

bool cmp(Pos A,Pos B);
void Solve(int l,int r);

int main()
{
    ios::sync_with_stdio(false);

    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;P[i].x&gt;&gt;P[i].y;
    sort(&amp;P[1],&amp;P[n+1],cmp);

    Solve(1,n);

    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

bool cmp(Pos A,Pos B)
{
    if (A.x!=B.x) return A.x&lt;B.x;
    return A.y&lt;B.y;
}

void Solve(int L,int R)
{
    if (L==R) return;
    int mid=(L+R)&gt;&gt;1;
    Solve(L,mid);Solve(mid+1,R);

    int h1=0,h2=0;
    int nowans=0;
    for (int i=L,j=mid+1;i&lt;=mid;i++)
    {
        //弹出左单调队列不合法节点，保证单调性
        while ((h1!=0)&amp;&amp;(P[Queue1[h1]].x&lt;P[i].x)) h1--;
        Queue1[++h1]=i;//把当前节点加入
        while ((j&lt;=R)&amp;&amp;(P[j].y&gt;P[i].y))//把右部分纵坐标大于当前左部分枚举到的点的纵坐标的加入右边的单调队列，因为这时它可能有贡献了
        {
            while ((h2!=0)&amp;&amp;(P[Queue2[h2]].x&gt;P[j].x)) h2--;//注意也要保证单调性
            Queue2[++h2]=j;j++;
        }
        if (h2==0) continue;//当第二个队列为空的时候，一定没有贡献
        int p1,p2;//p1记录第一个一个小于当前y的位置，p2记录第一个小于等于左单调队列中前一个的y的位置，注意y是单调降的
        int l=0,r=h2;
        P[0].y=inf;
        while (l&lt;=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if (P[Queue2[mid]].y&gt;P[i].y){
                p1=mid;l=mid+1;
            }
            else r=mid-1;
        }
        if (h1==1) p2=1;//特判左单调队列长度为1，此时不存在前一个，所以直接是最大的
        else
        {
            l=1,r=h2+1;P[0].y=0;Queue2[h2+1]=0;P[0].x=-10;
            while (l&lt;=r)
            {
                int mid=(l+r)&gt;&gt;1;
                if (P[Queue2[mid]].y&lt;=P[Queue1[h1-1]].y){
                    p2=mid;r=mid-1;
                }
                else l=mid+1;
            }
        }
        if (p1&gt;=p2) nowans+=(p1-p2+1),Ans+=(p1-p2+1);//统计答案
    }
    int p1=L,p2=mid+1;//按照y归并排序，方便上一层处理
    for (int i=L;i&lt;=R;i++)
        if ((p1&lt;=mid)&amp;&amp;((p2&gt;R)||(P[p1].y&gt;P[p2].y)))
            Backup[i]=P[p1++];
        else Backup[i]=P[p2++];
    for (int i=L;i&lt;=R;i++) P[i]=Backup[i];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>585</wp:post_id>
		<wp:post_date><![CDATA[2018-03-26 22:11:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-26 14:11:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4237%e7%a8%bb%e8%8d%89%e4%ba%ba%ef%bc%88%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86%ef%bc%8c%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[204]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1095/Luogu2056][ZJOI2007]Hide 捉迷藏（动态点分治，堆）</title>
		<link>http://sycstudio.com/archives/586</link>
		<pubDate>Tue, 27 Mar 2018 13:58:12 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=586</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

捉迷藏 Jiajia和Wind是一对恩爱的夫妻，并且他们有很多孩子。某天，Jiajia、Wind和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由N个屋子和N-1条双向走廊组成，这N-1条走廊的分布使得任意两个屋子都互相可达。游戏是这样进行的，孩子们负责躲藏，Jiajia负责找，而Wind负责操纵这N个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，Jiajia希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。 我们将以如下形式定义每一种操作： C(hange) i 改变第i个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。 G(ame) 开始一次游戏，查询最远的两个关灯房间的
距离。

<h3>Tag</h3>

动态点分治，堆

<h2>题目大意</h2>

动态维护图中最远的两个黑点的距离

<h2>解决思路</h2>

如果没有多次询问，我们用一遍点分治即可解决，具体来说分治每一个重心，要求这一次求出的答案一定要经过当前重心，那么枚举子树dfs求出点到当前重心的距离，用两棵不同子树的最大值相加即为答案。最后从所有的分治重心取最大值。
但是，由于有对点的黑白状态的改变，而我们不能每一次都分治求一遍。考虑到每一次只会改变一个点，那么对应到我们分治的过程，只会有logn个地方的转移是不同的，那么我们可以动态点分治。
在开始的时候先走一遍点分治过程，将每一个重心与它下一层分治出的重心相连，这样可以构出一棵点分树。由点分治的性质可以得到点分树的高度是&#92;(logn&#92;)的。
接下来考虑对于每一个重心要维护些什么。直接点分治求的方式启发我们每一个重心的答案与到这个重心的不同子树内的两个最大值有关。所以我们对每一个点维护两个堆，一个堆维护这个重心u管辖的范围内的所有点到这个重心在点分树中的父亲。注意是这个重心的父亲。第二个堆维护这个重心在点分树中所有儿子的第一个堆的对顶。
为什么要这样维护呢？如果我们对每一个点只维护一个堆，在这个堆中存其管辖范围内所有点到它的距离，那么我们在得到最大和次大的时候不能保证是从不同的子树得到的，而必须是不同的子树得到的答案才会一定经过当前分治重心。所以，我们维护两个堆，一个堆维护辖区内点到重心的父亲的距离，再让另一个维护其点分树儿子的堆顶，那么第二个堆的最大值和次大值就可以保证是从不同的儿子处得到的了。
我们在全局再维护一个全局答案堆，这个堆存所有第二类堆的最大值+次大值之和。
然后我们考虑修改一个点的黑白属性，那么就从这个点所在的点分树一直向上跳，一边跳一遍改变三个堆的值，注意顺序。
至于两点距离的计算，可以用树链剖分或倍增，这里采用倍增的方式。
另外要注意的是，当我们关闭某一个点的灯时，这时是会有链的情况的，所以我们需要在对应的堆中加入一个0；反之，在关掉一个灯的时候，要在堆中删除一个0;。堆中任意元素的删除可以用一个删除堆来维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200110;
const int maxM=maxN*2;
const int maxBit=20;
const int inf=214748367;

class Heap//自己写一个支持删除任意元素的堆
{
public:
    priority_queue&lt;int&gt; Q1,Q2;
    void Update(){//实时更新
        while ((!Q2.empty())&amp;&amp;(Q1.top()==Q2.top())) Q1.pop(),Q2.pop();
    }
    int Size(){
        return Q1.size()-Q2.size();
    }
    void Insert(const int x){
        Q1.push(x);
    }
    void Delete(const int x){
        Q2.push(x);
    }
    bool Empty(){
        Update();return Q1.empty();
    }
    void Pop(){
        Update();Q1.pop();
    }
    int Top(){
        Update();return Q1.top();
    }
    int STop(){//得到第二大的值，注意要提前判断是否存在第二大
        int x=Top();Pop();
        int ret=Top();Insert(x);
        return ret;
    }
};

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Size[maxN],Depth[maxN],ST[maxN][maxBit+1];
int root,mxSon[maxN],nowsum;
bool vis[maxN];
int offcnt=0,Fa[maxN];
Heap H1[maxN],H2[maxN],Ans;
bool Status[maxN];

void Add_Edge(int u,int v);
void dfs_ST(int u,int fa);
int Dist(int u,int v);
void GetRoot(int u,int fa);
void Div(int u);
void Insert_Ans(int u);
void Delete_Ans(int u);
void Off(int u);
void On(int u);

int main()
{
    mem(Head,-1);

    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);Add_Edge(v,u);
    }

    Depth[1]=1;//dfs求出倍增求lca时需要的祖先数组
    dfs_ST(1,1);
    for (int i=1;i&lt;=maxBit;i++)//构造倍增
        for (int j=1;j&lt;=n;j++)
            if (ST[j][i-1])
            ST[j][i]=ST[ST[j][i-1]][i-1];

    nowsum=n;mxSon[0]=inf;root=0;//建立点分树
    GetRoot(1,1);Fa[root]=0;
    Div(root);

    for (int i=1;i&lt;=n;i++) Off(i);//开始时全部初始化为关闭

    int m;scanf("%d",&amp;m);
    while (m--)
    {
        char opt[5];scanf("%s",opt);
        if (opt[0]=='G')//查询
            if (offcnt==1) printf("0\n");
            else if (offcnt==0) printf("-1\n");
            else printf("%d\n",Ans.Top());
        if (opt[0]=='C')//修改
        {
            int u;scanf("%d",&amp;u);
            if (Status[u]==0) On(u);
            else Off(u);
        }
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs_ST(int u,int fa)//dfs求父亲
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Depth[V[i]]=Depth[u]+1;ST[V[i]][0]=u;
            dfs_ST(V[i],u);
        }
    return;
}

int Dist(int u,int v)//倍增求两点之间的距离
{
    int ret=Depth[u]+Depth[v];
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit;i&gt;=0;i--)
        if ((ST[u][i]!=0)&amp;&amp;(Depth[ST[u][i]]&gt;=Depth[v])) u=ST[u][i];
    if (u==v) return ret-2*Depth[u];
    for (int i=maxBit;i&gt;=0;i--)
        if ((ST[u][i]!=0)&amp;&amp;(ST[v][i]!=0)&amp;&amp;(ST[u][i]!=ST[v][i])) u=ST[u][i],v=ST[v][i];
    u=ST[u][0];
    return ret-2*Depth[u];
}

void GetRoot(int u,int fa)//得到当前子树的重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Div(int u)//点分治，勾出构出点分树
{
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            root=0;nowsum=Size[V[i]];
            GetRoot(V[i],V[i]);Fa[root]=u;
            Div(root);
        }
    return;
}

void Insert_Ans(int u)//把u点的答案加入答案堆
{//注意需要判断u的堆是否有两个元素
    if (H2[u].Size()&gt;=2) Ans.Insert(H2[u].Top()+H2[u].STop());
    return;
}

void Delete_Ans(int u)//把u的答案从答案堆中删除
{
    if (H2[u].Size()&gt;=2) Ans.Delete(H2[u].Top()+H2[u].STop());
    return;
}

void Off(int u)//把u点灯关掉
{
    offcnt++;Status[u]=0;
    Delete_Ans(u);//先把u的答案删掉
    H2[u].Insert(0);//u开了之后，可能会有链的答案，所以要加入一个0
    Insert_Ans(u);//更新答案

    int now=u;
    while (Fa[now])//向上跳点分树
    {
        Delete_Ans(Fa[now]);//首先把父亲的答案去除

        if (!H1[now].Empty()) H2[Fa[now]].Delete(H1[now].Top());//把原来的堆顶删掉
        H1[now].Insert(Dist(u,Fa[now]));//加入新的元素
        H2[Fa[now]].Insert(H1[now].Top());//再把堆顶加入父亲的堆

        Insert_Ans(Fa[now]);//重新加入答案
        now=Fa[now];
    }
    return;
}

void On(int u)//把u节点打开，可以类比关闭
{
    offcnt--;Status[u]=1;
    Delete_Ans(u);
    H2[u].Delete(0);
    Insert_Ans(u);

    int now=u;
    while (Fa[now])
    {
        Delete_Ans(Fa[now]);

        H2[Fa[now]].Delete(H1[now].Top());
        H1[now].Delete(Dist(u,Fa[now]));
        if (!H1[now].Empty()) H2[Fa[now]].Insert(H1[now].Top());
        Insert_Ans(Fa[now]);
        now=Fa[now];
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>586</wp:post_id>
		<wp:post_date><![CDATA[2018-03-27 21:58:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-27 13:58:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1095-luogu2056zjoi2007hide-%e6%8d%89%e8%bf%b7%e8%97%8f%ef%bc%88%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e5%a0%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="post_tag" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[动态点分治]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[动态点分治]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[172]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1770/Luogu2962][Usaco2009 Nov]lights 燈（高斯消元，搜索）</title>
		<link>http://sycstudio.com/archives/588</link>
		<pubDate>Tue, 27 Mar 2018 14:11:31 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=588</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

貝希和她的閨密們在她們的牛棚中玩遊戲。但是天不從人願，突然，牛棚的電源跳閘了，所有的燈都被關閉了。貝希是一個很膽小的女生，在伸手不見拇指的無盡的黑暗中，她感到驚恐，痛苦與絕望。她希望您能夠幫幫她，把所有的燈都給重新開起來！她才能繼續快樂地跟她的閨密們繼續玩遊戲！ 牛棚中一共有N（1 &lt;= N &lt;= 35）盞燈，編號為1到N。這些燈被置於一個非常複雜的網絡之中。有M（1 &lt;= M &lt;= 595）條很神奇的無向邊，每條邊連接兩盞燈。 每盞燈上面都帶有一個開關。當按下某一盞燈的開關的時候，這盞燈本身，還有所有有邊連向這盞燈的燈的狀態都會被改變。狀態改變指的是：當一盞燈是開著的時候，這盞燈被關掉；當一盞燈是關著的時候，這盞燈被打開。 問最少要按下多少個開關，才能把所有的燈都給重新打開。 數據保證至少有一種按開關的方案，使得所有的燈都被重新打開。

<h3>Tag</h3>

高斯消元，搜索

<h2>解决思路</h2>

首先对于每一个点操作两次以上是没有意义的，每一个点最多只会操作一次。那么设F[i]表示i有没有被操作，能够列出异或方程
&#92;[F[i]\wedge F[v1]\wedge F[v2]……=1 \quad (v \quad linked\quad i)&#92;]
高斯消元解出这个方程后，可以得到一个上三角矩阵、若干有确定解的元和若干自由元。
那么枚举这些自由元是开灯还是不开灯。相应的，能够根据高斯消元消出的上三角矩阵解出所有的灯的操作情况，从它们中取最优值。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=40;
const int inf=2147483647;

int n,m;
int Ans=inf,Status[maxN];
bitset&lt;maxN&gt; A[maxN];

void Gauss();
void dfs(int now,int tot);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        A[u][v]=A[v][u]=1;
    }
    for (int i=1;i&lt;=n;i++) A[i][n+1]=A[i][i]=1;
    Gauss();//高斯消元
    dfs(n,0);//枚举自由元选择然后求解
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Gauss()//高斯消元
{
    int now=0;
    for (int i=1;i&lt;=n;i++)
    {
        now++;int j=now;
        while ((A[j][i]==0)&amp;&amp;(j&lt;=n)) j++;
        if (j&gt;n) continue;//如果发现是自由元，直接continue
        if (now!=j) swap(A[now],A[j]);
        for (int k=1;k&lt;=n;k++)
            if ((k!=now)&amp;&amp;(A[k][i]==1)) A[k]^=A[now];
    }
    return;
}

void dfs(int now,int tot)
{
    if (tot&gt;=Ans) return;//最优性剪枝
    if (now==0)
    {
        Ans=min(Ans,tot);
        return;
    }
    if (A[now][now]==1)//高斯消元时不是自由元，那么由上三角和后面得到的每一个变量的取值可以推出这一次的取值
    {
        int t=A[now][n+1];
        for (int i=now+1;i&lt;=n;i++) if (A[now][i]) t^=Status[i];
        Status[now]=t;
        dfs(now-1,tot+t);
    }
    else//是自由元，那就有两种取值，分别向下计算
    {
        Status[now]=0;dfs(now-1,tot);
        Status[now]=1;dfs(now-1,tot+1);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>588</wp:post_id>
		<wp:post_date><![CDATA[2018-03-27 22:11:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-27 14:11:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1770-luogu2962usaco2009-novlights-%e7%87%88%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%8c%e6%90%9c%e7%b4%a2%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="post_tag" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="category" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[141]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1778/Luogu2973][Usaco2010 Hol]Dotp 驱逐猪猡（高斯消元，期望）</title>
		<link>http://sycstudio.com/archives/589</link>
		<pubDate>Tue, 27 Mar 2018 14:32:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=589</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

奶牛们建立了一个随机化的臭气炸弹来驱逐猪猡。猪猡的文明包含1到N (2 &lt;= N &lt;= 300)一共N个猪城。这些城市由M (1 &lt;= M &lt;= 44,850)条由两个不同端点A_j和B_j (1 &lt;= A_j&lt;= N; 1 &lt;= B_j &lt;= N)表示的双向道路连接。保证城市1至少连接一个其它的城市。一开始臭气弹会被放在城市1。每个小时（包括第一个小时），它有P/Q (1 &lt;= P &lt;=1,000,000; 1 &lt;= Q &lt;= 1,000,000)的概率污染它所在的城市。如果这个小时内它没有污染它所在的城市，那麽它随机地选择一条道路，在这个小时内沿着这条道路走到一个新的城市。可以离开这个城市的所有道路被选择的概率均等。因为这个臭气弹的随机的性质，奶牛们很困惑哪个城市最有可能被污染。给定一个猪猡文明的地图和臭气弹在每个小时内爆炸的概率。计算每个城市最终被污染的概率。如下例，假设这个猪猡文明有两个连接在一起的城市。臭气炸弹从城市1出发，每到一个城市，它都有1/2的概率爆炸。 1--2 可知下面这些路径是炸弹可能经过的路径（最后一个城市是臭气弹爆炸的城市）： 1: 1 2: 1-2 3: 1-2-1 4: 1-2-1-2 5: 1-2-1-2-1 ... 要得到炸弹在城市1终止的概率，我们可以把上面的第1，第3，第5……条路径的概率加起来，（也就是上表奇数编号的路径）。上表中第k条路径的概率正好是(1/2)^k，也就是必须在前k-1个回合离开所在城市（每次的概率为1 - 1/2 = 1/2）并且留在最后一个城市（概率为1/2）。所以在城市1结束的概率可以表示为1/2 + (1/2)^3 + (1/2)^5 + ...。当我们无限地计算把这些项一个个加起来，我们最后会恰好得到2/3，也就是我们要求的概率，大约是0.666666667。这意味着最终停留在城市2的概率为1/3，大约为0.333333333。

<h3>Tag</h3>

高斯消元，期望

<h2>题目大意</h2>

一个从一号点出发的炸弹，在每一个点有p/q的概率爆炸，否则随机选择一条出边移动。求在每一个点爆炸的概率。

<h2>解决思路</h2>

由全期望公式，设F[u]表示在第u个点爆炸的概率，那么对于与u相连的一个点v，有
&#92;[F[u]=F[v]&#42;(1-\frac{p}{q})&#42;(v到u的路径条数)/(点v的度数)+[u是否是1号点]&#92;]
由于F的转移顺序是不确定的，所以我们可以转化为n个n元一次方程组，高斯消元得到每一个F[i]。
由于对于每一个点的&#92;(\frac{p}{q}&#92;)都是一定的，那么记&#92;(sum=\sum F[i]&#92;)，在第i个点爆炸的概率就是&#92;(\frac{F[i]}{sum}&#92;)

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=310;
const ld eps=1e-13;
const int inf=2147483647;

int n,m,P,Q;
ld F[maxN][maxN];
int Cnt[maxN][maxN],Degree[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;P&gt;&gt;Q;
    ld gl=(ld)1-(ld)P/(ld)Q;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        Cnt[u][v]++;Cnt[v][u]++;//统计路径条数
        Degree[u]++;Degree[v]++;//统计度数
    }
    F[1][n+1]=-1;
    for (int i=1;i&lt;=n;i++)//构造转移矩阵
    {
        F[i][i]=-1;
        for (int j=1;j&lt;=n;j++)
            if (Cnt[j][i])
                F[i][j]+=(ld)gl*(ld)Cnt[j][i]/(ld)Degree[j];
    }

    int now=0;
    for (int i=1;i&lt;=n;i++)//高斯消元
    {
        int j=i;
        while (fabs(F[j][i])&lt;eps) j++;
        for (int k=1;k&lt;=n+1;k++) swap(F[i][k],F[j][k]);
        ld d=(ld)1/F[i][i];
        for (int k=1;k&lt;=n+1;k++) F[i][k]*=d;
        for (int k=1;k&lt;=n;k++)
            if ((k!=i)&amp;&amp;(fabs(F[k][i])&gt;eps))
            {
                d=F[k][i]/F[i][i];
                for (int l=1;l&lt;=n+1;l++) F[k][l]=F[k][l]-F[i][l]*d;
            }
    }
    ld sum=0;//所有出现概率之和
    for (int i=1;i&lt;=n;i++) sum+=F[i][n+1];
    for (int i=1;i&lt;=n;i++) printf("%.9LF\n",fabs(F[i][n+1]/sum));
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>589</wp:post_id>
		<wp:post_date><![CDATA[2018-03-27 22:32:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-27 14:32:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1778-luogu2973usaco2010-holdotp-%e9%a9%b1%e9%80%90%e7%8c%aa%e7%8c%a1%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%8c%e6%9c%9f%e6%9c%9b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="post_tag" nicename="usaco"><![CDATA[USACO]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[192]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1923/Luogu2447][SDOI2010]外星千足虫 （高斯消元）</title>
		<link>http://sycstudio.com/archives/591</link>
		<pubDate>Thu, 29 Mar 2018 02:37:16 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=591</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/bzojch/file/1923_0.jpg" alt="BZOJ1923" />

<h3>Tag</h3>

高斯消元

<h2>解决思路</h2>

地球上的虫子足的奇偶性为0，外星的为1，那么题目就是给出若干个异或方程，求解。
直接高斯消元。注意判断多解的情况。另外，要记录最近的能够出解的地方。
由于只有异或操作，所以可以用bitset优化。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=2010;
const int inf=2147483647;

int n,m;
int Ans=0;
bitset&lt;maxN&gt; A[maxN];
char Input[maxN];

void Gauss();

int main()
{
    ios::sync_with_stdio(false);

    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;(Input+1);
        for (int j=1;j&lt;=n;j++) A[i][j]=Input[j]-'0';
        int x;cin&gt;&gt;x;
        A[i][n+1]=x;
    }
    Gauss();
    if (Ans==-1){
        cout&lt;&lt;"Cannot Determine"&lt;&lt;endl;
        return 0;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    for (int i=1;i&lt;=n;i++)
        if (A[i][n+1]) cout&lt;&lt;"?y7M#"&lt;&lt;endl;
        else cout&lt;&lt;"Earth"&lt;&lt;endl;
    return 0;
}

void Gauss()
{
    int now=0;
    for (int i=1;i&lt;=n;i++)
    {
        int j=now+1;
        while ((A[j][i]==0)&amp;&amp;(j&lt;=m)) j++;
        if (j==m+1){//多解
            Ans=-1;break;
        }
        now++;if (now!=j) swap(A[now],A[j]);
        Ans=max(Ans,j);//记录能得到解的最早的地方
        for (int k=1;k&lt;=m;k++)
            if ((k!=now)&amp;&amp;(A[k][i]==1)) A[k]^=A[now];
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>591</wp:post_id>
		<wp:post_date><![CDATA[2018-03-29 10:37:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-29 02:37:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1923-luogu2447sdoi2010%e5%a4%96%e6%98%9f%e5%8d%83%e8%b6%b3%e8%99%ab-%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[180]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3563/BZOJ3569]DZY Loves Chinese/DZY Loves Chinese II（线性基，随机化）</title>
		<link>http://sycstudio.com/archives/592</link>
		<pubDate>Thu, 29 Mar 2018 03:03:41 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=592</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

神校XJ之学霸兮，Dzy皇考曰JC。
摄提贞于孟陬兮，惟庚寅Dzy以降。
纷Dzy既有此内美兮，又重之以修能。
遂降临于OI界，欲以神力而凌♂辱众生。

今Dzy有一魞歄图，其上有N座祭坛，又有M条膴蠁边。
时而Dzy狂WA而怒发冲冠，神力外溢，遂有K条膴蠁边灰飞烟灭。
而后俟其日A50题则又令其复原。（可视为立即复原）
然若有祭坛无法相互到达，Dzy之神力便会大减，于是欲知其是否连通。

<h3>Tag</h3>

线性基，随机化

<h2>解决思路</h2>

考虑对整个图构一棵生成树，那么图不连通当且仅当有一条树边断开且跨越这条边的所有非树边也都断开。
如何判断一条树边断开的同时跨越它的所有非树边也都断开呢？可以给每一个非树边随机一个权值，树边的权值则为所有跨越了它的非树边的权值异或和。
那么，对于每一个询问，如果边的异或和为0，则说明有一组树边和所有覆盖它的非树边都被删除，所以不连通。
求树边的权值可以用树上差分，而求是否存在异或和为0可以用线性基。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500100*2;
const int maxM=500100*2;
const int inf=2147483647;

class Edge
{
public:
    int val;
    int u,v;
    bool path;
};

int n,m;
int edgecnt=-1,Head[maxN],Next[maxM],V[maxM];
Edge E[maxM];
int Val[maxN];
bool vis[maxN];
int Base[31];

void Add_Edge(int u,int v);
void dfs1(int u,int fa);
void dfs2(int u,int fa);

int main()
{
    srand(141404^170524);mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=0;i&lt;m;i++)
    {
        scanf("%d%d",&amp;E[i].u,&amp;E[i].v);
        Add_Edge(E[i].u,E[i].v);Add_Edge(E[i].v,E[i].u);
    }

    dfs1(1,1);//随机生成树
    for (int i=0;i&lt;m;i++)//给非树边随机一个权值
        if (E[i].path==0)
        {
            E[i].val=rand()%(1&lt;&lt;30);
            Val[E[i].u]^=E[i].val;//打上差分标记
            Val[E[i].v]^=E[i].val;
        }
    mem(vis,0);
    dfs2(1,1);//求树边权值

    int Q;scanf("%d",&amp;Q);
    int Ans=0;
    while (Q--)
    {
        int K;scanf("%d",&amp;K);
        mem(Base,0);//线性基求是否有异或和为0的
        bool flag=1;
        while (K--)
        {
            int e;scanf("%d",&amp;e);e^=Ans;e=E[e-1].val;
            for (int i=30;i&gt;=0;i--)
                if ((e&amp;(1&lt;&lt;i))!=0)
                {
                    if (Base[i]==0){
                        Base[i]=e;break;
                    }
                    else e^=Base[i];
                }
            if (e==0) flag=0;
        }
        if (flag==1) printf("Connected\n"),Ans++;
        else printf("Disconnected\n");
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u,int fa)//随便构出一棵生成树
{
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            E[i&gt;&gt;1].path=1;
            dfs1(V[i],u);
        }
    return;
}

void dfs2(int u,int fa)//求出树边上的权值
{
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            dfs2(V[i],u);
            E[i&gt;&gt;1].val^=Val[V[i]];
            Val[u]^=Val[V[i]];
        }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>592</wp:post_id>
		<wp:post_date><![CDATA[2018-03-29 11:03:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-29 03:03:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3563-bzoj3569dzy-loves-chinese-dzy-loves-chinese-ii%ef%bc%88%e7%ba%bf%e6%80%a7%e5%9f%ba%ef%bc%8c%e9%9a%8f%e6%9c%ba%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%80%a7%e5%9f%ba"><![CDATA[线性基]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e5%9f%ba"><![CDATA[线性基]]></category>
		<category domain="category" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[159]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2734/Luogu3226][HNOI2012]集合选数（状态压缩动态规划，构造）</title>
		<link>http://sycstudio.com/archives/593</link>
		<pubDate>Thu, 29 Mar 2018 03:43:18 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=593</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

《集合论与图论》这门课程有一道作业题，要求同学们求出{1, 2, 3, 4, 5}的所有满足以 下条件的子集：若 x 在该子集中，则 2x 和 3x 不能在该子集中。同学们不喜欢这种具有枚举性 质的题目，于是把它变成了以下问题：对于任意一个正整数 n≤100000，如何求出{1, 2,..., n} 的满足上述约束条件的子集的个数（只需输出对 1,000,000,001 取模的结果），现在这个问题就 交给你了。

<h3>Tag</h3>

状态压缩动态规划，构造

<h2>解决思路</h2>

构造一个矩阵，左上角是1，接下来每一个数是它左边的数的2倍，上面的数的3倍。这样问题转化为在矩阵中选择若干个不相邻的方案数。
由于是乘法，矩阵的长宽都是&#92;(log&#92;)级别的，所以可以状态压缩动态规划求解 。
但是可以发现，有一些数是没有出现在这个矩阵中的，所以我们再选择一个没有在矩阵中出现的最小的数，作为新的矩阵的左上角，再进行动态规划。直到所有数都在矩阵中出现过。由于各矩阵是互相独立的，所以是把方案数相乘。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxMap=18;
const int Mod=1000000001;
const int inf=2147483647;

int n;
bool Used[maxN];
int Len[maxMap];
int Map[maxMap][maxMap];
int F[maxMap][1&lt;&lt;maxMap];

ll Calc(int st);

int main()
{
    ios::sync_with_stdio(false);

    ll Ans=1;
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) if (Used[i]==0) Ans=Ans*Calc(i)%Mod;//枚举没有出现的数
    cout&lt;&lt;Ans&lt;&lt;endl;

    return 0;
}

ll Calc(int st)
{
    //构造矩阵
    Used[Map[1][1]=st]=1;
    for (int i=2;;i++)
    {
        if (Map[1][i-1]*3ll&gt;n){
            Len[1]=i-1;break;
        }
        Used[Map[1][i]=Map[1][i-1]*3ll]=1;
    }
    int line;
    for (int i=2;;i++)
    {
        if (Map[i-1][1]*2ll&gt;n){
            line=i-1;break;
        }
        Used[Map[i][1]=Map[i-1][1]*2ll]=1;
        for (int j=2;;j++)
        {
            if (Map[i][j-1]*3ll&gt;n){
                Len[i]=j-1;break;
            }
            Used[Map[i][j]=Map[i][j-1]*3]=1;
        }
    }
    //状压求解
    for (int i=1;i&lt;=line;i++) for (int S=0;S&lt;(1&lt;&lt;Len[i]);S++) F[i][S]=0;
    F[0][0]=1;
    for (int S=0;S&lt;(1&lt;&lt;Len[1]);S++)
        if ((S&amp;(S&lt;&lt;1))==0) F[1][S]=1;
    for (int i=2;i&lt;=line;i++)
    {
        for (int S1=0;S1&lt;(1&lt;&lt;Len[i-1]);S1++)
            if ((S1&amp;(S1&lt;&lt;1))==0)
                for (int S2=0;S2&lt;(1&lt;&lt;Len[i]);S2++)
                    if (((S2&amp;(S2&lt;&lt;1))==0) &amp;&amp; ((S1&amp;S2)==0))
                        F[i][S2]=(F[i][S2]+F[i-1][S1])%Mod;
    }
    ll Ret=0;
    for (int S=0;S&lt;(1&lt;&lt;Len[line]);S++)
        if ((S&amp;(S&lt;&lt;1))==0) Ret=(Ret+F[line][S])%Mod;
    return Ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>593</wp:post_id>
		<wp:post_date><![CDATA[2018-03-29 11:43:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-03-29 03:43:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2734-luogu3226hnoi2012%e9%9b%86%e5%90%88%e9%80%89%e6%95%b0%ef%bc%88%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%9e%84%e9%80%a0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%9e%84%e9%80%a0"><![CDATA[构造]]></category>
		<category domain="post_tag" nicename="%e6%9e%84%e9%80%a0"><![CDATA[构造]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[状态压缩动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[167]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3160/Luogu4199]万径人踪灭（FFT，Manacher）</title>
		<link>http://sycstudio.com/archives/594</link>
		<pubDate>Sun, 01 Apr 2018 14:13:10 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=594</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/media/BZOJ/BZOJ3160-1.jpg" alt="BZOJ3160-1" />
<img src="/media/BZOJ/BZOJ3160-2.jpg" alt="BZOJ3160-1" />

<h3>Tab</h3>

FFT，Manacher

<h2>解决思路</h2>

要求求不连续的回文子序列的数量，那么就用所有回文序列的数量（可以连续或不连续）减去回文子串的数量。
首先考虑回文子串的数量如何求，可以用Mancher求出所有位置的回文半径，然后每一个回文半径都可以组合出若干回文子串，这个可以直接计算。
然后考虑求所有可连续也可以不连续的回文子序列的个数。看一个例子，为了方便后面的求解，字符串从0开始编号。

<pre><code class="">01234
abaab
</code></pre>

由于回文序列的中心可能是字符也可能是字符的间隔，所以运用Manacher的思想，我们可以把字符串S补成这样S'

<pre><code class="">01234
abaab
$#a#b#a#a#b#
012345678901
</code></pre>

设F[i]为S'中以位置为i的地方为中心有几对字符相同，那么如果我们知道以i为中心的对称的a和b的数量，假设为x，我们就可以得到以i为中心的所有回文序列的个数了，即为&#92;(2^{\frac{x}{2}}-1&#92;)，这个可以用组合原理得到。
然后我们考虑如何得到这个x。观察原串编号之间的关系，比如aba的编号分别为012，在S'中为246，于是我们可以得到这样一个式子，对于原串S中对称的两个位置（不管是关于字符对称还是间隙对称）i，j，它们的对称中心在S'中为&#92;((i+1)+(j+1)&#92;)。
所以我们设F[i]表示在S'中以第i个位置为对称中心的相同的字符对数，那么有
&#92;[F[i]=\frac{\sum&#95;{j=1} [s[i]==s[i-2-j]]+1}{2}&#92;]
我们发现这个是一个类似卷积的形式，所以可以用&#92;(FFT&#92;)来做，具体来说，构造多项式的时候，分a和b两次来做，比如aba
第一次(a)：&#92;(1+0&#42;x+1&#42;x^2&#92;)
第二次(b)：&#92;(0+1&#42;x+0&#42;x^2&#92;)
分别自乘就可以求出对应系数，然后再用上面的公式算，最后减去用&#92;(Manacher&#92;)算出来的连续回文的贡献。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200100*4;
const ld Pi=acos(-1);
const int Mod=1e9+7;
const int inf=2147483647;

int N,L;
char str[maxN],str2[maxN];
complex&lt;ld&gt; A[maxN],B[maxN];
ll F[maxN],Rev[maxN],Bin[maxN],H[maxN];

void FFT(complex&lt;ld&gt; *P,int opt);
ll Manacher();

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;str;
    int len=strlen(str);

    for (N=1;N&lt;=len*2+1;N=N&lt;&lt;1) L++;
    for (int i=0;i&lt;N;i++) Rev[i]=(Rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));//Rader排序

    for (int i=0;i&lt;len;i++) A[i]=str[i]=='a',B[i]=str[i]=='b';//分别构造多项式
    FFT(A,1);FFT(B,1);//FFT求解卷积
    for (int i=0;i&lt;N;i++) A[i]=A[i]*A[i],B[i]=B[i]*B[i];
    for (int i=0;i&lt;N;i++) A[i]=A[i]+B[i];
    FFT(A,-1);
    for (int i=2;i&lt;2*len+1;i++) F[i]=(ll)((A[i-2].real()+0.5)/N+1)&gt;&gt;1;

    ll Ans=0;
    Bin[0]=1;for (int i=1;i&lt;2*len+1;i++) Bin[i]=(Bin[i-1]&lt;&lt;1)%Mod;
    for (int i=0;i&lt;2*len+1;i++) Ans=(Ans+Bin[F[i]]-1)%Mod;

    printf("%lld\n",(Ans+Mod-Manacher())%Mod);
}

void FFT(complex&lt;ld&gt; *P,int opt)//FFT
{
    for (int i=0;i&lt;N;i++) if (i&lt;Rev[i]) swap(P[i],P[Rev[i]]);
    for (int i=1;i&lt;N;i=i&lt;&lt;1)
    {
        int dl=i&lt;&lt;1;
        complex&lt;ld&gt; dw(cos((ld)Pi/(ld)i),(ld)opt*sin(Pi/(ld)i));
        for (int j=0;j&lt;N;j=j+dl)
        {
            complex&lt;ld&gt; w(1,0);
            for (int k=0;k&lt;i;k++,w=w*dw)
            {
                complex&lt;ld&gt; X=P[j+k],Y=w*P[j+k+i];
                P[j+k]=X+Y;P[j+k+i]=X-Y;
            }
        }
    }
    return;
}

ll Manacher()//Manacher算连续回文的贡献
{
    int l=1;str2[0]='$';str2[1]='#';
    int len=strlen(str);
    for (int i=0;i&lt;len;i++){
        str2[++l]=str[i];str2[++l]='#';
    }
    ll id=0,mx=0;
    for (int i=0;i&lt;=l;i++)
    {
        if (i&lt;=mx) H[i]=min(H[id*2-i],mx-i);
        else H[i]=1;
        while (str2[i+H[i]]==str2[i-H[i]]) H[i]++;
        if (i+H[i]&gt;mx){
            mx=i+H[i];id=i;
        }
    }
    ll sum=0;
    for (int i=0;i&lt;=l;i++) sum=(sum+(ll)H[i]/2)%Mod;
    return sum;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>594</wp:post_id>
		<wp:post_date><![CDATA[2018-04-01 22:13:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-01 14:13:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3160-luogu4199%e4%b8%87%e5%be%84%e4%ba%ba%e8%b8%aa%e7%81%ad%ef%bc%88fft%ef%bc%8cmanacher%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="fft"><![CDATA[FFT]]></category>
		<category domain="post_tag" nicename="fft"><![CDATA[FFT]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="manacher"><![CDATA[Manacher]]></category>
		<category domain="post_tag" nicename="manacher"><![CDATA[Manacher]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[190]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>153</wp:comment_id>
			<wp:comment_author><![CDATA[lalala]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[12345@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.4399.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-06-30 09:02:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-06-30 01:02:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主公式挂啦]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ1014/Luogu4036][JSOI2008]火星人prefix（字符串Hash，Splay，二分）</title>
		<link>http://sycstudio.com/archives/603</link>
		<pubDate>Sun, 01 Apr 2018 14:27:37 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=603</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：序号： 1 2 3 4 5 6 7 8 9 10 11 字符 m a d a m i m a d a m 现在，火星人定义了一个函数LCQ(x, y)，表示：该字符串中第x个字符开始的字串，与该字符串中第y个字符开始的字串，两个字串的公共前缀的长度。比方说，LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0 在研究LCQ函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出LCQ函数的值；同样，如果求出了LCQ函数的值，也可以很快地将该字符串的后缀排好序。 尽管火星人聪明地找到了求取LCQ函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取LCQ函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取LCQ函数的值。

<h3>Tag</h3>

字符串Hash，Splay，二分

<h2>解决思路</h2>

想要求两个字符串的lcp，一种方法是把字符串后缀排序后，借助Height数组来求解。但是这样的缺点是不能支持修改操作。另一种就是二分长度+Hash判断。由于这里有对字符的修改和插入，所以采用二分+Hash的方式。
具体来说，相当于用Splay维护一个无序区间，对每一个点维护一个它子树内这段字符串的Hash值，每一次更改Splay形状的时候，顺便维护。那么，插入就把位置旋转到根再在后面插入，查询则把左端点的前一个转到根，右端点的后一个转到根的儿子，这样根的右儿子的左儿子就保存了需要的字符串Hash值。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100*4;
const ull hashbase=233;
const int inf=2147483647;

class SplayData
{
public:
    int size;
    int fa,ch[2];
    ull hash,key;
};

int n,nodecnt,root;
ull Hash[maxN];
SplayData S[maxN];
char Input[maxN];

void Update(int now);
void Rotate(int x);
void Splay(int x,int goal);
int Find(int kth);
void Insert(int pos,int key);
ull GetHash(int ql,int qr);

int main()
{
    ios::sync_with_stdio(false);
    Hash[0]=1;for (int i=1;i&lt;maxN;i++) Hash[i]=Hash[i-1]*hashbase;

    cin&gt;&gt;(Input+1);
    int len=strlen(Input+1);
    //初始化Splay，直接把原字符串以一条链的形式放在Splay中。其实有更好的平衡方式，但是不想写啦
    //注意，这里为了方便操作，在两边分别加入了哨兵节点
    S[1].key=0;S[1].ch[1]=1;
    for (int i=1;i&lt;=len;i++)
    {
        S[i+1].key=Input[i];
        S[i+1].fa=i;
        S[i].ch[1]=i+1;
    }
    S[len+2].key=0;S[len+1].ch[1]=len+2;S[len+2].fa=len+1;
    Splay(len+2,0);nodecnt=len+2;

    int m;cin&gt;&gt;m;//回答询问
    int L=strlen(Input+1);
    while (m--)
    {
        char opt;cin&gt;&gt;opt;
        if (opt=='Q')
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            if (x&gt;y) swap(x,y);
            int l=1,r=L-y+1;
            int Ans=0;
            do//二分长度
            {
                int mid=(l+r)&gt;&gt;1;
                if (GetHash(x,x+mid-1)==GetHash(y,y+mid-1)) Ans=mid,l=mid+1;//截取Hash值判断
                else r=mid-1;
            }
            while (l&lt;=r);
            cout&lt;&lt;Ans&lt;&lt;endl;
        }
        if (opt=='R')//修改
        {
            int x;char ch;cin&gt;&gt;x&gt;&gt;ch;
            x=Find(x+1);
            Splay(x,0);
            S[x].key=ch;Update(x);
        }
        if (opt=='I')//插入
        {
            int x;char ch;cin&gt;&gt;x&gt;&gt;ch;
            Insert(x,ch);L++;
        }
    }
    return 0;
}

void Update(int now)//Splay更新
{
    S[now].hash=S[S[now].ch[0]].hash*Hash[S[S[now].ch[1]].size+1]+S[now].key*Hash[S[S[now].ch[1]].size]+S[S[now].ch[1]].hash;
    S[now].size=S[S[now].ch[0]].size+S[S[now].ch[1]].size+1;
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]),sy=(y==S[z].ch[1]);
    S[x].fa=z;if (z) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x,int goal)
{
    while (S[x].fa!=goal)
    {
        int y=S[x].fa,z=S[y].fa;
        if (z!=goal)
            ((x==S[y].ch[0])^(y==S[z].ch[0])?(Rotate(x)):(Rotate(y)));
        Rotate(x);
    }
    Update(x);
    if (goal==0) root=x;
    return;
}

int Find(int kth)
{
    int now=root;
    while (1)
    {
        int l=S[now].ch[0];
        if (S[l].size&gt;=kth) now=l;
        else if (S[l].size+1==kth) return now;
        else kth=kth-S[l].size-1,now=S[now].ch[1];
    }
}

void Insert(int pos,int key)
{
    int l=Find(pos+1),r=Find(pos+2);
    Splay(l,0);Splay(r,l);
    nodecnt++;
    S[nodecnt].key=key;S[nodecnt].fa=r;S[r].ch[0]=nodecnt;
    Splay(nodecnt,0);return;
}

ull GetHash(int ql,int qr)//得到[ql,qr]段内的hash值
{
    int l=Find(ql),r=Find(qr+2);
    Splay(l,0);Splay(r,l);
    return S[S[r].ch[0]].hash;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>603</wp:post_id>
		<wp:post_date><![CDATA[2018-04-01 22:27:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-01 14:27:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1014-luogu4036jsoi2008%e7%81%ab%e6%98%9f%e4%ba%baprefix%ef%bc%88%e5%ad%97%e7%ac%a6%e4%b8%b2hash%ef%bc%8csplay%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<category domain="category" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[222]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>124</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-03 19:22:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-03 11:22:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[http://blog.sina.com.cn/s/blog_14c9fa95b0102vzuh.html
点开有zsy！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ1042/Luogu1450][HAOI2008]硬币购物（动态规划，容斥原理）</title>
		<link>http://sycstudio.com/archives/605</link>
		<pubDate>Tue, 03 Apr 2018 15:51:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=605</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买s
i的价值的东西。请问每次有多少种付款方法。

<h3>Tag</h3>

动态规划，容斥原理

<h2>解决思路</h2>

考虑当没有硬币的数量限制时怎么做，设&#92;(F[i][j]&#92;)表示前i种硬币凑出j元的方案数，这个可以用类似背包的方式预处理出来。

<pre><code class="language-cpp ">for (int i=0;i&lt;4;i++)//枚举四种硬币
    {
        F[i][0]=0;
        for (int j=1;j&lt;c[i];j++) F[i][j]=F[max(i-1,0)][j];//对于小于面值的，直接转移
        F[i][c[i]]=F[max(i-1,0)][c[i]]+1;
        for (int j=c[i]+1;j&lt;=maxW;j++)
            F[i][j]=F[max(i-1,0)][j]+F[i][max(j-c[i],(ull)0)];
    }
</code></pre>

然后考虑限制了数量怎么做。无非是不限制数量的-强制一种一定超过限制+强制两种一定超过限制-强制三种+强制四种。利用容斥原理求解。

至于如何强制某一种面值为i硬币一定购买c个呢？用总数减去i&#42;c就可以得到了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxW=100000;
const int inf=2147483647;

int n;
ull c[4];
ull d[4];
ull F[4][maxN];

int main()
{
    ios::sync_with_stdio(false);

    cin&gt;&gt;c[0]&gt;&gt;c[1]&gt;&gt;c[2]&gt;&gt;c[3];
    for (int i=0;i&lt;4;i++)//预处理
    {
        F[i][0]=0;
        for (int j=1;j&lt;c[i];j++) F[i][j]=F[max(i-1,0)][j];
        F[i][c[i]]=F[max(i-1,0)][c[i]]+1;
        for (int j=c[i]+1;j&lt;=maxW;j++)
            F[i][j]=F[max(i-1,0)][j]+F[i][max(j-c[i],(ull)0)];
    }
    F[3][0]=1;//注意这里
    int Q;cin&gt;&gt;Q;
    while (Q--)//回答询问
    {
        ull s;
        cin&gt;&gt;d[0]&gt;&gt;d[1]&gt;&gt;d[2]&gt;&gt;d[3]&gt;&gt;s;
        ull Ans=0;
        for (int S=0;S&lt;(1&lt;&lt;4);S++)//容斥原理
        {
            int w=s;int opt=1;
            for (int i=0;i&lt;4;i++) if ((S&amp;(1&lt;&lt;i))!=0) w-=c[i]*(d[i]+1),opt=-opt;
            if (w&lt;0) continue;//当强制购买的超过限额，直接continue，因为此时不合法
            Ans=Ans+opt*F[3][w];
        }
        cout&lt;&lt;Ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>605</wp:post_id>
		<wp:post_date><![CDATA[2018-04-03 23:51:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-03 15:51:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1042-luogu1450haoi2008%e7%a1%ac%e5%b8%81%e8%b4%ad%e7%89%a9%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="post_tag" nicename="%e8%a1%a5%e9%9b%86"><![CDATA[补集]]></category>
		<category domain="category" nicename="%e8%a1%a5%e9%9b%86%e6%80%9d%e6%83%b3"><![CDATA[补集思想]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[156]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4348/SPOJ TTM]To the moon（主席树）</title>
		<link>http://sycstudio.com/archives/608</link>
		<pubDate>Wed, 04 Apr 2018 16:00:58 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=608</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

To The Moon is a independent game released in November 2011, it is a role-playing adventure game powered by RPG Maker.

<img src="\media\SPOJ\SPOJTTM.jpeg" alt="River &amp;&amp; Anya .. ." />

The premise of To The Moon is based around a technology that allows us to permanently reconstruct the memory on dying man. In this problem, we'll give you a chance, to implement the logic behind the scene.
Description

You‘ve been given N integers A[1], A[2],..., A[N]. On these integers, you need to implement the following operations:

<pre><code>C l r d: Adding a constant d for every {Ai | l &lt;= i &lt;= r}, and increase the timestamp by 1, this is the only operation that will cause the timestamp increase. 
Q l r: Querying the current sum of {Ai | l &lt;= i &lt;= r}.
H l r t: Querying a history sum of {Ai | l &lt;= i &lt;= r} in time t.
B t: Back to time t. And once you decide return to a past, you can never be access to a forward edition anymore.
</code></pre>

.. N, M ≤ 10^5, |A[i]| ≤ 10^9, 1 ≤ l ≤ r ≤ N, |d| ≤ 10^4 .. the system start from time 0, and the first modification is in time 1, t ≥ 0, and won't introduce you to a future state.

<h3>Tag</h3>

主席树

<h2>解决思路</h2>

根据题目的要求，分别用主席树维护各个时间戳的数列，当要回溯的时候回到对应的时间。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizoef(Arr))

const int maxN=101000;
const int inf=2147483647;

class SegData
{
public:
    ll sum,lazy;
    int ls,rs;
    void init(){
        sum=lazy=ls=rs=0;return;
    }
};

int n,m,nodecnt;
SegData S[maxN*100];
int root[maxN],Arr[maxN];

void Build(int &amp;now,int l,int r);
void Modify(int &amp;now,int l,int r,int ql,int qr,ll key);
ll Query(int r1,int r2,int l,int r,int ql,int qr);

int main()
{
    ios::sync_with_stdio(false);
    int cas=0;
    while (cin&gt;&gt;n&gt;&gt;m)
    {
        if (cas!=0) cout&lt;&lt;endl;cas++;
        nodecnt=0;root[0]=0;
        for (int i=1;i&lt;=n;i++) cin&gt;&gt;Arr[i];
        Build(root[0],1,n);

        int tim=0;
        while (m--)//处理询问
        {
            char opt;cin&gt;&gt;opt;S[0].init();
            if (opt=='C')
            {
                int l,r,d;cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;//向后加
                tim++;root[tim]=root[tim-1];
                Modify(root[tim],1,n,l,r,d);
            }
            if (opt=='Q')
            {
                int l,r;cin&gt;&gt;l&gt;&gt;r;//前缀查询
                cout&lt;&lt;Query(0,root[tim],1,n,l,r)&lt;&lt;endl;
            }
            if (opt=='H')
            {
                int l,r,t;cin&gt;&gt;l&gt;&gt;r&gt;&gt;t;//历史版本查询
                cout&lt;&lt;Query(0,root[t],1,n,l,r)&lt;&lt;endl;
            }
            if (opt=='B')//回溯
            {
                int t;cin&gt;&gt;t;
                tim=t;
            }
        }
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;S[now].init();
    if (l==r){
        S[now].sum=Arr[l];return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    S[now].sum=S[S[now].ls].sum+S[S[now].rs].sum;
    return;
}

void Modify(int &amp;now,int l,int r,int ql,int qr,ll key)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].sum+=(ll)(qr-ql+1)*(ll)key;
    if ((l==ql)&amp;&amp;(r==qr)){
        S[now].lazy+=(ll)key;return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(S[now].ls,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify(S[now].rs,mid+1,r,ql,qr,key);
    else{
        Modify(S[now].ls,l,mid,ql,mid,key);
        Modify(S[now].rs,mid+1,r,mid+1,qr,key);
    }
    return;
}

ll Query(int r1,int r2,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[r2].sum-S[r1].sum;
    int mid=(l+r)&gt;&gt;1;
    ll sum=(ll)(S[r2].lazy-S[r1].lazy)*(ll)(qr-ql+1);
    if (qr&lt;=mid) return Query(S[r1].ls,S[r2].ls,l,mid,ql,qr)+sum;
    else if (ql&gt;=mid+1) return Query(S[r1].rs,S[r2].rs,mid+1,r,ql,qr)+sum;
    else return Query(S[r1].ls,S[r2].ls,l,mid,ql,mid)+Query(S[r1].rs,S[r2].rs,mid+1,r,mid+1,qr)+sum;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>608</wp:post_id>
		<wp:post_date><![CDATA[2018-04-05 00:00:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-04 16:00:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4348-spoj-ttmto-the-moon%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-04-04]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[205]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3566/Luogu4284][SHOI2014]概率充电器（动态规划）</title>
		<link>http://sycstudio.com/archives/609</link>
		<pubDate>Wed, 04 Apr 2018 16:09:02 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=609</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品——概率充电器:
“采用全新纳米级加工技术,实现元件与导线能否通电完全由真随机数决定!SHOI 概率充电器,您生活不可或缺的必需品!能充上电吗?现在就试试看吧!”
SHOI 概率充电器由 n-1 条导线连通了 n 个充电元件。进行充电时,每条导线是否可以导电以概率决定,每一个充电元件自身是否直接进行充电也由概率决定。
随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。
作为 SHOI 公司的忠实客户,你无法抑制自己购买 SHOI 产品的冲动。在排了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。
你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道,进入充电状态的元件个数的期望是多少呢?

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

经典的树上换根动态规划。
把通电的点的数量期望转化为每一个点通电的概率适合。由于直接考虑通电的情况，需要考虑很多状态，不妨转化为不通电的概率。
那么先求子树的贡献，要么它自己直接没电，否则自己有电的时候，要么连接到儿子的边没有电；若连到儿子的边通电则要求儿子不通电。分别讨论三种情况转移过来。
然后再把父亲的通电情况转移过来，首先去掉自己的贡献，然后还是分边不导电和边导电点不导电来转移。这样得到不导电的概率，用1减去就是导电的概率了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=501000;
const int maxM=maxN*2;
const int inf=2147483647;

int n;
ld Node[maxN];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ld W[maxM];
ld F[maxN];

void Add_Edge(int u,int v,int w);
void dfs1(int u,int fa);
void dfs2(int u,int fa,ld gl);

int main()
{
    ios::sync_with_stdio(false);mem(Head,-1);

    cin&gt;&gt;n;
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        Add_Edge(u,v,w);Add_Edge(v,u,w);
    }
    for (int i=1;i&lt;=n;i++)
    {
        int w;cin&gt;&gt;w;
        Node[i]=(ld)w/(ld)(100);
    }
    dfs1(1,1);//子树内的
    dfs2(1,1,1);//把父亲的导下来
    ld Ans=0;
    for (int i=1;i&lt;=n;i++) Ans=Ans+(1-F[i]);
    printf("%.6LF\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    ld ww=(ld)w/(ld)100;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=ww;
    return;
}

void dfs1(int u,int fa)
{
    F[u]=1-Node[u];//自身不导电
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            dfs1(V[i],u);
            F[u]=F[u]*((1-W[i])+W[i]*F[V[i]]);//边不导电+边导电但点不导电
        }
    return;
}

void dfs2(int u,int fa,ld gl)
{
    F[u]=F[u]*gl;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            ld t=(1-W[i])+W[i]*F[V[i]];//t计算出这个点传递到父亲的答案
            t=F[u]/t;//得到父亲去掉这个点的答案
            dfs2(V[i],u,t+((ld)1-t)*((ld)1-W[i]));//还是分别讨论边不导电和边导电但点不导电两种情况
        }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>609</wp:post_id>
		<wp:post_date><![CDATA[2018-04-05 00:09:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-04 16:09:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3566-luogu4284shoi2014%e6%a6%82%e7%8e%87%e5%85%85%e7%94%b5%e5%99%a8%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[167]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4709][JSOI2011]柠檬 （动态规划，决策单调性，二分）</title>
		<link>http://sycstudio.com/archives/610</link>
		<pubDate>Thu, 05 Apr 2018 16:00:17 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=610</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Flute 很喜欢柠檬。它准备了一串用树枝串起来的贝壳，打算用一种魔法把贝壳变成柠檬。贝壳一共有 N (1 ≤ N ≤ 100,000) 只，按顺序串在树枝上。为了方便，我们从左到右给贝壳编号 1..N。每只贝壳的大小不一定相同，贝壳 i 的大小为 si(1 ≤ si ≤10,000)。变柠檬的魔法要求，Flute 每次从树枝一端取下一小段连续的贝壳，并选择一种贝壳的大小 s0。如果 这一小段贝壳中 大小为 s0 的贝壳有 t 只，那么魔法可以把这一小段贝壳变成 s0t^2 只柠檬。Flute 可以取任意多次贝壳，直到树枝上的贝壳被全部取完。各个小段中，Flute 选择的贝壳大小 s0 可以不同。而最终 Flute 得到的柠檬数，就是所有小段柠檬数的总和。Flute 想知道，它最多能用这一串贝壳
变出多少柠檬。请你帮忙解决这个问题。

<h3>Tag</h3>

动态规划，决策单调性，二分

<h2>解决思路</h2>

首先，我们是可以&#92;(O(n)&#92;)地处理出对于每一个位置上的柠檬，在它之前的与它大小一样的最后的柠檬的位置 ，基于这个，我们便还可以处理出&#92;(S[i]&#92;)表示前i个中与i颜色一样的柠檬的个数。
那么，设F[i]表示前i个柠檬可以得到的最大贝壳数。可以贪心地知道，最后一段中选择的柠檬的大小一定与最后一个的大小相同，因为若不相同，可以把最后一段再分开成其它段，这样答案不会更差，可能会更优。
于是我们可以得到一个这样的转移方程
&#92;[F[i]=max(F[j]+A[i]&#42;(S[i]-S[j]+1)^2)\quad 其中A[i]是i处的大小，j是i前面一个与i同大小的柠檬&#92;]
由于&#92;(S[i]&#92;)都是非负的，所以我们可以发现，当决策点&#92;(j&#92;)不动的时候，随着&#92;(i&#92;)的增大，&#92;((S[i]-S[j]+1)^2&#92;)这个值会增长得越来越快。由于二次函数的性质，S[j]更小的j虽然一开始可能比更大的j劣，但它增长得更快，所以决策点是向左移动的。
所以，我们对每一种大小维护一个单调队列，当队尾的第二个元素的值由于第一个时，就弹出队尾。
但是这样有一个问题，对于&#92;(a &lt; b &lt; c&#92;)，若开始的时候c比b更优，c比a更优，但随着i慢慢向后，a会超过c，b也会超过c；当b超过c的时候，我们会弹出c，但此时a可能已经比b更优了，我们却不知道，此时就会使得答案不是最优解。
怎么办呢？我们知道若a超过i1的时间早于b超过i1的时间，那么对于任何i1 &lt;  i2，a超过i2的时间也是早于b超过i2的，所以对于队尾的元素a，b，设a &lt; b，若a超过b的时间早于b超过当前的i的时间，则说明b是可以弹掉的。
至于怎么求一个函数超过另一个函数的时间呢？二分就好了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxNum=maxN;
const int inf=2147483647;

int n;
int Num[maxN],Last[maxN];
vector&lt;int&gt; Queue[maxNum];
ll F[maxN],S[maxN];

int Beyond(int u,int v);
ll Calc(int p,ll key);

int main()
{
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Num[i];
    for (int i=1;i&lt;=n;i++){
        S[i]=S[Last[Num[i]]]+1;Last[Num[i]]=i;//预处理S数组
    }
    ll Ans=0;
    for (int i=1;i&lt;=n;i++)
    {
        int id=Num[i];
        while ((Queue[id].size()&gt;=2)&amp;&amp;(Beyond(Queue[id][Queue[id].size()-2],Queue[id][Queue[id].size()-1])&lt;=Beyond(Queue[id][Queue[id].size()-1],i))) Queue[id].pop_back();//弹队尾
        Queue[id].push_back(i);
        while ((Queue[id].size()&gt;=2)&amp;&amp;(Beyond(Queue[id][Queue[id].size()-2],Queue[id][Queue[id].size()-1])&lt;=S[i])) Queue[id].pop_back();//取最优解
        F[i]=Calc(Queue[id][Queue[id].size()-1],S[i]-S[Queue[id][Queue[id].size()-1]]+1ll);
        Ans=max(Ans,F[i]);
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

int Beyond(int u,int v)//二分出u超过v的时间
{
    int l=1,r=n;
    int Ret=n+1;
    do
    {
        int mid=(l+r)&gt;&gt;1;
        if (Calc(u,mid-S[u]+1ll)&gt;=Calc(v,mid-S[v]+1ll)) Ret=mid,r=mid-1;
        else l=mid+1;
    }
    while (l&lt;=r);
    return Ret;
}

ll Calc(int p,ll key)
{
    return F[p-1]+(ll)Num[p]*key*key;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>610</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 00:00:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-05 16:00:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4709jsoi2011%e6%9f%a0%e6%aa%ac-%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7"><![CDATA[决策单调性]]></category>
		<category domain="category" nicename="%e5%86%b3%e7%ad%96%e5%8d%95%e8%b0%83%e6%80%a7%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[决策单调性动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[252]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU1109]Run Away（模拟退火，爬山算法）</title>
		<link>http://sycstudio.com/archives/611</link>
		<pubDate>Thu, 05 Apr 2018 16:06:54 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=611</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

One of the traps we will encounter in the Pyramid is located in the Large Room. A lot of small holes are drilled into the floor. They look completely harmless at the first sight. But when activated, they start to throw out very hot java, uh ... pardon, lava. Unfortunately, all known paths to the Center Room (where the Sarcophagus is) contain a trigger that activates the trap. The ACM were not able to avoid that. But they have carefully monitored the positions of all the holes. So it is important to find the place in the Large Room that has the maximal distance from all the holes. This place is the safest in the entire room and the archaeologist has to hide there.

<h3>Tag</h3>

模拟退火，爬山算法

<h2>题目大意</h2>

给出矩形内若干个点，现在要求求出一个点，使得这个点到给出所有点中距离的最小值最大。

<h2>解决思路</h2>

在平面上随机一个/多个点，然后随机向四周走，看是否更优。若更优，则直接走，否则，退火算法是一定概率接受这个不优的解，而爬山是只接受更优的解。

<h2>代码</h2>

下面的代码使用爬山实现（其实似乎是爬山与退火的混合？）

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxM=50;
const ld dt=0.75;
const ld eps=1e-5;
const ld Pi=acos(-1);
const ld INF=1e14;
const int inf=2147483647;

class Pos
{
public:
    ld x,y;
};

int X,Y,N;
Pos Hole[maxN],Ans[maxN];
ld Dis[maxN];

void SA();
ld Rand(ld l,ld r);
ld Dist(Pos A,Pos B);
ld Calc(Pos P);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        scanf("%d%d%d",&amp;X,&amp;Y,&amp;N);
        for (int i=1;i&lt;=N;i++) scanf("%lf%lf",&amp;Hole[i].x,&amp;Hole[i].y);
        SA();
    }
    return 0;
}

ld Rand(ld l,ld r)
{
    ld dou=(ld)rand()/(ld)RAND_MAX;
    return dou*(r-l+1)+l;
}

ld Dist(Pos A,Pos B){
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));
}

ld Calc(Pos P)
{
    ld ret=INF;
    for (int i=1;i&lt;=N;i++) ret=min(ret,Dist(P,Hole[i]));
    return ret;
}

void SA()
{
    ld T=max(X,Y);
    for (int i=1;i&lt;=maxM;i++)//随机多个点，增大正确性
    {
        Ans[i].x=Rand(0.0,X*1.0);
        Ans[i].y=Rand(0.0,Y*1.0);
        Dis[i]=Calc(Ans[i]);
    }
    while (T&gt;eps)
    {
        for (int i=1;i&lt;=maxM;i++)
            for (int t=1;t&lt;=50;t++)//多次行走
            {
                ld theta=Rand(0.0,Pi*2.0);//随机一个角度
                Pos now;
                now.x=Ans[i].x+cos(theta)*T;
                now.y=Ans[i].y+sin(theta)*T;
                //走，然后判断是否更优
                if ((now.x&lt;0)||(now.y&lt;0)||(now.x&gt;X)||(now.y&gt;Y)) continue;
                ld d=Calc(now);
                if (d&gt;=Dis[i])
                {
                    Dis[i]=d;Ans[i]=now;
                }
            }
        T=T*dt;
    }
    int id=1;
    for (int i=2;i&lt;=maxM;i++) if (Dis[i]&gt;Dis[id]) id=i;
    printf("The safest point is (%.1lf, %.1lf).\n",Ans[id].x,Ans[id].y);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>611</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 00:06:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-05 16:06:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu1109run-away%ef%bc%88%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab%ef%bc%8c%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95"><![CDATA[模拟退火/爬山算法]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95"><![CDATA[模拟退火/爬山算法]]></category>
		<category domain="category" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[150]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[TopCoder9915]RedIsGood（动态规划，期望概率）</title>
		<link>http://sycstudio.com/archives/612</link>
		<pubDate>Thu, 05 Apr 2018 16:13:26 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=612</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

You have a deck that contains R red and B black cards.
You are playing the following game: You shuffle the deck, and then begin dealing the cards one by one. For each red card you flip you get a dollar, and for each black card you flip you have to pay a dollar. At any moment (including the beginning of the game) you are allowed to stop and keep the money you have.
Write a method that will take the ints R and B, and return the expected amount you will gain if you play this game optimally.

<h3>Tag</h3>

动态规划，期望概率

<h2>题目大意</h2>

给出n张红牌和m张黑牌。现在把它们随机排列。翻到一张红牌获得1的收益，翻到一张黑牌会有1的损失。求随机情况下的最大收益

<h2>解决思路</h2>

由于是随机的，我们知道的信息只有当前已经翻了多少张红牌，多少张黑牌以及总共的两种颜色分别的牌数。那么，接下来或出现的牌的颜色我们是知道概率的，那么设&#92;(F[i][j]&#92;)表示还剩下i张红牌，j张黑牌，最大期望收益。根据概率有转移方程
&#92;[F[i][j]=max(0,\frac{i}{i+j}&#42;(F[i-1][j]+1)+\frac{j}{i+j}&#42;(F[i][j-1]-1)&#92;]
注意滚动。

<h2>代码</h2>

非滚动版本

<pre><code class="language-cpp "><br />class RedIsGood
{
public:
    double F[maxN][maxN];
    double getProfit(int R, int B){
        F[0][0]=0;
        for (int i=0;i&lt;=R;i++)
            for (int j=0;j&lt;=B;j++)
            {
                if ((i==0)&amp;&amp;(j==0)) continue;
                if (i==0) F[i][j]=0;
                else if (j==0) F[i][j]=F[i-1][j]+1;
                else F[i][j]=max(0.0,(1.0*i/(i+j)*(F[i-1][j]+1)+1.0*j/(i+j)*(F[i][j-1]-1)));
            }
        return F[R][B];
    }
};
</code></pre>

滚动版本

<pre><code class="language-cpp ">class RedIsGood
{
public:
    double F[maxN];
    double getProfit(int R, int B){
        for (int i=0;i&lt;=R;i++) F[i]=i;
        for (int j=1;j&lt;=B;j++)
            for (int i=0;i&lt;=R;i++)
                F[i]=max(0.0,(1.0*i/(i+j)*(F[i-1]+1)+1.0*j/(i+j)*(F[i]-1)));
        return F[R];
    }
};
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>612</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 00:13:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-05 16:13:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[topcoder9915redisgood%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%9c%9f%e6%9c%9b%e6%a6%82%e7%8e%87%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="topcoder"><![CDATA[Topcoder]]></category>
		<category domain="post_tag" nicename="topcoder"><![CDATA[Topcoder]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[229]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2768][JLOI2010]冠军调查/[BZOJ1934/Luogu2057][SHOI2007]Vote 善意的投票（网络流）</title>
		<link>http://sycstudio.com/archives/614</link>
		<pubDate>Fri, 06 Apr 2018 15:39:25 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=614</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一年一度的欧洲足球冠军联赛已经进入了淘汰赛阶段。随着卫冕冠军巴萨罗那的淘汰，英超劲旅切尔西成为了头号热门。新浪体育最近在吉林教育学院进行了一次大规模的调查，调查的内容就是关于切尔西能否在今年问鼎欧洲冠军。新浪体育的记者从各个院系中一共抽取了n位同学作为参与者，大家齐聚一堂，各抒己见。每一位参与者都将发言，阐述自己的看法。参与者的心里都有一个看法，比如FireDancer认为切尔西不可能夺冠，而WaterDancer认为切尔西一定问鼎。但是因为WaterDancer是FireDancer的好朋友，所以可能FireDancer为了迁就自己的好朋友，会在发言中支持切尔西。也就是说每个参与者发言时阐述的看法不一定就是心里所想的。现在告诉你大家心里的想法和参与者的朋友网，希望你能安排每个人的发言内容，使得违心说话的人的总数与发言时立场不同的朋友（对）的总数的和最小。

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

为什么会有两个不同的年份的省选题一模一样？连样例都是一样的？很迷。
考虑把转化成最小割模型，那么，一个人如果违背自己的意愿，相当于是与原来所在的源点/汇点断开，连到另一边；而朋友立场不同，则说明两个人被割开。
那么建图，对每一个人向自己本来的意愿那一边连边，然后对每一对朋友连边，求最小割。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=310;
const int maxM=(maxN*maxN+maxN)*2;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    ios::sync_with_stdio(false);mem(Head,-1);

    cin&gt;&gt;n&gt;&gt;m;S=n+1;T=n+2;
    for (int i=1;i&lt;=n;i++)
    {
        int opt;cin&gt;&gt;opt;
        if (opt==0) Add_Edge(S,i,1);
        else Add_Edge(i,T,1);
    }
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        Add_Edge(u,v,1);Add_Edge(v,u,1);
    }
    int Ans=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans+=di;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (h!=t);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>614</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 23:39:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-06 15:39:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2768jloi2010%e5%86%a0%e5%86%9b%e8%b0%83%e6%9f%a5-bzoj1934-luogu2057shoi2007vote-%e5%96%84%e6%84%8f%e7%9a%84%e6%8a%95%e7%a5%a8%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[159]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3144/Luogu3227][HNOI2013]切糕（网络流）</title>
		<link>http://sycstudio.com/archives/615</link>
		<pubDate>Fri, 06 Apr 2018 15:46:57 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=615</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

经过千辛万苦小 A 得到了一块切糕，切糕的形状是长方体，小 A 打算拦腰将切糕切成两半分给小 B。出于美观考虑，小 A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。

出于简便考虑，我们将切糕视作一个长 P、宽 Q、高 R 的长方体点阵。我们将位于第 z层中第 x 行、第 y 列上(1≤x≤P, 1≤y≤Q, 1≤z≤R)的点称为(x,y,z)，它有一个非负的不和谐值 v(x,y,z)。一个合法的切面满足以下两个条件：

<pre><code>与每个纵轴(一共有 P*Q 个纵轴)有且仅有一个交点。即切面是一个函数 f(x,y)，对于所有 1≤x≤P, 1≤y≤Q,我们需指定一个切割点 f(x,y),且 1≤f(x,y)≤R。

切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的 1≤x,x’≤P 和 1≤y,y’≤Q，若|x-x’|+|y-y’|=1，则|f(x,y)-f(x’,y’)| ≤D，其中 D 是给定的一个非负整数。 可能有许多切面f 满足上面的条件，小A 希望找出总的切割点上的不和谐值最小的那个。
</code></pre>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

转化为最小割，其实就是求一个权值最小的割面。
那么当没有对光滑性的限制的时候，就是求每一条竖线上的最小值，如果连成图论模型就是求每一条链上的最小割。
现在把光滑性的限制加入，即对于相邻的竖列，选择的割点的位置与当前列的差不能超过一个给定的值。
于是对于(u,v,w)的相邻的竖列，我们连边(u',v',w-k)，流量为无限，这样就可以保证当我们选择了w高度时，相邻列中小于w-k的边都是不能被割掉的；两边一起限制，就可以使得题目的要求得以实现。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=41;
const int maxN=maxMap*maxMap*maxMap;
const int maxM=maxN*5*2;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int P,Q,R,S,T,D;
int Mat[maxMap][maxMap][maxMap],Id[maxMap][maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],cur[maxN],Queue[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int fa);

int main()
{
    ios::sync_with_stdio(false);mem(Head,-1);

    cin&gt;&gt;P&gt;&gt;Q&gt;&gt;R&gt;&gt;D;
    for (int k=1;k&lt;=R;k++)
        for (int i=1;i&lt;=P;i++)
            for (int j=1;j&lt;=Q;j++)
                cin&gt;&gt;Mat[i][j][k];

    int idcnt=0;
    for (int i=1;i&lt;=P;i++) for (int j=1;j&lt;=Q;j++) for (int k=1;k&lt;=R;k++) Id[i][j][k]=++idcnt;
    S=++idcnt;T=++idcnt;
    for (int i=1;i&lt;=P;i++) for (int j=1;j&lt;=Q;j++) Add_Edge(S,Id[i][j][1],Mat[i][j][1]);
    for (int k=1;k&lt;R;k++)
        for (int i=1;i&lt;=P;i++)
            for (int j=1;j&lt;=Q;j++)//连限制边
            {
                Add_Edge(Id[i][j][k],Id[i][j][k+1],Mat[i][j][k+1]);
                if (k-D&lt;0) continue;
                if (i!=1) Add_Edge(Id[i][j][k],Id[i-1][j][k-D],inf);
                if (i!=P) Add_Edge(Id[i][j][k],Id[i+1][j][k-D],inf);
                if (j!=1) Add_Edge(Id[i][j][k],Id[i][j-1][k-D],inf);
                if (j!=Q) Add_Edge(Id[i][j][k],Id[i][j+1][k-D],inf);
            }
    for (int i=1;i&lt;=P;i++) for (int j=1;j&lt;=Q;j++) Add_Edge(Id[i][j][R],T,Mat[i][j][R]);
    int Ans=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans+=di;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>615</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 23:46:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-06 15:46:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3144-luogu3227hnoi2013%e5%88%87%e7%b3%95%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[161]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3680/Luogu1337]吊打XXX （模拟退火，爬山算法）</title>
		<link>http://sycstudio.com/archives/616</link>
		<pubDate>Fri, 06 Apr 2018 15:50:54 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=616</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

gty又虐了一场比赛，被虐的蒟蒻们决定吊打gty。gty见大势不好机智的分出了n个分身，但还是被人多势众的蒟蒻抓住了。蒟蒻们将n个gty吊在n根绳子上，每根绳子穿过天台的一个洞。这n根绳子有一个公共的绳结x。吊好gty后蒟蒻们发现由于每个gty重力不同，绳结x在移动。蒟蒻wangxz脑洞大开的决定计算出x最后停留处的坐标，由于他太弱了决定向你求助。不计摩擦，不计能量损失，由于gty足够矮所以不会掉到地上。

<h3>Tag</h3>

模拟退火，爬山算法

<h2>解决思路</h2>

在平面上随机一个点，然后向四周爬山或退火。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10010;
const int maxM=1;
const ld dt=0.9;
const ld Pi=acos(-1);
const ld eps=1e-4;
const ld inf=1e30;
//const int inf=2147483647;

class Pos
{
public:
    ld x,y;
};

int n;
Pos P[maxN];
ld W[maxN];
Pos Ans[maxN];
ld Dis[maxN];
Pos Outp;
ld ww=inf;

ld Make(ld l,ld r);
ld Calc(Pos P);
ld Dist(Pos A,Pos B);

int main()
{
    //srand(170524^141404);
    ios::sync_with_stdio(false);

    cin&gt;&gt;n;
    ld mxx=-inf,mxy=-inf,mnx=inf,mny=inf;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;P[i].x&gt;&gt;P[i].y&gt;&gt;W[i];
    ld x0=0,y0=0;
    for (int i=1;i&lt;=n;i++)
    {
        x0+=P[i].x;y0+=P[i].y;
        mxx=max(mxx,P[i].x);mxy=max(mxy,P[i].y);//得到平面范围，方便随机点
        mnx=min(mnx,P[i].x);mny=min(mny,P[i].y);
    }
    x0=x0/n;y0=y0/n;Calc((Pos){x0,y0});//得到中心，先贪心地选择中心
    ld dx=mxx-mnx,dy=mxy-mny;
    Ans[1].x=x0;Ans[1].y=y0;
    Dis[1]=Calc(Ans[1]);
    for (int i=2;i&lt;=maxM;i++)//随机若干个点
    {
        Ans[i].x=x0+Make(-dx*i/maxM,dx*i/maxM)/100;
        Ans[i].y=y0+Make(-dy*i/maxM,dy*i/maxM)/100;
        Dis[i]=Calc(Ans[i]);
    }
    ld T=1000;
    while (T&gt;eps)//开始爬山/退火
    {
        for (int i=1;i&lt;=maxM;i++)
            for (int tim=1;tim&lt;=20;tim++)
            {
                Pos now;
                now.x=Ans[i].x+T*Make(-1.0,1.0);
                now.y=Ans[i].y+T*Make(-1.0,1.0);
                ld d=Dis[i]-Calc(now);
                if ((d&gt;eps)) Ans[i]=now,Dis[i]=Calc(now);
            }
        T=T*dt;
    }
    int id=1;
    for(int tim=1;tim&lt;=1000;tim++)//由于答案最后会在一段区间内，所以要再随机向四周走一走
    {
        Pos now;
        now.x=Ans[id].x+T*Make(-1.0,1.0);
        now.y=Ans[id].y+T*Make(-1.0,1.0);
        ld d=Calc(now);
        if (d&lt;Dis[id]) Ans[id]=now,Dis[id]=d;
    }
    printf("%.3lf %.3lf\n",Outp.x,Outp.y);
    return 0;
}

ld Make(ld l,ld r)
{
    ld dou=(ld)(rand())/RAND_MAX;
    return dou*(r-l)+l;
}

ld Calc(Pos H)
{
    ld sd=0;
    for (int i=1;i&lt;=n;i++)
    {
        ld d=Dist(H,P[i]);
        sd=sd+W[i]*d;
    }
    if (sd&lt;ww) Outp=H,ww=sd;
    return sd;
}

ld Dist(Pos A,Pos B)
{
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>616</wp:post_id>
		<wp:post_date><![CDATA[2018-04-06 23:50:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-06 15:50:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3680-luogu1337%e5%90%8a%e6%89%93xxx-%ef%bc%88%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab%ef%bc%8c%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95"><![CDATA[模拟退火/爬山算法]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e6%8b%9f%e9%80%80%e7%81%ab-%e7%88%ac%e5%b1%b1%e7%ae%97%e6%b3%95"><![CDATA[模拟退火/爬山算法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[209]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[Codeforces908D]New Year and Arbitrary Arrangement（动态规划）</title>
		<link>http://sycstudio.com/archives/617</link>
		<pubDate>Sat, 07 Apr 2018 13:15:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=617</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

You are given three integers k, pa and pb.

You will construct a sequence with the following algorithm: Initially, start with the empty sequence. Each second, you do the following. With probability pa / (pa + pb), add 'a' to the end of the sequence. Otherwise (with probability pb / (pa + pb)), add 'b' to the end of the sequence.

You stop once there are at least k subsequences that form 'ab'. Determine the expected number of times 'ab' is a subsequence in the resulting sequence. It can be shown that this can be represented by P / Q, where P and Q are coprime integers, and . Print the value of .

<h3>Tag</h3>

动态规划

<h2>题目大意</h2>

随机生成一个只包含a和b的串，a和b分别有不同的生成期望，求当生成至少K个子序列ab时停止，求期望的ab的子序列个数。

<h2>解决思路</h2>

设&#92;(F[i][j]&#92;)表示生成了i个ab的子序列，当前接了j个a时，达到终止状态还要加的个数的期望，那么有转移方程
&#92;[F[i][j]=F[i][j+1]&#42;pa+F[i+j][j]&#42;pb&#92;]
但要注意的是，这个式子的前一项是可以无限展开的，其实际意义就是可以无限地在后面加a而不加b，这样就永远达不到子序列ab出现k次的要求，所以当i+j>=K的时候不能这么转移。
而i+j>=K的时候，只要再加一个b就会停止，我们把式子化出来看看
&#92;[F[i][j]=pb(i+j)+pa&#42;pb(i+j+1)+pa^2&#42;pb(i+j+2)+……&#92;]
&#92;[pa&#42;F[i][j]=pa&#42;pb&#42;(i+j)+pa^2&#42;pb&#42;(i+j+1)+pa^3&#42;pb&#42;(i+j+2)+……&#92;]
&#92;[(1-pa)&#42;S=pb(i+j)+pb(pa+pa^2+pa^3+……)&#92;]
里面是一个等比数列求和的形式，由于有pa &lt; 1，所以运用等比数列求和公式得到
&#92;[(1-pa)F[i][j]=pb(i+j)+pb&#42;\frac{pa}{1-pa}&#92;]
&#92;[(1-pa)F[i][j]=pb(i+j)+pa&#92;]
&#92;[pb&#42;F[i][j]=pb(i+j)+pa&#92;]
&#92;[F[i][j]=i+j+\frac{pa}{pb}&#92;]
所以，当i+j>=K时，运用我们推出的式子直接计算；否则，动态规划计算。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int Mod=1e9+7;
const int inf=2147483647;

ll K,a,b;
ll F[maxN][maxN];

ll QPow(ll x,ll cnt);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;K&gt;&gt;a&gt;&gt;b;
    ll invab=QPow(a+b,Mod-2);
    ll inva=QPow(a,Mod-2),invb=QPow(b,Mod-2);
    for (int i=K;i&gt;=0;i--)
        for (int j=K;j&gt;=0;j--)
            if ((i!=0)||(j!=0))
            {//分情况讨论
                if (i+j&gt;=K) F[i][j]=(ll)(i+j)+(ll)a*invb%Mod;
                else F[i][j]=((ll)a*F[i][j+1]%Mod*invab%Mod+(ll)b*F[i+j][j]%Mod*invab%Mod)%Mod;
            }
    cout&lt;&lt;F[0][1]&lt;&lt;endl;
    return 0;
}

ll QPow(ll x,ll cnt)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>617</wp:post_id>
		<wp:post_date><![CDATA[2018-04-07 21:15:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-07 13:15:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces908dnew-year-and-arbitrary-arrangement%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="post_tag" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[166]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4652]Dice（动态规划，期望概率）</title>
		<link>http://sycstudio.com/archives/618</link>
		<pubDate>Sat, 07 Apr 2018 14:41:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=618</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

You have a dice with m faces, each face contains a distinct number. We assume when we tossing the dice, each face will occur randomly and uniformly. Now you have T query to answer, each query has one of the following form:
0 m n: ask for the expected number of tosses until the last n times results are all same.
1 m n: ask for the expected number of tosses until the last n consecutive results are pairwise different.

<h3>Tag</h3>

动态规划，期望概率

<h2>题目大意</h2>

给出大小为m的字符集，现在等概率地随机生成字符，问：1.当生成的最后n种字符都相同时停止，求期望长度
2.当生成的最后n种字符都互不相同时停止，求期望长度

<h2>解决思路</h2>

先看第一问，可以想到设F[i]表示当前结尾有i个字符相同时，还要生成的字符的期望长度，则有
&#92;[F[i]=\frac{1}{m}F[i+1]+\frac{m-1}{m}f[1]+1&#92;]
意义就是，有&#92;(\frac{1}{m}&#92;)的概率生成的字符与当前最后一个相同，则由F[i+1]转移过来；否则，重新从f[1]开始。
那么，一种办法就是以F[1]为主元，然后依次用含F[1]的式子表示出F[2],F[3],F[4]……，最后由于我们是知道F[n]=0的，所以可以解出F[1]。
另一种办法就是差分，设G[i]为差分数组，G[i]=F[i]-F[i+1]，把F[i]的表达式带入可以得到
&#92;[G[i]=m^i&#92;]
又因为是差分数组，所以F[1]-F[n]=G[n-1]+G[n-2]+G[n-3]+……+G[1]，F[n]=0，所以有
&#92;[F[1]=m+m^2+m^3+m^4+……+m^{n-1}&#92;]
又因为F[0]=F[1]+1，所以
&#92;[F[0]=1+m+m^2+m^3+……+m^{n-1}&#92;]
这是一个等比数列，可以得到
&#92;[F[0]=\frac{m^{n+1}-m}{m-1}&#92;]
所以直接快速幂就好。
然后来看第二问
类似地，设F[i]表示当前结尾有i个字符两两不同时，达到终态的期望长度，则有
&#92;[F[i]=\frac{m-i}{m}F[i+1]+\sum&#95;{k=1}^{i}\frac{1}{m}F[k]&#92;]
意义是，若生成的是与前面i个都不一样的，则由F[i+1]转移过来；否则，生成了一个与前面一样的，由前面每一个转移过来。
同样的，这也可以以F[1]为主元进行加减消元，但复杂了许多。考虑差分。
设&#92;(G[i]=F[i]-F[i+1]&#92;)，把F[i]的式子带入，可以得到
&#92;[G[i]=\frac{m}{m-i-1}G[i+1]&#92;]
由F[0]-F[n]=F[0]-F[1]+F[1]-F[2]+F[2]-F[3]+……+F[n-1]-F[n]=G[0]+G[1]+G[2]+G[3]+……+G[n-1]，有F[n]=0，所以
&#92;[F[0]=G[0]+\frac{m-1}{m}G[0]+\frac{m-1}{m}\frac{m-2}{m}G[0]+…… &#92;&#92; +\frac{m-1}{m}……\frac{m-(n-1)}{m}G[0]&#92;]
&#92;[F[0]=G[0]&#42;(1+\frac{m-1}{m}+\frac{m-1}{m}&#42;\frac{m-2}{m}+……+\frac{m-1}{m}&#42;\frac{m-2}{m}&#42;……\frac{m-(m-1)}{m})&#92;]
这个可以用一个变量维护&#92;(\frac{m-i}{m}&#92;)的乘积，然后O(n)计算。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

ld Calc1(int m,int n);
ld Calc2(int m,int n);

int main()
{
    ios::sync_with_stdio(false);

    int T;
    while (cin&gt;&gt;T)
    {
        while (T--)
        {
            int opt,m,n;cin&gt;&gt;opt&gt;&gt;m&gt;&gt;n;
            if (opt==0) printf("%.9lf\n",Calc1(m,n));
            else printf("%.9lf\n",Calc2(m,n));
        }
    }
    return 0;
}

ld Calc1(int m,int n)
{
    return (pow(m,n)-1.0)/(m-1.0);
}

ld Calc2(int m,int n)
{
    ld ret=1;
    for (int i=n-1;i&gt;=1;i--) ret=1.0*m/(m-i)*ret+1.0;
    return ret;
}   
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>618</wp:post_id>
		<wp:post_date><![CDATA[2018-04-07 22:41:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-07 14:41:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4652dice%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%9c%9f%e6%9c%9b%e6%a6%82%e7%8e%87%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[204]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1492/Luogu4027][NOI2007]货币兑换Cash（动态规划，斜率优化，CDQ分治）</title>
		<link>http://sycstudio.com/archives/619</link>
		<pubDate>Sun, 08 Apr 2018 08:22:04 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=619</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小 Y 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：A 纪念券（以下简称 A 券）和 B 纪念券（以下简称 B 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。
每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 K 天中 A 券和 B 券的价值分别为 AKA_KAK​ 和BKB_KBK​ （元/单位金券）。
为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。
比例交易法分为两个方面：
a) 卖出金券：顾客提供一个[0，100]内的实数 OP 作为卖出比例，其意义为：将 OP%的 A 券和 OP%的 B 券以当时的价值兑换为人民币；
b) 买入金券：顾客支付 IP 元人民币，交易所将会兑换给用户总价值为IP 的金券，并且，满足提供给顾客的 A 券和 B 券的比例在第 K 天恰好为 RateKRate_KRateK​ ；
例如，假定接下来 3 天内的 AkA_kAk​ 、BkB_kBk​ 、RateKRate_KRateK​ 的变化分别为：
时间 AkA_kAk​ BkB_kBk​ RatekRate_kRatek​
第一天 1 1 1
第二天 1 2 2
第三天 2 2 3
假定在第一天时，用户手中有 100 元人民币但是没有任何金券。
用户可以执行以下的操作：
时间 用户操作 人民币(元) A 券的数量 B 券的数量
开户 无 100 0 0
第一天 买入 100 元 0 50 50
第二天 卖出 50% 75 25 25
第二天 买入 60 元 15 55 40
第三天 卖出 100% 205 0 0
注意到，同一天内可以进行多次操作。
小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 N 天内的 A 券和 B 券的价值以及 Rate。他还希望能够计算出来，如果开始时拥有 S 元钱，那么 N 天后最多能够获得多少元钱。

<h3>Tag</h3>

动态规划，斜率优化，CDQ分治

<h2>解决思路</h2>

题目里面明确提示了必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币；每次卖出操作卖出所有的金券。
所以不妨设F[i]表示前i天的最大收益（RMB），那么F[i]可以由之前的某一天j的钱全部换成金券再在这一天换回来。再设X[i]表示第i天的钱全部换成A券的数量和Y[i]表示第i天的钱全部换成B券的数量。
&#92;[F[i]=X[i]&#42;A[i]+Y[i]&#42;B[i]&#92;]
又因为&#92;(\frac{X[i]}{Y[i]}=Rate[i]&#92;)，带入解得
&#92;[X[i]=\frac{R[i]&#42;F[i]}{A[i]&#42;R[i]+B[i]} \quad Y[i]=\frac{F[i]}{A[i]&#42;R[i]+B[i]}&#92;]
所以转移方程为
&#92;[F[i]=A[i]&#42;X[j]+B[i]&#42;Y[j]&#92;]
化成斜率形式
&#92;[Y[j]=-\frac{A[i]}{B[i]}&#42;X[j]+\frac{F[i]}{B[i]}&#92;]
由于要最大化截距，所以维护一个凸包。但是，这里不论是斜率还是x都不是递增的，那么有两种维护方式，一种就是splay维护，另一种是CDQ分治。这里使用CDQ分治的方法。
即，每一次分治左右半边，先求左边的答案，然后让左边按照x有序，右边按照斜率k有序。当然大前提一定是在要保证左边的id小于右边的id，这样才能用左边更新右边。那么维护一个左边的凸包，来利用斜率优化更新右边，用一个单调队列就好了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const ld eps=1e-9;
const ld inf=1e9;

class Data
{
public:
    ld a,b,r,k;
    int id;
};

class Pos
{
public:
    ld x,y;
};

int n;
ld F[maxN];
Data Query[maxN],Q2[maxN];
Pos P[maxN],P2[maxN];
int Stack[maxN];

bool operator &lt; (Pos A,Pos B);
bool operator &lt; (Data A,Data B);
void Divide(int l,int r);
ld Slope(int u,int v);

int main()
{
    int S;
    scanf("%d%d",&amp;n,&amp;S);
    F[0]=S;
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%LF%LF%LF",&amp;Query[i].a,&amp;Query[i].b,&amp;Query[i].r);
        Query[i].k=-Query[i].a/Query[i].b;Query[i].id=i;
    }
    sort(&amp;Query[1],&amp;Query[n+1]);//将点按照斜率排序
    Divide(1,n);
    printf("%.3LF\n",F[n]);
    return 0;
}

bool operator &lt; (Pos A,Pos B){
    if (fabs(A.x-B.x)&lt;=eps) return A.y&lt;B.y+eps;
    else return A.x&lt;B.x+eps;
}

bool operator &lt; (Data A,Data B){
    return A.k&lt;B.k;
}

void Divide(int l,int r)
{
    if (l==r)
    {
        F[l]=max(F[l],F[l-1]);//可能上一个的更优
        P[l].y=F[l]/(Query[l].r*Query[l].a+Query[l].b);//得到(x,y)
        P[l].x=P[l].y*Query[l].r;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    int p1=l,p2=mid+1;//按照id排序，即原序列中的顺序，注意因为我们在外面已经按照斜率排序了，所以可以保证左边和右边分别斜率递增
    for (int i=l;i&lt;=r;i++)
        if (Query[i].id&lt;=mid) Q2[p1++]=Query[i];
        else Q2[p2++]=Query[i];
    for (int i=l;i&lt;=r;i++) Query[i]=Q2[i];
    //递归处理左半边
    Divide(l,mid);

    int top=0;
    for (int i=l;i&lt;=mid;i++)//构建左边的凸包
    {
        while ((top&gt;=2)&amp;&amp;(Slope(Stack[top],Stack[top-1])&lt;Slope(i,Stack[top])+eps)) top--;
        Stack[++top]=i;
    }

    for (int i=r,j=1;i&gt;=mid+1;i--)//用左边的答案更新右边，由于已经保证右边斜率递增，所以可以直接用一个单调指针，不需要二分了
    {
        while ((j&lt;top)&amp;&amp;(Query[i].k&lt;Slope(Stack[j],Stack[j+1])+eps)) j++;
        F[Query[i].id]=max(F[Query[i].id],P[Stack[j]].x*Query[i].a+P[Stack[j]].y*Query[i].b);
    }
    //递归处理右半边
    Divide(mid+1,r);
    p1=l;p2=mid+1;//由于返回要求按照x排序，所以这里按照x排序
    for (int i=l;i&lt;=r;i++)
        if ((p1&lt;=mid)&amp;&amp;((p2&gt;r)||(P[p1]&lt;P[p2]))) P2[i]=P[p1++];
        else P2[i]=P[p2++];
    for (int i=l;i&lt;=r;i++) P[i]=P2[i];
    return;
}

ld Slope(int u,int v)
{
    if (u==0) return -inf;
    if (v==0) return inf;
    if (fabs(P[u].x-P[v].x)&lt;=eps) return -inf;
    return (P[u].y-P[v].y)/(P[u].x-P[v].x);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>619</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 16:22:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 08:22:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1492-luogu4027noi2007%e8%b4%a7%e5%b8%81%e5%85%91%e6%8d%a2cash%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%8ccdq%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[157]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3156]防御准备（动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/621</link>
		<pubDate>Sun, 08 Apr 2018 08:47:30 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=621</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/bzojch/file/3156_0.jpg" alt="BZOJ3156" />

<h3>Tag</h3>

动态规划，斜率优化

<h2>解决思路</h2>

设F[i]表示前i个检查点并且强制在i这里设置一个检查点的最小花费，那么有
&#92;[F[i]=min(F[j]+(i-j)&#42;(i-j-1)/2)+Cost[i]&#92;]
里面是一个可以斜率优化的式子，化成斜率形式
&#92;[F[j]+\frac{1}{2}j^2+\frac{1}{2}j=ij-Cost[i]+F[i]+\frac{1}{2}i-\frac{1}{2}i^2&#92;]
那么现在的任务就是要最小化截距，由于斜率和i都是递增的，所以维护一个下凸壳，用单调队列维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1000100;
const ld eps=1e-5;
const int inf=2147483647;

int n;
ll Arr[maxN];
ll Queue[maxN];
ll F[maxN];

ld Slope(int i,int j);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Arr[i];
    int l=1,r=1;
    Queue[1]=0;
    for (int i=1;i&lt;=n;i++)
    {
        while ((l&lt;r)&amp;&amp;(Slope(Queue[l],Queue[l+1])&lt;2.0*i+eps)) l++;
        F[i]=Arr[i]+F[Queue[l]]+(i-Queue[l]-1)*(i-Queue[l])/2;
        while ((l&lt;r)&amp;&amp;(Slope(Queue[r-1],Queue[r])+eps&gt;Slope(Queue[r],i))) r--;
        Queue[++r]=i;
    }
    cout&lt;&lt;F[n]&lt;&lt;endl;
    return 0;
}

ld Slope(int i,int j)
{
    return (ld)((2.0*F[i]+1.0*i*i+1.0*i)-(2.0*F[j]+1.0*j*j+1.0*j))/(ld)(1.0*i-1.0*j);
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>621</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 16:47:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 08:47:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3156%e9%98%b2%e5%be%a1%e5%87%86%e5%a4%87%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[183]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3295/Luogu3157][CQOI2011]动态逆序对（CDQ分治）</title>
		<link>http://sycstudio.com/archives/622</link>
		<pubDate>Sun, 08 Apr 2018 09:01:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=622</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

对于序列A，它的逆序对数定义为满足i&lt; j，且Ai>Aj的数对(i,j)的个数。给1到n的一个排列，按照某种顺序依次删除m个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。

<h3>Tag</h3>

CDQ分治

<h2>解决思路</h2>

给每一个数赋上一个时间戳Tim[i]，第一个删除的数时间戳最大，然后依次递减，这样转化为一个偏序问题。
删除一个数i，减去的逆序对个数有两种，一种是对于j&lt; i且A[i]&lt; A[j]并且Tim[j]&lt; Tim[i]，另一种是对于j>i，A[i] >A[j]并且Tim[j]&lt; Tim[i]，这个可以用CDQ分治解决。
在外面对tim排序，然后分治，保证左边的tim一定小于右边。先递归左右两边，回来后保证左右分别按照在原数列中的位置（下面称作编号）排序。然后对右边的每一个数计算两次，第一次计算左边的编号小于它而值大于它的，第二次计算左边编号大于它而值小于它的，这个可以分别用树状数组做。
最后返回上一层的时候，把左右区间按照编号归并排序

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lowbit(x) ((x)&amp;(-(x)))

const int maxN=101000;
const int inf=2147483647;

class Data
{
public:
    ll tim,id,key;
    ll ans;
};

int n,m;
int Pos[maxN];
Data Q[maxN],Q2[maxN];
ll BIT[maxN],histcnt=0,Hist[maxN];
ll Ans[maxN];

bool operator &lt; (Data A,Data B);
void Add(int pos,ll key);
ll Sum(int pos);
ll Query(int l,int r);
void Divide(int l,int r);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;Q[i].key;Pos[Q[i].key]=i;
        Q[i].id=i;Q[i].tim=0;
    }
    int cnt=n;
    for (int i=m;i&gt;=1;i--)
    {
        int pos;cin&gt;&gt;pos;pos=Pos[pos];
        Q[pos].tim=cnt--;
    }
    for (int i=1;i&lt;=n;i++) if (Q[i].tim==0) Q[i].tim=cnt--;
    sort(&amp;Q[1],&amp;Q[n+1]);
    Divide(1,n);
    for (int i=1;i&lt;=n;i++) Ans[Q[i].tim]=Q[i].ans;
    for (int i=1;i&lt;=n;i++) Ans[i]+=Ans[i-1];
    for (int i=1,j=n;i&lt;=m;i++,j--) cout&lt;&lt;Ans[j]&lt;&lt;endl;
    return 0;
}

bool operator &lt; (Data A,Data B)
{
    if (A.tim!=B.tim) return A.tim&lt;B.tim;
    return A.id&lt;B.id;
}

void Add(int pos,ll key)
{
    while (pos&lt;=n)
    {
        if (Hist[pos]!=histcnt) BIT[pos]=key,Hist[pos]=histcnt;
        else BIT[pos]+=key;
        pos+=lowbit(pos);
    }
    return;
}

ll Sum(int pos)
{
    int ret=0;
    while (pos)
    {
        if (Hist[pos]==histcnt) ret+=BIT[pos];
        pos-=lowbit(pos);
    }
    return ret;
}

ll Query(int l,int r)
{
    if (l&gt;r) return 0;
    return Sum(r)-Sum(l-1);
}

void Divide(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Divide(l,mid);Divide(mid+1,r);//递归处理左右区间
    int p1=l,p2=mid+1;
    histcnt++;
    for (int i=l;i&lt;=r;i++)//先算左边编号小于而值大于的
        if ((p1&lt;=mid)&amp;&amp;((p2&gt;r)||(Q[p1].id&lt;Q[p2].id))){
            Add(Q[p1].key,1);p1++;
        }
        else{
            Q[p2].ans+=Query(Q[p2].key,n);p2++;
        }
    p1=mid,p2=r;histcnt++;
    for (int i=r;i&gt;=l;i--)//再算左边编号大于而值小于的
        if ((p1&gt;=l)&amp;&amp;((p2&lt;mid+1)||(Q[p1].id&gt;Q[p2].id))){
            Add(Q[p1].key,1);p1--;
        }
        else {
            Q[p2].ans+=Query(1,Q[p2].key);p2--;
        }

    p1=l;p2=mid+1;
    for (int i=l;i&lt;=r;i++)
        if ((p1&lt;=mid)&amp;&amp;((p2&gt;r)||(Q[p1].id&lt;Q[p2].id))) Q2[i]=Q[p1++];
        else Q2[i]=Q[p2++];
    for (int i=l;i&lt;=r;i++) Q[i]=Q2[i];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>622</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:01:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:01:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3295-luogu3157cqoi2011%e5%8a%a8%e6%80%81%e9%80%86%e5%ba%8f%e5%af%b9%ef%bc%88cdq%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[161]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4887/Luogu3758][TJOI2017]可乐（动态规划，矩阵快速幂）</title>
		<link>http://sycstudio.com/archives/623</link>
		<pubDate>Sun, 08 Apr 2018 09:08:20 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=623</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的1号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现 在给加里敦星球城市图，在第0秒时可乐机器人在1号城市，问经过了t秒，可乐机器人的行为方案数是多少？

<h3>Tag</h3>

动态规划，矩阵快速幂

<h2>解决思路</h2>

每一次走都是一个类似计数动态规划的过程。发现每一次的转移其实是一样的，所以可以用矩阵快速幂优化转移。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=32;
const int Mod=2017;
const int inf=2147483647;

int n,m;
int Ans[maxN][maxN],Mat[maxN][maxN];
int Backup[maxN][maxN];

void Mul1();
void Mul2();

int main()
{
    ios::sync_with_stdio(false);

    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;//构建转移矩阵
        Mat[u][v]=Mat[v][u]=1;
    }
    for (int i=0;i&lt;=n;i++) Mat[i][i]=Mat[i][0]=1;
    Ans[0][1]=1;//答案矩阵
    int T;cin&gt;&gt;T;
    while (T)//矩阵快速幂
    {
        if (T&amp;1) Mul1();
        Mul2();
        T=T&gt;&gt;1;
    }
    ll sum=0;
    for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) sum=(sum+Ans[i][j])%Mod;
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}

void Mul1()
{
    for (int i=0;i&lt;=n;i++) Backup[0][i]=Ans[0][i],Ans[0][i]=0;
    for (int i=0;i&lt;=0;i++)
        for (int j=0;j&lt;=n;j++)
            for (int k=0;k&lt;=n;k++)
                Ans[i][j]=(Ans[i][j]+Backup[i][k]*Mat[k][j]%Mod)%Mod;
    return;
}

void Mul2()
{
    for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) Backup[i][j]=Mat[i][j],Mat[i][j]=0;
    for (int i=0;i&lt;=n;i++)
        for (int j=0;j&lt;=n;j++)
            for (int k=0;k&lt;=n;k++)
                Mat[i][j]=(Mat[i][j]+Backup[i][k]*Backup[k][j]%Mod)%Mod;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>623</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:08:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:08:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4887-luogu3758tjoi2017%e5%8f%af%e4%b9%90%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[189]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1017/Luogu4037][JSOI2008]魔兽地图DotR（动态规划）</title>
		<link>http://sycstudio.com/archives/624</link>
		<pubDate>Sun, 08 Apr 2018 09:27:14 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=624</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

DotR (Defense of the Robots) Allstars是一个风靡全球的魔兽地图，他的规则简单与同样流行的地图DotA(Defense of the Ancients) Allstars。DotR里面的英雄只有一个属性——力量。他们需要购买装备来提升自己的力量值，每件装备都可以使佩戴它的英雄的力量值提高固定的点数，所以英雄的力量值等于它购买的所有装备的力量值之和。装备分为基本装备和高级装备两种。基本装备可以直接从商店里面用金币购买，而高级装备需要用基本装备或者较低级的高级装备来合成，合成不需要附加的金币。装备的合成路线可以用一棵树来表示。比如，Sangeand Yasha的合成需要Sange,Yasha和Sange and Yasha Recipe Scroll三样物品。其中Sange又要用Ogre Axe, Belt of Giant Strength和 Sange Recipe Scroll合成。每件基本装备都有数量限制，这限制了你不能无限制地合成某些性价比很高的装备。现在，英雄Spectre有M个金币，他想用这些钱购买装备使自己的力量值尽量高。你能帮帮他吗？他会教你魔法Haunt（幽灵附体）作为回报的。

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

这题麻烦的地方就在于，当一个物品被用来合成更高级的物品时，它原来的力量值不能算进去，而往高级合成，虽然我们知道它的合成上限，但不能保证基础物品的数量不超过限制，所以与常规的树型动态规划有些不同，在计算一个点的值时不能只考虑它和它的子树，还要考虑到它的父亲。
首先，由儿子转移过来的信息，可以得到每一个物品实际上需要多少钱，实际上最多能合成多少。然后设F[i][j][k]表示i这个物品，把j个i物品用于上面的合成，总共花费k元的最大力量值。当然首先还是递归处理出儿子的信息，然后返回来枚举这一次总共合成多少个i，然后再枚举从儿子出应该转移过来多少个，花多少钱，最后再枚举这生成的这么多个留多少个给自己，多少个传递给上一层。有些复杂。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=60;
const int maxM=maxN*maxN*4;
const int maxW=2010;
const int maxL=201;
const int inf=47483647;

class Edge
{
public:
    int v,cnt;
};

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],Degree[maxN];
Edge E[maxM];
int Limit[maxN],Cost[maxN],W[maxN];
bool Leaf[maxN];
int F[maxN][maxL][maxW];
int G[maxN][maxW],H[maxN][maxW];

void Add_Edge(int u,int v,int cnt);
void dfs(int u);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);mem(F,-0x3f3f3f3f);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++)
    {
        char opt;cin&gt;&gt;W[i]&gt;&gt;opt;
        if (opt=='A')
        {
            int C;cin&gt;&gt;C;
            while (C--)
            {
                int v,cnt;cin&gt;&gt;v&gt;&gt;cnt;
                Add_Edge(i,v,cnt);
                Leaf[i]=0;
            }
        }
        if (opt=='B')
        {
            cin&gt;&gt;Cost[i]&gt;&gt;Limit[i];
            Limit[i]=min(Limit[i],m/Cost[i]);
            Leaf[i]=1;
        }
    }
    int tot=0;
    for (int node=1;node&lt;=n;node++)
        if (Degree[node]==0)
        {
            dfs(node);
            tot++;
            for (int i=0;i&lt;=m;i++)//枚举花多少钱
                for (int j=0;j&lt;=i;j++)//枚举这i元钱中有多少从上一次转移过来
                    for (int k=0;k&lt;=Limit[node];k++)//枚举这一次node号选择合成多少个
                        H[tot][i]=max(H[tot][i],H[tot-1][j]+F[node][k][i-j]);
        }
    int Ans=0;
    for (int i=0;i&lt;=m;i++) Ans=max(Ans,H[tot][i]);
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v,int cnt)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].cnt=cnt;
    Degree[v]++;
    return;
}

void dfs(int u)
{
    if (Leaf[u]==1)//叶子节点
    {
        for (int i=0;i&lt;=Limit[u];i++)//枚向上贡献多少个
            for (int j=i;j&lt;=Limit[u];j++)//枚举总共多少个，那么j-i就是自己保留的个数
                F[u][i][j*Cost[u]]=W[u]*(j-i);
        return;
    }
    Limit[u]=inf;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        dfs(E[i].v);
        Cost[u]+=Cost[E[i].v]*E[i].cnt;
        Limit[u]=min(Limit[u],Limit[E[i].v]/E[i].cnt);
    }
    Limit[u]=min(Limit[u],m/Cost[u]);
    mem(G,-0x3f3f3f3f);
    G[0][0]=0;//G[i][j]表示前i棵子树中，花费j元的最大力量值
    for (int l=Limit[u];l&gt;=0;l--)//枚举合成多少个物品i
    {
        int tot=0;
        for (int e=Head[u];e!=-1;e=Next[e])
        {
            tot++;
            for (int i=0;i&lt;=m;i++)//枚举这一次总共花多少钱
                for (int j=0;j&lt;=i;j++)//枚举从这一棵子树转移过来多少钱，那么i-j就是从前面的子树转移过来的
                    G[tot][i]=max(G[tot][i],G[tot-1][i-j]+F[E[e].v][l*E[e].cnt][j]);
        }
        for (int i=0;i&lt;=l;i++)//枚举这一次合成的l个物品i中，有多少个要用于上面的合成
            for (int j=0;j&lt;=m;j++)
                F[u][i][j]=max(F[u][i][j],G[tot][j]+(l-i)*W[u]);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>624</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:27:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:27:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1017-luogu4037jsoi2008%e9%ad%94%e5%85%bd%e5%9c%b0%e5%9b%bedotr%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[191]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1040/Luogu2607][ZJOI2008]骑士（基环树动态规划）</title>
		<link>http://sycstudio.com/archives/625</link>
		<pubDate>Sun, 08 Apr 2018 09:33:59 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=625</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Z国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。最近发生了一件可怕的事情，邪恶的Y国发动了一场针对Z国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的Z国又怎能抵挡的住Y国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。为了描述战斗力，我们将骑士按照1至N编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。

<h3>Tag</h3>

基环树动态规划

<h2>解决思路</h2>

观察题目给出的性质，一个人只会有一个最讨厌的人，那么这张图最多只会有n条边，也就是说，是一棵树加上一条边（当然也有可能直接就是树）。由于图可能是不连通的，所以我们对每一个联通快单独考虑。
如果只考虑树的话，设F[i][0/1]表示i这个点，[0]选[1]不选时的最大和，分别从儿子转移过来就好。但是由于是基环树，不能直接树型DP。
怎么办呢？把环上任意一条边去掉就变成一棵树了，然后我们强制让去掉的边的两个端点状态不一样，分两次讨论即可得到基环树的解。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int maxM=maxN*2;
const int inf=2147483647;

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxN];
ll F[2][maxN];
int vis[maxN];
int node1,node2;
ll Ans=0;

void Add_Edge(int u,int v);
void Do(int u);
void dfs_find(int u,int fa);
void dfs(int u,int fa);

int main()
{
    ios::sync_with_stdio(false);mem(Head,-1);

    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++)
    {
        int v;cin&gt;&gt;W[i]&gt;&gt;v;
        Add_Edge(i,v);Add_Edge(v,i);
    }
    for (int i=1;i&lt;=n;i++)
        if (vis[i]==0) Do(i);
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v)
{
    for (int i=Head[u];i!=-1;i=Next[i]) if (V[i]==v) return;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void Do(int u)
{
    node1=node2=0;
    dfs_find(u,u);//找到环
    if (node1==0)//当不是环的时候，直接做树型DP
    {
        dfs(u,u);
        Ans+=max(F[0][u],F[1][u]);
        return;
    }
    dfs(node1,node1);//否则，强制一个选另一个不选
    ll mx=max(F[0][node1],F[1][node1]);
    swap(node1,node2);//交换两个点，再做一遍
    dfs(node1,node1);
    mx=max(mx,max(F[0][node1],F[1][node1]));
    Ans+=mx;
    return;
}

void dfs_find(int u,int fa)
{
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            //cout&lt;&lt;u&lt;&lt;"-&gt;"&lt;&lt;V[i]&lt;&lt;endl;
            if (vis[V[i]]==1) node1=u,node2=V[i];
            else dfs_find(V[i],u);
        }
    return;
}

void dfs(int u,int fa)
{
    F[0][u]=0;F[1][u]=W[u];
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            if ((u==node1)&amp;&amp;(V[i]==node2)) continue;
            if ((u==node2)&amp;&amp;(V[i]==node1)) continue;
            dfs(V[i],u);
            F[0][u]+=max(F[0][V[i]],F[1][V[i]]);
            F[1][u]+=F[0][V[i]];
        }
    if (u==node2) F[1][u]=0;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>625</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:33:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:33:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1040-luogu2607zjoi2008%e9%aa%91%e5%a3%ab%ef%bc%88%e5%9f%ba%e7%8e%af%e6%a0%91%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%9f%ba%e7%8e%af%e6%a0%91%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[基环树动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[234]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1207/Luogu2285][HNOI2004]打鼹鼠（动态规划）</title>
		<link>http://sycstudio.com/archives/626</link>
		<pubDate>Sun, 08 Apr 2018 09:36:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=626</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿Q编写了一个打鼹鼠的游戏：在一个n<em>n的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果i时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为（i,j）的网格移向(i-1, j),(i+1, j),(i,j-1),(i,j+1)四个网格，机器人不能走出整个n</em>n的网格。游戏开始时，你可以自由选定机器人的初始位置。现在你知道在一段时间内，鼹鼠出现的时间和地点，希望你编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

别想复杂了，这题的复杂度是&#92;(O(m^2)&#92;)。
设F[i]表示到第i只鼹鼠时，一定打死第i只的最大个数，那么枚举前面所有鼹鼠，从合法的地方转移过来，取最大值。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

const int maxN=10100;
const int inf=2147483647;

int n,m;
int Tim[maxN],X[maxN],Y[maxN];
int F[maxN];

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    RG int Ans=0;
    for (RG int i=1;i&lt;=m;++i)
    {
        F[i]=1;cin&gt;&gt;Tim[i]&gt;&gt;X[i]&gt;&gt;Y[i];
        for (RG int j=1;j&lt;i;++j)
            if (abs(X[i]-X[j])+abs(Y[i]-Y[j])&lt;=Tim[i]-Tim[j]) F[i]=max(F[i],F[j]+1);
        Ans=max(Ans,F[i]);
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>626</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:36:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:36:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1207-luogu2285hnoi2004%e6%89%93%e9%bc%b9%e9%bc%a0%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[184]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3672/Luogu2305][NOI2014]购票（点分治，动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/627</link>
		<pubDate>Sun, 08 Apr 2018 09:52:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=627</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

今年夏天，NOI在SZ市迎来了她30周岁的生日。来自全国 n 个城市的OIer们都会从各地出发，到SZ市参加这次盛会。
全国的城市构成了一棵以SZ市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的 n 个城市用 1 到 n 的整数编号。其中SZ市的编号为 1。对于除SZ市之外的任意一个城市 v，我们给出了它在这棵树上的父亲城市 fv  以及到父亲城市道路的长度 sv。
从城市 v 前往SZ市的方法为：选择城市 v 的一个祖先 a，支付购票的费用，乘坐交通工具到达 a。再选择城市 a 的一个祖先 b，支付费用并到达 b。以此类推，直至到达SZ市。
对于任意一个城市 v，我们会给出一个交通工具的距离限制 lv。对于城市 v 的祖先 a，只有当它们之间所有道路的总长度不超过 lv  时，从城市 v 才可以通过一次购票到达城市 a，否则不能通过一次购票到达。对于每个城市 v，我们还会给出两个非负整数 pv,qv  作为票价参数。若城市 v 到城市 a 所有道路的总长度为 d，那么从城市 v 到城市 a 购买的票价为 dpv+qv。
每个城市的OIer都希望自己到达SZ市时，用于购票的总资金最少。你的任务就是，告诉每个城市的OIer他们所花的最少资金是多少。

<h3>Tag</h3>

点分治，动态规划，斜率优化

<h2>解决思路</h2>

设F[i]表示i这一点到达根的最优值，那么对于每一个合法的j有，其中Depth[i]表示i这一点到根的距离
&#92;[F[i]=min(F[j]+(Depth[i]-Depth[j])&#42;P[i]+Q[i])&#92;]
但关键就是这个<strong>合法的j</strong>不好确定。就算没有距离的限制，要想在树上动态维护一个凸包？可持久化凸包？再加上个距离的限制，完全不能解。
考虑另一种方法。假设对于一个点i，我们已经能够确定i以及i到根路径上所有的点的答案，那么如何用这些答案取更新i的子树内的点的答案呢？
考虑把i子树内的点按照它的深度-距离限制排序，这样就可以得到一个单调的序列。同时，我们从i开始跳i的父亲，每一次把符合当前限制的点加入凸包，这样我们就可以用i到根路径上的点的权值来更新i子树内的点了。
那么，如何选择这个点i呢？为了保证复杂度，可以用点分治来解决。每一次点分治重心，先递归处理重心到当前真正的根，得到这一条路径上的答案，这样才能用来更新重心的子树。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int maxM=maxN*2;
const int inf=2147483647;

class Data
{
public:
    ll p,q,l;
};

class Edge
{
public:
    int v;ll w;
};

int n;
int edgecnt=0,Head[maxN],Next[maxM];
Edge E[maxM];
int nowsum,root,Size[maxN],mxSon[maxN],Fa[maxN];
ll F[maxN],Dist[maxN];
int qh,Queue[maxN],Stack[maxN];
Data P[maxN];
bool vis[maxN];

void Add_Edge(int u,int v,int w);
void dfs_init(int u,int fa);
void GetRoot(int u,int fa);
void Divide(int u);
bool cmp(int u,int v);
void dfs(int u,int fa);
ld Slope(int u,int v);

int main()
{
    ios::sync_with_stdio(false);mem(Head,-1);mem(F,63);

    cin&gt;&gt;n;int opt;cin&gt;&gt;opt;
    for (int i=2;i&lt;=n;i++)
    {
        ll fa,dis;cin&gt;&gt;fa&gt;&gt;dis&gt;&gt;P[i].p&gt;&gt;P[i].q&gt;&gt;P[i].l;
        Add_Edge(i,fa,dis);Add_Edge(fa,i,dis);
    }
    Dist[1]=0;F[1]=0;
    dfs_init(1,1);
    nowsum=n;root=0;mxSon[0]=inf;
    Divide(1);

    for (int i=2;i&lt;=n;i++) cout&lt;&lt;F[i]&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].w=w;
    return;
}

void dfs_init(int u,int fa)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (E[i].v!=fa)
        {
            Fa[E[i].v]=u;Dist[E[i].v]=Dist[u]+E[i].w;
            dfs_init(E[i].v,u);
            Size[u]+=Size[E[i].v];
        }
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((E[i].v!=fa)&amp;&amp;(vis[E[i].v]==0))
        {
            GetRoot(E[i].v,u);
            Size[u]+=Size[E[i].v];
            mxSon[u]=max(mxSon[u],Size[E[i].v]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Divide(int u)//点分治
{
    if (nowsum&lt;=1) return;
    root=0;GetRoot(u,u);int nowroot=root;//得到当前分治区域的重心

    nowsum=Size[u]-Size[root];vis[root]=1;
    Divide(u);//先分治当前根到重心这一区域

    for (int i=nowroot;i!=Fa[u];i=Fa[i])
        if (P[nowroot].l&gt;=Dist[nowroot]-Dist[i])//用u到重心路径上的答案来更新重心的答案
        {
            F[nowroot]=min(F[nowroot],F[i]+(Dist[nowroot]-Dist[i])*P[nowroot].p+P[nowroot].q);
        }

    qh=0;
    for (int i=Head[nowroot];i!=-1;i=Next[i])//得到当前区域内除原根所在区域的所有点
        if ((vis[E[i].v]==0)&amp;&amp;(E[i].v!=Fa[nowroot])) dfs(E[i].v,nowroot);
    sort(&amp;Queue[1],&amp;Queue[qh+1],cmp);//按照深度-限制进行排序

    int stacktop=0;
    for (int i=1,j=nowroot;i&lt;=qh;i++)
    {
        while ((j!=Fa[u])&amp;&amp;(Dist[j]&gt;=Dist[Queue[i]]-P[Queue[i]].l))//将符合条件的根到重心路径上的点加入凸包
        {
            while ((stacktop&gt;=2)&amp;&amp;(Slope(Stack[stacktop],Stack[stacktop-1])&lt;=Slope(Stack[stacktop],j))) stacktop--;
            Stack[++stacktop]=j;
            j=Fa[j];
        }
        if (stacktop==1)//特判凸包内只有一个点的情况
        {
            if (Dist[Stack[stacktop]]&gt;=Dist[Queue[i]]-P[Queue[i]].l)
                F[Queue[i]]=min(F[Queue[i]],F[Stack[stacktop]]+(Dist[Queue[i]]-Dist[Stack[stacktop]])*P[Queue[i]].p+P[Queue[i]].q);
        }
        else
        {
            int fd=1,l=1,r=stacktop;
            do//二分最优斜率的位置
            {
                int mid=(l+r)&gt;&gt;1;
                if (Slope(Stack[mid],Stack[mid+1])&gt;=P[Queue[i]].p) fd=mid+1,l=mid+1;
                else r=mid-1;
            }
            while (l&lt;=r);
            fd=min(fd,stacktop);//由于若二分到结尾，会多一，所以要与栈顶取min
            if (Dist[Stack[fd]]&gt;=Dist[Queue[i]]-P[Queue[i]].l)
                F[Queue[i]]=min(F[Queue[i]],F[Stack[fd]]+(Dist[Queue[i]]-Dist[Stack[fd]])*P[Queue[i]].p+P[Queue[i]].q);
        }
    }

    for (int i=Head[nowroot];i!=-1;i=Next[i])//点分治子树
        if (vis[E[i].v]==0){
            nowsum=Size[E[i].v];Divide(E[i].v);
        }
    return;
}

void dfs(int u,int fa)
{
    Queue[++qh]=u;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((E[i].v!=fa)&amp;&amp;(vis[E[i].v]==0)) dfs(E[i].v,u);
    return;
}

bool cmp(int u,int v)
{
    return Dist[u]-P[u].l&gt;Dist[v]-P[v].l;
}

ld Slope(int u,int v)
{
    return 1.0*(F[u]-F[v])/(1.0*(Dist[u]-Dist[v]));
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>627</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 17:52:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 09:52:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3672-luogu2305noi2014%e8%b4%ad%e7%a5%a8%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[229]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4567/Luogu3294][SCOI2016]背单词（Trie树，贪心）</title>
		<link>http://sycstudio.com/archives/628</link>
		<pubDate>Sun, 08 Apr 2018 10:08:31 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=628</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Lweb 面对如山的英语单词，陷入了深深的沉思，“我怎么样才能快点学完，然后去玩三国杀呢？”。这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，他的计划册是长这样的：
—————
序号  单词
—————
 1
 2
……
n-2
n-1
 n
—————
然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 n 个，现在我们从上往下完成计划表，对于一个序号为 x 的单词（序号 1...x-1 都已经被填入）：
1) 如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n×n 颗泡椒才能学会；
2) 当它的所有后缀都被填入表内的情况下，如果在 1...x-1 的位置上的单词都不是它的后缀，那么你吃 x 颗泡椒就能记住它；
3) 当它的所有后缀都被填入表内的情况下，如果 1...x-1的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 y ，那么你只要吃 x-y 颗泡椒就能把它记住。
Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb ，寻找一种最优的填写单词方案，使得他记住这 n 个单词的情况下，吃最少的泡椒。

<h3>Tag</h3>

Trie树，贪心

<h2>解决思路</h2>

首先肯定是要尽量避免第一种情况的，那么就让一个串的所有后缀的位置一定优于这个串。所以可以想到把字符串反过来插入到Trie树中，这样我们就可以处理后缀的问题了。
把Trie树中所有是单词结尾的地方以及0号根节点单独提出来，建立一棵新的树。现在的问题是，如歌分配这些点的编号使得所有的儿子-父亲的编号之和最小。
贪心地想到，每一次向下走的时候，优先走size更小的子树，这样使得差值会尽量小。所以统计出size后，对每一个点的儿子按照size排序，优先走小的进行编号。
注意对根节点0的特殊处理

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxTrie=600010;
const int maxAlpha=26;
const int inf=2147483647;

class Trie
{
public:
    int end;
    int son[maxAlpha];
    int id;
};

int n,nodecnt;
Trie T[maxTrie];
char str[maxTrie];
vector&lt;int&gt; Son[maxTrie];
ll Size[maxTrie];
ll Ans=0;
ll idcnt=0,Id[maxTrie];

void dfs(int u,int top);
void GetSize(int u);
void Calc(int u);
bool cmp(int a,int b);

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",str+1);
        int len=strlen(str+1);
        int now=0;
        for (int j=len;j&gt;=1;j--)//建立Trie树
        {
            if (T[now].son[str[j]-'a']==0) T[now].son[str[j]-'a']=++nodecnt;
            now=T[now].son[str[j]-'a'];
        }
        T[now].end=1;T[now].id=i;
    }
    dfs(0,0);//第一遍dfs在Trie树上构出那棵只包含根节点和所有单词结尾节点的树
    GetSize(0);//第二遍dfs统计出每一个点的size
    Calc(0);//第三遍dfs按照size从小到大遍历，统计答案
    printf("%lld\n",Ans);
    return 0;
}

void dfs(int u,int top)
{
    if (T[u].end){
        Son[top].push_back(u);
        top=u;
    }
    for (int i=0;i&lt;maxAlpha;i++) if (T[u].son[i]) dfs(T[u].son[i],top);
    return;
}

void GetSize(int u)
{
    Size[u]=1;
    int cnt=Son[u].size();
    for (int i=0;i&lt;cnt;i++) GetSize(Son[u][i]),Size[u]+=Size[Son[u][i]];
    return;
}

void Calc(int u)
{
    sort(Son[u].begin(),Son[u].end(),cmp);//排序
    int cnt=Son[u].size();if (u!=0) Id[u]=++idcnt;
    for (int i=0;i&lt;cnt;i++){
        Calc(Son[u][i]);Ans+=Id[Son[u][i]]-Id[u];
    }
    return;
}

bool cmp(int a,int b)
{
    return Size[a]&lt;Size[b];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>628</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 18:08:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 10:08:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4567-luogu3294scoi2016%e8%83%8c%e5%8d%95%e8%af%8d%ef%bc%88trie%e6%a0%91%ef%bc%8c%e8%b4%aa%e5%bf%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="trie%e6%a0%91"><![CDATA[Trie树]]></category>
		<category domain="post_tag" nicename="trie%e6%a0%91"><![CDATA[Trie树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[224]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1415/Luogu4206][NOI2005]聪聪和可可（动态规划，期望概率，记忆化搜索）</title>
		<link>http://sycstudio.com/archives/629</link>
		<pubDate>Sun, 08 Apr 2018 10:19:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=629</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽 然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠， 同样不变的是，聪聪成天想着要吃掉可可。
一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确 的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发， 去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。 小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可 可，可她不知道还有没有足够的时间。
整个森林可以认为是一个无向图，图中有 N 个美丽的景点，景点从 1 至 N 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。
当聪聪得到 GPS 时，可可正在景点 M(M≤N)处。以后的每个时间单位，可可 都会选择去相邻的景点(可能有多个)中的一个或停留在原景点不动。而去这些地 方所发生的概率是相等的。假设有 P 个景点与景点 M 相邻，它们分别是景点 R、 景点 S，……景点 Q，在时刻 T 可可处在景点 M，则在(T＋1)时刻，可可有 1/(1 +P) 的可能在景点 R，有 1/(1 +P) 的可能在景点 S，……，有 1/(1 +P) 的可能在景点 Q，还 有1/(1 +P)的可能停在景点 M。
我们知道，聪聪是很聪明的，所以，当她在景点 C 时，她会选一个更靠近 可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太 想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再 向可可走近一步。
在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位 于同一个景点，则可怜的可可就被吃掉了。
灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑 娘尽快的找到答案。

<h3>Tag</h3>

动态规划，期望概率，记忆化搜索

<h2>解决思路</h2>

由于猫一定是向着最靠近鼠的方向移动，并且鼠移动一次时猫可以移动两次，所以猫一定是可以抓到鼠的。
设F[i][j]表示鼠在点i猫在点j猫还没有行动时猫抓到老鼠的期望。那么由于鼠当前的位置已经确定，所以猫可以直接向着最靠近鼠的位置前进两步。
这个可以预处理出来的，设Path[i][j]为鼠在i猫在j时，猫下一步走到的点的编号，这个可以把鼠放在每一个点上，以这个点为中心bfs求最短路。
接着考虑F[i][j]，那么若猫在j可以经过不超过两步到达i，则F[i][j]=1，否则，扫描i的每一条出边进行等概率转移，最后还要加上鼠不动的期望。
由于转移顺序不好确定，可以采用记忆化搜索的方式实现动态规划。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxM=maxN*2;
const int inf=2147483647;

int n,m,S,T;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Queue[maxN],Dist[maxN],Degree[maxN];
int Path[maxN][maxN];
ld F[maxN][maxN];

void Add_Edge(int u,int v);
void Bfs(int st);
ld dfs(int u,int v);

int main()
{
    mem(Head,-1);

    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) F[i][j]=-1;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        Add_Edge(u,v);Add_Edge(v,u);
    }
    for (int i=1;i&lt;=n;i++)//预处理Path
    {
        Bfs(i);
        for (int j=1;j&lt;=n;j++)
            if (i==j) Path[i][j]=0;
            else
            {
                Path[i][j]=inf;
                for (int e=Head[j];e!=-1;e=Next[e])
                    if (Dist[j]==Dist[V[e]]+1) Path[i][j]=min(Path[i][j],V[e]);
            }
    }
    printf("%.3LF\n",dfs(T,S));
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    Degree[u]++;
    return;
}

void Bfs(int st)
{
    int h=1,t=0;mem(Dist,-1);Dist[st]=0;
    Queue[1]=st;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if (Dist[V[i]]==-1)
                Dist[Queue[++h]=V[i]]=Dist[u]+1;
    }
    while (t!=h);
    return;
}

ld dfs(int u,int v)//u-鼠，v-猫
{
    if (u==v) return F[u][v]=0;
    if ((Path[u][v]==u)||(Path[u][Path[u][v]]==u)) return F[u][v]=1;//直接抓到
    if (F[u][v]!=-1) return F[u][v];
    int now=Path[u][Path[u][v]];//猫走两步
    ld Ret=0;
    for (int i=Head[u];i!=-1;i=Next[i])//等概率转移
        Ret+=dfs(V[i],now);
    Ret+=dfs(u,now);//不动
    F[u][v]=Ret/(Degree[u]+1)+1;
    return F[u][v];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>629</wp:post_id>
		<wp:post_date><![CDATA[2018-04-08 18:19:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-08 10:19:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1415-luogu4206noi2005%e8%81%aa%e8%81%aa%e5%92%8c%e5%8f%af%e5%8f%af%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%9c%9f%e6%9c%9b%e6%a6%82%e7%8e%87%ef%bc%8c%e8%ae%b0%e5%bf%86%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="category" nicename="%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2"><![CDATA[记忆化搜索]]></category>
		<category domain="post_tag" nicename="%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2"><![CDATA[记忆化搜索]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[203]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1496/Luogu2703][NOI2006]千年虫（动态规划）</title>
		<link>http://sycstudio.com/archives/631</link>
		<pubDate>Tue, 10 Apr 2018 13:59:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=631</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家J发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家K敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态A，找到一个符合理论模型的形态B，使得B是最有可能在形成化石时变成形态A。
<img src="/bzojch/file/1496_0.jpg" alt="BZOJ1496-1" />
理论学家提出的“千年虫形态特征模型”如下（如上图所示）：躯体由头、尾、躯干、足四大部分构成。1.头，尾用一对平行线段表示。称平行于头、尾的方向为x方向；垂直于x的方向为y方向；2.在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于x方向。3.每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于x方向的梯形或矩形，且其中远离躯干一侧的边垂直于x方向。注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如下图，左边有4条足，右边有5条足）
<img src="/bzojch/file/1496_1.jpg" alt="BZOJ1496-2" />
可见，x-y直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体都由一些单位方格拼成。每个单位方格都由坐标(x,y)唯一确定。设头尾之间的距离为n，则我们可以用2×n个整数来描述一条千年虫B（如右图）：将B沿平行x轴方向剖分成n条宽度为1的横条，每个横条最左边一格的x坐标设为Li，最右一格的的x坐标设为Ri。则(n,L1,L2,..,Ln,R1,R2,..Rn)就确定了一条千年虫。 由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。 地质、物理、生物学家共同研究得出： 1、腐蚀是以格子为单位的，只能一整格被腐蚀； 2、腐蚀是分步进行的，每一步只有一格被腐蚀； 3、如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀； 4、如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀； 5、与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀； 倘若满足上面五条，我们仍然可以用(n,L’1,L’2,..,L’n,R’1,R’2,..R’n)来描述一个化石里头的千年虫的形态。其中L’i≤R’i。 例如下图：
<img src="/bzojch/file/1496_2.jpg" alt="BZOJ1496-3" />
现在你的任务是，输入一个化石里的千年虫的描述A，找一个满足理论模型的千年虫的描述B，使得B可以通过腐蚀过程得以变为A，且由B转化为A的代价(须被腐蚀的格子数)最少。输出此最小代价。

<h3>Tag</h3>

动态规划

<h2>题目大意</h2>

给定数列，求增加最少的数量使得数列变成梳子状的数列并且首尾皆为凹。

<h2>解决思路</h2>

题目说的非常复杂，简化题意后得到求花费最少的代价使得序列变成一个类似梳子的序列且头尾都是凹的。考虑到两边的其实是互不影响的，所以分成两次来考虑。
设&#92;(F[i][j][k]&#92;) 表示当前处理到第i个数字，当前数字为j，当前凹凸性为k最小代价。则F[i][j][k]可以由F[i-1][p][k]或F[i-1][p][k^1]转移过来，具体要看p与j的关系。论文证明，每一次p和j的取值其实是在一定范围内的，即在当前行的上三行下三行范围内，原数列值到原数列值+3这个范围内的数，那么可行的转移状态就剩下常数个了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1000100;
const int inf=47483647;

int n;
int L[maxN],R[maxN];
ll H[maxN];
ll F[2][maxN][2],Pos[2][maxN],Cnt[2];

ll Calc();

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;L[i]&gt;&gt;R[i];
    for (int i=1;i&lt;=n;i++) H[i]=R[i];
    ll Ans=0;
    Ans+=Calc();//分为两次计算
    for (int i=1;i&lt;=n;i++) H[i]=maxN-L[i];
    Ans+=Calc();
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

ll Calc()
{
    Cnt[1]=0;//求出第一个数可能的所有状态
    for (int i=1;i&lt;=3;i++)
        for (int j=H[i];j&lt;=H[i]+3;j++)
            if (j&gt;=H[1]) Pos[1][++Cnt[1]]=j;
    mem(F,63);//得到第一个数每一种状态对应的代价
    for (int i=1;i&lt;=Cnt[1];i++) F[1][i][0]=Pos[1][i]-H[1];
    int now=1;
    for (int i=2;i&lt;=n;i++)//从第二个数开始计算
    {
        now^=1;Cnt[now]=0;
        int l=max(1,i-2),r=min(n,i+2);//枚举的上下界
        for (int j=l;j&lt;=r;j++)//得到当前这一个数的所有可能状态
            for (int k=H[j];k&lt;=H[j]+2;k++)
                if (k&gt;=H[i]) Pos[now][++Cnt[now]]=k;
        for (int j=1;j&lt;=Cnt[now];j++)//枚举这一次的状态
        {
            F[now][j][0]=F[now][j][1]=inf;
            for (int k=1;k&lt;=Cnt[now^1];k++)//枚举当前这个状态由上一行的哪一个转过来
                if (Pos[now][j]&gt;Pos[now^1][k]) F[now][j][1]=min(F[now][j][1],F[now^1][k][0]);//上一个数大，那就是上一个数凸转移到这一个数凹
                else if (Pos[now][j]&lt;Pos[now^1][k]) F[now][j][0]=min(F[now][j][0],F[now^1][k][1]);//上一个数小，那就是上一个数凹转移到这一个数凸
                else//相同时，凹凸皆可以转移
                {
                    F[now][j][0]=min(F[now][j][0],F[now^1][k][0]);
                    F[now][j][1]=min(F[now][j][1],F[now^1][k][1]);
                }
            F[now][j][0]+=Pos[now][j]-H[i];
            F[now][j][1]+=Pos[now][j]-H[i];
        }
    }
    ll Ret=inf;//取最优值
    for (int i=1;i&lt;=Cnt[now];i++) Ret=min(Ret,F[now][i][0]);
    return Ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>631</wp:post_id>
		<wp:post_date><![CDATA[2018-04-10 21:59:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-10 13:59:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1496-luogu2703noi2006%e5%8d%83%e5%b9%b4%e8%99%ab%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[229]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1497/Luogu4174][NOI2006]最大获利（网络流）</title>
		<link>http://sycstudio.com/archives/633</link>
		<pubDate>Tue, 17 Apr 2018 11:36:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=633</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU集团旗下的CS&amp;T通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。在前期市场调查和站址勘测之后，公司得到了一共N个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第i个通讯中转站需要的成本为Pi（1≤i≤N）。另外公司调查得出了所有期望中的用户群，一共M个。关于第i个用户群的信息概括为Ai, Bi和Ci：这些用户会使用中转站Ai和中转站Bi进行通讯，公司可以获益Ci。（1≤i≤M, 1≤Ai, Bi≤N） THU集团的CS&amp;T公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 - 投入成本之和）

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

把所有收益加起来，将最大获利转化为最小损失。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=505010;
const int maxM=maxN*6;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Queue[maxN],Depth[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);

    cin&gt;&gt;n&gt;&gt;m;S=n+m+1;T=n+m+2;
    for (int i=1;i&lt;=n;i++)
    {
        int C;cin&gt;&gt;C;
        Add_Edge(S,i,C);
    }
    int Ans=0;//建图
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;Ans+=w;
        Add_Edge(i+n,T,w);
        Add_Edge(u,i+n,inf);Add_Edge(v,i+n,inf);
    }
    //最大流
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans-=di;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;
    Depth[S]=1;Queue[1]=S;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>633</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 19:36:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 11:36:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1497-luogu4174noi2006%e6%9c%80%e5%a4%a7%e8%8e%b7%e5%88%a9%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[191]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1513/Luogu3437][POI2006]Tet-Tetris 3D（树套树）</title>
		<link>http://sycstudio.com/archives/634</link>
		<pubDate>Tue, 17 Apr 2018 11:42:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=634</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Tetris 3D "Tetris" 游戏的作者决定做一个新的游戏, 一个三维的版本, 在里面很多立方体落在平面板,一个立方体开始落下直到碰上一个以前落下的立方体或者落地即停止. 作者想改变一下游戏的目的使得它更大众化,在新游戏中你将知道落下的立方体信息以及位置,你的任务就是回答所有立方体落下后最高的方块的高度.所有的立方体在下落过程中都是垂直的并且不会旋转.平板左下角坐标为原点,并且平行于坐标轴.

<h3>Tag</h3>

树套树

<h2>解决思路</h2>

观察，题目要求的便是取区间最大值和区间覆盖。那么如果是在序列上的操作，直接用线段树来维护就好了，区间最大值可以直接合并得到，而区间覆盖可以用懒标记来实现。
现在转到了二维平面上，那么就用二维线段树来维护，同样维护懒标记，只不过由于不好下放，采用标记永久化的方式。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=1010;
const int inf=2147483647;

int n,m;

class InSegTree//内层线段树，即普通的线段树，维护y轴信息
{
public:
    int Val[maxN&lt;&lt;2],Lazy[maxN&lt;&lt;2];
    void Modify(int now,int l,int r,int ql,int qr,int key){
        Val[now]=max(Val[now],key);
        if ((l==ql)&amp;&amp;(r==qr))
        {
            Lazy[now]=max(Lazy[now],key);
            return;
        }
        int mid=(l+r)&gt;&gt;1;
        if (qr&lt;=mid) Modify(lson,l,mid,ql,qr,key);
        else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr,key);
        else
        {
            Modify(lson,l,mid,ql,mid,key);
            Modify(rson,mid+1,r,mid+1,qr,key);
        }
        return;
    }
    int Query(int now,int l,int r,int ql,int qr){
        if ((l==ql)&amp;&amp;(r==qr)) return max(Val[now],Lazy[now]);
        int Ret=Lazy[now];
        int mid=(l+r)&gt;&gt;1;
        if (qr&lt;=mid) return max(Ret,Query(lson,l,mid,ql,qr));
        else if (ql&gt;=mid+1) return max(Ret,Query(rson,mid+1,r,ql,qr));
        else return max(Ret,max(Query(lson,l,mid,ql,mid),Query(rson,mid+1,r,mid+1,qr)));
    }
};

class OutSegTree//外层线段树，维护x轴信息
{
public:
    InSegTree Val[maxN&lt;&lt;2],Lazy[maxN&lt;&lt;2];//外层线段树的每一个节点都是一棵内层线段树，注意懒标记也要用线段树来维护
    void Modify(int now,int l,int r,int ql,int qr,int p,int q,int key){
        Val[now].Modify(1,1,m,p,q,key);
        if ((l==ql)&amp;&amp;(r==qr))
        {
            Lazy[now].Modify(1,1,m,p,q,key);
            return;
        }
        int mid=(l+r)&gt;&gt;1;
        if (qr&lt;=mid) Modify(lson,l,mid,ql,qr,p,q,key);
        else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr,p,q,key);
        else
        {
            Modify(lson,l,mid,ql,mid,p,q,key);
            Modify(rson,mid+1,r,mid+1,qr,p,q,key);
        }
        return;
    }
    int Query(int now,int l,int r,int ql,int qr,int p,int q){
        if ((l==ql)&amp;&amp;(r==qr)) return Val[now].Query(1,1,m,p,q);
        int mid=(l+r)&gt;&gt;1;
        int Ret=Lazy[now].Query(1,1,m,p,q);
        if (qr&lt;=mid) return max(Ret,Query(lson,l,mid,ql,qr,p,q));
        else if (ql&gt;=mid+1) return max(Ret,Query(rson,mid+1,r,ql,qr,p,q));
        else return max(Ret,max(Query(lson,l,mid,ql,mid,p,q),Query(rson,mid+1,r,mid+1,qr,p,q)));
    }
};

OutSegTree S;

int main()
{
    ios::sync_with_stdio(false);
    int Q;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q;n++;m++;
    while (Q--)
    {
        int d,s,w,x,y;cin&gt;&gt;d&gt;&gt;s&gt;&gt;w&gt;&gt;x&gt;&gt;y;x++;y++;
        w=w+S.Query(1,1,n,x,x+d-1,y,y+s-1);
        S.Modify(1,1,n,x,x+d-1,y,y+s-1,w);
    }
    cout&lt;&lt;S.Query(1,1,n,1,n,1,m)&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>634</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 19:42:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 11:42:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1513-luogu3437poi2006tet-tetris-3d%ef%bc%88%e6%a0%91%e5%a5%97%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="poi"><![CDATA[POI]]></category>
		<category domain="post_tag" nicename="poi"><![CDATA[POI]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[164]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4355]Play with sequence（线段树）</title>
		<link>http://sycstudio.com/archives/635</link>
		<pubDate>Tue, 17 Apr 2018 12:15:09 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=635</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

维护一个长度为N的序列a，现在有三种操作：
1）给出参数U,V,C，将a[U],a[U+1],...,a[V-1],a[V]都赋值为C。
2）给出参数U,V,C，对于区间[U,V]里的每个数i，将a[i]赋值为max(a[i]+C,0)。
3）给出参数U,V，输出a[U],a[U+1],...,a[V-1],a[V]里值为0的数字个数。

<h3>Tag</h3>

线段树

<h2>解决思路</h2>

观察题目给出的数据范围，发现在任意时刻，任意序列中的最小值是非负的，也就是说0若存在一定是序列的最小值。所以题目中较好处理的是1,3两个操作，第一个可以直接标记覆盖，而第三个可以通过维护最小值和最小值出现的次数来实现。
那么关键是第二个操作如何处理。考虑把第二个操作分成两步，先区间加法，再区间取max。区间加法也比较好实现，用区间加标记就好。但要注意区间加标记与区间覆盖标记的操作顺序。当区间覆盖的时候，要清空区间加标记；而若区间加的时候，如果有区间覆盖标记，就直接加到区间覆盖标记上。
所以问题在于区间取max的操作。一个自然的想法就是维护区间最小值，若区间最小值都大于当前要取max的值，那么就不向下修改，否则递归左右分别处理。这样最坏可以达到&#92;(O(nq)&#92;)的复杂度。
从<a href="http://c-sunshine.blog.uoj.ac/blog/1270">吉老师线段树</a>这里，我们得到一种更优的操作，那就是在维护区间最小和区间最小的个数的同时，再维护区间次小。当取max的值小于最小时，不操作；当大于区间最小而小于区间次小时，只修改区间最小；当大于区间次小时，递归处理。这样可以证明复杂度是&#92;(O(nlogn)&#92;)的。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)
#define RG register
#define IL inline

const int maxN=301000;
const int inf=2147483647;
const ll INF=1e15;

class SegmentData
{
public:
    ll mn,mns;//区间最小，次小、
    ll cnt;//区间最小的次数
    ll cover,add,delta;//区间覆盖标记，区间加标记，区间最小值的加标记
    ll size;
    SegmentData(){
        cover=delta=-INF;add=0;
        return;
    }
};

int n,m;
ll Arr[maxN];
SegmentData S[maxN&lt;&lt;2];

IL void PushDown(RG int now);//标记下方
IL void Update(RG int now);//从儿子更新
IL void Cover(RG int now,RG ll key);//区间覆盖标记
IL void Add(RG int now,RG ll key);//区间加标记
IL void Delta(RG int now,RG ll key);//区间最小值加标记
void Build(RG int now,RG int l,RG int r);//初始化
void Modify_cover(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key);//区间覆盖
void Modify_add(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key);//区间加
void Modify_mx(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key);//区间取max
ll Query(RG int now,RG int l,RG int r,RG int ql,RG int qr);//查询

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (RG int i=1;i&lt;=n;i++) scanf("%lld",&amp;Arr[i]);
    Build(1,1,n);
    while (m--)
    {
        RG int opt;scanf("%d",&amp;opt);
        if (opt==1)
        {
            RG int l,r,c;scanf("%d%d%d",&amp;l,&amp;r,&amp;c);
            Modify_cover(1,1,n,l,r,c);
        }
        if (opt==2)
        {
            RG int l,r,c;scanf("%d%d%d",&amp;l,&amp;r,&amp;c);
            Modify_add(1,1,n,l,r,c);
            Modify_mx(1,1,n,l,r,0);
        }
        if (opt==3)
        {
            RG int l,r;scanf("%d%d",&amp;l,&amp;r);
            printf("%lld\n",Query(1,1,n,l,r));
        }
    }
    return 0;
}

IL void PushDown(RG int now)
{
    if (S[now].add)//区间加标记
    {
        Add(lson,S[now].add);Add(rson,S[now].add);
        S[now].add=0;
    }
    if (S[now].cover!=-INF)//区间覆盖
    {
        Cover(lson,S[now].cover);Cover(rson,S[now].cover);
        S[now].cover=-INF;
    }
    if (S[now].delta!=-INF)//区间最小值加
    {
        Delta(lson,S[now].delta);Delta(rson,S[now].delta);
        S[now].delta=-INF;
    }
    return;
}

IL void Update(RG int now)//自下而上更新
{
    S[now].mn=min(S[lson].mn,S[rson].mn);
    S[now].mns=min(S[lson].mns,S[rson].mns);
    if (S[now].mn!=S[lson].mn) S[now].mns=min(S[now].mns,S[lson].mn);
    if (S[now].mn!=S[rson].mn) S[now].mns=min(S[now].mns,S[rson].mn);
    S[now].cnt=0;
    if (S[now].mn==S[lson].mn) S[now].cnt+=S[lson].cnt;
    if (S[now].mn==S[rson].mn) S[now].cnt+=S[rson].cnt;
    return;
}

IL void Cover(RG int now,RG ll key)//覆盖标记直接覆盖，同时清空加标记和最小值加标记
{
    S[now].mn=key;S[now].mns=INF;S[now].add=0;S[now].delta=-INF;
    S[now].cover=key;S[now].cnt=S[now].size;
    return;
}

IL void Add(RG int now,RG ll key)
{
    S[now].mn+=key;
    if (S[now].mns!=inf) S[now].mns+=key;
    if (S[now].cover!=-INF) S[now].cover+=key;//当有覆盖标记时，直接加到覆盖标记上
    else S[now].add+=key;//否则加到区间加标记上
    if (S[now].delta!=-INF) S[now].delta+=key;//注意区间最小值加标记也要加
    return;
}

IL void Delta(RG int now,RG ll key)//区间最小值加标记
{
    if (S[now].mn&lt;key)
    {
        S[now].mn=key;
        S[now].delta=max(S[now].delta,key);
    }
    return;
}

void Build(RG int now,RG int l,RG int r)
{
    S[now].size=r-l+1;
    if (l==r)
    {
        S[now].mn=Arr[l];S[now].mns=INF;
        S[now].cnt=1;
        return;
    }
    RG int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    Update(now);return;
}

void Modify_cover(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key)
{
    if ((l==ql)&amp;&amp;(r==qr)){
        Cover(now,key);return;
    }
    PushDown(now);
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_cover(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify_cover(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify_cover(lson,l,mid,ql,mid,key);
        Modify_cover(rson,mid+1,r,mid+1,qr,key);
    }
    Update(now);return;
}

void Modify_add(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key)
{
    if ((l==ql)&amp;&amp;(r==qr)){
        Add(now,key);return;
    }
    PushDown(now);
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_add(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify_add(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify_add(lson,l,mid,ql,mid,key);
        Modify_add(rson,mid+1,r,mid+1,qr,key);
    }
    Update(now);return;
}

void Modify_mx(RG int now,RG int l,RG int r,RG int ql,RG int qr,RG ll key)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        if (S[now].mn&gt;=key) return;//取max的值小于等于区间最小值，直接返回
        if (S[now].mns&gt;key)//大于区间最小值但小于区间次小值，则只修改区间最小值后返回
        {
            S[now].delta=S[now].mn=key;
            return;
        }//若上面两条都不满足，则向下递归处理
        PushDown(now);
        int mid=(l+r)&gt;&gt;1;
        Modify_mx(lson,l,mid,ql,mid,key);
        Modify_mx(rson,mid+1,r,mid+1,qr,key);
        Update(now);return;
    }
    PushDown(now);
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_mx(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify_mx(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify_mx(lson,l,mid,ql,mid,key);
        Modify_mx(rson,mid+1,r,mid+1,qr,key);
    }
    Update(now);return;
}

ll Query(RG int now,RG int l,RG int r,RG int ql,RG int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return ((S[now].mn==0)?(S[now].cnt):(0));
    PushDown(now);
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query(rson,mid+1,r,ql,qr);
    else return Query(lson,l,mid,ql,mid)+Query(rson,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>635</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 20:15:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 12:15:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4355play-with-sequence%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[146]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4653/Luogu1712][NOI2016]区间（线段树，尺取法）</title>
		<link>http://sycstudio.com/archives/636</link>
		<pubDate>Tue, 17 Apr 2018 12:27:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=636</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在数轴上有 n个闭区间 [l1,r1],[l2,r2],...,[ln,rn]。现在要从中选出 m 个区间，使得这 m个区间共同包含至少一个位置。换句话说，就是使得存在一个 x，使得对于每一个被选中的区间 [li,ri]，都有 li≤x≤ri。
对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 [li,ri] 的长度定义为 ri−li，即等于它的右端点的值减去左端点的值。
求所有合法方案中最小的花费。如果不存在合法的方案，输出 −1。

<h3>Tag</h3>

线段树，尺取法。

<h2>解决思路</h2>

由于题目定义方案的花费为最长区间的长度-最短区间长度，那么长度在两者之间的区间是都可以加进去的。所以如果爱把区间按照长度排序后，任意一个合法方案都是一段连续区间的组合。
那么，可以用尺取法维护这个合法区间。每一次加入一个区间，就在对应线段树节点进行区间加法操作，若全局max等于要求的m时，此时表示至少有一个位置被m个区间覆盖，记录答案，然后移动左端点去掉一个区间，继续做。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=501000*2;
const int inf=2147483647;

class Range
{
public:
    int l,r,len;
};

class SegmentData
{
public:
    int mx,lazy;
};

int n,m;
Range R[maxN];
int numcnt,Num[maxN*2];
SegmentData S[maxN*4];

bool operator &lt; (Range A,Range B);
void PushDown(int now);
void Modify(int now,int l,int r,int ql,int qr,int key);

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;R[i].l&gt;&gt;R[i].r;R[i].len=R[i].r-R[i].l;
        Num[++numcnt]=R[i].l;Num[++numcnt]=R[i].r;
    }
    //离散
    sort(&amp;Num[1],&amp;Num[numcnt+1]);
    numcnt=unique(&amp;Num[1],&amp;Num[numcnt+1])-Num-1;
    for (int i=1;i&lt;=n;i++)
    {
        R[i].l=lower_bound(&amp;Num[1],&amp;Num[numcnt+1],R[i].l)-Num;
        R[i].r=lower_bound(&amp;Num[1],&amp;Num[numcnt+1],R[i].r)-Num;
    }
    sort(&amp;R[1],&amp;R[n+1]);//将区间按照长度排序
    int Ans=inf;
    for (int i=1,j=0;i&lt;=n;i++)//尺取
    {
        while ((j&lt;n)&amp;&amp;(S[1].mx&lt;m))//移动右端点加入区间
        {
            j++;
            Modify(1,1,numcnt,R[j].l,R[j].r,1);
        }
        if (S[1].mx==m) Ans=min(Ans,R[j].len-R[i].len);//若最大值等于m，则记录最优答案
        else break;
        Modify(1,1,numcnt,R[i].l,R[i].r,-1);//删除左端点区间
    }
    if (Ans==inf) cout&lt;&lt;-1&lt;&lt;endl;
    else cout&lt;&lt;Ans&lt;&lt;endl;
    return 0;
}

bool operator &lt; (Range A,Range B)
{
    return A.len&lt;B.len;
}

void PushDown(int now)
{
    if (S[now].lazy)
    {
        int lz=S[now].lazy;
        S[lson].mx+=lz;S[lson].lazy+=lz;
        S[rson].mx+=lz;S[rson].lazy+=lz;
        S[now].lazy=0;
    }
    return;
}

void Modify(int now,int l,int r,int ql,int qr,int key)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        S[now].mx+=key;S[now].lazy+=key;
        return;
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify(lson,l,mid,ql,mid,key);
        Modify(rson,mid+1,r,mid+1,qr,key);
    }
    S[now].mx=max(S[lson].mx,S[rson].mx);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>636</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 20:27:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 12:27:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4653-luogu1712noi2016%e5%8c%ba%e9%97%b4%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e5%b0%ba%e5%8f%96%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%b0%ba%e5%8f%96%e6%b3%95"><![CDATA[尺取法]]></category>
		<category domain="post_tag" nicename="%e5%b0%ba%e5%8f%96%e6%b3%95"><![CDATA[尺取法]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[216]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1558/Luogu4243][JSOI2009]等差数列（线段树，差分）</title>
		<link>http://sycstudio.com/archives/637</link>
		<pubDate>Tue, 17 Apr 2018 12:38:05 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=637</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="\media\BZOJ\BZOJ1558.gif" alt="BZOJ1558" />

<h3>Tag</h3>

线段树，差分

<h2>解决思路</h2>

一般而言，遇到等差数列的问题，通常是转化为差分数组后，相同的数即可组成一个等差数列。
但，等差数列差分后，第一个数是可以与后面的数不一样的，这就不是很好处理。所以，要把它们分开考虑。
具体来说，用线段树维护区间左右端点的值，然后再维护f00,f01,f10,f11分别表示前后端点选or不选时的最小等差数列个数，0代表不选，1代表选。这里的选指的是是否记录进当前区间的答案。
那么合并两个区间的时候，分情况讨论一下求和。
至于修改，考虑差分后的数组，则是两个端点的单点修改和中间区间的区间修改操作。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)
#define MIN(a,b,c) min(a,min(b,c))

const int maxN=101000;
const int inf=2147483647;

class Data
{
public:
    int f00,f01,f10,f11;
    int left,right;
    int lazy;
    Data(){
        lazy=0;
    }
};

int n,m;
int Arr[maxN];
Data S[maxN&lt;&lt;2];

Data operator + (Data A,Data B);
void PushDown(int now);
void Build(int now,int l,int r);
void Modify(int now,int l,int r,int ql,int qr,int key);
Data Query(int now,int l,int r,int ql,int qr);
void OutpNum(int now,int l,int r);

int main()
{
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]);
    for (int i=n;i&gt;=1;i--) Arr[i]=Arr[i]-Arr[i-1];
    Build(1,1,n);

    cin&gt;&gt;m;
    while (m--)
    {
        char opt;
        opt=getchar();
        while ((opt!='A')&amp;&amp;(opt!='B')) opt=getchar();
        if (opt=='A')
        {
            int s,t,a,b;scanf("%d%d%d%d",&amp;s,&amp;t,&amp;a,&amp;b);
            Modify(1,1,n,s,s,a);//单点修改left
            if (s&lt;t) Modify(1,1,n,s+1,t,b);//区间修改
            if (t&lt;n) Modify(1,1,n,t+1,t+1,-(t-s)*b-a);//单点修改right+1
        }
        if (opt=='B')
        {
            int s,t;scanf("%d%d",&amp;s,&amp;t);
            Data G=Query(1,1,n,s,t);
            printf("%d\n",min(G.f11,G.f01));//注意这里只能是头尾都选或头不选
        }
    }
    return 0;
}

Data operator + (Data A,Data B)//分情况讨论，合并答案
{
    Data Ret;
    Ret.left=A.left;Ret.right=B.right;
    Ret.f00=MIN(A.f01+B.f10-(A.right==B.left),A.f00+B.f10,A.f01+B.f00);
    Ret.f01=MIN(A.f01+B.f11-(A.right==B.left),A.f00+B.f11,A.f01+B.f01);
    Ret.f10=MIN(A.f11+B.f10-(A.right==B.left),A.f10+B.f10,A.f11+B.f00);
    Ret.f11=MIN(A.f11+B.f11-(A.right==B.left),A.f10+B.f11,A.f11+B.f01);
    return Ret;
}

void PushDown(int now)
{
    if (S[now].lazy)
    {
        int lz=S[now].lazy;
        S[lson].left+=lz;S[lson].right+=lz;S[lson].lazy+=lz;
        S[rson].left+=lz;S[rson].right+=lz;S[rson].lazy+=lz;
        S[now].lazy=0;
    }
    return;
}

void Build(int now,int l,int r)
{
    if (l==r)
    {
        S[now].f00=0;S[now].f10=S[now].f01=1;S[now].f11=1;
        S[now].left=S[now].right=Arr[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    S[now]=S[lson]+S[rson];
    return;
}

void Modify(int now,int l,int r,int ql,int qr,int key)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        S[now].left+=key;S[now].right+=key;S[now].lazy+=key;
        return;
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify(lson,l,mid,ql,mid,key);
        Modify(rson,mid+1,r,mid+1,qr,key);
    }
    S[now]=S[lson]+S[rson];
    return;
}

Data Query(int now,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[now];
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query(rson,mid+1,r,ql,qr);
    else return Query(lson,l,mid,ql,mid)+Query(rson,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>637</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 20:38:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 12:38:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1558-luogu4243jsoi2009%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e5%b7%ae%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[181]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1901/ZOJ2122/Luogu2617]Dynamic Rankings（树套树，树状数组，线段树）</title>
		<link>http://sycstudio.com/archives/638</link>
		<pubDate>Tue, 17 Apr 2018 13:08:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=638</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改变后的a继续回答上面的问题。你需要编一个这样的程序，从输入文件中读入序列a，然后读入一系列的指令，包括询问指令和修改指令。对于每一个询问指令，你必须输出正确的回答。 第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。分别表示序列的长度和指令的个数。第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。接下来的m行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t。

<h3>Tag</h3>

树套树，树状数组，线段树

<h2>解决思路</h2>

如果是静态的化，就是主席树处理了。但由于有修改操作，如果用前缀和维护的话，查询是&#92;(O(logn)&#92;)，但修改就是&#92;(O(n)&#92;)的了。
考虑一种更加均衡的前缀和的查询姿势。我们知道，树状数组的查询和修改都是&#92;(O(logn)&#92;)的，复杂度较均衡。那么可以用树状数组套值域线段树的方式来维护前缀和。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lowbit(x) ((x)&amp;(-(x)))
#define find(x) (lower_bound(&amp;Num[1],&amp;Num[numcnt+1],x)-Num)

const int maxN=30010;
const int maxBit=15;
const int inf=2147483647;

class SegmentData
{
public:
    int cnt;
    int ls,rs;
};

class Question
{
public:
    char opt;
    int a,b,c;
};

int n,m,nodecnt;
int Arr[maxN],root[maxN];
int numcnt=0,Num[maxN];
SegmentData S[maxN*400];
Question Q[maxN];
int rA[maxBit],rB[maxBit],cnt1,cnt2;

void Insert(int pos,int key,int opt);
void Modify(int &amp;now,int l,int r,int pos,int key);
int Query(int l,int r,int kth);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Arr[i]);
        Num[++numcnt]=Arr[i];
    }
    for (int i=1;i&lt;=m;i++)
    {
        Q[i].opt=getchar();
        while ((Q[i].opt!='Q')&amp;&amp;(Q[i].opt!='C')) Q[i].opt=getchar();
        if (Q[i].opt=='Q') scanf("%d%d%d",&amp;Q[i].a,&amp;Q[i].b,&amp;Q[i].c);
        if (Q[i].opt=='C')
        {
            scanf("%d%d",&amp;Q[i].a,&amp;Q[i].b);
            Num[++numcnt]=Q[i].b;
        }
    }
    //离散化
    sort(&amp;Num[1],&amp;Num[numcnt+1]);
    numcnt=unique(&amp;Num[1],&amp;Num[numcnt+1])-Num-1;

    for (int i=1;i&lt;=n;i++) Insert(i,find(Arr[i]),1);//初始化
    for (int i=1;i&lt;=m;i++)
        if (Q[i].opt=='Q')
        {
            cnt1=0;cnt2=0;//先分解成log个位置，方便查询
            for (int x=Q[i].a-1;x;x-=lowbit(x)) rA[++cnt1]=root[x];
            for (int x=Q[i].b;x;x-=lowbit(x)) rB[++cnt2]=root[x];
            printf("%d\n",Num[Query(1,numcnt,Q[i].c)]);
        }
        else
        {
            Insert(Q[i].a,find(Arr[Q[i].a]),-1);
            Arr[Q[i].a]=Q[i].b;
            Insert(Q[i].a,find(Arr[Q[i].a]),1);
        }
    return 0;
}

void Insert(int pos,int key,int opt)
{
    while (pos&lt;=n)
    {
        Modify(root[pos],1,numcnt,key,opt);
        pos+=lowbit(pos);
    }
    return;
}

void Modify(int &amp;now,int l,int r,int pos,int key)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].cnt+=key;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(S[now].ls,l,mid,pos,key);
    else Modify(S[now].rs,mid+1,r,pos,key);
    return;
}

int Query(int l,int r,int kth)//查询
{
    if (l==r) return l;
    int lsize=0;//运用树状数组的优良性质，查询左边值域的个数
    for (int i=1;i&lt;=cnt2;i++) lsize+=S[S[rB[i]].ls].cnt;
    for (int i=1;i&lt;=cnt1;i++) lsize-=S[S[rA[i]].ls].cnt;
    int mid=(l+r)&gt;&gt;1;
    if (lsize&gt;=kth)//分别向左边或右边走
    {
        for (int i=1;i&lt;=cnt1;i++) rA[i]=S[rA[i]].ls;
        for (int i=1;i&lt;=cnt2;i++) rB[i]=S[rB[i]].ls;
        return Query(l,mid,kth);
    }
    else
    {
        for (int i=1;i&lt;=cnt1;i++) rA[i]=S[rA[i]].rs;
        for (int i=1;i&lt;=cnt2;i++) rB[i]=S[rB[i]].rs;
        return Query(mid+1,r,kth-lsize);
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>638</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:08:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:08:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1901-zoj2122-luogu2617dynamic-rankings%ef%bc%88%e6%a0%91%e5%a5%97%e6%a0%91%ef%bc%8c%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[150]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2243/Luogu2486][SDOI2011]染色（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/639</link>
		<pubDate>Tue, 17 Apr 2018 13:16:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=639</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定一棵有n个节点的无根树和m个操作，操作有2类：
1、将节点a到节点b路径上所有点都染成颜色c；
2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。
请你写一个程序依次完成这m个操作。

<h3>Tag</h3>

树链剖分，线段树

<h2>解决思路</h2>

将树树链剖分后，考虑用线段树维护连续区间上的颜色段数量，那么合并两个区间时，对结果有影响的即为端点颜色，记录下来合并。在树链剖分跳链的时候，也记录下颜色 。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=100101;
const int maxM=maxN*2;
const int inf=2147483647;

class Data
{
public:
    int cnt;
    int left,right;
    int cover;
    Data(){
        cover=-1;
    }
};

int n,m;
int Col[maxN];
Data S[maxN&lt;&lt;2];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Size[maxN],Hson[maxN],Fa[maxN],Top[maxN],Depth[maxN];
int idcnt,Id[maxN],Di[maxN];

Data operator + (Data A,Data B);
void Add_Edge(int u,int v);
void dfs1(int u,int fa);
void dfs2(int u,int top);
void Build(int now,int l,int r);
void Modify_TC(int u,int v,int key);
int Query_TC(int u,int v);
void PushDown(int now);
void Modify_Seg(int now,int l,int r,int ql,int qr,int key);
Data Query_Seg(int now,int l,int r,int ql,int qr);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);

    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Col[i];
    for (int i=1;i&lt;n;i++)
    {
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        Add_Edge(u,v);Add_Edge(v,u);
    }
    Depth[1]=1;
    dfs1(1,1);dfs2(1,1);//树链剖分
    Build(1,1,n);

    while (m--)
    {
        char opt;cin&gt;&gt;opt;
        if (opt=='C')
        {
            int u,v,col;cin&gt;&gt;u&gt;&gt;v&gt;&gt;col;
            Modify_TC(u,v,col);
        }
        if (opt=='Q')
        {
            int u,v;cin&gt;&gt;u&gt;&gt;v;
            cout&lt;&lt;Query_TC(u,v)&lt;&lt;endl;
        }
    }
    return 0;
}

Data operator + (Data A,Data B)
{
    Data Ret;
    Ret.left=A.left;Ret.right=B.right;
    Ret.cnt=A.cnt+B.cnt-(A.right==B.left);//当端点有色相同时，颜色段个数-1
    return Ret;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u,int fa)
{
    Size[u]=1;Hson[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[V[i]]=u;Depth[V[i]]=Depth[u]+1;
            dfs1(V[i],u);
            Size[u]+=Size[V[i]];
            if (Size[Hson[u]]&lt;Size[V[i]]) Hson[u]=V[i];
        }
    return;
}

void dfs2(int u,int top)
{
    Top[u]=top;Id[u]=++idcnt;Di[idcnt]=u;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u]))
            dfs2(V[i],V[i]);
    return;
}

void Build(int now,int l,int r)//建树
{
    if (l==r)
    {
        S[now].cnt=1;S[now].left=S[now].right=Col[Di[l]];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    S[now]=S[lson]+S[rson];
    return;
}

void Modify_TC(int u,int v,int key)//修改
{
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        Modify_Seg(1,1,n,Id[Top[u]],Id[u],key);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    Modify_Seg(1,1,n,Id[u],Id[v],key);
    return;
}

int Query_TC(int u,int v)//查询
{
    int Ret=0,lastcolu=-1,lastcolv=-1;//注意这里要记录上一次的颜色段数量
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v),swap(lastcolu,lastcolv);//两个要同时交换
        Data G=Query_Seg(1,1,n,Id[Top[u]],Id[u]);
        Ret+=G.cnt-(G.right==lastcolu);
        lastcolu=G.left;
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v),swap(lastcolu,lastcolv);
    Data G=Query_Seg(1,1,n,Id[u],Id[v]);
    Ret+=G.cnt-(G.left==lastcolu)-(G.right==lastcolv);
    return Ret;
}

void PushDown(int now)
{
    if (S[now].cover!=-1)
    {
        int col=S[now].cover;
        S[lson].cnt=1;S[lson].left=S[lson].right=col;S[lson].cover=col;
        S[rson].cnt=1;S[rson].left=S[rson].right=col;S[rson].cover=col;
        S[now].cover=-1;
    }
    return;
}

void Modify_Seg(int now,int l,int r,int ql,int qr,int key)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        S[now].cover=S[now].left=S[now].right=key;
        S[now].cnt=1;S[now].cover=key;
        return;
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_Seg(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify_Seg(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify_Seg(lson,l,mid,ql,mid,key);
        Modify_Seg(rson,mid+1,r,mid+1,qr,key);
    }
    S[now]=S[lson]+S[rson];
    return;
}

Data Query_Seg(int now,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[now];
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query_Seg(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_Seg(rson,mid+1,r,ql,qr);
    else return Query_Seg(lson,l,mid,ql,mid)+Query_Seg(rson,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>639</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:16:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:16:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2243-luogu2486sdoi2011%e6%9f%93%e8%89%b2%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[164]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2527/Luogu3527][POI2011]Meteors（整体二分）</title>
		<link>http://sycstudio.com/archives/640</link>
		<pubDate>Tue, 17 Apr 2018 13:23:53 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=640</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Byteotian Interstellar Union有N个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为M份（第M份和第1份相邻），第i份上有第Ai个国家的太空站。
这个星球经常会下陨石雨。BIU已经预测了接下来K场陨石雨的情况。
BIU的第i个成员国希望能够收集Pi单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。

<h3>Tag</h3>

整体二分

<h2>解决思路</h2>

对于每一个国家，二分答案。每一次算到当前二分时间的mid，然后将已经满足的国家归到左边处理，还未满足的国家归到右边处理。
为了方便处理最后收集不满的国家，可以在最后面再加一个为inf的陨石雨，方便所有国家都收集满。
至于每一次陨石雨的计算，可以用树状数组来维护。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lowbit(x) ((x)&amp;(-(x)))

const int maxN=300100;
const int inf=2147483647;

int n,m,K;
int P[maxN],O[maxN];
int L[maxN],R[maxN],A[maxN];
int edgecnt=0,Head[maxN],Next[maxN],V[maxN];
int Ans[maxN],Last[maxN];
ll BIT[maxN],Sum[maxN];
int histcnt=0,Hist[maxN];
int Id[maxN],Bp[maxN];

void Add_Edge(int u,int v);
void Solve(int tl,int tr,int il,int ir);
void Add(int pos,int key);
ll Query(int pos);

int main()
{
    mem(Head,-1);

    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int o;scanf("%d",&amp;o);
        Add_Edge(o,i);
    }
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;P[i]);
    cin&gt;&gt;K;
    for (int i=1;i&lt;=K;i++) scanf("%d%d%d",&amp;L[i],&amp;R[i],&amp;A[i]);
    K++;L[K]=1;R[K]=m;A[K]=inf;

    for (int i=1;i&lt;=n;i++) Id[i]=i;
    Solve(1,K,1,n);

    for (int i=1;i&lt;=n;i++)
        if (Ans[i]==K) printf("NIE\n");
        else printf("%d\n",Ans[i]);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void Solve(int tl,int tr,int il,int ir)
{
    if (il&gt;ir) return;
    if (tl==tr)//得到对应区间答案
    {
        for (int i=il;i&lt;=ir;i++) Ans[Id[i]]=tl;
        return;
    }
    histcnt++;
    int mid=(tl+tr)&gt;&gt;1;
    for (int t=tl;t&lt;=mid;t++)//进行所有mid之前的陨石雨
        if (L[t]&lt;=R[t]) Add(L[t],A[t]),Add(R[t]+1,-A[t]);
        else Add(L[t],A[t]),Add(1,A[t]),Add(R[t]+1,-A[t]);
    int l=il,r=ir;
    for (int i=il;i&lt;=ir;i++)//统计每一个国家收集到的陨石雨
    {
        Sum[Id[i]]=0;
        for (int e=Head[Id[i]];e!=-1;e=Next[e])
        {
            Sum[Id[i]]+=Query(V[e]);
            if (Sum[Id[i]]+Last[Id[i]]&gt;P[Id[i]]) break;
        }
        //按照要求分为两类
        if (Sum[Id[i]]+Last[Id[i]]&gt;=P[Id[i]])  Bp[l++]=Id[i];
        else Bp[r--]=Id[i],Last[Id[i]]+=Sum[Id[i]];
    }
    for (int i=il;i&lt;=ir;i++) Id[i]=Bp[i];
    Solve(tl,mid,il,l-1);Solve(mid+1,tr,r+1,ir);//左右分治
    return;
}

void Add(int pos,int key)
{
    while (pos&lt;=m)
    {
        if (Hist[pos]!=histcnt) BIT[pos]=key,Hist[pos]=histcnt;
        else BIT[pos]+=key;
        pos+=lowbit(pos);
    }
    return;
}

ll Query(int pos)
{
    ll Ret=0;
    while (pos)
    {
        if (Hist[pos]==histcnt) Ret+=BIT[pos];
        pos-=lowbit(pos);
    }
    return Ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>640</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:23:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:23:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2527-luogu3527poi2011meteors%ef%bc%88%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="poi"><![CDATA[POI]]></category>
		<category domain="post_tag" nicename="poi"><![CDATA[POI]]></category>
		<category domain="category" nicename="%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86"><![CDATA[整体二分]]></category>
		<category domain="post_tag" nicename="%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86"><![CDATA[整体二分]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[171]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2957/Luogu4198]楼房重建（线段树）</title>
		<link>http://sycstudio.com/archives/641</link>
		<pubDate>Tue, 17 Apr 2018 13:26:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=641</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小A的楼房外有一大片施工工地，工地上有N栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。
为了简化问题，我们考虑这些事件发生在一个二维平面上。小A在平面上(0,0)点的位置，第i栋楼房可以用一条连接(i,0)和(i,Hi)的线段表示，其中Hi为第i栋楼房的高度。如果这栋楼房上任何一个高度大于0的点与(0,0)的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。
施工队的建造总共进行了M天。初始时，所有楼房都还没有开始建造，它们的高度均为0。在第i天，建筑队将会将横坐标为Xi的房屋的高度变为Yi(高度可以比原来大---修建，也可以比原来小---拆除，甚至可以保持不变---建筑队这天什么事也没做)。请你帮小A数数每天在建筑队完工之后，他能看到多少栋楼房？

<h3>Tag</h3>

线段树

<h2>解决思路</h2>

考虑维护区间内的答案。首先左半边是一定有答案的，再看右半边。若左半边的最大值大于右半边的，则右半边无贡献。否则，看右左半边和右右半边。对当前左半边的最高斜率讨论。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=100100;
const int inf=2147483647;

class SegmentData
{
public:
    int cnt;
    ld k;
};

int n,m;
SegmentData S[maxN&lt;&lt;2];

void Modify(int now,int l,int r,int pos,ld key);
int Query(int now,int l,int r,ld K);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    while (m--)
    {
        int x,y;scanf("%d%d",&amp;x,&amp;y);
        Modify(1,1,n,x,y);
        printf("%d\n",S[1].cnt);
    }
    return 0;
}

void Modify(int now,int l,int r,int pos,ld key)
{
    if (l==r)
    {
        S[now].k=key/(ld)pos;
        S[now].cnt=1;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(lson,l,mid,pos,key);
    else Modify(rson,mid+1,r,pos,key);
    S[now].k=max(S[lson].k,S[rson].k);
    S[now].cnt=S[lson].cnt+Query(rson,mid+1,r,S[lson].k);
    return;
}

int Query(int now,int l,int r,ld K)
{
    if (K&gt;=S[now].k) return 0;
    if (l==r) return 1;
    int mid=(l+r)&gt;&gt;1;
    if (S[lson].k&gt;=K) return Query(lson,l,mid,K)+S[now].cnt-S[lson].cnt;
    else return Query(rson,mid+1,r,K);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>641</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:26:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:26:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2957-luogu4198%e6%a5%bc%e6%88%bf%e9%87%8d%e5%bb%ba%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[185]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3110/Luogu3332][ZJOI2013]K大数查询（树套树，线段树）</title>
		<link>http://sycstudio.com/archives/642</link>
		<pubDate>Tue, 17 Apr 2018 13:30:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=642</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有N个位置，M个操作。操作有两种，每次操作如果是1 a b c的形式表示在第a个位置到第b个位置，每个位置加入一个数c
如果是2 a b c形式，表示询问从第a个位置到第b个位置，第C大的数是多少。

<h3>Tag</h3>

树套树，线段树

<h2>解决思路</h2>

外层维护权值线段树，内层维护位置线段树。修改则对外层单点修改，内层区间加法。查询则是在外层线段树上二分地查询。需要动态开点。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=50100;
const int inf=2147483647;

int n,m;
ll numcnt=0,Num[maxN];

class SegData
{
public:
    ll val,lazy;
    int ls,rs;
};

int nodecnt=0;
SegData S[maxN*200];

class InTree//内层线段树
{
public:
    int root;
    InTree(){
        root=0;return;
    }

    void Modify(int &amp;now,int l,int r,int ql,int qr,ll key){
        if (now==0) now=++nodecnt;
        S[now].val+=key*(qr-ql+1);
        if ((l==ql)&amp;&amp;(r==qr)){
            S[now].lazy+=key;return;
        }
        int mid=(l+r)&gt;&gt;1;
        if (qr&lt;=mid) Modify(S[now].ls,l,mid,ql,qr,key);
        else if (ql&gt;=mid+1) Modify(S[now].rs,mid+1,r,ql,qr,key);
        else
        {
            Modify(S[now].ls,l,mid,ql,mid,key);
            Modify(S[now].rs,mid+1,r,mid+1,qr,key);
        }
        return;
    }
    ll Query(int now,int l,int r,int ql,int qr){
        if (now==0) return 0;
        if ((l==ql)&amp;&amp;(r==qr)) return S[now].val;
        int mid=(l+r)&gt;&gt;1;
        ll Ret=S[now].lazy*(ll)(qr-ql+1);
        if (qr&lt;=mid) return Query(S[now].ls,l,mid,ql,qr)+Ret;
        else if (ql&gt;=mid+1) return Query(S[now].rs,mid+1,r,ql,qr)+Ret;
        else return Query(S[now].ls,l,mid,ql,mid)+Query(S[now].rs,mid+1,r,mid+1,qr)+Ret;
    }
};

class OutTree//外层线段树
{
public:
    InTree T[maxN&lt;&lt;2];
    void Modify(int now,int l,int r,int pos,int Rl,int Rr){
        T[now].Modify(T[now].root,1,n,Rl,Rr,1);
        if (l==r) return;
        int mid=(l+r)&gt;&gt;1;
        if (pos&lt;=mid) Modify(lson,l,mid,pos,Rl,Rr);
        else Modify(rson,mid+1,r,pos,Rl,Rr);
        return;
    }
    ll Query(int now,int l,int r,int Rl,int Rr,ll kth){
        if (l==r) return l;
        int mid=(l+r)&gt;&gt;1;
        ll G=T[rson].Query(T[rson].root,1,n,Rl,Rr);
        if (G&gt;=kth) return Query(rson,mid+1,r,Rl,Rr,kth);
        else return Query(lson,l,mid,Rl,Rr,kth-G);
    }
};

class Question
{
public:
    ll opt,a,b,c;
};

Question Q[maxN];
OutTree T;

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        scanf("%lld%lld%lld%lld",&amp;Q[i].opt,&amp;Q[i].a,&amp;Q[i].b,&amp;Q[i].c);
        if (Q[i].opt==1) Num[++numcnt]=Q[i].c;
    }
    sort(&amp;Num[1],&amp;Num[numcnt+1]);//离散化
    numcnt=unique(&amp;Num[1],&amp;Num[numcnt+1])-Num-1;
    for (int i=1;i&lt;=m;i++)
        if (Q[i].opt==1)
        {
            Q[i].c=lower_bound(&amp;Num[1],&amp;Num[numcnt+1],Q[i].c)-Num;
            T.Modify(1,1,numcnt,Q[i].c,Q[i].a,Q[i].b);
        }
        else
        {
            printf("%lld\n",Num[T.Query(1,1,numcnt,Q[i].a,Q[i].b,Q[i].c)]);
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>642</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:30:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:30:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3110-luogu3332zjoi2013k%e5%a4%a7%e6%95%b0%e6%9f%a5%e8%af%a2%ef%bc%88%e6%a0%91%e5%a5%97%e6%a0%91%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[231]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3211/Luogu4145/SPOJ GSS4]花神游历各国（线段树）</title>
		<link>http://sycstudio.com/archives/643</link>
		<pubDate>Tue, 17 Apr 2018 13:34:31 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=643</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="/media/BZOJ/BZOJ3211.gif" alt="BZOJ3211" />

<h3>Tag</h3>

线段树

<h2>解决思路</h2>

当开根到1或0的时候就不需要开根了。所以对每一个区间记录最大值，当最大值都小于等于1时，就不用向下了，否则，暴力向下修改。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=201000;
const int inf=2147483647;

class SegmentData
{
public:
    ll mx,sum;
};

int n,m;
ll Arr[maxN];
SegmentData S[maxN&lt;&lt;2];

void Build(int now,int l,int r);
void Modify(int now,int l,int r,int ql,int qr);
ll Query(int now,int l,int r,int ql,int qr);

int main()
{
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++) scanf("%lld\n",&amp;Arr[i]);
    Build(1,1,n);

    scanf("%d",&amp;m);
    while (m--)
    {
        int opt,l,r;scanf("%d%d%d",&amp;opt,&amp;l,&amp;r);
        if (opt==1) printf("%lld\n",Query(1,1,n,l,r));
        if (opt==2) Modify(1,1,n,l,r);
    }
    return 0;
}

void Build(int now,int l,int r)
{
    if (l==r)
    {
        S[now].mx=S[now].sum=Arr[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    S[now].sum=S[lson].sum+S[rson].sum;
    S[now].mx=max(S[lson].mx,S[rson].mx);
    return;
}

void Modify(int now,int l,int r,int ql,int qr)
{
    if (S[now].mx&lt;=1) return;
    if (l==r)
    {
        S[now].mx=sqrt(S[now].mx);S[now].sum=S[now].mx;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr);
    else
    {
        Modify(lson,l,mid,ql,mid);
        Modify(rson,mid+1,r,mid+1,qr);
    }
    S[now].sum=S[lson].sum+S[rson].sum;
    S[now].mx=max(S[lson].mx,S[rson].mx);
    return;
}

ll Query(int now,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query(rson,mid+1,r,ql,qr);
    else return Query(lson,l,mid,ql,mid)+Query(rson,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>643</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:34:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:34:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3211-luogu4145-spoj-gss4%e8%8a%b1%e7%a5%9e%e6%b8%b8%e5%8e%86%e5%90%84%e5%9b%bd%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[205]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3196/Luogu3380]二逼平衡树（树套树，线段树）</title>
		<link>http://sycstudio.com/archives/644</link>
		<pubDate>Tue, 17 Apr 2018 13:37:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=644</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1.查询k在区间内的排名
2.查询区间内排名为k的值
3.修改某一位值上的数值
4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)
5.查询k在区间内的后继(后继定义为大于x，且最小的数)

<h3>Tag</h3>

树套树，线段树

<h2>解决思路</h2>

值域线段树套位置线段树的做法，对于每一种操作分别处理。至于求严格前驱和严格后继，可以用求区间内某值域范围内的数的个数来解决

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define find(x) (lower_bound(&amp;Num[1],&amp;Num[numcnt+1],x)-Num)
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=50100;
const int inf=2147483647;

class SegmentData
{
public:
    int cnt;
    int ls,rs;
};

class Question
{
public:
    int opt,a,b,c;
};

int n,m,nodecnt;
int Arr[maxN];
int numcnt=0,Num[maxN*10];
int root[maxN*40];
SegmentData S[maxN*200];
Question Qs[maxN];

void Modify_out(int now,int l,int r,int val,int pos,int opt);
void Modify_in(int &amp;now,int l,int r,int pos,int opt);
int Query_out_rank(int now,int l,int r,int rl,int rr,int key);//查询[rl,rr]内key的排名
int Query_out_kth(int now,int l,int r,int rl,int rr,int kth);//查询[rl,rr]内排名为kth的数
int Query_out_cnt(int now,int l,int r,int vl,int vr,int rl,int rr);//查询区间内[vl,vr]的数的个数
int Query_in(int now,int l,int r,int ql,int qr);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Arr[i]);
        Num[++numcnt]=Arr[i];
    }
    for (int i=1;i&lt;=m;i++)
    {
        scanf("%d",&amp;Qs[i].opt);
        if (Qs[i].opt==3)
        {
            scanf("%d%d",&amp;Qs[i].a,&amp;Qs[i].b);
            Num[++numcnt]=Qs[i].b;
        }
        else
        {
            scanf("%d%d%d",&amp;Qs[i].a,&amp;Qs[i].b,&amp;Qs[i].c);
            Num[++numcnt]=Qs[i].c;
        }
    }
    sort(&amp;Num[1],&amp;Num[numcnt+1]);
    numcnt=unique(&amp;Num[1],&amp;Num[numcnt+1])-Num-1;

    for (int i=1;i&lt;=n;i++) Modify_out(1,1,numcnt,Arr[i]=find(Arr[i]),i,1);

    for (int i=1;i&lt;=m;i++)
    {
        if (Qs[i].opt==1) printf("%d\n",Query_out_rank(1,1,numcnt,Qs[i].a,Qs[i].b,find(Qs[i].c)));
        if (Qs[i].opt==2) printf("%d\n",Num[Query_out_kth(1,1,numcnt,Qs[i].a,Qs[i].b,Qs[i].c)]);
        if (Qs[i].opt==3)
        {
            int val=find(Qs[i].b),pos=Qs[i].a;
            Modify_out(1,1,numcnt,Arr[pos],pos,-1);
            Modify_out(1,1,numcnt,val,pos,1);
            Arr[pos]=val;
        }
        if (Qs[i].opt==4)
        {
            int val=find(Qs[i].c);
            int kcnt=Query_out_cnt(1,1,numcnt,val,val,Qs[i].a,Qs[i].b);
            int sumcnt=Query_out_cnt(1,1,numcnt,1,val,Qs[i].a,Qs[i].b);
            if (kcnt==sumcnt) printf("%d\n",-inf);
            else printf("%d\n",Num[Query_out_kth(1,1,numcnt,Qs[i].a,Qs[i].b,sumcnt-kcnt)]);
        }
        if (Qs[i].opt==5)
        {
            int val=find(Qs[i].c);
            int sumcnt=Query_out_cnt(1,1,numcnt,1,val,Qs[i].a,Qs[i].b);
            int allcnt=Query_out_cnt(1,1,numcnt,1,numcnt,Qs[i].a,Qs[i].b);
            if (sumcnt==allcnt) printf("%d\n",inf);
            else printf("%d\n",Num[Query_out_kth(1,1,numcnt,Qs[i].a,Qs[i].b,sumcnt+1)]);
        }
    }
    return 0;
}

void Modify_out(int now,int l,int r,int val,int pos,int opt)
{
    Modify_in(root[now],1,n,pos,opt);
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (val&lt;=mid) Modify_out(lson,l,mid,val,pos,opt);
    else Modify_out(rson,mid+1,r,val,pos,opt);
}

void Modify_in(int &amp;now,int l,int r,int pos,int opt)
{
    if (now==0) now=++nodecnt;
    S[now].cnt+=opt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify_in(S[now].ls,l,mid,pos,opt);
    else Modify_in(S[now].rs,mid+1,r,pos,opt);
}

int Query_out_rank(int now,int l,int r,int rl,int rr,int key)//查询[rl,rr]内key的排名
{
    if (l==r) return 1;
    int lsize=Query_in(root[lson],1,n,rl,rr);
    int mid=(l+r)&gt;&gt;1;
    if (key&lt;=mid) return Query_out_rank(lson,l,mid,rl,rr,key);
    else return Query_out_rank(rson,mid+1,r,rl,rr,key)+lsize;
}

int Query_out_kth(int now,int l,int r,int rl,int rr,int kth)//查询[rl,rr]内排名为kth的数
{
    if (l==r) return l;
    int lsize=Query_in(root[lson],1,n,rl,rr);
    int mid=(l+r)&gt;&gt;1;
    if (lsize&gt;=kth) return Query_out_kth(lson,l,mid,rl,rr,kth);
    else return Query_out_kth(rson,mid+1,r,rl,rr,kth-lsize);
}

int Query_out_cnt(int now,int l,int r,int vl,int vr,int rl,int rr)//查询[rl,rr]内[vl,vr]的数的个数
{
    if ((l==vl)&amp;&amp;(r==vr)) return Query_in(root[now],1,n,rl,rr);
    int mid=(l+r)&gt;&gt;1;
    if (vr&lt;=mid) return Query_out_cnt(lson,l,mid,vl,vr,rl,rr);
    else if (vl&gt;=mid+1) return Query_out_cnt(rson,mid+1,r,vl,vr,rl,rr);
    else return Query_out_cnt(lson,l,mid,vl,mid,rl,rr)+Query_out_cnt(rson,mid+1,r,mid+1,vr,rl,rr);
}

int Query_in(int now,int l,int r,int ql,int qr)
{
    if (now==0) return 0;
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].cnt;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query_in(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_in(S[now].rs,mid+1,r,ql,qr);
    else return Query_in(S[now].ls,l,mid,ql,mid)+Query_in(S[now].rs,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>644</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:37:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:37:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3196-luogu3380%e4%ba%8c%e9%80%bc%e5%b9%b3%e8%a1%a1%e6%a0%91%ef%bc%88%e6%a0%91%e5%a5%97%e6%a0%91%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[265]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4538/Luogu3250][HNOI2016]网络（树链剖分，线段树，堆）</title>
		<link>http://sycstudio.com/archives/645</link>
		<pubDate>Tue, 17 Apr 2018 13:41:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=645</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：1.  在某两个服务器之间出现一条新的数据交互请求；2.  某个数据交互结束请求；3.  某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。

<h3>Tag</h3>

树链剖分，线段树，堆

<h2>解决思路</h2>

把路径拆成覆盖不是这个的其他点，这样转化为补集问题，这样就比较好处理单点询问了。可以树链剖分后用线段树套堆的方法解决。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxM=maxN*2;
const int inf=2147483647;

class Heap//自己写的可删除堆
{
public:
    priority_queue&lt;int&gt; Q,Del;
    void MainTain(){
        while ((!Q.empty())&amp;&amp;(!Del.empty())&amp;&amp;(Q.top()==Del.top())) Q.pop(),Del.pop();
    }
    bool Empty(){
        MainTain();
        return (Q.size()-Del.size())==0;
    }
    void Push(int x){
        MainTain();
        Q.push(x);return;
    }
    int Top(){
        MainTain();
        return Q.top();
    }
    void Pop(){
        MainTain();Q.pop();
    }
    void Delete(int x){
        MainTain();Del.push(x);MainTain();return;
    }
};

class SegmentData
{
public:
    Heap H;
    int ls,rs;
};

class Range
{
public:
    int l,r;
};

int n,m,root,nodecnt;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
SegmentData S[maxN&lt;&lt;2];
int Hson[maxN],Top[maxN],Fa[maxN],Size[maxN],Depth[maxN];
int idcnt,Id[maxN];
int PU[maxN*2],PV[maxN*2],PW[maxN*2];

bool operator &lt; (Range A,Range B);
void Add_Edge(int u,int v);
void dfs1(int u,int fa);
void dfs2(int u,int top);
vector&lt;Range&gt; GetPath(int u,int v);
void Modify(int &amp;now,int l,int r,int ql,int qr,int key,int opt);
int Query(int now,int l,int r,int pos);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);Add_Edge(v,u);
    }
    Depth[n]=1;
    dfs1(n,n);dfs2(n,n);
    int pcnt=0;
    while (m--)
    {
        pcnt++;
        int opt;scanf("%d",&amp;opt);
        if (opt==0)
        {
            scanf("%d%d%d",&amp;PU[pcnt],&amp;PV[pcnt],&amp;PW[pcnt]);
            vector&lt;Range&gt; R=GetPath(PU[pcnt],PV[pcnt]);
            for (int i=0;i&lt;R.size();i++) Modify(root,1,n,R[i].l,R[i].r,PW[pcnt],1);
        }
        if (opt==1)
        {
            int t;scanf("%d",&amp;t);
            vector&lt;Range&gt; R=GetPath(PU[t],PV[t]);
            for (int i=0;i&lt;R.size();i++) Modify(root,1,n,R[i].l,R[i].r,PW[t],-1);
        }
        if (opt==2)
        {
            int x;scanf("%d",&amp;x);
            printf("%d\n",Query(root,1,n,Id[x]));
        }
    }
    return 0;
}

bool operator &lt; (Range A,Range B)
{
    if (A.l!=B.l) return A.l&lt;B.l;
    return A.r&lt;B.r;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u,int fa)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[V[i]]=u;Depth[V[i]]=Depth[u]+1;
            dfs1(V[i],u);
            Size[u]+=Size[V[i]];
            if (Size[V[i]]&gt;=Size[Hson[u]]) Hson[u]=V[i];
        }
    return;
}

void dfs2(int u,int top)
{
    Top[u]=top;
    Id[u]=++idcnt;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u]))
            dfs2(V[i],V[i]);
    return;
}

vector&lt;Range&gt; GetPath(int u,int v)
{
    //得到树链剖分后的序列
    vector&lt;Range&gt; Ran;Ran.clear();
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        Ran.push_back((Range){Id[Top[u]],Id[u]});
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    //把序列转化为补集形式
    Ran.push_back((Range){Id[u],Id[v]});
    sort(Ran.begin(),Ran.end());
    vector&lt;Range&gt; Ret;Ret.clear();
    if (Ran[0].l!=1) Ret.push_back((Range){1,Ran[0].l-1});
    for (int i=1;i&lt;Ran.size();i++) if (Ran[i-1].r+1&lt;=Ran[i].l-1) Ret.push_back((Range){Ran[i-1].r+1,Ran[i].l-1});
    if (Ran[Ran.size()-1].r!=n) Ret.push_back((Range){Ran[Ran.size()-1].r+1,n});
    return Ret;
}

void Modify(int &amp;now,int l,int r,int ql,int qr,int key,int opt)
{
    if (now==0) now=++nodecnt;
    if ((l==ql)&amp;&amp;(r==qr))
    {
        if (opt==1) S[now].H.Push(key);
        else S[now].H.Delete(key);
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(S[now].ls,l,mid,ql,qr,key,opt);
    else if (ql&gt;=mid+1) Modify(S[now].rs,mid+1,r,ql,qr,key,opt);
    else
    {
        Modify(S[now].ls,l,mid,ql,mid,key,opt);
        Modify(S[now].rs,mid+1,r,mid+1,qr,key,opt);
    }
    return;
}

int Query(int now,int l,int r,int pos)
{
    if (now==0) return -1;
    int Ret=-1;
    if (S[now].H.Empty()==0) Ret=S[now].H.Top();
    if (l==r) return Ret;
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) return max(Ret,Query(S[now].ls,l,mid,pos));
    else return max(Ret,Query(S[now].rs,mid+1,r,pos));
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>645</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 21:41:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 13:41:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4538-luogu3250hnoi2016%e7%bd%91%e7%bb%9c%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e5%a0%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[209]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2756][SCOI2012]奇怪的游戏（二分，网络流）</title>
		<link>http://sycstudio.com/archives/648</link>
		<pubDate>Sun, 06 May 2018 13:38:02 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=648</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Blinker最近喜欢上一个奇怪的游戏。
这个游戏在一个 N&#42;M 的棋盘上玩，每个格子有一个数。每次 Blinker 会选择两个相邻的格子，并使这两个数都加上 1。
现在 Blinker 想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出-1。

<h3>Tag</h3>

二分，网络流

<h2>解决思路</h2>

将格子黑白染色后，统计黑白格子的数量和分别的和。设数量分别为&#92;(cnt1,cnt2&#92;)，和分别为&#92;(sum1,sum2&#92;)，然后讨论。
对于黑白格子数量一样的，当&#92;(sum1!=sum2&#92;)时，一定无解，因为观察题目中的操作可以发现，每一次操作一定是给一个白色格子和一个黑色格子分别+1，而当黑色与白色格子一样时，若和不一样，则永远都不会一样，永远无解；当&#92;(sum1==sum2&#92;)时，一定有解，并且对于合法的答案&#92;(X&#92;)，&#92;(X+1&#92;)一定有解，那么可以二分这个答案，然后判定是否合法。
对于黑白格子数量不一样的，此时可以直接得出最后全部应该变成的数。设这个数为$X$，则一定有
$$X&#42;cnt1-sum1==X&#42;cnt2-sum2$$

那么移项既可以得到$X$的值，判断是否合法即可。
至于如何判断一个最终数$X$的合法性，建立源点和汇点，源点连向黑格，黑格连向相邻的白格，白格连向汇点，黑白格之间流量为无穷，而分别与源汇点的流量为原数值减去$X$。当满流即合法。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=51;
const int maxN=maxMap*maxMap;
const int maxM=maxN*20;
const int inf=2147483647;
const ll INF=1e17;

class Edge
{
public:
    int v;
    ll flow;
};

int n,m;
int S,T;
int edgecnt,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];
ll Id[maxMap][maxMap],Mat[maxMap][maxMap];

bool Check(ll num);
void Add_Edge(int u,int v,ll flow);
bool Bfs();
ll dfs(int u,ll flow);

int main()
{
    int Cas;
    scanf("%d",&amp;Cas);
    while (Cas--)
    {
        scanf("%d%d",&amp;n,&amp;m);S=n*m+1;T=S+1;
        ll sum1=0,sum2=0,idcnt=0,cnt1=0,cnt2=0;
        ll maxnum=0;
        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=m;j++)
            {
                scanf("%lld",&amp;Mat[i][j]);
                Id[i][j]=++idcnt;
                maxnum=max(maxnum,Mat[i][j]);
                if ((i+j)%2==0) sum1+=Mat[i][j],cnt1++;
                else sum2+=Mat[i][j],cnt2++;
            }
        if (cnt1==cnt2)
        {
            if (sum1!=sum2)
            {
                printf("-1\n");
                continue;
            }
            else
            {
                ll L=maxnum,R=1ll&lt;&lt;35;
                ll Num=0;
                do
                {
                    ll mid=(L+R)&gt;&gt;1;
                    if (Check(mid)) Num=mid,R=mid-1;
                    else L=mid+1;
                }
                while (L&lt;=R);
                printf("%lld\n",1ll*Num*cnt1-sum1);
            }
        }
        else
        {
            ll X=(sum1-sum2)/(cnt1-cnt2);
            if (X&lt;maxnum)
            {
                printf("-1\n");
                continue;
            }
            if (Check(X)) printf("%lld\n",1ll*X*cnt1-sum1);
            else printf("-1\n");
        }
    }
    return 0;
}

bool Check(ll num)
{
    mem(Head,-1);edgecnt=-1;
    ll sum=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
            if ((i+j)%2==0)
            {
                sum=sum+num-Mat[i][j];
                Add_Edge(S,Id[i][j],num-Mat[i][j]);
                if (i!=1) Add_Edge(Id[i][j],Id[i-1][j],INF);
                if (j!=1) Add_Edge(Id[i][j],Id[i][j-1],INF);
                if (i!=n) Add_Edge(Id[i][j],Id[i+1][j],INF);
                if (j!=m) Add_Edge(Id[i][j],Id[i][j+1],INF);
            }
            else Add_Edge(Id[i][j],T,num-Mat[i][j]);
    ll mxflow=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (ll di=dfs(S,inf))
            mxflow+=di;
    }
    if (mxflow==sum) return 1;
    else return 0;
}

void Add_Edge(int u,int v,ll flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;
    Depth[S]=1;Queue[1]=S;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

ll dfs(int u,ll flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            ll di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>648</wp:post_id>
		<wp:post_date><![CDATA[2018-05-06 21:38:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-06 13:38:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2756scoi2012%e5%a5%87%e6%80%aa%e7%9a%84%e6%b8%b8%e6%88%8f%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%8c%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[185]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[UOJ228]基础数据结构练习题（线段树）</title>
		<link>http://sycstudio.com/archives/649</link>
		<pubDate>Mon, 07 May 2018 07:44:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=649</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

sylvia 是一个热爱学习的女孩子，今天她想要学习数据结构技巧。
在看了一些博客学了一些姿势后，她想要找一些数据结构题来练练手。于是她的好朋友九条可怜酱给她出了一道题。
给出一个长度为 nn 的数列 AA，接下来有 mm 次操作，操作有三种：
    对于所有的 i∈[l,r]i∈[l,r]，将 AiAi 变成 Ai+xAi+x。
    对于所有的 i∈[l,r]i∈[l,r]，将 AiAi 变成 ⌊Ai‾‾√⌋⌊Ai⌋。
    对于所有的 i∈[l,r]i∈[l,r]，询问 AiAi 的和。
作为一个不怎么熟练的初学者，sylvia 想了好久都没做出来。而可怜酱又外出旅游去了，一时间联系不上。于是她决定向你寻求帮助：你能帮她解决这个问题吗。

<h3>Tag</h3>

线段树

<h2>解决思路</h2>

区间开根不满足加和性，所以只能暴力下放。
考虑有那些时候是可以简化开根操作的。首先，若区间内所有数都小于等于1，则不需要向下操作了。
其次，不断地开根会使得数值范围越来越小，那么若区间最大值与区间最小值开根后的结果相等，那么直接区间覆盖。
最后，当最大值$max-\sqrt{max}$与最小值$min-\sqrt{min}$相同，则打区间减法标记。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=101000;
const int inf=2147483647;

class SegmentData
{
public:
    ll sum,siz;
    ll mx,mn;
    ll cov,add;
    SegmentData(){
        cov=-1;return;
    }
};

int n,m;
int Arr[maxN];
SegmentData S[maxN&lt;&lt;2];

void Build(int now,int l,int r);
void Update(int now);
void PushDown(int now);
void Add(int now,ll key);
void Cover(int now,ll key);
void Modify_add(int now,int l,int r,int ql,int qr,ll key);
void Modify_sqrt(int now,int l,int r,int ql,int qr);
ll Query(int now,int l,int r,int ql,int qr); 

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]);
    Build(1,1,n);
    for (int i=1;i&lt;=m;i++)
    {
        int opt,l,r;scanf("%d%d%d",&amp;opt,&amp;l,&amp;r);
        if (opt==1)
        {
            int x;scanf("%d",&amp;x);
            Modify_add(1,1,n,l,r,x);
        }
        if (opt==2) Modify_sqrt(1,1,n,l,r);
        if (opt==3) printf("%lld\n",Query(1,1,n,l,r));
    }
    return 0;
}

void Build(int now,int l,int r)
{
    S[now].siz=r-l+1;
    if (l==r)
    {
        S[now].mx=S[now].mn=S[now].sum=Arr[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    Update(now);return;
}

void Update(int now)
{
    S[now].mn=min(S[lson].mn,S[rson].mn);
    S[now].mx=max(S[lson].mx,S[rson].mx);
    S[now].sum=S[lson].sum+S[rson].sum;
    return;
}

void PushDown(int now)
{
    if (S[now].add!=0)
    {
        Add(lson,S[now].add);Add(rson,S[now].add);
        S[now].add=0;
    }
    if (S[now].cov!=-1)
    {
        Cover(lson,S[now].cov);Cover(rson,S[now].cov);
        S[now].cov=-1;
    }
    return;
}

void Add(int now,ll key)
{
    S[now].mn+=key;S[now].mx+=key;
    S[now].sum+=key*S[now].siz;
    if (S[now].cov!=-1) S[now].cov+=key;
    else S[now].add+=key;
    return;
}

void Cover(int now,ll key)
{
    S[now].mn=S[now].mx=key;
    S[now].sum=key*S[now].siz;
    S[now].add=0;S[now].cov=key;
    return;
}

void Modify_add(int now,int l,int r,int ql,int qr,ll key)
{
    if ((l==ql)&amp;&amp;(r==qr)){
        Add(now,key);return;
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_add(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify_add(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify_add(lson,l,mid,ql,mid,key);
        Modify_add(rson,mid+1,r,mid+1,qr,key);
    }
    Update(now);return;
}

void Modify_sqrt(int now,int l,int r,int ql,int qr)
{
    if (S[now].mx&lt;=1) return;
    if ((l==ql)&amp;&amp;(r==qr))
    {
        int x1=sqrt(S[now].mx),x2=sqrt(S[now].mn);
        if (x1==x2)
        {
            Cover(now,x1);
            return;
        }
        if (S[now].mx-x1==S[now].mn-x2)
        {
            Add(now,x1-S[now].mx);
            return;
        }
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify_sqrt(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Modify_sqrt(rson,mid+1,r,ql,qr);
    else
    {
        Modify_sqrt(lson,l,mid,ql,mid);
        Modify_sqrt(rson,mid+1,r,mid+1,qr);
    }
    Update(now);return;
}

ll Query(int now,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query(rson,mid+1,r,ql,qr);
    else return Query(lson,l,mid,ql,mid)+Query(rson,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>649</wp:post_id>
		<wp:post_date><![CDATA[2018-05-07 15:44:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-07 07:44:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[uoj228%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%bb%83%e4%b9%a0%e9%a2%98%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="post_tag" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[193]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3997/Luogu3974][TJOI2015]组合数学（动态规划）</title>
		<link>http://sycstudio.com/archives/650</link>
		<pubDate>Mon, 07 May 2018 12:18:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=650</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给出一个网格图，其中某些格子有财宝，每次从左上角出发，只能向下或右走。问至少走多少次才能将财宝捡完。此对此问题变形，假设每个格子中有好多财宝，而每一次经过一个格子至多只能捡走一块财宝，至少走多少次才能把财宝全部捡完。

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

把网格图转化成为一个&#92;(DAG&#92;)，那么现在的问题就是，求用最少的链来覆盖所有的点。注意是链而不是路径，因为链只要求相邻的两个点有边到达而不要求直接相连。
然后由最小链覆盖=最长反链。反链的定义是对于反链上的u->v，u不能到v，v也不能到u。
然后，网络流？
注意网格图的性质，可以不用网络流。有点类似平面图转对偶图的思路，网格图上的反链是有一定规律的。设$F[i][j]$表示以$(i,j)$为左下角的网格中的最长反链。因为$(i,j)$与$(i-1,j),(i,j+1)$直接相连，而与$(i-1,j+1)$不直接相连，所以有转移式
$$F[i][j]=max(F[i-1][j],F[i][j+1],F[i-1][j+1]+Val[i][j])$$

<h2>代码</h2>

<pre class=" line-numbers"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int inf=2147483647;

int n,m;
ll Arr[maxN][maxN],F[maxN][maxN];

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        scanf("%d%d",&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%lld",&amp;Arr[i][j]);
        mem(F,0);
        for (int i=1;i&lt;=n;i++) for (int j=m;j&gt;=1;j--) F[i][j]=max(F[i-1][j+1]+Arr[i][j],max(F[i-1][j],F[i][j+1]));
        printf("%lld\n",F[n][1]);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>650</wp:post_id>
		<wp:post_date><![CDATA[2018-05-07 20:18:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-07 12:18:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3997-luogu3974tjoi2015%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%9b%be%e4%b8%8a%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[图上动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[199]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4383/Luogu3588][POI2015]Pustynia（差分约束，线段树，拓扑）</title>
		<link>http://sycstudio.com/archives/651</link>
		<pubDate>Mon, 07 May 2018 13:25:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=651</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定一,个长度为n的正整数序列a，每个数都在1到$10^9$范围内，告诉你其中s个数，并给出m条信息，每条信息包含三个数l,r,k以及接下来k个正整数，表示$a[l],a[l+1],...,a[r-1],a[r]$里这k个数中的任意一个都比任意一个剩下的r-l+1-k个数大（严格大于，即没有等号）。请任意构造出一组满足条件的方案，或者判断无解。

<h3>Tag</h3>

差分约束，线段树，拓扑

<h2>解决思路</h2>

$$-$$
题目中给出是若干点大于另外一些点的限制，那么也就是一些点大于等于另一些点$+1$。按照差分约束的思想，对于$x>y$，连边$y->x$，边权为$1$。
但是这样连边是$O(n^2)$的。对于区间$[l,r]$中的$k$个点，把这个区间最多分成$k+1$个区间。从区间着手，我们可以想到用线段树优化连边。
具体来说，对于每一组$(l,r,k)$，新建一个点$node$，从$node$分别向这$k$个点连权为$1$的边，表示这$k$个点比这个新建点大。那么接下来的任务就是把剩下的$(r-l+1)-k$个点连到$node$上，权为$0$。考虑到区间，所以在把每一个区间拆分成$log$个放到线段树上，从这些线段树上的点引边到$node$。注意，线段树的点也要连边，即从儿子向父亲连权为$0$的边
那么，用拓扑排序求一边，得到每一个点的权值下界。无解有三种情况，一是出现环，无法完成拓扑；二是某个点本来给定了权值，但这个给定的权值比得到的下界还要小，这时也无解；三是注意到题目中给出的值域要求在$1e9$内，所以若出现某个下界大于$1e9$，则也无解。

<h2>代码</h2>

<pre class=" line-numbers"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=101000;
const int maxQ=201000;
const int maxNode=(maxN&lt;&lt;2)+maxQ;
const int maxM=maxNode*10;
const int inf=2147483648;

int n,m,nodecnt;
int edgecnt=0,Head[maxNode],Next[maxM],V[maxM],W[maxM];
int Id[maxN],Input[maxN];
int Val[maxNode],Min[maxNode];
int Degree[maxNode],Queue[maxNode];

void Build(int now,int l,int r);
void Add_Edge(int u,int v,int w);
void Query(int now,int l,int r,int ql,int qr,int node);

int main()
{
    mem(Head,-1);mem(Val,-1);
    int know;
    scanf("%d%d%d",&amp;n,&amp;know,&amp;m);
    Build(1,1,n);//初始化线段树上的连边，同时记录下每一个序列中的编号对应的线段树节点位置
    for (int i=1;i&lt;=know;i++)
    {
        int pos,key;scanf("%d%d",&amp;pos,&amp;key);
        Val[Id[pos]]=Min[Id[pos]]=key;//对于已知的，直接赋值
    }
    for (int i=1;i&lt;=m;i++)
    {
        int l,r,k;scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
        nodecnt++;
        for (int j=1;j&lt;=k;j++) scanf("%d",&amp;Input[j]);
        for (int j=1;j&lt;=k;j++) Add_Edge(nodecnt,Id[Input[j]],1);//从新建点向这k个点连边
        Input[0]=l-1;Input[k+1]=r+1;
        for (int j=1;j&lt;=k+1;j++) if ((Input[j-1]+1!=Input[j])&amp;&amp;(Input[j-1]!=Input[j])) Query(1,1,n,Input[j-1]+1,Input[j]-1,nodecnt);//从线段树节点连边
    }
    int h=0,t=0;//拓扑排序
    for (int i=1;i&lt;=nodecnt;i++) if (Degree[i]==0) Queue[++h]=i;
    bool flag=1;
    do
    {
        int u=Queue[++t];
        Min[u]=max(Min[u],1);//注意值域下界为1
        if (Val[u]==-1) Val[u]=Min[u];
        else if (Val[u]&lt;Min[u]){//原来有值，但小于下界，则无解
            flag=0;break;
        }
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            Degree[V[i]]--;Min[V[i]]=max(Min[V[i]],Val[u]+W[i]);
            if (Degree[V[i]]==0) Queue[++h]=V[i];
        }
    }
    while (t!=h);
    for (int i=1;i&lt;=n;i++) if (Val[Id[i]]&gt;1e9) flag=0;//判断值域是否超过上限制
    if ((t!=nodecnt)||(flag==0)) printf("NIE\n");
    else
    {
        printf("TAK\n");
        for (int i=1;i&lt;=n;i++) printf("%d ",Val[Id[i]]);
        printf("\n");
    }
    return 0;
}

void Build(int now,int l,int r)
{
    nodecnt=max(nodecnt,now);
    if (l==r){
        Id[l]=now;return;
    }
    int mid=(l+r)&gt;&gt;1;
    Add_Edge(lson,now,0);Add_Edge(rson,now,0);
    Build(lson,l,mid);Build(rson,mid+1,r);
    return;
}

void Add_Edge(int u,int v,int w)
{
    Degree[v]++;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void Query(int now,int l,int r,int ql,int qr,int node)//从线段树[ql,qr]区间的点连到node
{
    if ((l==ql)&amp;&amp;(r==qr)){
        Add_Edge(now,node,0);return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Query(lson,l,mid,ql,qr,node);
    else if (ql&gt;=mid+1) Query(rson,mid+1,r,ql,qr,node);
    else
    {
        Query(lson,l,mid,ql,mid,node);
        Query(rson,mid+1,r,mid+1,qr,node);
    }
    return;
}
</code></pre>

$$-$$]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>651</wp:post_id>
		<wp:post_date><![CDATA[2018-05-07 21:25:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-07 13:25:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4383-luogu3588poi2015pustynia%ef%bc%88%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e6%8b%93%e6%89%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="poi"><![CDATA[POI]]></category>
		<category domain="post_tag" nicename="poi"><![CDATA[POI]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f"><![CDATA[差分约束]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86%e7%ba%a6%e6%9d%9f"><![CDATA[差分约束]]></category>
		<category domain="category" nicename="%e6%8b%93%e6%89%91"><![CDATA[拓扑]]></category>
		<category domain="post_tag" nicename="%e6%8b%93%e6%89%91"><![CDATA[拓扑]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[262]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1037/Luogu2592][ZJOI2008]生日聚会Party（动态规划）</title>
		<link>http://sycstudio.com/archives/652</link>
		<pubDate>Tue, 08 May 2018 12:37:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=652</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：对于任意连续的一段，男孩与女孩的数目之差不超过k。很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题…… 假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

$$-$$
考虑如何限制这个任意连续段男女数目只差不超过$$k$$。
对于一个合法的序列，我们在这个序列右边加入一个人，那么是否能加入这个人取决于以原右端点为右边的所有序列中男-女的最大值和女-男的最大值。
所以设$$F[i][j][k][l]$$表示选择了$i$个男生，$j$个女生，右端点男-女的最大值为$k$，女-男的最大值为$l$时的方案数。按照当前选择放置男还是女来转移。
注意，由于可能出现男生永远比女生多或反过来的情况，所以$$k,l$$可能是负值，这个直接归到$0$的情况就好。

<h2>代码</h2>

<pre class=" line-numbers"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=151;
const int maxK=21;
const int Mod=12345678;
const int inf=2147483647;

int n,m,K;
int F[maxN*2][maxN][maxK][maxK];

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
    F[0][0][0][0]=1;
    for (int i=0;i&lt;=n;i++)
        for (int j=0;j&lt;=m;j++)
            for (int k=0;k&lt;=K;k++)
                for (int l=0;l&lt;=K;l++)
                {
                    if ((i&lt;n)&amp;&amp;(k&lt;K)) F[i+1][j][k+1][max(0,l-1)]=(F[i+1][j][k+1][max(0,l-1)]+F[i][j][k][l])%Mod;
                    if ((j&lt;m)&amp;&amp;(l&lt;K)) F[i][j+1][max(0,k-1)][l+1]=(F[i][j+1][max(0,k-1)][l+1]+F[i][j][k][l])%Mod;
                }
    int Ans=0;
    for (int i=0;i&lt;=K;i++) for (int j=0;j&lt;=K;j++) Ans=(Ans+F[n][m][i][j])%Mod;
    printf("%d\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>652</wp:post_id>
		<wp:post_date><![CDATA[2018-05-08 20:37:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-08 12:37:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1037-luogu2592zjoi2008%e7%94%9f%e6%97%a5%e8%81%9a%e4%bc%9aparty%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[201]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3073][PA2011]Journeys（最短路径，线段树）</title>
		<link>http://sycstudio.com/archives/653</link>
		<pubDate>Tue, 08 May 2018 12:50:22 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=653</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Seter建造了一个很大的星球，他准备建造N个国家和无数双向道路。N个国家很快建造好了，用1..N编号，但是他发现道路实在太多了，他要一条条建简直是不可能的！于是他以如下方式建造道路：(a,b),(c,d)表示，对于任意两个国家x,y，如果a&lt;=x&lt;=b,c&lt;=y&lt;=d，那么在xy之间建造一条道路。Seter保证一条道路不会修建两次，也保证不会有一个国家与自己之间有道路。
Seter好不容易建好了所有道路，他现在在位于P号的首都。Seter想知道P号国家到任意一个国家最少需要经过几条道路。当然，Seter保证P号国家能到任意一个国家。

<h3>Tag</h3>

最短路径，线段树

<h2>解决思路</h2>

如果数据范围小一点的话，那么这就是最短路径的题。但由于是区间连边，最坏情况下边数可能到达爆炸的$$O(n^2m)$$，所以考虑优化连边。
由区间可以想到处理区间的利器——线段树。对于双向路径$(a,b)-(c,d)$，我们把它拆成两条单向的路径。对于每一组$(a,b)->(c,d)$，我们新建立一个虚点$node$，然后考虑如何建图。
单个一棵线段树是无法处理双向边的问题的，不妨建立两棵线段树，一棵成为出线段树，即$(a,b)->node$，反之，另一颗为入线段树。建边如下。
首先是线段树上的建边。对于出线段树，从儿子指向父亲，表示若能到达儿子，则也能到达父亲，权为0；对于入线段树，从父亲指向儿子，表示若能到达父亲，也能到达儿子，权为0；另外再从入线段树的点直到对应出线段树的节点，权为0。
然后是$$(a,b)->(c,d)$$。在出线段树上找到$(a,b)$对应的$log$个区间，分别从这些区间连到$node$，权为$1$；再在入线段树上找到$(c,d)$对应的$log$个区间，从$node$连边到这些区间，权为$0$。
然后跑最短路，最后的答案就在每一个点对应的第一棵线段树的节点上。

<h2>代码</h2>

<pre class=" line-numbers"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=501000;
const int maxQ=101000;
const int maxNode=((maxN&lt;&lt;2)+(maxQ&lt;&lt;1))&lt;&lt;1;
const int maxM=maxNode*10;
const int inf=2147483647;

class HeapData
{
public:
    int u,dist;
};

int n,m,P;
int Id1[maxN],Id2[maxN],nodesum,nodecnt;
int edgecnt=0,Head[maxNode],Next[maxM],V[maxM],W[maxM];
bool vis[maxNode];
int Dist[maxNode];
priority_queue&lt;HeapData&gt; H;

bool operator &lt; (HeapData A,HeapData B);
void Add_Edge(int u,int v,int w);
void Build1(int now,int l,int r);
void Build2(int now,int l,int r);
void Add1(int now,int l,int r,int ql,int qr,int node,int opt);
void Add2(int now,int l,int r,int ql,int qr,int node,int opt);

int main()
{
    mem(Head,-1);
    scanf("%d%d%d",&amp;n,&amp;m,&amp;P);
    Build1(1,1,n);Build2(1,1,n);//建树
    nodecnt=nodesum&lt;&lt;1;
    for (int i=1;i&lt;=m;i++)
    {
        int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);
        nodecnt++;
        Add1(1,1,n,a,b,nodecnt,0);
        Add2(1,1,n,c,d,nodecnt,1);
        nodecnt++;
        Add1(1,1,n,c,d,nodecnt,0);
        Add2(1,1,n,a,b,nodecnt,1);
    }
    mem(Dist,-1);P=Id1[P];Dist[P]=0;H.push((HeapData){P,0});
    do
    {
        int u=H.top().u;H.pop();
        if (vis[u]) continue;
        vis[u]=1;
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;((Dist[V[i]]==-1)||(Dist[V[i]]&gt;Dist[u]+W[i])))
            {
                Dist[V[i]]=Dist[u]+W[i];
                H.push((HeapData){V[i],Dist[V[i]]});
            }
    }
    while (!H.empty());
    for (int i=1;i&lt;=n;i++) printf("%d\n",Dist[Id1[i]]);
    return 0;
}

bool operator &lt; (HeapData A,HeapData B)
{
    return A.dist&gt;B.dist;
}

void Add_Edge(int u,int v,int w)
{
    //cout&lt;&lt;"Add:"&lt;&lt;u&lt;&lt;"-&gt;"&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
}

void Build1(int now,int l,int r)
{
    if (l==r){
        Id1[l]=now;nodesum=max(nodesum,now);return;
    }
    int mid=(l+r)&gt;&gt;1;
    Add_Edge(lson,now,0);Add_Edge(rson,now,0);
    Build1(lson,l,mid);Build1(rson,mid+1,r);
    return;
}

void Build2(int now,int l,int r)
{
    Add_Edge(now+nodesum,now,0);
    if (l==r){
        Id2[l]=now+nodesum;return;
    }
    int mid=(l+r)&gt;&gt;1;
    Add_Edge(now+nodesum,lson+nodesum,0);Add_Edge(now+nodesum,rson+nodesum,0);
    Build2(lson,l,mid);Build2(rson,mid+1,r);
    return;
}

void Add1(int now,int l,int r,int ql,int qr,int node,int opt)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        if (opt==0) Add_Edge(now,node,1);
        else Add_Edge(node,now,0);
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Add1(lson,l,mid,ql,qr,node,opt);
    else if (ql&gt;=mid+1) Add1(rson,mid+1,r,ql,qr,node,opt);
    else
    {
        Add1(lson,l,mid,ql,mid,node,opt);
        Add1(rson,mid+1,r,mid+1,qr,node,opt);
    }
    return;
}

void Add2(int now,int l,int r,int ql,int qr,int node,int opt)
{
    if ((l==ql)&amp;&amp;(r==qr))
    {
        if (opt==0) Add_Edge(now+nodesum,node,1);
        else Add_Edge(node,now+nodesum,0);
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Add2(lson,l,mid,ql,qr,node,opt);
    else if (ql&gt;=mid+1) Add2(rson,mid+1,r,ql,qr,node,opt);
    else
    {
        Add2(lson,l,mid,ql,mid,node,opt);
        Add2(rson,mid+1,r,mid+1,qr,node,opt);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>653</wp:post_id>
		<wp:post_date><![CDATA[2018-05-08 20:50:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-08 12:50:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3073pa2011journeys%ef%bc%88%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="pa"><![CDATA[PA]]></category>
		<category domain="post_tag" nicename="pa"><![CDATA[PA]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[251]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4892/Luogu3763][TJOI2017]DNA（二分，Hash）</title>
		<link>http://sycstudio.com/archives/655</link>
		<pubDate>Wed, 09 May 2018 07:20:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=655</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列S,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列S,任意修改其中不超过3个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在DNA链S0上的位置。所以你需要统计在一个表现出吃藕性状的人的DNA序列S0上，有多少个连续子串可能是该基因，即有多少个S0的连续子串修改小于等于三个字母能够变成S。

<h3>Tag</h3>

二分，Hash

<h2>解决思路</h2>

枚举起始位置，然后求四遍$lcp$，若四遍以内能够匹配完，则说明能够匹配，否则不行。
求$lcp$有两种方式，一种是后缀数组+$rmp$的方式，另一种是二分+$hash$，这里采用二分+$hash$的方式。

<h2>代码</h2>

<pre class=" line-numbers"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const ull Base=37;
const int inf=2147483647;

int L1,L2;
char str1[maxN],str2[maxN];
ull H1[maxN],H2[maxN];
ull R[maxN];

void InitHash(char *str,ull *H);
ull GetHash(ull *H,int l,int r);

int main()
{
    int T;scanf("%d",&amp;T);
    R[0]=1;
    for (int i=1;i&lt;maxN;i++) R[i]=R[i-1]*Base;
    while (T--)
    {
        scanf("%s",str1+1);scanf("%s",str2+1);
        L1=strlen(str1+1);L2=strlen(str2+1);
        if (L1&lt;L2)
        {
            printf("0\n");
            continue;
        }
        InitHash(str1,H1);InitHash(str2,H2);
        int Ans=0;
        for (int i=1;i+L2-1&lt;=L1;i++)
        {
            int l1=i,l2=1;
            for (int tim=1;tim&lt;=4;tim++)
            {
                int L=l1,R=i+L2-1;
                int pos=l1-1;
                do
                {
                    int mid=(L+R)&gt;&gt;1;int sz=mid-l1+1;
                    if (GetHash(H1,l1,mid)==GetHash(H2,l2,l2+sz-1)){
                        L=mid+1;pos=mid;
                    }
                    else R=mid-1;
                }
                while (L&lt;=R);
                l1=pos+2;l2=pos-i+3;
                if (tim==4) l1--,l2--;
                if (l1&gt;i+L2-1) break;
            }
            if (l1&gt;i+L2-1) Ans++;
        }
        printf("%d\n",Ans);
    }
    return 0;
}

void InitHash(char *str,ull *H)
{
    int len=strlen(str+1);
    H[0]=0;
    for (int i=1;i&lt;=len;i++) H[i]=H[i-1]*Base+str[i];
    return;
}

ull GetHash(ull *H,int l,int r)
{
    return H[r]-H[l-1]*R[r-l+1];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>655</wp:post_id>
		<wp:post_date><![CDATA[2018-05-09 15:20:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-09 07:20:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4892-luogu3763tjoi2017dna%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%8chash%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[177]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2648]SJY摆棋子（KDT）</title>
		<link>http://sycstudio.com/archives/656</link>
		<pubDate>Fri, 11 May 2018 02:58:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=656</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

这天，SJY显得无聊。在家自己玩。在一个棋盘上，有N个黑色棋子。他每次要么放到棋盘上一个黑色棋子，要么放上一个白色棋子，如果是白色棋子，他会找出距离这个白色棋子最近的黑色棋子。此处的距离是 曼哈顿距离 即(|x1-x2|+|y1-y2|) 。现在给出N&lt;=500000个初始棋子。和M&lt;=500000个操作。对于每个白色棋子，输出距离这个白色棋子最近的黑色棋子的距离。同一个格子可能有多个棋子。

<h3>Tag</h3>

KDT

<h2>解决思路</h2>

运用$KDT$求最近点。当插入过多点时可以重构。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=501000*2;
const int maxK=2;
const int inf=2147483647;

class KDT
{
public:
    int P[maxK],Mn[maxK],Mx[maxK];
    int ls,rs;
};

int n,m;
int nowD,root,Ans;
KDT T[maxN];

bool operator &lt; (KDT A,KDT B);
int Build(int l,int r,int D);
void Update(int now);
void Insert(int now,int D);
void Query(int now,int x,int y);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d%d",&amp;T[i].P[0],&amp;T[i].P[1]);
    root=Build(1,n,0);
    for (int i=1;i&lt;=m;i++)
    {
        int opt,x,y;scanf("%d%d%d",&amp;opt,&amp;x,&amp;y);
        if (opt==1)
        {
            T[++n].P[0]=x;T[n].P[1]=y;
            for (int j=0;j&lt;2;j++) T[n].Mn[j]=T[n].Mx[j]=T[n].P[j];
            Insert(root,0);
            if (i%100000==0) root=Build(1,n,0);
        }
        else
        {
            Ans=inf;
            Query(root,x,y);
            printf("%d\n",Ans);
        }
    }
    return 0;
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

int Build(int l,int r,int D)
{
    if (l&gt;r) return 0;
    int mid=(l+r)&gt;&gt;1;
    nowD=D;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    for (int i=0;i&lt;2;i++) T[mid].Mn[i]=T[mid].Mx[i]=T[mid].P[i];
    T[mid].ls=Build(l,mid-1,D^1);
    T[mid].rs=Build(mid+1,r,D^1);
    Update(mid);return mid;
}

void Update(int now)
{
    for (int i=0;i&lt;2;i++)
    {
        if (T[now].ls) T[now].Mn[i]=min(T[now].Mn[i],T[T[now].ls].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[T[now].ls].Mx[i]);
        if (T[now].rs) T[now].Mn[i]=min(T[now].Mn[i],T[T[now].rs].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[T[now].rs].Mx[i]);
    }
    return;
}

void Insert(int now,int D)
{
    if (T[now].P[D]&gt;T[n].P[D])
    {
        if (T[now].ls) Insert(T[now].ls,D^1);
        else T[now].ls=n;
    }
    else
    {
        if (T[now].rs) Insert(T[now].rs,D^1);
        else T[now].rs=n;
    }
    Update(now);return;
}

void Query(int now,int x,int y)
{
    Ans=min(Ans,abs(x-T[now].P[0])+abs(y-T[now].P[1]));
    int dl=inf,dr=inf;
    int ls=T[now].ls,rs=T[now].rs;
    if (T[now].ls) dl=max(0,x-T[ls].Mx[0])+max(0,T[ls].Mn[0]-x)+max(0,y-T[ls].Mx[1])+max(0,T[ls].Mn[1]-y);
    if (T[now].rs) dr=max(0,x-T[rs].Mx[0])+max(0,T[rs].Mn[0]-x)+max(0,y-T[rs].Mx[1])+max(0,T[rs].Mn[1]-y);
    if (dl&lt;dr)
    {
        if (dl&lt;Ans) Query(ls,x,y);
        if (dr&lt;Ans) Query(rs,x,y);
    }
    else
    {
        if (dr&lt;Ans) Query(rs,x,y);
        if (dl&lt;Ans) Query(ls,x,y);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>656</wp:post_id>
		<wp:post_date><![CDATA[2018-05-11 10:58:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-11 02:58:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2648sjy%e6%91%86%e6%a3%8b%e5%ad%90%ef%bc%88kdt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[155]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1941/Luogu2479][SDOI2010]Hide and Seek（KDT）</title>
		<link>http://sycstudio.com/archives/658</link>
		<pubDate>Fri, 11 May 2018 08:21:06 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=658</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小猪iPig在PKU刚上完了无聊的猪性代数课，天资聪慧的iPig被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友giPi（鸡皮）玩一个更加寂寞的游戏---捉迷藏。 但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。一番寂寞的剪刀石头布后，他们决定iPig去捉giPi。由于他们都很熟悉PKU的地形了，所以giPi只会躲在PKU内n个隐秘地点，显然iPig也只会在那n个地点内找giPi。游戏一开始，他们选定一个地点，iPig保持不动，然后giPi用30秒的时间逃离现场（显然，giPi不会呆在原地）。然后iPig会随机地去找giPi，直到找到为止。由于iPig很懒，所以他到总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。 由于iPig现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig告诉了你PKU的n个隐秘地点的坐标，请你编程求出iPig的问题。

<h3>Tag</h3>

KDT

<h2>解决思路</h2>

直接枚举每一个点，然后求与这个点最近的点和最远的点。这个可以用$$KDT$$求，注意要去掉自己。由于保证了题目中没有重复的点，所以在求最小距离的时候只要判断不是$$0$$即可。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=501000;
const int inf=2147483647;

class KDT
{
public:
    int ls,rs;
    int P[2],Mn[2],Mx[2];
};

int n;
KDT T[maxN];
int root,nowD;
int Min,Max;

bool operator &lt; (KDT A,KDT B);
int Build(int l,int r,int D);
void Update(int now);
void Query_max(int now,int x,int y);
void Query_min(int now,int x,int y);

int main()
{
    scanf("%d",&amp;n);
    for (int i=1;i&lt;=n;i++) scanf("%d%d",&amp;T[i].P[0],&amp;T[i].P[1]);
    root=Build(1,n,0);
    int Ans=inf;
    for (int i=1;i&lt;=n;i++)
    {
        Min=inf;Max=-inf;
        Query_max(root,T[i].P[0],T[i].P[1]);Query_min(root,T[i].P[0],T[i].P[1]);
        Ans=min(Ans,Max-Min);
    }
    printf("%d\n",Ans);
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

int Build(int l,int r,int D)//建树
{
    if (l&gt;r) return 0;
    nowD=D;
    int mid=(l+r)&gt;&gt;1;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    for (int i=0;i&lt;2;i++) T[mid].Mn[i]=T[mid].Mx[i]=T[mid].P[i];
    T[mid].ls=Build(l,mid-1,D^1);
    T[mid].rs=Build(mid+1,r,D^1);
    Update(mid);return mid;
}

void Update(int now)
{
    int ls=T[now].ls,rs=T[now].rs;
    for (int i=0;i&lt;2;i++)
    {
        if (ls) T[now].Mn[i]=min(T[now].Mn[i],T[ls].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[ls].Mx[i]);
        if (rs) T[now].Mn[i]=min(T[now].Mn[i],T[rs].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[rs].Mx[i]);
    }
    return;
}

void Query_max(int now,int x,int y)//求最大距离
{
    Max=max(Max,abs(x-T[now].P[0])+abs(y-T[now].P[1]));
    int dl=-inf,dr=-inf;
    int ls=T[now].ls,rs=T[now].rs;
    if (ls) dl=max(abs(T[ls].Mn[0]-x),abs(T[ls].Mx[0]-x))+max(abs(T[ls].Mn[1]-y),abs(T[ls].Mx[1]-y));
    if (rs) dr=max(abs(T[rs].Mn[0]-x),abs(T[rs].Mx[0]-x))+max(abs(T[rs].Mn[1]-y),abs(T[rs].Mx[1]-y));
    if (dl&gt;dr)
    {
        if (dl&gt;Max) Query_max(ls,x,y);
        if (dr&gt;Max) Query_max(rs,x,y);
    }
    else
    {
        if (dr&gt;Max) Query_max(rs,x,y);
        if (dl&gt;Max) Query_max(ls,x,y);
    }
    return;
}

void Query_min(int now,int x,int y)//求最小距离
{
    if (abs(x-T[now].P[0])+abs(y-T[now].P[1])!=0) Min=min(Min,abs(x-T[now].P[0])+abs(y-T[now].P[1]));
    int dl=inf,dr=inf;
    int ls=T[now].ls,rs=T[now].rs;
    if (ls) dl=max(0,T[ls].Mn[0]-x)+max(0,x-T[ls].Mx[0])+max(0,T[ls].Mn[1]-y)+max(0,y-T[ls].Mx[1]);
    if (rs) dr=max(0,T[rs].Mn[0]-x)+max(0,x-T[rs].Mx[0])+max(0,T[rs].Mn[1]-y)+max(0,y-T[rs].Mx[1]);
    if (dl&lt;dr)
    {
        if (dl&lt;Min) Query_min(ls,x,y);
        if (dr&lt;Min) Query_min(rs,x,y);
    }
    else
    {
        if (dr&lt;Min) Query_min(rs,x,y);
        if (dl&lt;Min) Query_min(ls,x,y);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>658</wp:post_id>
		<wp:post_date><![CDATA[2018-05-11 16:21:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-11 08:21:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1941-luogu2479sdoi2010hide-and-seek%ef%bc%88kdt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[174]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4520/Luogu4357][CQOI2016]K远点对（KDT，堆）</title>
		<link>http://sycstudio.com/archives/859</link>
		<pubDate>Sun, 13 May 2018 15:42:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=859</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

已知平面内 N 个点的坐标，求欧氏距离下的第 K 远点对。

<h3>Tag</h3>

KDT，堆

<h2>解决思路</h2>

用小根堆维护当前得到的前$$K$$大的距离，用$$KDT$$优化暴力寻找距离的方式。
注意，由于在用$$KDT$$的时候点对是无序的，所以要存$$2K$$个值。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))

const int maxN=101000*2;
const int inf=2147483647;

class KDT
{
public:
    int ls,rs;
    ll P[2],Mn[2],Mx[2];
};

int n,K;
int nowD,root;
KDT T[maxN];
priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; H;

bool operator &lt; (KDT A,KDT B);
int Build(int l,int r,int D);
void Update(int now);
void Query(int now,ll x,ll y);

int main()
{
    scanf("%d%d",&amp;n,&amp;K);K=K&lt;&lt;1;
    for (int i=1;i&lt;=K;i++) H.push(0ll);
    for (int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;T[i].P[0],&amp;T[i].P[1]);
    root=Build(1,n,0);
    for (int i=1;i&lt;=n;i++) Query(root,T[i].P[0],T[i].P[1]);
    printf("%lld\n",H.top());
    return 0;
}

int Build(int l,int r,int D)//建树
{
    if (l&gt;r) return 0;
    int mid=(l+r)&gt;&gt;1;
    nowD=D;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    T[mid].Mx[0]=T[mid].Mn[0]=T[mid].P[0];
    T[mid].Mx[1]=T[mid].Mn[1]=T[mid].P[1];
    T[mid].ls=Build(l,mid-1,D^1);
    T[mid].rs=Build(mid+1,r,D^1);
    Update(mid);return mid;
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

void Update(int now)
{
    int ls=T[now].ls,rs=T[now].rs;
    if (ls) T[now].Mn[0]=min(T[now].Mn[0],T[ls].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[ls].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[ls].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[ls].Mx[1]);
    if (rs) T[now].Mn[0]=min(T[now].Mn[0],T[rs].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[rs].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[rs].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[rs].Mx[1]);
    return;
}

void Query(int now,ll x,ll y)//KDT优化查询
{
    ll d=sqr(T[now].P[0]-x)+sqr(T[now].P[1]-y);
    if (d&gt;H.top()){
        H.pop();H.push(d);
    }
    ll dl=-inf,dr=-inf;
    int ls=T[now].ls,rs=T[now].rs;
    if (ls) dl=max(sqr(x-T[ls].Mn[0]),sqr(x-T[ls].Mx[0]))+max(sqr(y-T[ls].Mn[1]),sqr(y-T[ls].Mx[1]));
    if (rs) dr=max(sqr(x-T[rs].Mn[0]),sqr(x-T[rs].Mx[0]))+max(sqr(y-T[rs].Mn[1]),sqr(y-T[rs].Mx[1]));
    if (dl&gt;=dr)
    {
        if (H.top()&lt;dl) Query(ls,x,y);
        if (H.top()&lt;dr) Query(rs,x,y);
    }
    else
    {
        if (H.top()&lt;dr) Query(rs,x,y);
        if (H.top()&lt;dl) Query(ls,x,y);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>859</wp:post_id>
		<wp:post_date><![CDATA[2018-05-13 23:42:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-13 15:42:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4520-luogu4357cqoi2016k%e8%bf%9c%e7%82%b9%e5%af%b9%ef%bc%88kdt%ef%bc%8c%e5%a0%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[164]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4066/Luogu4148]简单题（KDT）</title>
		<link>http://sycstudio.com/archives/862</link>
		<pubDate>Mon, 14 May 2018 12:28:22 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=862</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

你有一个 N×NN \times NN×N 的棋盘，每个格子内有一个整数，初始时的时候全部为0，现在需要维护两种操作：
1 x y A 1≤x,y≤N1\le x,y\le N1≤x,y≤N$$ ，A是正整数。将格子x,y里的数字加上 AAA
2 x1 y1 x2 y2 1≤x1≤x2≤N1 \le x_1 \le x_2 \le N1≤x1​≤x2​≤N ， 1≤y1≤y2≤N1 \le y_1\le y_2 \le N1≤y1​≤y2​≤N 。输出 x1,y1,x2,y2x_1, y_1, x_2, y_2x1​,y1​,x2​,y2​ 这个矩形内的数字和
3 无 终止程序

<h3>Tag</h3>

KDT

<h2>解决思路</h2>

用KDT维护暴力查找点是否在矩形内部。具体来说，若当前KDT结点维护的矩形与查询矩形没有交，则直接退出。若当前矩形整个完全包含于查询矩形中，则直接返回整个矩形的和。
至于插入操作，按照KDT的排序方式插入，每10000重构一次。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define InRange(x,y,x1,y1,x2,y2) ((x&gt;=x1)&amp;&amp;(x&lt;=x2)&amp;&amp;(y&gt;=y1)&amp;&amp;(y&lt;=y2))

const int maxN=201000*2;
const int inf=2147483647;

class KDT
{
public:
    int ls,rs;
    int sum,key;
    int P[2],Mn[2],Mx[2];
};

int n;
KDT T[maxN];
int root,nowD;

bool operator &lt; (KDT A,KDT B);
int Build(int l,int r,int D);
void Update(int now);
void Insert(int now,int D);
int Query(int now,int x1,int y1,int x2,int y2);
void Outp(int now);

int main()
{
    int N;scanf("%d",&amp;N);N=0;
    int opt,lastans=0;
    while (scanf("%d",&amp;opt)!=EOF)
    {
        if (opt==3) break;
        if (opt==1)
        {
            n++;scanf("%d%d%d",&amp;T[n].P[0],&amp;T[n].P[1],&amp;T[n].key);
            T[n].P[0]^=lastans;T[n].P[1]^=lastans;T[n].key^=lastans;
            T[n].Mn[0]=T[n].Mx[0]=T[n].P[0];
            T[n].Mn[1]=T[n].Mx[1]=T[n].P[1];
            T[n].sum=T[n].key;
            if (n==1) root=1;
            else Insert(root,0);
            if (n%10000==0) root=Build(1,n,0);
        }
        if (opt==2)
        {
            int x1,y1,x2,y2;scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            x1^=lastans;y1^=lastans;x2^=lastans;y2^=lastans;
            printf("%d\n",lastans=Query(root,x1,y1,x2,y2));
        }
    }
    return 0;
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

int Build(int l,int r,int D)
{
    if (l&gt;r) return 0;
    int mid=(l+r)&gt;&gt;1;
    nowD=D;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    T[mid].Mn[0]=T[mid].Mx[0]=T[mid].P[0];
    T[mid].Mn[1]=T[mid].Mx[1]=T[mid].P[1];
    T[mid].sum=T[mid].key;
    T[mid].ls=Build(l,mid-1,D^1);
    T[mid].rs=Build(mid+1,r,D^1);
    Update(mid);return mid;
}

void Update(int now)
{
    int ls=T[now].ls,rs=T[now].rs;
    T[now].sum=T[now].key;
    if (ls) T[now].sum+=T[ls].sum;
    if (rs) T[now].sum+=T[rs].sum;
    if (ls) T[now].Mn[0]=min(T[now].Mn[0],T[ls].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[ls].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[ls].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[ls].Mx[1]);
    if (rs) T[now].Mn[0]=min(T[now].Mn[0],T[rs].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[rs].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[rs].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[rs].Mx[1]);
    return;
}

void Insert(int now,int D)
{
    if (T[now].P[D]&gt;T[n].P[D])
    {
        if (T[now].ls==0) T[now].ls=n;
        else Insert(T[now].ls,D^1);
    }
    else
    {
        if (T[now].rs==0) T[now].rs=n;
        else Insert(T[now].rs,D^1);
    }
    Update(n);
    Update(now);return;
}

int Query(int now,int x1,int y1,int x2,int y2)
{
    if ((T[now].Mn[0]&gt;=x1)&amp;&amp;(T[now].Mn[0]&lt;=x2)&amp;&amp;(T[now].Mn[1]&gt;=y1)&amp;&amp;(T[now].Mn[1]&lt;=y2)&amp;&amp;(T[now].Mx[0]&gt;=x1)&amp;&amp;(T[now].Mx[0]&lt;=x2)&amp;&amp;(T[now].Mx[1]&gt;=y1)&amp;&amp;(T[now].Mx[1]&lt;=y2)) return T[now].sum;
    if ((x2&lt;T[now].Mn[0])||(x1&gt;T[now].Mx[0])||(y1&gt;T[now].Mx[1])||(y2&lt;T[now].Mn[1])) return 0;
    int Ret=0;
    if ((T[now].P[0]&gt;=x1)&amp;&amp;(T[now].P[0]&lt;=x2)&amp;&amp;(T[now].P[1]&gt;=y1)&amp;&amp;(T[now].P[1]&lt;=y2)) Ret+=T[now].key;
    if (T[now].ls) Ret+=Query(T[now].ls,x1,y1,x2,y2);
    if (T[now].rs) Ret+=Query(T[now].rs,x1,y1,x2,y2);
    return Ret;
}

void Outp(int now)
{
    cout&lt;&lt;now&lt;&lt;":("&lt;&lt;T[now].P[0]&lt;&lt;","&lt;&lt;T[now].P[1]&lt;&lt;") ("&lt;&lt;T[now].Mn[0]&lt;&lt;","&lt;&lt;T[now].Mn[1]&lt;&lt;") ("&lt;&lt;T[now].Mx[0]&lt;&lt;","&lt;&lt;T[now].Mx[1]&lt;&lt;") "&lt;&lt;T[now].ls&lt;&lt;" "&lt;&lt;T[now].rs&lt;&lt;endl;
    if (T[now].ls) Outp(T[now].ls);
    if (T[now].rs) Outp(T[now].rs);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>862</wp:post_id>
		<wp:post_date><![CDATA[2018-05-14 20:28:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-14 12:28:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4066-luogu4148%e7%ae%80%e5%8d%95%e9%a2%98%ef%bc%88kdt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[193]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4552][TJOI2016]排序（二分，线段树）</title>
		<link>http://sycstudio.com/archives/864</link>
		<pubDate>Tue, 15 May 2018 13:15:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=864</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在2016年，佳媛姐姐喜欢上了数字序列。因而他经常研究关于序列的一些奇奇怪怪的问题，现在他在研究一个难题，需要你来帮助他。这个难题是这样子的：给出一个1到n的全排列，现在对这个全排列序列进行m次局部排序，排序分为两种：1:(0,l,r)表示将区间[l,r]的数字升序排序2:(1,l,r)表示将区间[l,r]的数字降序排序最后询问第q位置上的数字。

<h3>Tag</h3>

二分，线段树

<h2>解决思路</h2>

当数据值域很小的时候，我们可以用桶来维护值域，直接进行排序，但是这里并没有值域限制。考虑到最后其实只询问一个位置上的答案，不妨二分这个值，将序列中的数，大于它的设为1，小于等于它的设为0。只有0和1的序列很好排序，直接统计数量就好，这里采用支持区间覆盖的线段树来实现。最后看这个位置上的数，如果是0，说明答案小于等于当前二分的值，否则是大于。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define lson (now&lt;&lt;1)
#define rson (lson|1)

const int maxN=101000;
const int inf=2147483647;

class SegmentData
{
public:
    int sum[2];
    int cov,siz;
};

class Option
{
public:
    int opt,l,r;
};

int n,Mid,m,Pos;
int numcnt,Num[maxN],Arr[maxN];
SegmentData S[maxN&lt;&lt;2];
Option O[maxN];

bool Check(int mid);
void Build(int now,int l,int r);
void Update(int now);
void PushDown(int now);
void Cover(int now,int key);
int Query(int now,int l,int r,int ql,int qr);
void Modify(int now,int l,int r,int ql,int qr,int key);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Arr[i]);
        Num[i]=Arr[i];
    }
    for (int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;O[i].opt,&amp;O[i].l,&amp;O[i].r);
    scanf("%d",&amp;Pos);
    sort(&amp;Num[1],&amp;Num[n+1]);
    numcnt=unique(&amp;Num[1],&amp;Num[n+1])-Num-1;
    int L=1,R=numcnt;
    int Ans=0;
    do
    {
        int mid=(L+R)&gt;&gt;1;
        if (Check(mid)) Ans=mid,R=mid-1;
        else L=mid+1;
    }
    while (L&lt;=R);
    printf("%d\n",Num[Ans]);
    return 0;
}

bool Check(int mid)
{
    Mid=mid;
    Build(1,1,n);
    for (int i=1;i&lt;=m;i++)
    {
        int num=Query(1,1,n,O[i].l,O[i].r);
        if (O[i].opt==0)
        {
            if (num) Modify(1,1,n,O[i].l,O[i].l+num-1,0);
            if (num!=O[i].r-O[i].l+1) Modify(1,1,n,O[i].l+num,O[i].r,1);
        }
        else
        {
            num=O[i].r-O[i].l+1-num;
            if (num) Modify(1,1,n,O[i].l,O[i].l+num-1,1);
            if (num!=O[i].r-O[i].l+1) Modify(1,1,n,O[i].l+num,O[i].r,0);
        }
    }
    return (Query(1,1,n,Pos,Pos)==1);
}

void Build(int now,int l,int r)
{
    S[now].cov=-1;
    S[now].sum[0]=S[now].sum[1]=0;
    S[now].siz=r-l+1;
    if (l==r)
    {
        S[now].sum[Arr[l]&gt;Num[Mid]]=1;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(lson,l,mid);Build(rson,mid+1,r);
    Update(now);return;
}

void Update(int now)
{
    S[now].sum[0]=S[lson].sum[0]+S[rson].sum[0];
    S[now].sum[1]=S[lson].sum[1]+S[rson].sum[1];
    return;
}

int Query(int now,int l,int r,int ql,int qr)
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum[0];
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(lson,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query(rson,mid+1,r,ql,qr);
    else return Query(lson,l,mid,ql,mid)+Query(rson,mid+1,r,mid+1,qr);
}

void PushDown(int now)
{
    if (S[now].cov!=-1)
    {
        Cover(lson,S[now].cov);Cover(rson,S[now].cov);
        S[now].cov=-1;
    }
    return;
}

void Cover(int now,int key)
{
    S[now].cov=key;
    S[now].sum[key]=S[now].siz;S[now].sum[key^1]=0;
    return;
}

void Modify(int now,int l,int r,int ql,int qr,int key)
{
    if ((l==ql)&amp;&amp;(r==qr)){
        Cover(now,key);return;
    }
    PushDown(now);
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(lson,l,mid,ql,qr,key);
    else if (ql&gt;=mid+1) Modify(rson,mid+1,r,ql,qr,key);
    else
    {
        Modify(lson,l,mid,ql,mid,key);
        Modify(rson,mid+1,r,mid+1,qr,key);
    }
    Update(now);return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>864</wp:post_id>
		<wp:post_date><![CDATA[2018-05-15 21:15:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-15 13:15:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4552tjoi2016%e6%8e%92%e5%ba%8f%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[255]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2850/Luogu4475]巧克力王国（KDT）</title>
		<link>http://sycstudio.com/archives/866</link>
		<pubDate>Tue, 15 May 2018 13:38:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=866</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

巧克力王国里的巧克力都是由牛奶和可可做成的。但是并不是每一块巧克力都受王国人民的欢迎，因为大家都不喜欢过于甜的巧克力。对于每一块巧克力，我们设x和y为其牛奶和可可的含量。由于每个人对于甜的程度都有自己的评判标准，所以每个人都有两个参数a和b，分别为他自己为牛奶和可可定义的权重，因此牛奶和可可含量分别为x和y的巧克力对于他的甜味程度即为ax + by。而每个人又有一个甜味限度c，所有甜味程度大于等于c的巧克力他都无法接受。每块巧克力都有一个美味值h。现在我们想知道对于每个人，他所能接受的巧克力的美味值之和为多少

<h3>Tag</h3>

KDT

<h2>解决思路</h2>

维护二维平面上的若干个点，每次查询这些点中符合要求的。用KDT优化暴力寻找。
需要注意的是，由于坐标和甜味程度都有可能是负数，所以要四个方向都判断一遍。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51000;
const int inf=2147483647;

class KDT
{
public:
    ll sum,key;
    int ls,rs;
    ll P[2],Mx[2],Mn[2];
};

int n,m;
KDT T[maxN];
int nowD,root;

bool operator &lt; (KDT A,KDT B);
int Build(int l,int r,int D);
void Update(int now);
ll Query(int now,ll a,ll b,ll c);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%lld%lld%lld",&amp;T[i].P[0],&amp;T[i].P[1],&amp;T[i].key);
    root=Build(1,n,0);
    for (int i=1;i&lt;=m;i++)
    {
        ll a,b,c;scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);
        printf("%lld\n",Query(root,a,b,c));
    }
    return 0;
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

int Build(int l,int r,int D)
{
    if (l&gt;r) return 0;
    int mid=(l+r)&gt;&gt;1;
    nowD=D;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    T[mid].Mx[0]=T[mid].Mn[0]=T[mid].P[0];
    T[mid].Mx[1]=T[mid].Mn[1]=T[mid].P[1];
    T[mid].sum=T[mid].key;
    T[mid].ls=Build(l,mid-1,D^1);
    T[mid].rs=Build(mid+1,r,D^1);
    Update(mid);return mid;
}

void Update(int now)
{
    int ls=T[now].ls,rs=T[now].rs;
    T[now].sum=T[now].key;
    if (ls) T[now].sum+=T[ls].sum,T[now].Mn[0]=min(T[now].Mn[0],T[ls].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[ls].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[ls].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[ls].Mx[1]);
    if (rs) T[now].sum+=T[rs].sum,T[now].Mn[0]=min(T[now].Mn[0],T[rs].Mn[0]),T[now].Mn[1]=min(T[now].Mn[1],T[rs].Mn[1]),T[now].Mx[0]=max(T[now].Mx[0],T[rs].Mx[0]),T[now].Mx[1]=max(T[now].Mx[1],T[rs].Mx[1]);
    return;
}

ll Query(int now,ll a,ll b,ll c)
{
    int cnt=((T[now].Mn[0]*a+T[now].Mn[1]*b)&lt;c)+((T[now].Mn[0]*a+T[now].Mx[1]*b)&lt;c)+((T[now].Mx[0]*a+T[now].Mn[1]*b)&lt;c)+((T[now].Mx[0]*a+T[now].Mx[1]*b)&lt;c);
    if (cnt==0) return 0;
    if (cnt==4) return T[now].sum;
    ll Ret=0;
    if (T[now].P[0]*a+T[now].P[1]*b&lt;c) Ret+=T[now].key;
    if (T[now].ls) Ret+=Query(T[now].ls,a,b,c);
    if (T[now].rs) Ret+=Query(T[now].rs,a,b,c);
    return Ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>866</wp:post_id>
		<wp:post_date><![CDATA[2018-05-15 21:38:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-15 13:38:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2850-luogu4475%e5%b7%a7%e5%85%8b%e5%8a%9b%e7%8e%8b%e5%9b%bd%ef%bc%88kdt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[196]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3270]博物馆 （高斯消元）</title>
		<link>http://sycstudio.com/archives/869</link>
		<pubDate>Wed, 23 May 2018 07:24:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=869</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有一天Petya和他的朋友Vasya在进行他们众多旅行中的一次旅行，他们决定去参观一座城堡博物馆。这座博物馆有着特别的样式。它包含由m条走廊连接的n间房间，并且满足可以从任何一间房间到任何一间别的房间。
两个人在博物馆里逛了一会儿后两人决定分头行动，去看各自感兴趣的艺术品。他们约定在下午六点到一间房间会合。然而他们忘记了一件重要的事：他们并没有选好在哪儿碰面。等时间到六点，他们开始在博物馆里到处乱跑来找到对方（他们没法给对方打电话因为电话漫游费是很贵的）
不过，尽管他们到处乱跑，但他们还没有看完足够的艺术品，因此他们每个人采取如下的行动方法：每一分钟做决定往哪里走，有Pi 的概率在这分钟内不去其他地方（即呆在房间不动），有1-Pi 的概率他会在相邻的房间中等可能的选择一间并沿着走廊过去。这里的i指的是当期所在房间的序号。在古代建造是一件花费非常大的事，因此每条走廊会连接两个不同的房间，并且任意两个房间至多被一条走廊连接。
两个男孩同时行动。由于走廊很暗，两人不可能在走廊碰面，不过他们可以从走廊的两个方向通行。（此外，两个男孩可以同时地穿过同一条走廊却不会相遇）两个男孩按照上述方法行动直到他们碰面为止。更进一步地说，当两个人在某个时刻选择前往同一间房间，那么他们就会在那个房间相遇。
两个男孩现在分别处在a，b两个房间，求两人在每间房间相遇的概率。

<h3>Tag</h3>

高斯消元

<h2>解决思路</h2>

设$$F[i][j]$$表示$A$在$i$号点，$B$在$j$号点的概率，那么$i$和$j$分别有不动和从旁边转移过来两种方式。列出$O(n^2)$个方程，消元求解。
需要注意的是，不能从两个相同的点转移过来，因为这样表示已经达到目标状态了。

<h2>代码</h2>

<pre data-language=><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=23;
const int maxM=maxN*maxN;
const ld eps=1e-13;
const int inf=2147483647;

int n,m;
int S,T;
ld P[maxN];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Id[maxN][maxN];
ld Degree[maxN],To[maxN];
ld Mat[maxN*maxN][maxN*maxN];

int main()
{
    mem(Head,-1);
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
        Degree[u]+=1.0;Degree[v]+=1.0;
    }
    for (int i=1;i&lt;=n;i++) scanf("%LF",&amp;P[i]);
    for (int i=1;i&lt;=n;i++) To[i]=(1.0-P[i])/Degree[i];

    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) Id[i][j]=++idcnt;

    for (int u=1;u&lt;=n;u++)
        for (int v=1;v&lt;=n;v++)
        {
            if (u!=v) Mat[Id[u][v]][Id[u][v]]=(P[u]*P[v]-1.0);
            else Mat[Id[u][v]][Id[u][v]]=1.0;
            for (int e1=Head[u];e1!=-1;e1=Next[e1])
                for (int e2=Head[v];e2!=-1;e2=Next[e2])
                {
                    if ((u!=V[e2])&amp;&amp;(v!=V[e2])) Mat[Id[u][v]][Id[u][V[e2]]]=P[u]*(1.0-P[V[e2]])/(ld)Degree[V[e2]];
                    if ((u!=V[e1])&amp;&amp;(v!=V[e1])) Mat[Id[u][v]][Id[V[e1]][v]]=(1.0-P[V[e1]])*P[v]/(ld)Degree[V[e1]];
                    if (V[e1]!=V[e2]) Mat[Id[u][v]][Id[V[e1]][V[e2]]]=(1.0-P[V[e1]])*(1.0-P[V[e2]])/(ld)Degree[V[e1]]/(ld)Degree[V[e2]];
                }
        }
    Mat[Id[S][T]][idcnt+1]=1;
    for (int i=1;i&lt;=idcnt;i++)
    {
        int j=i;
        while (fabs(Mat[j][i])&lt;eps) j++;
        for (int k=1;k&lt;=idcnt+1;k++) swap(Mat[j][k],Mat[i][k]);
        ld d=(ld)1.0/Mat[i][i];
        for (int k=1;k&lt;=idcnt+1;k++) Mat[i][k]*=d;
        for (int k=1;k&lt;=idcnt;k++)
            if ((k!=i)&amp;&amp;(fabs(Mat[k][i])&gt;eps))
            {
                d=Mat[k][i]/Mat[i][i];
                for (int l=1;l&lt;=idcnt+1;l++) Mat[k][l]=Mat[k][l]-Mat[i][l]*d;
            }
    }
    ld sum=0;
    for (int i=1;i&lt;=n;i++) sum=sum+Mat[Id[i][i]][idcnt+1];
    for (int i=1;i&lt;=n;i++) printf("%.6LF ",Mat[Id[i][i]][idcnt+1]/sum);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>869</wp:post_id>
		<wp:post_date><![CDATA[2018-05-23 15:24:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-23 07:24:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3270%e5%8d%9a%e7%89%a9%e9%a6%86-%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[178]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2337/Luogu3211][HNOI2011]XOR和路径（高斯消元）</title>
		<link>http://sycstudio.com/archives/875</link>
		<pubDate>Thu, 24 May 2018 09:12:37 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=875</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定一个无向连通图，其节点编号为 1 到 N，其边的权值为非负整数。试求出一条从 1 号节点到 N 号节点的路径，使得该路径上经过的边的权值的“XOR 和”最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算“XOR 和”时也要被重复计算相应多的次数。
直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 1 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 N 号节点为止，便得到一条从 1 号节点到 N 号节点的路径。显然得到每条这样的路径的概率是不同的并且每条这样的路径的“XOR 和”也不一样。现在请你求出该算法得到的路径的“XOR 和”的期望值。

<h3>Tag</h3>

高斯消元

<h2>解决思路</h2>

$XOR$不能直接消元计算，那么就分开每一位来算。
对于每一位，设$F[i]$表示$i$到$n$的路径异或和为$1$的概率，则有（其中$i-u$权为$0$，$i-v$权为$1$）
$$F[i]=\sum \frac{F[u]}{Degree[i]}+\sum \frac{1-F[v]}{Degree[i]}$$
另外，由于到达$n$后就停止行动，所以有$F[n]=0$。
这样就可以得到$n$个方程，大力消元就好。
最后把答案统计起来，设当前层为$bit$，则$Ans+=F[1]&#42;2^{bit}$-

<h2>代码</h2>

<pre><code class="language-cpp  line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=110;
const int maxM=10100*2;
const ld eps=1e-6;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
ld Degree[maxN],Mat[maxN][maxN];

void Add_Edge(int u,int v,int w);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v,w);
        if (u!=v) Add_Edge(v,u,w);
    }
    ld Ans=0;
    for (int bit=0;bit&lt;31;bit++)
    {
        mem(Mat,0);
        for (int i=1;i&lt;n;i++)
        {
            Mat[i][i]=1;
            for (int j=Head[i];j!=-1;j=Next[j])
                {
                    if ((W[j]&amp;(1&lt;&lt;bit))!=0) Mat[i][V[j]]+=1.0/Degree[i],Mat[i][n+1]+=1.0/Degree[i];
                    else Mat[i][V[j]]-=1.0/Degree[i];
                }
        }
        Mat[n][n]=1;

        for (int i=1;i&lt;=n;i++)
        {
            int j=i;
            while (fabs(Mat[j][i])&lt;eps) j++;
            if (i!=j) for (int k=1;k&lt;=n+1;k++) swap(Mat[j][k],Mat[i][k]);
            ld d=(ld)1.0/Mat[i][i];
            for (int k=1;k&lt;=n+1;k++) Mat[i][k]*=d;
            for (int k=1;k&lt;=n;k++)
                if ((k!=i)&amp;&amp;(fabs(Mat[k][i])&gt;0))
                {
                    d=Mat[k][i]/Mat[i][i];
                    for (int l=1;l&lt;=n+1;l++) Mat[k][l]=Mat[k][l]-Mat[i][l]*d;
                }
        }

        Ans=Ans+Mat[1][n+1]*(ld)(1ll&lt;&lt;bit);
    }
    printf("%.3LF\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    Degree[u]+=1.0;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>875</wp:post_id>
		<wp:post_date><![CDATA[2018-05-24 17:12:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-24 09:12:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2337-luogu3211hnoi2011xor%e5%92%8c%e8%b7%af%e5%be%84%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[177]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3143/Luogu3232][HNOI2013]游走（高斯消元，贪心）</title>
		<link>http://sycstudio.com/archives/881</link>
		<pubDate>Thu, 24 May 2018 14:07:49 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=881</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一个无向连通图，顶点从1编号到N，边从1编号到M。
小Z在该图上进行随机游走，初始时小Z在1号顶点，每一步小Z以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z 到达N号顶点时游走结束，总分为所有获得的分数之和。
现在，请你对这M条边进行编号，使得小Z获得的总分的期望值最小。

<h3>Tag</h3>

高斯消元，贪心

<h2>解决思路</h2>

如果我们能够知道每一条边期望经过的次数，那么根据期望的累加性，就按照期望从大到小排序，贪心地分配编号。
又因为我们知道经过一条边的期望次数等于经过它的两个端点的期望次数分别除以点度数再累加，即对于边$$u-v$$来说$$w=\frac{W[u]}{Degree[u]}+\frac{W[v]}{Degree[v]}$$，问题转化为求经过每一个点的期望次数。
设经过点$$u$$的期望次数为$$F[u]$$，则对于$$u$$的出边$$u-v$$，有
&#92;[F[u]=\sum \frac{F[v]}{Degree[v]}&#92;]
由于是从$$1$$出发的，所以$$F[1]=\sum \frac{F[v]}{Degree[v]}+1$$
由于到达$$n$$后不再行动，所以$$F[n]=0$$
可以列出$$n$$个方程，大力高斯消元就好。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=510;
const int maxM=maxN*maxN;
const ld eps=1e-7;
const int inf=2147483647;

int n,m;
ld Degree[maxN];
int U[maxM],V[maxM];
ld Mat[maxN][maxN],W[maxM];

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        scanf("%d%d",&amp;U[i],&amp;V[i]);
        Degree[U[i]]+=1.0;Degree[V[i]]+=1.0;
    }
    for (int i=1;i&lt;=m;i++)
    {
        Mat[U[i]][V[i]]-=(ld)1.0/Degree[V[i]];
        Mat[V[i]][U[i]]-=(ld)1.0/Degree[U[i]];
    }
    for (int i=1;i&lt;=n+1;i++) Mat[n][i]=0;
    for (int i=1;i&lt;=n;i++) Mat[i][i]=1;
    Mat[1][n+1]=1;

    for (int i=1;i&lt;=n;i++)
    {
        int j=i;
        while (fabs(Mat[j][i])&lt;eps) j++;
        for (int k=1;k&lt;=n+1;k++) swap(Mat[j][k],Mat[i][k]);
        ld d=(ld)1.0/Mat[i][i];
        for (int k=1;k&lt;=n+1;k++) Mat[i][k]*=d;
        for (int k=1;k&lt;=n;k++)
            if ((i!=k)&amp;&amp;(fabs(Mat[k][i])&gt;eps))
            {
                d=Mat[k][i]/Mat[i][i];
                for (int l=1;l&lt;=n+1;l++) Mat[k][l]=Mat[k][l]-Mat[i][l]*d;
            }
    }
    for (int i=1;i&lt;=m;i++) W[i]=Mat[U[i]][n+1]/Degree[U[i]]+Mat[V[i]][n+1]/Degree[V[i]];
    sort(&amp;W[1],&amp;W[m+1]);
    ld Ans=0;
    for (int i=1;i&lt;=m;i++) Ans=Ans+W[i]*(ld)(m-i+1);
    printf("%.3LF\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>881</wp:post_id>
		<wp:post_date><![CDATA[2018-05-24 22:07:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-24 14:07:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3143-luogu3232hnoi2013%e6%b8%b8%e8%b5%b0%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%8c%e8%b4%aa%e5%bf%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[184]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[AIZU2784]Similarity of Subtrees（树Hash）</title>
		<link>http://sycstudio.com/archives/882</link>
		<pubDate>Thu, 24 May 2018 14:17:38 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=882</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Define the depth of a node in a rooted tree by applying the following rules recursively:

<pre><code class="language-plain ">    The depth of a root node is 0.
    The depths of child nodes whose parents are with depth d are d+1
</code></pre>

Let S(T,d) be the number of nodes of T with depth d. Two rooted trees T and T′ are similar if and only if S(T,d) equals S(T′,d) for all non-negative integer d
You are given a rooted tree Twith N nodes. The nodes of T are numbered from 1 to N. Node 1 is the root node of T. Let Ti be the rooted subtree of T whose root is node i. Your task is to write a program which calculates the number of pairs (i,j) such that Ti and Tj are similar and i&lt;j.

<h3>Tag</h3>

树Hash

<h2>题目大意</h2>

给出一棵有根树，定义两棵树是同构的当且仅当每一层的节点数都相同，求同构的子树对数。

<h2>解决思路</h2>

根据题目对同构的树的定义，可以得到合适树$$Hash$$的函数，即对于$$u$$的儿子$$v$$，有
&#92;[Hash[u]=\sum Hash[v]&#42;base&#92;]
求完$$hash$$之后，排一边序，找出相同的，统计答案。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int maxM=maxN*2;
const ull base=20729;
const int inf=2147483647;

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ull W[maxN];

void dfs(int u);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int a,b;scanf("%d%d",&amp;a,&amp;b);
        edgecnt++;Next[edgecnt]=Head[a];Head[a]=edgecnt;V[edgecnt]=b;
    }
    dfs(1);
    sort(&amp;W[1],&amp;W[n+1]);
    ll Ans=0;
    W[++n]=inf;
    for (int i=1,j=0;i&lt;=n;i++) if (W[i]!=W[j]) Ans=Ans+1ll*(ll)(i-1-j+1)*(ll)(i-1-j)/2,j=i;
    printf("%lld\n",Ans);
    return 0;
}

void dfs(int u)
{
    W[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        dfs(V[i]);
        W[u]=W[u]+W[V[i]]*base;
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>882</wp:post_id>
		<wp:post_date><![CDATA[2018-05-24 22:17:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-24 14:17:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[aizu2784similarity-of-subtrees%ef%bc%88%e6%a0%91hash%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="aizu"><![CDATA[Aizu]]></category>
		<category domain="post_tag" nicename="aizu"><![CDATA[Aizu]]></category>
		<category domain="category" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<category domain="post_tag" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[143]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4754/Luogu4323][JSOI2016]独特的树叶（树Hash）</title>
		<link>http://sycstudio.com/archives/883</link>
		<pubDate>Thu, 24 May 2018 14:35:38 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=883</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

JYY有两棵树A和B：树A有N个点，编号为1到N；树B有N+1个点，编号为1到N+1。JYY知道树B恰好是由树A加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树B中的哪一个叶节点呢？

<h3>Tag</h3>

树Hash

<h2>解决思路</h2>

此题关键在于如何快速判断两个树是否同构。这里采用树$Hash$的方式。
先把第一棵树$Hash$出来，求出以任意一个点为根时的$hash$值。可以先选取一个点出发，求出以这个点为根时每一个点子树内的$hash$值，然后再从上向下传递一边，求出以每一个点为根的$hash$值。用$Map$记录下第一棵树中出现过的$Hash$值。
然后用同样的$Hash$方式，求出第二棵树上的$Hash$值，由于选择的点一定是叶子节点，所以求出分别去掉每一个叶子节点后的$Hash$值，在$Map$中进行查找。
由于有子树的关系，又因为要快速向下传递，这里采用异或和加权的方式求$Hash$，具体参见代码。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int maxM=maxN*2;
const ull base1=50;
const ull base2=20020729;
const int inf=2147483647;

int n;
int edgecnt,Head[maxN],Next[maxM],V[maxM];
ull Hash[maxN];
int Size[maxN],Degree[maxN];
int Ans=inf;
map&lt;ull,bool&gt; Get;

void Add_Edge(int u,int v);
void Build(int u,int fa);
void Calc(int u,int fa);
void GetAns(int u,int fa);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);Add_Edge(v,u);
    }
    Build(1,0);
    Calc(1,0);
    edgecnt=0;mem(Head,-1);mem(Hash,0);mem(Size,0);n++;
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);Add_Edge(v,u);
        Degree[u]++;Degree[v]++;
    }
    for (int i=1;i&lt;=n;i++)
        if (Degree[i]&gt;1)
        {
            Build(i,0);
            GetAns(i,0);
            break;
        }
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void Build(int u,int fa)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Build(V[i],u);
            Hash[u]=Hash[u]^(Hash[V[i]]+base1);
            Size[u]+=Size[V[i]];
        }
    Hash[u]=Hash[u]+base2*Size[u]+1;
    return;
}

void Calc(int u,int fa)
{
    Get[Hash[u]]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            ull tmp=((Hash[u]-(ull)n*base2-1)^(Hash[V[i]]+base1))+(ull)(n-Size[V[i]])*base2+1;
            Hash[V[i]]=((Hash[V[i]]-(ull)Size[V[i]]*base2-1)^(tmp+base1))+(ull)n*base2+1;
            Size[V[i]]=n;
            Calc(V[i],u);
        }
    return;
}

void GetAns(int u,int fa)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            if (Degree[V[i]]&gt;1)
            {
                ull tmp=((Hash[u]-base2*n-1)^(Hash[V[i]]+base1))+(n-Size[V[i]])*base2+1;
                Hash[V[i]]=((Hash[V[i]]-base2*Size[V[i]]-1)^(tmp+base1))+base2*n+1;
                Size[V[i]]=n;
                GetAns(V[i],u);
            }
            else
            {
                ull tmp=((Hash[u]-base2*n-1)^(Hash[V[i]]+base1))+(n-1)*base2+1;
                if (Get.count(tmp)) Ans=min(Ans,V[i]);
            }
        }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>883</wp:post_id>
		<wp:post_date><![CDATA[2018-05-24 22:35:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-24 14:35:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4754-luogu4323jsoi2016%e7%8b%ac%e7%89%b9%e7%9a%84%e6%a0%91%e5%8f%b6%ef%bc%88%e6%a0%91hash%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<category domain="post_tag" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[271]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>132</wp:comment_id>
			<wp:comment_author><![CDATA[xzy]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[347605798@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.cnblogs.com/xzyxzy/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-05-27 20:26:16]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-05-27 12:26:16]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主$出问题辣$！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ3197/Luogu3296][SDOI2013]Assassin/刺客信条（树Hash，二分图）</title>
		<link>http://sycstudio.com/archives/885</link>
		<pubDate>Fri, 25 May 2018 03:49:27 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=885</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。
曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。
在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。
而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。

<h3>Tag</h3>

树Hash，二分图

<h2>解决思路</h2>

首先知道，一棵树如果重新编号后与自身同构，一定有重心不变，若重心有两个，则新建一个点连接两个重心，使得只有一个重心。
这样我们就可以确定以重心个点为根进行匹配。子树同构判断可以用树$$Hash$$来做。
预处理出任意一棵子树的$$Hash$$值后，设$$F[i][j]$$表示编号为$$i$$的点新编号为$$j$$后的最小代价，前提是$$i$$与$$j$$同构。那么，就需要把$$i$$和$$j$$的儿子进行匹配，由于保证儿子的值现在已经求出来了，所以对$$Hash$$值相同的连边，作二分图最小权匹配。这里采用费用流的形式实现。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define ull unsigned long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const ull base1=20020729;
const ull base2=170524;
const int inf=2147483647;

class SortData
{
public:
    int depth,id;
    ull hash;
};

int n;
int Val1[maxN],Val2[maxN];
ull Hash[maxN];
int Depth[maxN],Fa[maxN];
SortData Sorter[maxN];
int F[maxN][maxN];

bool cmp1(SortData A,SortData B);
bool cmp2(int a,int b);
int DP(int u,int v);

namespace Tree
{
    const int maxN=1010;
    const int maxM=maxN*2;

    int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
    int Size[maxN],mxSon[maxN];
    int root;
    ull Sorter[maxN];

    void Init();
    void Add_Edge(int u,int v);
    void GetRoot();
    void dfs_root(int u,int fa);
    void GetHash(int u,int fa);
}

namespace Flow
{
    const int maxN=1510;
    const int maxM=maxN*maxN*30;

    class Edge
    {
    public:
        int u,v,flow,w;
    };

    int S,T;
    int edgecnt,Head[maxN],Next[maxM];
    Edge E[maxM];
    int Dist[maxN],Flow[maxN],Path[maxN];
    queue&lt;int&gt; Queue;
    bool inqueue[maxN];

    void Init();
    void Add_Edge(int u,int v,int flow,int w);
    int GetMxFlow();
    bool Spfa();
}

int main()
{
    Tree::Init();
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Tree::Add_Edge(u,v);Tree::Add_Edge(v,u);
    }

    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Val1[i]);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Val2[i]);

    Tree::GetRoot();//得到重心
    Tree::GetHash(Tree::root,0);//预处理出Hash值

    for (int i=1;i&lt;=n;i++) Sorter[i]=((SortData){Depth[i],i,Hash[i]});
    sort(&amp;Sorter[1],&amp;Sorter[n+1],cmp1);//将Hash值排序，按深度从大到小，Hash值从小到大
    for (int i=1,j;i&lt;=n;i=j)
    {
        j=i+1;
        while ((j&lt;=n)&amp;&amp;(Sorter[i].depth==Sorter[j].depth)&amp;&amp;(Sorter[i].hash==Sorter[j].hash)) j++;
        for (int k=i;k&lt;j;k++)
            for (int l=i;l&lt;j;l++)//对于Hash值相同的，说明子树同构，匹配求解出最小代价
                F[Sorter[k].id][Sorter[l].id]=DP(Sorter[k].id,Sorter[l].id);
    }
    printf("%d\n",F[Tree::root][Tree::root]);
}

bool cmp1(SortData A,SortData B)
{
    if (A.depth!=B.depth) return A.depth&gt;B.depth;
    return A.hash&lt;B.hash;
}

bool cmp2(int a,int b)
{
    return Hash[a]&lt;Hash[b];
}

int DP(int u,int v)
{
    int st1[maxN],st2[maxN],top1=0,top2=0;
    for (int i=Tree::Head[u];i!=-1;i=Tree::Next[i])
        if (Tree::V[i]!=Fa[u]) st1[++top1]=Tree::V[i];
    for (int i=Tree::Head[v];i!=-1;i=Tree::Next[i])
        if (Tree::V[i]!=Fa[v]) st2[++top2]=Tree::V[i];
    sort(&amp;st1[1],&amp;st1[top1+1],cmp2);
    sort(&amp;st2[1],&amp;st2[top2+1],cmp2);
    Flow::Init();
    Flow::S=top1+top2+1;Flow::T=Flow::S+1;
    for (int i=1;i&lt;=top1;i++) Flow::Add_Edge(Flow::S,i,1,0);
    for (int i=1;i&lt;=top2;i++) Flow::Add_Edge(i+top1,Flow::T,1,0);
    for (int i=1,j;i&lt;=top1;i=j)
    {
        j=i+1;
        while ((j&lt;=top1)&amp;&amp;(Hash[st1[i]]==Hash[st1[j]])) j++;
        for (int k=i;k&lt;j;k++)
            for (int l=i;l&lt;j;l++)
                Flow::Add_Edge(k,top1+l,1,F[st1[k]][st2[l]]);
    }
    return Flow::GetMxFlow()+(Val1[u]^Val2[v]);
}

namespace Tree
{
    void Init()
    {
        edgecnt=0;mem(Head,-1);
        return;
    }

    void Add_Edge(int u,int v)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        return;
    }

    void GetRoot()
    {
        root=0;mxSon[0]=inf;
        dfs_root(1,0);

        if ((mxSon[root]&lt;&lt;1)==n)
        {
            int node1=root;
            root=0;dfs_root(node1,0);
            for (int i=Head[node1],last=-1;i!=-1;last=i,i=Next[i])
                if ((Size[V[i]]&lt;&lt;1)==n)
                {
                    ++n;
                    if (i==Head[node1]) Head[node1]=Next[i];
                    else Next[last]=Next[i];
                    for (int j=Head[V[i]],last2=-1;j!=-1;last2=j,j=Next[j])
                        if (V[j]==node1)
                        {
                            if (j==Head[V[i]]) Head[V[i]]=Next[j];
                            else Next[last2]=Next[j];
                            break;
                        }

                    Add_Edge(node1,n);Add_Edge(n,node1);Add_Edge(V[i],n);Add_Edge(n,V[i]);
                    root=n;
                    break;
                }
        }

        return;
    }

    void dfs_root(int u,int fa)
    {
        Size[u]=1;mxSon[u]=0;
        for (int i=Head[u];i!=-1;i=Next[i])
            if (V[i]!=fa)
            {
                dfs_root(V[i],u);
                Size[u]+=Size[V[i]];
                mxSon[u]=max(mxSon[u],Size[V[i]]);
            }
        mxSon[u]=max(mxSon[u],n-Size[u]);
        if (mxSon[u]&lt;mxSon[root]) root=u;
        return;
    }

    void GetHash(int u,int fa)
    {
        Depth[u]=Depth[fa]+1;Fa[u]=fa;
        for (int i=Head[u];i!=-1;i=Next[i])
            if (V[i]!=fa) GetHash(V[i],u);
        int cnt=0;
        for (int i=Head[u];i!=-1;i=Next[i])
            if (V[i]!=fa) Sorter[++cnt]=Hash[V[i]];
        sort(&amp;Sorter[1],&amp;Sorter[cnt+1]);
        Hash[u]=base2;
        for (int i=1;i&lt;=cnt;i++) Hash[u]=((Hash[u]*base1)^Sorter[i])+Sorter[i];
        return;
    }
}

namespace Flow
{
    void Init()
    {
        edgecnt=-1;mem(Head,-1);
        return;
    }

    void Add_Edge(int u,int v,int flow,int w)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].u=u;E[edgecnt].v=v;E[edgecnt].flow=flow;E[edgecnt].w=w;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].u=v;E[edgecnt].v=u;E[edgecnt].flow=0;E[edgecnt].w=-w;
        return;
    }

    int GetMxFlow()
    {
        int Ans=0;
        int flowsum=0;
        while (Spfa())
        {
            Ans=Ans+Flow[T]*Dist[T];flowsum+=Flow[T];
            int now=T;
            while (now!=S)
            {
                E[Path[now]].flow-=Flow[T];
                E[Path[now]^1].flow+=Flow[T];
                now=E[Path[now]].u;
            }
        }
        return Ans;
    }

    bool Spfa()
    {
        for (int i=1;i&lt;=T;i++) Dist[i]=inf;
        while (!Queue.empty()) Queue.pop();
        mem(inqueue,0);
        Dist[S]=0;Queue.push(S);Flow[S]=inf;inqueue[S]=1;
        do
        {
            int u=Queue.front();Queue.pop();
            for (int i=Head[u];i!=-1;i=Next[i])
                if ((E[i].flow&gt;0)&amp;&amp;(Dist[E[i].v]&gt;Dist[u]+E[i].w))
                {
                    Dist[E[i].v]=Dist[u]+E[i].w;Flow[E[i].v]=min(Flow[u],E[i].flow);Path[E[i].v]=i;
                    if (inqueue[E[i].v]==0)
                    {
                        Queue.push(E[i].v);
                        inqueue[E[i].v]=1;
                    }
                }
            inqueue[u]=0;
        }
        while (!Queue.empty());
        if (Dist[T]==inf) return 0;
        return 1;
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>885</wp:post_id>
		<wp:post_date><![CDATA[2018-05-25 11:49:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-25 03:49:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3197-luogu3296sdoi2013assassin-%e5%88%ba%e5%ae%a2%e4%bf%a1%e6%9d%a1%ef%bc%88%e6%a0%91hash%ef%bc%8c%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<category domain="post_tag" nicename="%e6%a0%91hash"><![CDATA[树Hash]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[261]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2286/Luogu2495][SDOI2011]消耗战（虚树，树型动态规划）</title>
		<link>http://sycstudio.com/archives/886</link>
		<pubDate>Fri, 25 May 2018 14:16:00 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=886</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。
侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。

<h3>Tag</h3>

虚树，树型动态规划

<h2>解决思路</h2>

把虚树建立出来后，在树上动态规划求解最小切割的代价。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=251000*2;
const int maxM=maxN*2;
const int maxBit=20;
const int inf=2147483647;
const ll INF=1e18;

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM];
int dfncnt=0,Dfn[maxN],Last[maxN];
int Fa[maxBit][maxN];
ll MinPath[maxN],Depth[maxN];
int Node[maxN*2],Stack[maxN];

void Add_Edge(int u,int v,ll w);
void dfs_init(int u,int fa,ll w);
int GetLCA(int u,int v);
bool cmp(int a,int b);

namespace Tree
{
    int Mark[maxN];
    int edgecnt,Head[maxN],Next[maxM],V[maxM];
    ll F[maxN];

    void Add_Edge(int u,int v);
    void dfs(int u,int fa);
}

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v,w);Add_Edge(v,u,w);
    }
    dfs_init(1,0,INF);
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=n;j++)
            if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                Fa[i][j]=Fa[i-1][Fa[i-1][j]];

    int TQ;scanf("%d",&amp;TQ);
    while (TQ--)
    {
        int K;scanf("%d",&amp;K);
        for (int i=1;i&lt;=K;i++) scanf("%d",&amp;Node[i]);
        for (int i=1;i&lt;=K;i++) Tree::Mark[Node[i]]=1;

        sort(&amp;Node[1],&amp;Node[K+1],cmp);
        for (int i=1;i&lt;K;i++) Node[K+i]=GetLCA(Node[i],Node[i+1]);
        K=K+K-1;Node[++K]=1;
        sort(&amp;Node[1],&amp;Node[K+1],cmp);K=unique(&amp;Node[1],&amp;Node[K+1])-Node-1;

        Tree::edgecnt=0;
        for (int i=1;i&lt;=K;i++) Tree::Head[Node[i]]=-1;

        int top=0;
        for (int i=1;i&lt;=K;i++)
        {
            while ((top)&amp;&amp;(Last[Stack[top]]&lt;Dfn[Node[i]])) top--;
            if (top) Tree::Add_Edge(Stack[top],Node[i]);
            Stack[++top]=Node[i];
        }
        Tree::dfs(Node[1],0);

        for (int i=1;i&lt;=K;i++) Tree::Mark[Node[i]]=0;
        printf("%lld\n",Tree::F[Node[1]]);
    }
    return 0;
}

void Add_Edge(int u,int v,ll w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void dfs_init(int u,int fa,ll w)
{
    Dfn[u]=++dfncnt;Depth[u]=Depth[fa]+1;MinPath[u]=w;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[0][V[i]]=u;
            dfs_init(V[i],u,min(w,W[i]));
        }
    Last[u]=dfncnt;
    return;
}

int GetLCA(int u,int v)
{
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
    if (u==v) return u;
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
    return Fa[0][u];
}

bool cmp(int u,int v)
{
    return Dfn[u]&lt;Dfn[v];
}

namespace Tree
{
    void Add_Edge(int u,int v)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
        return;
    }

    void dfs(int u,int fa)
    {
        if (Mark[u]){
            F[u]=MinPath[u];return;
        }
        F[u]=0;
        for (int i=Head[u];i!=-1;i=Next[i])
            if (V[i]!=fa)
            {
                dfs(V[i],u);
                F[u]=F[u]+F[V[i]];
            }
        F[u]=min(F[u],MinPath[u]);
        return;
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>886</wp:post_id>
		<wp:post_date><![CDATA[2018-05-25 22:16:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-25 14:16:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2286-luogu2495sdoi2011%e6%b6%88%e8%80%97%e6%88%98%ef%bc%88%e8%99%9a%e6%a0%91%ef%bc%8c%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<category domain="post_tag" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[202]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3611/Luogu4103][HEOI2014]大工程（虚树，树型动态规划）</title>
		<link>http://sycstudio.com/archives/887</link>
		<pubDate>Fri, 25 May 2018 14:18:30 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=887</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。 
我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。 
在 2 个国家 a,b 之间建一条新通道需要的代价为树上 a,b 的最短路径。
 现在国家有很多个计划，每个计划都是这样，我们选中了 k 个点，然后在它们两两之间 新建 C(k,2)条 新通道。
现在对于每个计划，我们想知道：
 1.这些新通道的代价和
 2.这些新通道中代价最小的是多少 
3.这些新通道中代价最大的是多少

<h3>Tag</h3>

虚树，树型动态规划

<h2>解决思路</h2>

建立出虚树后，现在要求的就是各个关键点之间的路径长度之和，两端均为关键点的最长和最短路径，在虚树上动态规划求解。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000*2;
const int maxM=maxN*2;
const int maxBit=20;
const int inf=2000000000;
const ll INF=1e18;

int n,K;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int dfncnt=0,Dfn[maxN],Last[maxN],Fa[maxBit][maxN];
ll Depth[maxN];
int Node[maxN&lt;&lt;1],Stack[maxN];

void Add_Edge(int u,int v);
void dfs_init(int u,int fa);
bool cmp(int a,int b);
int GetLCA(int u,int v);
int Dist(int u,int v);

namespace Tree
{
    int nodecnt,Mark[maxN];
    int edgecnt,Head[maxN],Next[maxM],V[maxM];
    ll Size[maxN],F[maxN],E[maxN];
    ll Ans1,Ans2,Ans3;

    void Add_Edge(int u,int v);
    void Do();
    void dfs(int u,int fa);
}

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);
    }

    dfs_init(1,0);
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=n;j++)
            if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                Fa[i][j]=Fa[i-1][Fa[i-1][j]];

    int TQ;scanf("%d",&amp;TQ);
    while (TQ--)
    {
        scanf("%d",&amp;K);
        for (int i=1;i&lt;=K;i++) scanf("%d",&amp;Node[i]);
        Tree::nodecnt=K;
        for (int i=1;i&lt;=K;i++) Tree::Mark[Node[i]]=1;

        sort(&amp;Node[1],&amp;Node[K+1],cmp);
        for (int i=1;i&lt;K;i++) Node[i+K]=GetLCA(Node[i],Node[i+1]);
        K=K+K-1;Node[++K]=1;
        sort(&amp;Node[1],&amp;Node[K+1],cmp);K=unique(&amp;Node[1],&amp;Node[K+1])-Node-1;

        Tree::edgecnt=0;
        for (int i=1;i&lt;=K;i++) Tree::Head[Node[i]]=-1;

        int top=0;
        for (int i=1;i&lt;=K;i++)
        {
            while ((top)&amp;&amp;(Last[Stack[top]]&lt;Dfn[Node[i]])) top--;
            if (top) Tree::Add_Edge(Stack[top],Node[i]);
            Stack[++top]=Node[i];
        }
        Tree::Do();

        printf("%lld %lld %lld\n",Tree::Ans1,Tree::Ans2,Tree::Ans3);
        for (int i=1;i&lt;=K;i++) Tree::Mark[Node[i]]=0;
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    return;
}

void dfs_init(int u,int fa)
{
    Dfn[u]=++dfncnt;Depth[u]=Depth[fa]+1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[0][V[i]]=u;
            dfs_init(V[i],u);
        }
    Last[u]=dfncnt;return;
}

bool cmp(int a,int b){
    return Dfn[a]&lt;Dfn[b];
}

int GetLCA(int u,int v)
{
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
    if (u==v) return u;
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
    return Fa[0][u];
}

int Dist(int u,int v)
{
    int lca=GetLCA(u,v);
    return Depth[u]+Depth[v]-2*Depth[lca];
}

namespace Tree
{
    void Add_Edge(int u,int v)
    {
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
        return;
    }

    void Do()
    {
        Ans1=0;Ans2=INF;Ans3=-INF;
        dfs(1,0);
    }

    void dfs(int u,int fa)
    {
        F[u]=(Mark[u])?(0):(-INF);
        E[u]=(Mark[u])?(0):(INF);
        Size[u]=Mark[u];
        for (int i=Head[u];i!=-1;i=Next[i])
            if (V[i]!=fa)
            {
                dfs(V[i],u);Size[u]+=Size[V[i]];
                int w=Dist(V[i],u);
                Ans1=Ans1+1ll*Size[V[i]]*(nodecnt-Size[V[i]])*w;
                Ans2=min(Ans2,E[u]+E[V[i]]+w);
                Ans3=max(Ans3,F[u]+F[V[i]]+w);
                E[u]=min(E[u],E[V[i]]+w);
                F[u]=max(F[u],F[V[i]]+w);
            }
        return;
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>887</wp:post_id>
		<wp:post_date><![CDATA[2018-05-25 22:18:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-25 14:18:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3611-luogu4103heoi2014%e5%a4%a7%e5%b7%a5%e7%a8%8b%ef%bc%88%e8%99%9a%e6%a0%91%ef%bc%8c%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<category domain="post_tag" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[177]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[Codeforces613D]Kingdom and its Cities（虚树，树型动态规划）</title>
		<link>http://sycstudio.com/archives/897</link>
		<pubDate>Sun, 27 May 2018 06:40:44 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=897</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Meanwhile, the kingdom of K is getting ready for the marriage of the King's daughter. However, in order not to lose face in front of the relatives, the King should first finish reforms in his kingdom. As the King can not wait for his daughter's marriage, reforms must be finished as soon as possible.
The kingdom currently consists of n cities. Cities are connected by n - 1 bidirectional road, such that one can get from any city to any other city. As the King had to save a lot, there is only one path between any two cities.
What is the point of the reform? The key ministries of the state should be relocated to distinct cities (we call such cities important). However, due to the fact that there is a high risk of an attack by barbarians it must be done carefully. The King has made several plans, each of which is described by a set of important cities, and now wonders what is the best plan.
Barbarians can capture some of the cities that are not important (the important ones will have enough protection for sure), after that the captured city becomes impassable. In particular, an interesting feature of the plan is the minimum number of cities that the barbarians need to capture in order to make all the important cities isolated, that is, from all important cities it would be impossible to reach any other important city.
Help the King to calculate this characteristic for each of his plan.

<h3>Tag</h3>

虚树，树型动态规划

<h2>题目大意</h2>

给出一棵树，每次选出若干个点作为关键点，问至少需要割掉多少个非关键点才能使得所有的关键点不连通。

<h2>解决思路</h2>

首先肯定是把每一次询问单独提出来建立虚树，在虚树上动态规划。
无解的情况就是两个关键点直接相连，这个可以输入后就直接判掉。
需要割点的情况有两种，一是当前点不是关键点，但其儿子中有超过$1$个是关键点，那么这个点一定要割掉；二是当前点是关键点，那么它的每一个儿子中有关键点的都要割掉。动态规划的时候对这两种情况分别讨论。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int maxM=maxN*2;
const int maxBit=20;
const int inf=2147483647;

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int Fa[maxBit][maxN],Depth[maxN];
int dfncnt=0,Dfn[maxN],Last[maxN];
int Node[maxN&lt;&lt;1],Stack[maxN&lt;&lt;1],Mark[maxN],Size[maxN];

void Add_Edge(int u,int v);
void dfs_init(int u,int fa);
int GetLCA(int u,int v);
bool cmp(int a,int b);
int dfs(int u,int fa);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);
    }
    dfs_init(1,0);
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=n;j++)
            if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                Fa[i][j]=Fa[i-1][Fa[i-1][j]];

    edgecnt=0;mem(Head,-1);
    int TTT;scanf("%d",&amp;TTT);
    while (TTT--)
    {
        int K;scanf("%d",&amp;K);
        for (int i=1;i&lt;=K;i++) scanf("%d",&amp;Node[i]);
        for (int i=1;i&lt;=K;i++) Mark[Node[i]]=1;

        bool flag=1;
        for (int i=1;i&lt;=K;i++)
            if (Mark[Fa[0][Node[i]]]){
                flag=0;break;
            }
        if (flag==0)
        {
            printf("-1\n");
            for (int i=1;i&lt;=K;i++) Mark[Node[i]]=0;
            continue;
        }

        sort(&amp;Node[1],&amp;Node[K+1],cmp);
        for (int i=1;i&lt;K;i++) Node[K+i]=GetLCA(Node[i],Node[i+1]);
        K=K+K;Node[K]=1;
        sort(&amp;Node[1],&amp;Node[K+1],cmp);K=unique(&amp;Node[1],&amp;Node[K+1])-Node-1;

        edgecnt=0;
        for (int i=1;i&lt;=K;i++) Head[Node[i]]=-1;

        int top=0;
        for (int i=1;i&lt;=K;i++)
        {
            while ((top)&amp;&amp;(Last[Stack[top]]&lt;Dfn[Node[i]])) top--;
            if (top) Add_Edge(Node[i],Stack[top]);
            Stack[++top]=Node[i];
        }

        printf("%d\n",dfs(1,0));

        for (int i=1;i&lt;=K;i++) Mark[Node[i]]=0;
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    return;
}

void dfs_init(int u,int fa)
{
    Depth[u]=Depth[fa]+1;
    Dfn[u]=++dfncnt;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[0][V[i]]=u;
            dfs_init(V[i],u);
        }
    Last[u]=dfncnt;return;
}

int GetLCA(int u,int v)
{
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
    if (u==v) return u;
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
    return Fa[0][u];
}

bool cmp(int a,int b)
{
    return Dfn[a]&lt;Dfn[b];
}

int dfs(int u,int fa)
{
    int ret=0,cnt=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            ret+=dfs(V[i],u);
            cnt+=Size[V[i]];
        }
    if (Mark[u])
    {
        Size[u]=1;
        ret+=cnt;
    }
    else
    {
        ret+=(cnt&gt;1);
        Size[u]=(cnt==1);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>897</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 14:40:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 06:40:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces613dkingdom-and-its-cities%ef%bc%88%e8%99%9a%e6%a0%91%ef%bc%8c%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="post_tag" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<category domain="post_tag" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[202]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3991/Luogu3320][SDOI2015]寻宝游戏（dfs序）</title>
		<link>http://sycstudio.com/archives/898</link>
		<pubDate>Sun, 27 May 2018 06:47:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=898</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小B最近正在玩一个寻宝游戏，这个游戏的地图中有N个村庄和N-1条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。小B希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小B需要不断地更新数据，但是小B太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物

<h3>Tag</h3>

dfs序

<h2>解决思路</h2>

题目中并没有限制询问点数之和，所以不能用虚树做呢。
但是，询问有一个良好的性质，即每一次最多只会动一个点。考虑询问的内容，我们发现，只要从任意一个关键点出发，每次均走到没有经过$dfn$序最近的的一个关键点，最后再返回来即可。
所以用$set$以$dfn$序维护一个点的集合，每一次加入或删除的时候讨论一下，维护答案。
注意当集合中元素个数小于等于$2$个和插入元素为头或尾的时候的特殊处理。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int maxM=maxN*2;
const int maxBit=18;
const int inf=2147483647;

class SetData
{
public:
    int pos;
};

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM];
int dfncnt,Dfn[maxN];
int Depth[maxN],Fa[maxBit][maxN];
ll Dist[maxN];
set&lt;SetData&gt; Set;
int Mark[maxN];

bool operator &lt; (SetData A,SetData B);
void Add_Edge(int u,int v,int w);
void dfs_init(int u,int fa);
int GetLCA(int u,int v);
ll GetDist(int u,int v);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v,w);
    }
    dfs_init(1,0);
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=n;j++)
            if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                Fa[i][j]=Fa[i-1][Fa[i-1][j]];

    ll Ans=0;
    for (int i=1;i&lt;=m;i++)
    {
        int u;scanf("%d",&amp;u);
        SetData uu=((SetData){u});
        if (Mark[u])
        {
            Mark[u]=0;
            if (Set.size()==1){
                Set.erase(uu);Ans=0;
            }
            else if (Set.size()==2){
                Set.erase(uu);Ans=0;
            }
            else
            {
                set&lt;SetData&gt;::iterator p1=Set.find(uu),p2,p3;
                if ((*p1).pos==(*Set.begin()).pos)
                {
                    p2=p1;p2++;
                    Ans-=GetDist((*p1).pos,(*p2).pos);
                    Ans-=GetDist((*p1).pos,(*Set.rbegin()).pos);
                    Set.erase(p1);
                    Ans+=GetDist((*Set.begin()).pos,(*Set.rbegin()).pos);
                }
                else if ((*p1).pos==(*Set.rbegin()).pos)
                {
                    p2=p1;p2--;
                    Ans-=GetDist((*p1).pos,(*p2).pos);
                    Ans-=GetDist((*p1).pos,(*Set.begin()).pos);
                    Set.erase(p1);
                    Ans+=GetDist((*Set.begin()).pos,(*Set.rbegin()).pos);
                }
                else
                {
                    p2=p1;p2--;p3=p1;p3++;
                    Ans-=GetDist((*p1).pos,(*p2).pos);
                    Ans-=GetDist((*p1).pos,(*p3).pos);
                    Ans+=GetDist((*p2).pos,(*p3).pos);
                    Set.erase(p1);
                }
            }
        }
        else
        {
            Mark[u]=1;
            Set.insert(uu);
            set&lt;SetData&gt;::iterator p1=Set.find(uu),p2,p3;
            if (Set.size()==1) Ans=0;
            else if (Set.size()==2) Ans=GetDist((*Set.begin()).pos,(*Set.rbegin()).pos)*2ll;
            else
            {
                if ((*p1).pos==(*Set.begin()).pos)
                {
                    p2=p1;p2++;
                    Ans-=GetDist((*p2).pos,(*Set.rbegin()).pos);
                    Ans+=GetDist((*p1).pos,(*p2).pos);
                    Ans+=GetDist((*p1).pos,(*Set.rbegin()).pos);
                }
                else if ((*p1).pos==(*Set.rbegin()).pos)
                {
                    p2=p1;p2--;
                    Ans-=GetDist((*p2).pos,(*Set.begin()).pos);
                    Ans+=GetDist((*p1).pos,(*p2).pos);
                    Ans+=GetDist((*p1).pos,(*Set.begin()).pos);
                }
                else
                {
                    p2=p1;p2--;p3=p1;p3++;
                    Ans-=GetDist((*p2).pos,(*p3).pos);
                    Ans+=GetDist((*p1).pos,(*p2).pos);
                    Ans+=GetDist((*p1).pos,(*p3).pos);
                }
            }
        }
        printf("%lld\n",Ans);
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;W[edgecnt]=w;
    return;
}

void dfs_init(int u,int fa)
{
    Depth[u]=Depth[fa]+1;Dfn[u]=++dfncnt;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Dist[V[i]]=Dist[u]+W[i];
            Fa[0][V[i]]=u;
            dfs_init(V[i],u);
        }
    return;
}

bool operator &lt; (SetData A,SetData B){
    return Dfn[A.pos]&lt;Dfn[B.pos];
}

int GetLCA(int u,int v)
{
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
    if (u==v) return u;
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
    return Fa[0][u];
}

ll GetDist(int u,int v)
{
    int lca=GetLCA(u,v);
    return Dist[u]-Dist[lca]+Dist[v]-Dist[lca];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>898</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 14:47:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 06:47:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3991-luogu3320sdoi2015%e5%af%bb%e5%ae%9d%e6%b8%b8%e6%88%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="dfs%e5%ba%8f"><![CDATA[dfs序]]></category>
		<category domain="post_tag" nicename="dfs%e5%ba%8f"><![CDATA[dfs序]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[551]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3572/Luogu3233][HNOI2014]世界树（虚树，树型动态规划）</title>
		<link>http://sycstudio.com/archives/899</link>
		<pubDate>Sun, 27 May 2018 11:19:14 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=899</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。
世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。
出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。
现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。

<h3>Tag</h3>

虚树，树型动态规划

<h2>解决思路</h2>

首先对于每一个询问建立出虚树。对于在虚树中的点，我们可以比较方便地求出距离每一个点最近的议事处的位置。那么对于不在虚树中的点，它一定能连接到虚树上的点或虚树上的边。
对于虚树上的每一对边，如果边两边的点被管辖的点相同，那么这整个一条边上的点都是如此。反之，我们可以倍增地找到一个中间点，使得这个点以下的部分与下端点同，以上的部分与上端点同。
当然，由于建立出虚树后有一些点已经在虚树中统计过了，所以另外还要考虑去重的问题。可以用一个$sum$数组来统计，表示虚树上的贡献，开始的时候置为$size$，然后每计算一部分就从中减掉，最后再把虚树上的贡献统计到答案中。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=301000;
const int maxM=maxN*2;
const int maxBit=16;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int dfncnt,Dfn[maxN],Last[maxN],Depth[maxN],Fa[maxBit][maxN],Size[maxN];
int Stack[maxN],Node[maxN&lt;&lt;1],Mark[maxN],Input[maxN],Sum[maxN],Cnt[maxN],nowFa[maxN];
int Near[maxN];

void Add_Edge(int u,int v);
void dfs_init(int u,int fa);
int GetLCA(int u,int v);
int GetDist(int u,int v);
bool cmp(int u,int v);
void dfs1(int u,int fa);
void dfs2(int u,int fa);
void Do(int u,int fa);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Add_Edge(u,v);
    }
    dfs_init(1,0);
    for (int i=1;i&lt;maxBit;i++)
        for (int j=1;j&lt;=n;j++)
            if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                Fa[i][j]=Fa[i-1][Fa[i-1][j]];

    edgecnt=0;
    mem(Head,-1);
    int TTT;scanf("%d",&amp;TTT);
    while (TTT--)
    {
        int K,KK;scanf("%d",&amp;K);KK=K;
        for (int i=1;i&lt;=K;i++) scanf("%d",&amp;Node[i]),Input[i]=Node[i];

        for (int i=1;i&lt;=K;i++) Mark[Node[i]]=1,Cnt[Node[i]]=0,Near[Node[i]]=Node[i];

        sort(&amp;Node[1],&amp;Node[K+1],cmp);
        for (int i=1;i&lt;K;i++) Node[i+K]=GetLCA(Node[i],Node[i+1]);
        K=K+K;Node[K]=1;
        sort(&amp;Node[1],&amp;Node[K+1],cmp);K=unique(&amp;Node[1],&amp;Node[K+1])-Node-1;

        edgecnt=0;
        for (int i=1;i&lt;=K;i++) Head[Node[i]]=-1;

        int top=0;
        for (int i=1;i&lt;=K;i++)
        {
            while ((top)&amp;&amp;(Last[Stack[top]]&lt;Dfn[Node[i]])) top--;
            if (top) Add_Edge(Stack[top],Node[i]);
            Stack[++top]=Node[i];
        }

        dfs1(1,0);
        dfs2(1,0);

        for (int i=1;i&lt;=K;i++)
            for (int j=Head[Node[i]];j!=-1;j=Next[j])
                if (V[j]!=nowFa[Node[i]])
                    Do(V[j],Node[i]);

        for (int i=1;i&lt;=K;i++) Cnt[Near[Node[i]]]+=Sum[Node[i]];

        for (int i=1;i&lt;=KK;i++) printf("%d ",Cnt[Input[i]]);
        printf("\n");

        for (int i=1;i&lt;=K;i++) Mark[Node[i]]=Cnt[Node[i]]=Sum[Node[i]]=Near[Node[i]]=0;
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    return;
}

void dfs_init(int u,int fa)
{
    Depth[u]=Depth[fa]+1;Dfn[u]=++dfncnt;Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[0][V[i]]=u;
            dfs_init(V[i],u);
            Size[u]+=Size[V[i]];
        }
    Last[u]=dfncnt;
    return;
}

int GetLCA(int u,int v)
{
    if (Depth[u]&lt;Depth[v]) swap(u,v);
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
    if (u==v) return u;
    for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
    return Fa[0][u];
}

int GetDist(int u,int v){
    return Depth[u]+Depth[v]-2*Depth[GetLCA(u,v)];
}

bool cmp(int u,int v){
    return Dfn[u]&lt;Dfn[v];
}

void dfs1(int u,int fa)
{
    Sum[u]=Size[u];
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            nowFa[V[i]]=u;
            dfs1(V[i],u);
            if (Near[V[i]]==0) continue;
            int d1=GetDist(Near[V[i]],u),d2=GetDist(Near[u],u);
            if ((Near[u]==0)||(d1&lt;d2)||((d1==d2)&amp;&amp;(Near[V[i]]&lt;Near[u])))
                Near[u]=Near[V[i]];
        }
    return;
}

void dfs2(int u,int fa)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            int d1=GetDist(Near[u],V[i]),d2=GetDist(Near[V[i]],V[i]);
            if ((Near[V[i]]==0)||(d1&lt;d2)||((d1==d2)&amp;&amp;(Near[u]&lt;Near[V[i]]))) Near[V[i]]=Near[u];
            dfs2(V[i],u);
        }
    return;
}

void Do(int u,int fa)
{
    int An=u;
    for (int i=maxBit;i&gt;=0;i--) if ((Fa[i][An])&amp;&amp;(Depth[Fa[i][An]]&gt;Depth[fa])) An=Fa[i][An];
    Sum[fa]-=Size[An];
    if (Near[u]==Near[fa])
    {
        Cnt[Near[u]]+=Size[An]-Size[u];
        return;
    }
    int now=u;
    for (int i=maxBit-1;i&gt;=0;i--)
        if ((Fa[i][now])&amp;&amp;(Depth[Fa[i][now]]&gt;Depth[fa]))
        {
            int d1=GetDist(Near[u],Fa[i][now]),d2=GetDist(Near[fa],Fa[i][now]);
            if ((d1&lt;d2)||((d1==d2)&amp;&amp;(Near[u]&lt;Near[fa]))) now=Fa[i][now];
        }
    Cnt[Near[u]]+=Size[now]-Size[u];
    Cnt[Near[fa]]+=Size[An]-Size[now];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>899</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 19:19:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 11:19:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3572-luogu3233hnoi2014%e4%b8%96%e7%95%8c%e6%a0%91%ef%bc%88%e8%99%9a%e6%a0%91%ef%bc%8c%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<category domain="post_tag" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[320]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3124/Luogu3304][SDOI2013]直径（树的直径）</title>
		<link>http://sycstudio.com/archives/900</link>
		<pubDate>Sun, 27 May 2018 12:23:01 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=900</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有N个节点，可以证明其有且仅有N-1 条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 dis(a,b)
表示点a和点b的路径上各边长度之和。称dis(a,b)为a、b两个节点间的距离。 
 直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。
现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。

<h3>Tag</h3>

树的直径

<h2>解决思路</h2>

第一问可以用两次搜索求得。
考虑把第一问求出的直径截出来，这样我们就得到了若干直径中的一条。因为直径的性质保证所有的直径必交于连续一段，所以用两个指针扫。先从左往右扫描，从每一个点$BFS$找到最深的点，设这个点的深度为$deep$，若$deep$与该点右边直径部分的长度相同，则说明我们找到了一条新的直径，从这个点向右都不是必须经过的点了，找到右端点。
对于向左的也是同理，这样我们就确定了重合区间的左右端点。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
const int maxN=201000;
const int maxM=maxN*2;
const int inf=2147483647;

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM];
ll Dist[maxM],Sum1[maxN],Sum2[maxN];
int Queue[maxN],Fa[maxN],St[maxN];
bool vis[maxN];

void Add_Edge(int u,int v,int w);
int Bfs(int S);

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v,w);
    }

    mem(vis,0);
    Bfs(1);
    int id=1;
    for (int i=2;i&lt;=n;i++) if (Dist[i]&gt;Dist[id]) id=i;

    mem(vis,0);
    Bfs(id);
    id=1;
    for (int i=2;i&lt;=n;i++) if (Dist[i]&gt;Dist[id]) id=i;
    ll Ans=Dist[id];

    int now=id,cnt=0;
    while (now) St[++cnt]=now,now=Fa[now];

    Sum1[1]=0;
    for (int i=2;i&lt;=cnt;i++)
        for (int j=Head[St[i]];j!=-1;j=Next[j])
            if (V[j]==St[i-1]){
                Sum1[i]=Sum1[i-1]+W[j];break;
            }

    Sum2[cnt]=0;
    for (int i=cnt-1;i&gt;=1;i--)
        for (int j=Head[St[i]];j!=-1;j=Next[j])
            if (V[j]==St[i+1]){
                Sum2[i]=Sum2[i+1]+W[j];break;
            }

    mem(vis,0);
    for (int i=1;i&lt;=cnt;i++) vis[St[i]]=1;
    int L,R;
    for (R=1;R&lt;=cnt;R++)
    {
        int sz=Bfs(St[R]);
        ll mx=-1;
        for (int i=2;i&lt;=sz;i++) mx=max(mx,Dist[Queue[i]]);
        if (mx==Sum2[R]) break;
    }

    mem(vis,0);
    for (int i=1;i&lt;=cnt;i++) vis[St[i]]=1;
    for (L=cnt;L&gt;=1;L--)
    {
        int sz=Bfs(St[L]);
        ll mx=-1;
        for (int i=2;i&lt;=sz;i++) mx=max(mx,Dist[Queue[i]]);
        if (mx==Sum1[L]) break;
    }
    L=max(1,L);R=min(R,cnt);

    printf("%lld\n%d\n",Ans,R-L);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;W[edgecnt]=w;
    return;
}

int Bfs(int S)
{
    int h=1,t=0;Queue[1]=S;vis[S]=1;Dist[S]=0;Fa[S]=0;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if (vis[V[i]]==0)
                Dist[Queue[++h]=V[i]]=Dist[u]+W[i],vis[V[i]]=1,Fa[V[i]]=u;
    }
    while (t!=h);
    return t;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>900</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 20:23:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 12:23:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3124-luogu3304sdoi2013%e7%9b%b4%e5%be%84%ef%bc%88%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%9b%b4%e5%be%84"><![CDATA[直径]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[350]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4086/Luogu3323][SDOI2015]旅行计划（分类讨论，容斥原理，计数）</title>
		<link>http://sycstudio.com/archives/901</link>
		<pubDate>Sun, 27 May 2018 14:37:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=901</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在有 N 座城市的国度．Alice希望可以开始一场充满传奇的旅行。TA 希可以从一个城市出发开始旅行，每次前往一个相邻的城市，途中不重复得经过恰好 K 座城市，最后抵达另外一个城市并结束旅行。需要注意的是，起点与终点也被考虑为经过的城市，也就是说包括起点和终点在内经过的所有城市都是不能重复的。现在，Alice 希望知道哪些城市对 &lt;u,v> 可以作为合法的旅行起点与终点。

<h3>Tag</h3>

分类讨论，容斥原理，计数

<h2>解决思路</h2>

看到&#92;(K&#92;)这么小，第一个想到的就是状态压缩。
可惜这道题与状态压缩并没有什么关系。看到数据这么小，于是我们可以<del>数据分治</del>分类讨论一下。
&#92;(K==2&#92;)，直接就是每一条边
&#92;(K==3&#92;)，对于合法的&#92;(x-u-y&#92;)，我们可以枚举&#92;(x,y&#92;)，然后扫描从&#92;(x&#92;)出发的每一条边，&#92;(x->t&#92;)，看&#92;(t&#92;)是否与&#92;(y&#92;)直接右边相连。
&#92;(K==4&#92;)，对于合法的&#92;(x-u-v-y&#92;)，同样是枚举&#92;(x,y&#92;)，然后分别扫描从&#92;(x&#92;)出发的边&#92;(x->u&#92;)和&#92;(y&#92;)出发的边&#92;(y->v&#92;)，看&#92;(u&#92;)与&#92;(v&#92;)是否直接连通。
&#92;(K==5&#92;)，从&#92;(K==5&#92;)开始，情况变得有些复杂。对于合法的路径&#92;(x-p-u-q-y&#92;)，我们在最外层枚举&#92;(p&#92;)和&#92;(q&#92;)，然后扫描&#92;(p&#92;)的出边看&#92;(p->u&#92;)能不能与&#92;(q&#92;)直接相连，这样我们就处理出若干&#92;(p,u,q&#92;)的三元组。然后我们再扫描&#92;(p&#92;)的出边和&#92;(q&#92;)的出边构造出&#92;(x,y&#92;)?
且住，这里我们无法保证&#92;(x,y&#92;)不是我们之前枚举的&#92;(u&#92;)啊。所以利用容斥原理，我们记对于当前的&#92;(p,q&#92;)，&#92;(Cnt[i]&#92;)表示&#92;(i&#92;)这个点作为中间点&#92;(u&#92;)几次，&#92;(sum&#92;)记录这一次的&#92;(Cnt[]&#92;)之和，那么我们在枚举&#92;(x,y&#92;)的时候，只需要判断&#92;(sum-Cnt[x]-Cnt[y]&#92;)是不是大于&#92;(0&#92;)就可以知道是否合法了。
代码表示就是这样

<pre><code class="language-cpp ">for (int p=1;p&lt;=n;p++)
    for (int q=p+1;q&lt;=n;q++)
    {
        int sum=0;mem(Cnt,0);
        for (int i=Head[p];i!=-1;i=Next[i])
            if ((V[i]!=q)&amp;&amp;(Map[V[i]][q]))
                Cnt[V[i]]++,sum++;
        for (int i=Head[p];i!=-1;i=Next[i])
            if (V[i]!=q)
                for (int j=Head[q];j!=-1;j=Next[j])
                    if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(sum-Cnt[V[i]]-Cnt[V[j]]))
                        Ans[V[i]][V[j]]=Ans[V[j]][V[i]]=1;
    }
</code></pre>

&#92;(K==6&#92;)，类似&#92;(K==5&#92;)的做法，还是利用容斥。设合法路径为&#92;(x-p-u-v-q-y&#92;)，先枚举&#92;(p,q&#92;)并扫描其出边得到&#92;(u,v&#92;)，这样就得到了合法的四元组。记&#92;(Cnt[i]&#92;)表示点&#92;(i&#92;)出现在四元组中的次数，&#92;(sum&#92;)记总次数，然后再枚举&#92;(p,q&#92;)的出边得到&#92;(x,y&#92;)。需要注意的是，像上面那样&#92;(Sum-Cnt[x]-Cnt[y]&#92;)是不行的，因为可能&#92;(x-y&#92;)也正好是一对二元组，所以要加上&#92;(x-y&#92;)是否连通，即要判断的应该是&#92;(sum-Cnt[x]-Cnt[y]+Map[x][y]&#92;)是否大于&#92;(0&#92;)
代码是这样的

<pre><code class="language-cpp ">for (int p=1;p&lt;=n;p++)
    for (int q=p+1;q&lt;=n;q++)
    {
        int sum=0;mem(Cnt,0);
        for (int i=Head[p];i!=-1;i=Next[i])
            if (V[i]!=q)
                for (int j=Head[q];j!=-1;j=Next[j])
                    if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(Map[V[i]][V[j]]))
                        Cnt[V[i]]++,Cnt[V[j]]++,sum++;
        for (int i=Head[p];i!=-1;i=Next[i])
            if (V[i]!=q)
                for (int j=Head[q];j!=-1;j=Next[j])
                    if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(sum-Cnt[V[i]]-Cnt[V[j]]+Map[V[i]][V[j]])) Ans[V[i]][V[j]]=Ans[V[j]][V[i]]=1;
    }
</code></pre>

&#92;(K==7&#92;)，点数越来越多了。这一次直接枚举复杂度会太高。设合法路径的形态为&#92;(x-p-u-z-v-q-y&#92;)。我们先预处理处所有的三元组&#92;(u-z-v&#92;)，记为&#92;(Node[u][v]&#92;)的元素，然后同样还是枚举&#92;(p,q&#92;)，再枚举其出边找到&#92;(u,v&#92;)，由于我们已经预处理好了所有的三元组，所以我们可以直接得到&#92;(z=Node[u][v]&#92;)，然后依然&#92;(sum&#92;)记录三元组数量，&#92;(Cnt[i]&#92;)记录&#92;(i&#92;)出现的次数。但这还要记录两个值，因为若像上面那样减的话，会多减去&#92;(x,y&#92;)作为三元组两端和分别作为三元组一端与中间的情况，所以记&#92;(Cnt1[i][j]&#92;)表示&#92;(i,j&#92;)分别作为三元组两端的次数，记&#92;(Cnt2[i][j]&#92;)表示&#92;(i&#92;)作为三元组一端，&#92;(j&#92;)作为三元组中间的次数。然后依然枚举&#92;(p,q&#92;)的出边得到&#92;(x,y&#92;)，若&#92;(sum-Cnt[x]-Cnt[y]+Cnt1[x][y]+Cnt2[x][y]+Cnt2[y][2]&#92;)大于等于&#92;(0&#92;)，则合法。
代码长这样

<pre><code class="language-cpp ">for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) Node[i][j].clear(),Tim1[i][j]=Tim2[i][j]=0;
for (int i=1;i&lt;=n;i++)//预处理出所有三元组
    for (int j=Head[i];j!=-1;j=Next[j])
        for (int k=Head[V[j]];k!=-1;k=Next[k])
            if (V[k]!=i)
                Node[i][V[k]].push_back(V[j]);
int tim=0;//为了防止清空二维数组时耗费大量时间，这里记录一个时间戳，下面的Tim1[][]和Tim2[][]分别对应相应的Cnt1[][]和Cnt2[][]的时间戳
for (int p=1;p&lt;=n;p++)
    for (int q=p+1;q&lt;=n;q++)
    {
        int sum=0;mem(Cnt,0);tim++;
        for (int i=Head[p];i!=-1;i=Next[i])
            if (V[i]!=q)
                for (int j=Head[q];j!=-1;j=Next[j])
                    if ((V[j]!=p)&amp;&amp;(V[i]!=V[j]))
                    {
                        int u=V[i],v=V[j];
                        for (int k=0;k&lt;Node[u][v].size();k++)
                        {
                            int z=Node[u][v][k];
                            if ((z==p)||(z==q)) continue;
                            Cnt[u]++;Cnt[v]++;Cnt[z]++;sum++;
                            if (Tim1[u][v]!=tim) Tim1[u][v]=tim,Cnt1[u][v]=1;
                            else Cnt1[u][v]++;
                            if (Tim2[u][z]!=tim) Tim2[u][z]=tim,Cnt2[u][z]=1;
                            else Cnt2[u][z]++;
                            if (Tim2[v][z]!=tim) Tim2[v][z]=tim,Cnt2[v][z]=1;
                            else Cnt2[v][z]++;
                        }
                    }
            for (int i=Head[p];i!=-1;i=Next[i])
            if (V[i]!=q)
                for (int j=Head[q];j!=-1;j=Next[j])
                    if ((V[j]!=p)&amp;&amp;(V[i]!=V[j]))
                    {
                        int x=V[i],y=V[j];
                        if (sum-Cnt[x]-Cnt[y]+((Tim2[x][y]==tim)?(Cnt2[x][y]):(0))+((Tim2[y][x]==tim)?(Cnt2[y][x]):(0))+((Tim1[x][y]==tim)?(Cnt1[x][y]):(0)))
                            Ans[x][y]=Ans[y][x]=1;
                    }
    }
</code></pre>

<del>可以说非常休闲了</del>

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxM=5010*2;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],U[maxM],V[maxM];
bool Map[maxN][maxN],Ans[maxN][maxN];
int Cnt[maxN],Cnt1[maxN][maxN],Cnt2[maxN][maxN];
int Tim1[maxN][maxN],Tim2[maxN][maxN];
vector&lt;int&gt; Node[maxN][maxN];

void Add_Edge(int u,int v);
void Do2();
void Do3();
void Do4();
void Do5();
void Do6();
void Do7();

int main()
{
    int TTT;scanf("%d",&amp;TTT);
    while (TTT--)
    {
        edgecnt=0;mem(Head,-1);mem(Map,0);mem(Ans,0);
        int K;
        scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
        for (int i=1;i&lt;=m;i++)
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            if ((Map[u][v])||(u==v)) continue;
            Add_Edge(u,v);Map[u][v]=Map[v][u]=1;
        }
        if (K==2) Do2();
        if (K==3) Do3();
        if (K==4) Do4();
        if (K==5) Do5();
        if (K==6) Do6();
        if (K==7) Do7();
        for (int i=1;i&lt;=n;i++)
        {
            for (int j=1;j&lt;=n;j++)
                printf("%c",(Ans[i][j])?('Y'):('N'));
            printf("\n");
        }
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;U[edgecnt]=u;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;U[edgecnt]=v;
    return;
}

void Do2()
{
    for (int i=1;i&lt;=edgecnt;i++) Ans[U[i]][V[i]]=1;
    return;
}

void Do3()
{
    for (int i=1;i&lt;=n;i++)
        for (int j=i+1;j&lt;=n;j++)
            for (int k=Head[i];k!=-1;k=Next[k])
                if (Map[V[k]][j]) Ans[i][j]=Ans[j][i]=1;
    return;
}

void Do4()
{
    for (int x=1;x&lt;=n;x++)
        for (int y=x+1;y&lt;=n;y++)
            for (int i=Head[x];i!=-1;i=Next[i])
                if (V[i]!=y)
                    for (int j=Head[y];j!=-1;j=Next[j])
                        if ((V[i]!=V[j])&amp;&amp;(V[j]!=x)&amp;&amp;(Map[V[i]][V[j]]))
                            Ans[x][y]=Ans[y][x]=1;
    return;
}

void Do5()
{
    for (int p=1;p&lt;=n;p++)
        for (int q=p+1;q&lt;=n;q++)
        {
            int sum=0;mem(Cnt,0);
            for (int i=Head[p];i!=-1;i=Next[i])
                if ((V[i]!=q)&amp;&amp;(Map[V[i]][q]))
                    Cnt[V[i]]++,sum++;
            for (int i=Head[p];i!=-1;i=Next[i])
                if (V[i]!=q)
                    for (int j=Head[q];j!=-1;j=Next[j])
                        if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(sum-Cnt[V[i]]-Cnt[V[j]]))
                            Ans[V[i]][V[j]]=Ans[V[j]][V[i]]=1;
        }
    return;
}

void Do6()
{
    for (int p=1;p&lt;=n;p++)
        for (int q=p+1;q&lt;=n;q++)
        {
            int sum=0;mem(Cnt,0);
            for (int i=Head[p];i!=-1;i=Next[i])
                if (V[i]!=q)
                    for (int j=Head[q];j!=-1;j=Next[j])
                        if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(Map[V[i]][V[j]]))
                            Cnt[V[i]]++,Cnt[V[j]]++,sum++;
            for (int i=Head[p];i!=-1;i=Next[i])
                if (V[i]!=q)
                    for (int j=Head[q];j!=-1;j=Next[j])
                        if ((V[j]!=p)&amp;&amp;(V[i]!=V[j])&amp;&amp;(sum-Cnt[V[i]]-Cnt[V[j]]+Map[V[i]][V[j]])) Ans[V[i]][V[j]]=Ans[V[j]][V[i]]=1;
        }
    return;
}

void Do7()
{
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) Node[i][j].clear(),Tim1[i][j]=Tim2[i][j]=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=Head[i];j!=-1;j=Next[j])
            for (int k=Head[V[j]];k!=-1;k=Next[k])
                if (V[k]!=i)
                    Node[i][V[k]].push_back(V[j]);
    int tim=0;
    for (int p=1;p&lt;=n;p++)
        for (int q=p+1;q&lt;=n;q++)
        {
            int sum=0;mem(Cnt,0);tim++;
            for (int i=Head[p];i!=-1;i=Next[i])
                if (V[i]!=q)
                    for (int j=Head[q];j!=-1;j=Next[j])
                        if ((V[j]!=p)&amp;&amp;(V[i]!=V[j]))
                        {
                            int u=V[i],v=V[j];
                            for (int k=0;k&lt;Node[u][v].size();k++)
                            {
                                int z=Node[u][v][k];
                                if ((z==p)||(z==q)) continue;
                                Cnt[u]++;Cnt[v]++;Cnt[z]++;sum++;
                                if (Tim1[u][v]!=tim) Tim1[u][v]=tim,Cnt1[u][v]=1;
                                else Cnt1[u][v]++;
                                if (Tim2[u][z]!=tim) Tim2[u][z]=tim,Cnt2[u][z]=1;
                                else Cnt2[u][z]++;
                                if (Tim2[v][z]!=tim) Tim2[v][z]=tim,Cnt2[v][z]=1;
                                else Cnt2[v][z]++;
                            }
                        }

            for (int i=Head[p];i!=-1;i=Next[i])
                if (V[i]!=q)
                    for (int j=Head[q];j!=-1;j=Next[j])
                        if ((V[j]!=p)&amp;&amp;(V[i]!=V[j]))
                        {
                            int x=V[i],y=V[j];
                            if (sum-Cnt[x]-Cnt[y]+((Tim2[x][y]==tim)?(Cnt2[x][y]):(0))+((Tim2[y][x]==tim)?(Cnt2[y][x]):(0))+((Tim1[x][y]==tim)?(Cnt1[x][y]):(0)))
                                Ans[x][y]=Ans[y][x]=1;
                        }
        }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>901</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 22:37:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 14:37:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4086-luogu3323sdoi2015%e6%97%85%e8%a1%8c%e8%ae%a1%e5%88%92%ef%bc%88%e5%88%86%e7%b1%bb%e8%ae%a8%e8%ae%ba%ef%bc%8c%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86%ef%bc%8c%e8%ae%a1%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e7%b1%bb%e8%ae%a8%e8%ae%ba"><![CDATA[分类讨论]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[390]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[Luogu2462][SDOI2007]游戏（字符串Hash，最长路）</title>
		<link>http://sycstudio.com/archives/902</link>
		<pubDate>Mon, 28 May 2018 03:29:19 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=902</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小木木和小凳子试两个聪明的孩子，他们五岁的时候就开始学习英语了。
英语老师教他们玩一个很简单的游戏。老师给他们一张全小写并无特殊符号的英语单词表，单词表如下：
ab arc arco bar bran carbon carbons
cobra crab crayon narc 
然后让他们从单词表里找词语接龙。接龙的规则如下:
1 前一个单词拥有的所有字母，在后一个单词里必须出现，而且字母出现次数不少于前一单词。
2 后一个单词的长度比前一个单词的长度恰好多1
对于以上例子，一合法的接龙为:
ab bar crab cobra carbon carbons
他们之中，谁接龙的长度长，谁就赢了。小木木肯定不想输，所以找到你，放肆撒娇，导致你因为不想再被打扰而帮他了。至于小凳子呢？？说不定找郭大牛去了。嘿嘿，你和郭大牛的编程比赛？？加油吧！！！

<h3>Tag</h3>

字符串Hash，最长路

<h2>解决思路</h2>

<del>标签中给的虚树？</del>
把单词&#92;(Hash&#92;)起来，然后枚举加上哪一个字母，再&#92;(hash&#92;)判断是否存在这样的单词，如果存在则连边，这样可以构建出一张&#92;(DAG&#92;)，在&#92;(DAG&#92;)上动态规划求最长路就好。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=11000;
const int maxM=maxN*100;
const int HashSize=1000000;
const int maxS=110;
const int Base=29;
const int maxAlpha=26;
const int inf=2147483647;

int n;
int Map[HashSize];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
char Input[maxN][maxS];
int Cnt[maxN][maxAlpha];
int Degree[maxN],Queue[maxN],F[maxN],Path[maxN];

void Add_Edge(int u,int v);
void Outp(int id);

int main()
{
    n=0;mem(Head,-1);
    while (scanf("%s",Input[++n]+1)!=EOF);
    n--;
    for (int i=1;i&lt;=n;i++)
    {
        int l=strlen(Input[i]+1);
        for (int j=1;j&lt;=l;j++) Cnt[i][Input[i][j]-'a']++;
        int hash=0;
        for (int j=0;j&lt;maxAlpha;j++) hash=(hash*Base%HashSize+Cnt[i][j])%HashSize;
        Map[hash]=i;
    }
    for (int i=1;i&lt;=n;i++)
    {
        for (int j=0;j&lt;maxAlpha;j++)
        {
            Cnt[i][j]++;
            int hash=0;
            for (int k=0;k&lt;maxAlpha;k++) hash=(hash*Base%HashSize+Cnt[i][k])%HashSize;
            if (Map[hash]) Add_Edge(i,Map[hash]);
            Cnt[i][j]--;
        }
    }
    int h=0,t=0;
    for (int i=1;i&lt;=n;i++) if (Degree[i]==0) Queue[++h]=i,F[i]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            Degree[V[i]]--;
            if (F[V[i]]&lt;F[u]+1) F[V[i]]=F[u]+1,Path[V[i]]=u;
            if (Degree[V[i]]==0) Queue[++h]=V[i];
        }
    }
    while (t!=h);
    int id=1;
    for (int i=2;i&lt;=n;i++) if (F[i]&gt;F[id]) id=i;
    printf("%d\n",F[id]);
    Outp(id);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;Degree[v]++;
    return;
}

void Outp(int id)
{
    if (id==0) return;
    Outp(Path[id]);
    printf("%s\n",Input[id]+1);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>902</wp:post_id>
		<wp:post_date><![CDATA[2018-05-28 11:29:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-28 03:29:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu2462sdoi2007%e6%b8%b8%e6%88%8f%ef%bc%88%e5%ad%97%e7%ac%a6%e4%b8%b2hash%ef%bc%8c%e6%9c%80%e9%95%bf%e8%b7%af%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hash"><![CDATA[Hash]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2hash"><![CDATA[字符串Hash]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[473]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4912/Luogu3783][SDOI2017]天才黑客（Trie树，最短路径，构造）</title>
		<link>http://sycstudio.com/archives/903</link>
		<pubDate>Mon, 28 May 2018 03:53:30 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=903</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

SD0062号选手小Q同学为了偷到SDOI7012的试题，利用高超的黑客技术潜入了SDOI出题组的内联网的中央控制系统，然而这个内联网除了配备有中央控制系统，还为内联网中的每条单向网线设定了特殊的通信口令，这里通信口令是一个字符串，不同网线的口令可能不同。这让小Q同学感觉有些棘手，不过这根本难不倒他，很快他就分析出了整个内联网的结构。
内联网中有 nnn 个节点（从 111 到 nnn 标号）和 mmm 条单向网线，中央控制系统在第 111 个节点上，每条网线单向连接内联网中的某两个节点，从 111 号节点出发经过若干条网线总能到达其他任意一个节点。每个节点都可以运行任意的应用程序，应用程序会携带一条通信口令，当且仅当程序的口令与网线的口令相同时，程序才能通过这条网线到达另一端的节点继续运行，并且通过每条网线都需要花费一定的时间。
每个应用程序可以在任意一个节点修改通信口令，修改通信口令花费的时间可以忽略不计，但是为了减小修改量，需要先调用一个子程序来计算当前程序的口令和网线的口令的最长公共前缀（记其长度为 lenlenlen ），由于获取网线的口令的某个字符会比较耗时，调用一次这个子程序需要花费 lenlenlen 个单位时间。
除此之外，小Q同学还在中央控制系统中发现了一个字典，每条网线的口令都是字典中的某个字符串。具体来说，这个字典是一棵 kkk 个节点（从 111 到 kkk 标号）的有根树，其中根是第 111 个节点，每条边上有一个字符，字符串 SSS 在字典中当且仅当存在某个点u使得从根节点出发往下走到u的这条路径上的字符顺次拼接构成 SSS 。
现在小Q同学在 111 号节点同时开启了 n−1n-1n−1 个应用程序，这些应用程序同时运行且互不干扰，每个程序的通信口令都为空，他希望用最短的时间把这些程序分别发送到其他节点上，你需要帮小Q同学分别计算出发送到第 i(=2,3,…,n)i(=2,3,\dots ,n)i(=2,3,…,n) 个节点的程序完成任务的最短时间。

<h3>Tag</h3>

Trie树，最短路，构造

<h2>解决思路</h2>

直接在原图上跑最短路不好记录状态。由于我们知道进入一个点时的口令一定是入边的口令，而出一个点的口令则是离开这个点的边的口令，所以我们想到把边转化成点，这样点权就可以直接固定了。
但是直接连边是&#92;(O(m^2)&#92;)的，所以要考虑优化建图。
一种方法就是，对于原图中的点，把它的所有入边和出边统计（也就是新图中的点），找到它们的口令对应的在&#92;(Trie&#92;)树中的节点，然后构建出虚树。由于&#92;(lcp&#92;)有良好的性质，即&#92;(Trie&#92;)上两点代表的字符串的&#92;(lcp&#92;)长度就是这两个点&#92;(lca&#92;)的深度。所以只需把&#92;(Trie&#92;)的每一个点的每一棵子树中的点相互连边。又因为子树的&#92;(dfn&#92;)序表示为一个连续区间，一个区间在线段树上最多拆分成&#92;(log_n&#92;)个区间，所以，再加上一个辅助点的话可以把边优化到&#92;(log&#92;)级别。
但这样建图还是太麻烦了，这里介绍一种不需要虚树和线段树优化建图的方法。[来源：<a href="https://www.cnblogs.com/clrs97/p/7833797.html">Clairs</a>]
还是考虑每一条边的口令在&#92;(Trie&#92;)树上的对应的点，按照&#92;(dfn&#92;)序排序后，类似后缀数组中的&#92;(height&#92;)有&#92;(lcp(u,v)=min(height[u],height[u+1],...,height[v-1])&#92;)，两个点&#92;(u,v&#92;)的&#92;(lcp&#92;)长度应该就是这两个点之间所有的点中最浅的&#92;(lca&#92;)。
所以，现在的问题是如何建图使得能够得到一段边权取&#92;(min&#92;)的最短路呢？可以采用建立前缀虚点和后缀虚点的方法，建立四排点，分别表示入边前缀，入边后缀，出边前缀和出边后缀，然后在对应的前后缀之间连边，边权为&#92;(lca&#92;)的深度。这样以来，边数和点数均优化到&#92;(O(m)&#92;)级别了。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51000*10;
const int maxM=maxN*10;
const int inf=2147483647;

class EDGE
{
public:
    int a,b,c,d;
};

int n,m,K;
int edgecnt,HeadIn[maxN],HeadOut[maxN],Next[maxN],V[maxN];
EDGE E[maxN];
int PreIn[maxN],PreOut[maxN],SufIn[maxN],SufOut[maxN],Queue[maxN];

void Add(int &amp;head,int v);
void Doing(int id);
bool cmp(int a,int b);

namespace TRIE
{
    const int maxBit=15;

    map&lt;int,int&gt; Son[maxN];
    int dfncnt,Dfn[maxN],Fa[maxBit][maxN],Depth[maxN];

    void Add(int u,int v,int w);
    void Do();
    void dfs_dfn(int u);
    int GetLCA(int u,int v);
}

namespace GRAPH
{
    class HeapData
    {
    public:
        int u,dist;
    };

    int NodeW[maxN];
    int nodecnt;
    int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM],Dist[maxN];
    bool vis[maxN];
    priority_queue&lt;HeapData&gt; H;

    void Add_Edge(int u,int v,int w);
    bool operator &lt; (HeapData A,HeapData B);
    void Dij();
}

int main()
{
    mem(HeadIn,-1);mem(HeadOut,-1);edgecnt=0;TRIE::dfncnt=0;GRAPH::nodecnt=0;GRAPH::edgecnt=0;mem(GRAPH::Head,-1);
    int TTT;scanf("%d",&amp;TTT);
    while (TTT--)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
        GRAPH::nodecnt=m;
        for (int i=1;i&lt;=m;i++)
        {
            scanf("%d%d%d%d",&amp;E[i].a,&amp;E[i].b,&amp;E[i].c,&amp;E[i].d);
            Add(HeadIn[E[i].b],i);Add(HeadOut[E[i].a],i);
            GRAPH::NodeW[i]=E[i].c;
        }
        for (int i=1;i&lt;K;i++)
        {
            int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
            TRIE::Add(u,v,w);
        }

        TRIE::Do();

        for (int i=1;i&lt;=n;i++) Doing(i);

        GRAPH::Dij();

        for (int i=2;i&lt;=n;i++)
        {
            int ans=inf;
            for (int j=HeadIn[i];j!=-1;j=Next[j])
                ans=min(ans,GRAPH::Dist[V[j]]);
            printf("%d\n",ans);
        }

        mem(HeadIn,-1);mem(HeadOut,-1);edgecnt=0;TRIE::dfncnt=0;GRAPH::nodecnt=0;GRAPH::edgecnt=0;mem(GRAPH::Head,-1);mem(TRIE::Fa,0);mem(TRIE::Depth,0);mem(GRAPH::NodeW,0);
        for (int i=1;i&lt;=K;i++) TRIE::Son[i].clear();
    }
    return 0;
}

void Add(int &amp;head,int v)
{
    edgecnt++;Next[edgecnt]=head;head=edgecnt;V[edgecnt]=v;
    return;
}

void Doing(int id)
{
    int cnt=0;
    for (int i=HeadIn[id];i!=-1;i=Next[i]) Queue[++cnt]=V[i];
    for (int i=HeadOut[id];i!=-1;i=Next[i]) Queue[++cnt]=-V[i];
    sort(&amp;Queue[1],&amp;Queue[cnt+1],cmp);

    for (int i=1;i&lt;=cnt;i++)
    {
        PreIn[i]=++GRAPH::nodecnt;PreOut[i]=++GRAPH::nodecnt;SufIn[i]=++GRAPH::nodecnt;SufOut[i]=++GRAPH::nodecnt;
        if (i&gt;1)
        {
            GRAPH::Add_Edge(PreIn[i-1],PreIn[i],0);
            GRAPH::Add_Edge(PreOut[i-1],PreOut[i],0);
            GRAPH::Add_Edge(SufIn[i],SufIn[i-1],0);
            GRAPH::Add_Edge(SufOut[i],SufOut[i-1],0);
        }
        if (Queue[i]&gt;0) GRAPH::Add_Edge(Queue[i],PreIn[i],0),GRAPH::Add_Edge(Queue[i],SufIn[i],0);
        if (Queue[i]&lt;0) Queue[i]*=-1,GRAPH::Add_Edge(PreOut[i],Queue[i],0),GRAPH::Add_Edge(SufOut[i],Queue[i],0);
    }

    for (int i=1;i&lt;cnt;i++)
    {
        int lca=TRIE::GetLCA(E[Queue[i]].d,E[Queue[i+1]].d);
        int d=TRIE::Depth[lca]-1;
        GRAPH::Add_Edge(PreIn[i],PreOut[i+1],d);
        GRAPH::Add_Edge(SufIn[i+1],SufOut[i],d);
    }
    return;
}

bool cmp(int u,int v){
    return TRIE::Dfn[E[abs(u)].d]&lt;TRIE::Dfn[E[abs(v)].d];
}

namespace TRIE
{
    void Add(int u,int v,int w){
        Son[u][w]=v;return;
    }

    void Do()
    {
        Depth[1]=1;
        dfs_dfn(1);
        for (int i=1;i&lt;maxBit;i++)
            for (int j=1;j&lt;=K;j++)
                if ((Fa[i-1][j])&amp;&amp;(Fa[i-1][Fa[i-1][j]]))
                    Fa[i][j]=Fa[i-1][Fa[i-1][j]];
        return;
    }

    void dfs_dfn(int u)
    {
        Dfn[u]=++dfncnt;
        for (map&lt;int,int&gt;::iterator i=Son[u].begin();i!=Son[u].end();i++) Depth[(*i).second]=Depth[u]+1,Fa[0][(*i).second]=u,dfs_dfn((*i).second);
        return;
    }

    int GetLCA(int u,int v)
    {
        if (Depth[u]&lt;Depth[v]) swap(u,v);
        for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Depth[Fa[i][u]]&gt;=Depth[v])) u=Fa[i][u];
        if (u==v) return u;
        for (int i=maxBit-1;i&gt;=0;i--) if ((Fa[i][u])&amp;&amp;(Fa[i][v])&amp;&amp;(Fa[i][u]!=Fa[i][v])) u=Fa[i][u],v=Fa[i][v];
        return Fa[0][u];
    }
}

namespace GRAPH
{
    void Add_Edge(int u,int v,int w){
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;return;
    }

    bool operator &lt; (HeapData A,HeapData B){
        return A.dist&gt;B.dist;
    }

    void Dij()
    {
        mem(Dist,127);mem(vis,0);while (!H.empty()) H.pop();
        for (int i=1;i&lt;=m;i++) if (E[i].a==1) if (Dist[i]&gt;NodeW[i]) Dist[i]=NodeW[i],H.push((HeapData){i,Dist[i]});
        do
        {
            int u=H.top().u;H.pop();
            if (vis[u]) continue;
            vis[u]=1;
            for (int i=Head[u];i!=-1;i=Next[i])
                if ((vis[V[i]]==0)&amp;&amp;(Dist[V[i]]&gt;Dist[u]+NodeW[V[i]]+W[i]))
                    Dist[V[i]]=Dist[u]+NodeW[V[i]]+W[i],H.push((HeapData){V[i],Dist[V[i]]});
        }
        while (!H.empty());
        return;
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>903</wp:post_id>
		<wp:post_date><![CDATA[2018-05-28 11:53:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-28 03:53:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4912-luogu3783sdoi2017%e5%a4%a9%e6%89%8d%e9%bb%91%e5%ae%a2%ef%bc%88trie%e6%a0%91%ef%bc%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%ef%bc%8c%e6%9e%84%e9%80%a0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="trie%e6%a0%91"><![CDATA[Trie树]]></category>
		<category domain="post_tag" nicename="trie%e6%a0%91"><![CDATA[Trie树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="category" nicename="%e6%9e%84%e9%80%a0"><![CDATA[构造]]></category>
		<category domain="post_tag" nicename="%e6%9e%84%e9%80%a0"><![CDATA[构造]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[439]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1823/Luogu4171][JSOI2010]满汉全席（2-sat，Tarjan）</title>
		<link>http://sycstudio.com/archives/904</link>
		<pubDate>Mon, 28 May 2018 15:31:28 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=904</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现在數量繁多的菜色之中。由于菜色众多而繁杂，只有极少數博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。 世界满汉全席协会是由能够料理满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在參赛的厨师之中，找到满汉料理界的明日之星。 大会的规则如下：每位參赛的选手可以得到n 种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。大会的评审制度是：共有m 位评审员分别把关。每一位评审员对于满汉全席有各自独特的見解，但基本见解是，要有兩样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主見的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出來的狀况下，才能淘汰一位选手，否则不能淘汰一位參赛者。换句话說，只要參赛者能在这兩种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： 评审一 评审二 评审三 评审四 满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 如參赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而參赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。 但大会后來发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的參赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。如有四个评审员喜好如下表时，则不論參赛者采取什么样的做法，都不可能通过所有评审的考核： 评审一 评审二 评审三 评审四 满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 所以大会希望有人能写一个程序來判断，所选出的m 位评审，会不会发生 没有人能通过考核的窘境，以便协会组织合适的评审团。

<h3>Tag</h3>

2-sat，Tarjan

<h2>解决思路</h2>

由于每一种食材只能选择制作汉式或满式的一种，同时又有&#92;(m&#92;)组如果选择不制作某种食物就必须制作另一种的限制，所以是一个经典的&#92;(2-sat&#92;)模型，建立&#92;(4n&#92;)个点分别连边，然后&#92;(Tarjan&#92;)缩点判断是否矛盾。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101*4;
const int maxM=maxN*maxN*4;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int top=0,Stack[maxN];
bool instack[maxN];
int idcnt=0,Id[maxN];
int dfncnt,dfn[maxN],low[maxN];

void Add_Edge(int u,int v);
void tarjan(int u,int fa);

int main()
{
    int TTT;scanf("%d",&amp;TTT);
    while (TTT--)
    {
        scanf("%d%d",&amp;n,&amp;m);
        edgecnt=0;mem(Head,-1);dfncnt=0;mem(dfn,0);top=0;mem(instack,0);
        for (int i=1;i&lt;=n;i++) Add_Edge(i,i+n*3),Add_Edge(i+n*3,i),Add_Edge(i+n,i+n*2),Add_Edge(i+n*2,i+n);
        for (int i=1;i&lt;=m;i++)
        {
            int id1,id2;
            char opt1,opt2;
            scanf("\n%c%d %c%d",&amp;opt1,&amp;id1,&amp;opt2,&amp;id2);
            int d1=((opt1=='h')?(0):(n)),d2=((opt2=='h')?(0):(n));
            Add_Edge(id1+2*n+d1,id2+d2);Add_Edge(id2+2*n+d2,id1+d1);
        }
        for (int i=1;i&lt;=n*4;i++)
            if (dfn[i]==0) tarjan(i,0);

        bool flag=1;
        for (int i=1;i&lt;=2*n;i++) if (Id[i]==Id[i+2*n]) flag=0;
        printf("%s\n",(flag)?("GOOD"):("BAD"));
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++dfncnt;
    instack[u]=1;Stack[++top]=u;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (dfn[V[i]]==0)
        {
            tarjan(V[i],u);
            low[u]=min(low[u],low[V[i]]);
        }
        else if (instack[V[i]]) low[u]=min(low[u],dfn[V[i]]);
    if (dfn[u]==low[u])
    {
        int v;idcnt++;
        do v=Stack[top--],instack[v]=0,Id[v]=idcnt;
        while (u!=v);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>904</wp:post_id>
		<wp:post_date><![CDATA[2018-05-28 23:31:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-28 15:31:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1823-luogu4171jsoi2010%e6%bb%a1%e6%b1%89%e5%85%a8%e5%b8%ad%ef%bc%882-sat%ef%bc%8ctarjan%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="2-sat"><![CDATA[2-sat]]></category>
		<category domain="post_tag" nicename="2-sat"><![CDATA[2-sat]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="post_tag" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[300]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3339/Luogu4137]Rmq Problem（主席树）</title>
		<link>http://sycstudio.com/archives/906</link>
		<pubDate>Mon, 28 May 2018 15:37:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=906</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="\media\BZOJ\BZOJ3339.jpg" alt="BZOJ3339" />

<h3>Tag</h3>

主席树

<h2>解决思路</h2>

考虑对每一个位置维护一棵值域线段树，记录每一个值到当前的最晚出现时间。那么对于询问&#92;([l,r]&#92;)，在值域线段树上二分，若左边的最小值小于&#92;(l&#92;)说明可以继续往左儿子走，否则向右儿子走。
由于每一位只修改一个地方的值，所以用主席树代替&#92;(n&#92;)棵线段树。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=201000;
const int maxNum=200000;
const int inf=2147483647;

class SegmentData
{
public:
    int mn,mx;
    int ls,rs;
};

int n,m;
int Arr[maxN];
int nodecnt,root[maxN];
SegmentData S[maxN*100];

void Build(int &amp;now,int l,int r);
void Modify(int &amp;now,int l,int r,int ql,int qr);
int Query(int now,int l,int r,int limit);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]);
    Build(root[0],0,maxNum);
    for (int i=1;i&lt;=n;i++)
    {
        root[i]=root[i-1];
        Modify(root[i],0,maxNum,Arr[i],i);
    }
    for (int i=1;i&lt;=m;i++)
    {
        int l,r;scanf("%d%d",&amp;l,&amp;r);
        printf("%d\n",Query(root[r],0,maxNum,l));
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    S[now].mn=S[now].mx=0;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    return;
}

void Modify(int &amp;now,int l,int r,int pos,int key)
{
    S[++nodecnt]=S[now];now=nodecnt;
    if (l==r){
        S[now].mn=S[now].mx=key;return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(S[now].ls,l,mid,pos,key);
    else Modify(S[now].rs,mid+1,r,pos,key);
    S[now].mn=min(S[S[now].ls].mn,S[S[now].rs].mn);
    S[now].mx=max(S[S[now].ls].mx,S[S[now].rs].mx);
    return;
}

int Query(int now,int l,int r,int limit)
{
    if (l==r) return l;
    int mid=(l+r)&gt;&gt;1;
    if (S[S[now].ls].mn&lt;limit) return Query(S[now].ls,l,mid,limit);
    else return Query(S[now].rs,mid+1,r,limit);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>906</wp:post_id>
		<wp:post_date><![CDATA[2018-05-28 23:37:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-28 15:37:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3339-luogu4137rmq-problem%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[444]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3489]A simple rmq problem（KDT）</title>
		<link>http://sycstudio.com/archives/907</link>
		<pubDate>Mon, 28 May 2018 15:44:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=907</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

因为是OJ上的题，就简单点好了。给出一个长度为n的序列，给出M个询问：在[l,r]之间找到一个在这个区间里只出现过一次的数，并且要求找的这个数尽可能大。如果找不到这样的数，则直接输出0。我会采取一些措施强制在线。

<h3>Tag</h3>

KDT

<h2>解决思路</h2>

考虑对每一个位置上的数求出它前面第一个与它一样的记为&#92;(Last[i]&#92;)，后面第一个与它一样的记为&#92;(Next[i]&#92;)，那么对于询问&#92;([l,r]&#92;)，要求满足&#92;(l \le i \le r \quad Last[i] &lt; l \quad Next[i] > r &#92;)，这个位置上的数就作为权值，那么题目就转化为一个求三维空间中一定区域的点中最大的点权，用&#92;(KDT&#92;)优化&#92;(O(n^2)&#92;)的朴素查询。

<h2>代码</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int maxK=3;
const int inf=2147483647;

class KDT
{
public:
    int P[maxK];
    int Mn[maxK],Mx[maxK];
    int key,mx;
    int ls,rs;
};

int n,m;
int nowD,root,Ans;
int Arr[maxN],Last[maxN],Next[maxN],Pos[maxN];
KDT T[maxN];

bool operator &lt; (KDT A,KDT B);
void Update(int now);
int Build(int l,int r,int D);
void Query(int now,int k1,int k2);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]);
    for (int i=1;i&lt;=n;i++) Last[i]=Pos[Arr[i]],Pos[Arr[i]]=i;
    for (int i=1;i&lt;=n;i++) Pos[i]=n+1;
    for (int i=n;i&gt;=1;i--) Next[i]=Pos[Arr[i]],Pos[Arr[i]]=i;

    for (int i=1;i&lt;=n;i++) T[i].P[0]=i,T[i].P[1]=Last[i],T[i].P[2]=Next[i],T[i].key=Arr[i];
    root=Build(1,n,0);
    int lastans=0;
    for (int i=1;i&lt;=m;i++)
    {
        int x,y,l,r;scanf("%d%d",&amp;x,&amp;y);
        l=min((x+lastans)%n+1,(y+lastans)%n+1);
        r=max((x+lastans)%n+1,(y+lastans)%n+1);
        Ans=0;
        Query(root,l,r);
        printf("%d\n",lastans=Ans);
    }
    return 0;
}

bool operator &lt; (KDT A,KDT B){
    return A.P[nowD]&lt;B.P[nowD];
}

void Update(int now)
{
    if (T[now].ls) T[now].mx=max(T[now].mx,T[T[now].ls].mx);
    if (T[now].rs) T[now].mx=max(T[now].mx,T[T[now].rs].mx);
    for (int i=0;i&lt;maxK;i++)
    {
        if (T[now].ls) T[now].Mn[i]=min(T[now].Mn[i],T[T[now].ls].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[T[now].ls].Mx[i]);
        if (T[now].rs) T[now].Mn[i]=min(T[now].Mn[i],T[T[now].rs].Mn[i]),T[now].Mx[i]=max(T[now].Mx[i],T[T[now].rs].Mx[i]);
    }
    return;
}

int Build(int l,int r,int D)
{
    if (l&gt;r) return 0;
    nowD=D;
    int mid=(l+r)&gt;&gt;1;
    nth_element(&amp;T[l],&amp;T[mid],&amp;T[r+1]);
    for (int i=0;i&lt;maxK;i++) T[mid].Mn[i]=T[mid].Mx[i]=T[mid].P[i];
    T[mid].mx=T[mid].key;
    T[mid].ls=Build(l,mid-1,(D+1)%maxK);
    T[mid].rs=Build(mid+1,r,(D+1)%maxK);
    Update(mid);
    return mid;
}

void Query(int now,int k1,int k2)
{
    if (T[now].mx&lt;Ans) return;
    if ((T[now].Mn[0]&gt;k2)||(T[now].Mx[0]&lt;k1)||(T[now].Mn[1]&gt;=k1)||(T[now].Mx[2]&lt;=k2)) return;

    if ((T[now].Mn[0]&gt;=k1)&amp;&amp;(T[now].Mn[0]&lt;=k2)&amp;&amp;(T[now].Mx[0]&gt;=k1)&amp;&amp;(T[now].Mx[0]&lt;=k2)&amp;&amp;(T[now].Mn[1]&lt;k1)&amp;&amp;(T[now].Mx[1]&lt;k1)&amp;&amp;(T[now].Mn[2]&gt;k2)&amp;&amp;(T[now].Mx[2]&gt;k2))
    {
        Ans=max(Ans,T[now].mx);
        return;
    }
    if ((T[now].P[0]&gt;=k1)&amp;&amp;(T[now].P[0]&lt;=k2)&amp;&amp;(T[now].P[1]&lt;k1)&amp;&amp;(T[now].P[2]&gt;k2)) Ans=max(Ans,T[now].key);
    if (T[T[now].ls].mx&gt;=T[T[now].rs].mx)
    {
        if (T[now].ls) Query(T[now].ls,k1,k2);
        if (T[now].rs) Query(T[now].rs,k1,k2);
    }
    else
    {
        if (T[now].rs) Query(T[now].rs,k1,k2);
        if (T[now].ls) Query(T[now].ls,k1,k2);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>907</wp:post_id>
		<wp:post_date><![CDATA[2018-05-28 23:44:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-28 15:44:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3489a-simple-rmq-problem%ef%bc%88kdt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="kdt"><![CDATA[KDT]]></category>
		<category domain="post_tag" nicename="kdt"><![CDATA[KDT]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[356]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>一言 Hitokoto</title>
		<link>http://sycstudio.com/hitokoto</link>
		<pubDate>Sun, 09 Sep 2018 15:10:11 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=929</guid>
		<description></description>
		<content:encoded><![CDATA[(收集的一些一言)
(假装还在更新...)
有你在的日子才是我的日常。
夹在我女友与前女友与青梅竹马间的果然是修罗场！
既然如此，就再努力一次吧。别在这里愁眉不展，也不要再自欺欺人，重新来过！
比自己,比梦想更重要的东西永远都存在着…
嘛，那又怎么样呢？
自身不先改变的话，一切都不会改变。
比起有一百个朋友，不如有个比一百人还要重要的真心朋友。
我有在反省，但我不后悔。
要超越过去与悲伤，用坚强和笑容去开拓明天。
男人许下的诺言就一定要遵守。
没有回忆就去创造回忆，没有道路就去开辟道路。
我敬你是条汉子！
不相信自己的人，连努力的价值都没有。
微风摇曳着窗帘，夕阳斜射入教室，在那里鼓起勇气告白的少年。即使现在也能清晰地回想起她的声音「当朋友，不行吗？」
就算是沉落地面的太阳，只要夜晚过了一定会再度升起，不管有什么痛苦或难过的事，跟今天截然不同的明天也一定会到来。
我的腿让我停下，可是心却不允许我那么做。
生活就像超级女生，走到最后的都是纯爷们。
我要拼，装上假牙也要拼！
想要成为无论多么悲伤的时候，也能够漂亮微笑的人吧。
人们只是用好人来称呼对自己有用的人而以，不存在对所有人都有用的人。
烈焰中舞动的火花，将赐予邪恶异性交往以天罚。
无论乌云有多浓厚，星星也一定还在，只是暂时看不到了而已。
不相信人咬不到肚脐的，咬破肚脐去死如何？
人一生会遇到约万人，两个人相爱的概率是.。所以你不爱我，我不怪你。
不管看到什么样的过去，都请不要迷失自己，不管你变成什么样子，我都是你的同伴。
心，可是很重的。
我爱上的人，称我为怪叔叔
慕君之心，至死方休。
虚伪的眼泪，会伤害别人，虚伪的笑容，会伤害自己。
若隐若现才是艺术！
生我何用？不能欢笑。灭我何用？不减狂骄。
就是因为你不好，才要留在你身边，给你幸福。
呐，我们好像是，被宇宙和地球拆散的恋人似的。
你会梦游，我会磨牙，我们晚上一起去吓人吧！
或许只需一滴露水，便能守护这绽放的花朵。
自己永远是孤单的，但你可以让其他人变得不孤单。
和哥哥的便当比起来夜空的薯片就像大便一样！只会给我大便的大便夜空是笨蛋～笨蛋～
我手中的魔法，是守护挚爱的力量，是坚定这个信念所必须的力量，我一定会拯救你的，无论在何时、何地。
要改变别人的心真是件很难办的事，不过改变自己要容易一点。
风筝的线你随时可以放开，只是别盼望我会回来。
Nothing is true, everything is permitted.
与你的生命等价的东西，这个世界上根本没有。
君子可寓意于物，但不可留意于物。
最好的感觉，是有人懂你的欲言又止。
看似美好的东西，往往藏着陷阱。
爱,其实很简单，困难的是去接受它。
喜欢大胸只是本能，喜欢贫乳才是审美。
二次元什么的我本来是不感冒的，直到我的膝盖中了一箭。
你才是⑨！你全家都是⑨！
努力是不会背叛自己的，虽然梦想有时会背叛自己。
面对就好，去经历就好。
我从小就害怕虫子
做不到的话，不过就是一死 。但是，赢了就能活下去，要是不战斗就赢不了。
既然认准这条路，何必去打听要走多久。
研表究明，汉字的序顺并不定一能影阅响读，比如当你看完这句话后，才发这现里的字全是都乱的。
少年心意，一如明月松间的青石流水，那些年里看到了，却不懂。
明明只是活着，哀伤却无处不在⋯⋯
少罗嗦，你还不如虫子呢！
天空是连着的，如果我们也能各自发光的话，无论距离有多远，都能看到彼此努力的身影。
别人恋爱不成功，你连暗恋都不成功！
H什么的最讨厌了！
如果你都不知道自己想去哪里，那去哪里都是一样的。
越是困难，越要抬起头，地上可找不到任何希望！
人与人在偶然之中创造相遇与别离。
所以，他们的祭典还没结束。
既不回头，何必不忘；既然无缘，何必誓言；今日种种，似水无痕。
正因为听不见和看不到，所以风子才会做这样的事情。
你为了你的正义，我为了我的正义。
可是就算我们通一千次短信，我们各自的心，大概也只会相互靠近一厘米吧。
用我一生，换你十年天真无邪。
不忘初心，方得始终。
我的终点，与幸福同在。
什么都无法舍弃的人，什么都无法改变 。
错的不是我， 错的是世界。
有些人，一旦遇见，便一眼万年；有些心动，一旦开始，便覆水难收。
有光的地方必有影，有影的地方也必定有光，绝望的颜色越是浓重，一定会有光芒耀眼的希望。
已经无法回到过去了。也不知道将来会是什么模样。
我知道的，面码⋯⋯自己已经死掉这点事，还是知道的⋯⋯
苦到头未必是甜的，而甜到头一定是苦的 。
文能提笔控萝莉，武能床上定人妻。进可欺身压正太，退能提臀迎众基。
就算只有六十亿分之一的机会，我们还是会邂逅。
无法飞翔的翅膀也是有意义的，因为它是曾经翱翔于天空所留下的珍贵回忆。
不会停的雨的确存在，但是撑起伞来就行了，接下来抬起头前进，这样一来，偶尔会出现下着太阳雨的日子，经过阳光的反射闪闪发亮的雨滴，一定非常美丽。
人总是会变的，不要害怕改变哦。
即使从梦中醒来，还会有回忆留下。
想了解喜欢的人，可是，却不能理解。
只要有想见面的人，自己就不再是孤单一人。
一定是红线下得太乱，才不小心把我和你绑在一起了……却没系稳。
挡着在我们面前的是巨大庞然的人生，阻隔在我们中间的是广阔无际的时间，对于他们，我们无能为力⋯⋯
这是眼泪吗？原来眼泪是这么的温暖，我一直以为，哀伤的东西都是冰冷的。
时间并不存在，存在的只有此刻。
梦想是否无聊并不是别人来决定的，不管是什么样的梦想，自己拼命努力去追寻才是最重要的。
等待，不是为了你能回来，而是找个借口不离开。
世界这么大，人生这么长，总会有那么一个人，让你想要温柔的对待。
嗯，一个人也要加油，我是坚强的孩子。
我想让自己强大起来，因为至少我已经有幸和想要保护的人相遇了。
老是低着头，幸福可是会离你而去的喔。
我觉得，我这辈子最灿烂的笑容，大概都奉献给我电脑屏幕了。
如果还有来生 ，我无论如何都要来到你身边，我已经没有了其他想要追求的东西，因为没有比你更重要的了。
将愿望倾入不愿忘却的回忆中⋯⋯
胸不平何以平天下，乳不巨何以聚人心。
你最无暇的时光是哪段，你又把它奉献给了谁？
男人变态有什么错！
失去的东西虽然拿不回来，但是，忘记的事情是可以想起来的。
生生生生暗生始，死死死死冥死终。
我的小伙伴们都惊呆了！
刁蛮少女贵千金，比武招亲动芳心。盼能与君长相依，结伴江湖侠侣行。
控兄是我的个性的同时，也是勋章！
哭泣并不能改变任何事情。
既不回头，何必不忘；既然无缘，何须誓言；今日种种，似水无痕；明夕何夕，君已陌路。
欺骗世界，欺骗最初的你。
只有破碎的心才有伤人的棱角。
我只对现实世界绝望过，却未对自己绝望过！
从小好女色的男人的想像力比不上狗。
我并不羡慕别人的人生，这就是所谓幸福。
All for one, one for all.
神曲的存在并不是为了享受音乐，而是品味那段最珍贵的回忆。
有些事情本身我们无法控制，只好控制自己。
日子过的象流水一般。它静静的从我们身边缓缓流过，不带半分声响。那些我们当年执着的人，执着的事，执着之后，却变成一种负担。
不要把你所遭遇的苦难看得太大，更不要把你所拥有的幸福看得太少。
就是因为抱有不现实的理想，所以才总是做出如此极端的事情！
给我一个电话亭，我要拯救地球。
这个城市大得让人到处能一见钟情，却没法重逢。
一直注视着你，似近似远，总是触碰不到。
不要祈求生活公平，只需要适应它。
男人就应该保持冷静，沸腾的水只会被蒸发掉。
如果我会变成恶魔，那就随他吧。我会接受放逐，一切只为了保护她。
如果你执意追寻着我的幻影，总有一天会被真正的我打败。
魔装少女就是本少爷！
天空本是一种风景，可是遇见你之后，它变成了一种心情。
我是一个经常笑的人，可我不是经常开心的人。
只是相谈就会开心起来，沉浸在温柔的眼神当中，竭尽全力的思念，悄悄地奉献。
你愿意陪我走到地狱的底端吗？
重要的不是你做了多少事，而是你放了多少心思进去。
今后无论发生什么事也好，这个左手上的⋯⋯都是同伴的记号！
不要哀求，学会争取；若是如此，终有所获。
无论是丢下还是被丢下，都是一样痛苦的。
新闻联播的牛X之处在于就算你一直在换台，也能完整的看完一条新闻。
我们所过的每个平凡的日常，也许就是连续发生的奇迹。
喜欢上你，爱上你，真是太好了，谢谢。
共道人间惆怅事，不知今夕是何年。
没有动漫的世界，就是没有的光明的大地！
所谓的言语，只有当对方听进去了才开始有意义啊。
臣妾做不到啊~
因为无法再见面，所以要笑着说再见。
与其被自己的本性牵着走而痛苦，倒不如试着改变自己。
你永远是我唯爱旅行中名为秘密的起点站。
为毛我的眼里常含泪水，因为我老是中枪。
我们一路奋战，不是为了改变世界，而是为了不让世界改变我们。
如果你愿意的话，让我带您去吧，这座小镇，愿望实现的地方⋯⋯
美丽的不是这个世界，而是看世界的你的眼神。
我们走过风走过雨，就是没能走进彼此的内心。
以前高中时，羡慕大学考试只要及格就行；现在大学了，怀念高中考试及不及格都行⋯⋯
人生最糟糕的事，一个是饿肚子，一个是孤独。
从一开始，我就不那么喜欢你。
旅行唯有出发前最愉快，狗儿唯有叫声最吓人，女人唯有背影最美丽。
人的记忆本来就是暧昧的，不值得信任。
既然忘不掉，就把它留在心中，让时间去冲淡它。
就算风吹散了冰雪，想念也会留存下来。
生活中若没有朋友，就像生活中没有阳光一样。
上帝说要有光，于是萝莉就掀起了裙子。
什么都无所谓只想在你身边，什么都无所谓只想和你说话，什么都无所谓所以请你不要逃避。
我很好奇！
忘记本身就是一件不可能的事。
能够轻易就放弃的梦想，有存在的价值么？
彼此相互推卸不幸是没有结果的。
如果分手的恋人还能做朋友，要不从没爱过，要不还在爱着。
宅，是一种生活状态；死宅，是一种人生境界⋯⋯
烦恼这东西，是只有活着的人，才有的特权哦。
( ⊙ o ⊙ )啊，你在看这条一言
半夜还在Coding的人也是蛮拼的吧…
如果你是我该多好，那你就会知道我有多难过，多喜欢你。
风停之后再扬帆，船绝不会前行。
当你想做一件事，却无能为力的时候，是最痛苦的。
请不要忘记，那给你带来感动的，名为二次元的理想乡。
如果聚集负的感情，世界就会陷入负的洪流；反之聚集正的感情，世界就会循着正道而行。
自己的感觉，不说出来，别人也不会懂，如果不懂，就应该互相沟通。
故乡的云。上古的玉。随手的诗。十九岁的你。
黑暗不能驱除黑暗，只有光明可以做到；仇恨不能驱除仇恨，只有爱可以做到。
我不是萝莉控，是妹控啊！
相信十年后的八月，我们还会相遇。
（根据相关法律法规，相关内容已被屏蔽。）
看到的感受到的永远都不会消失永远都不会忘记，与各种各样的相遇一同永存。
沒有永远下不停的雨。
一天吐槽太多次的话，梗也是会用完的。
只是，想要做些什么而已。 觉得不做些什么就会死掉而已。
想要试着去相互接近，但最后还是无法敞开心扉，结果就是擦肩而过⋯⋯
今天你最后遇见的那个人有在微笑吗？
弱小和无知不是生存的障碍，傲慢才是。
别人说的记在脑袋里，而自己的，则放在心里。
煩い！煩い！煩い！
我们开始一起攀登，这长长的，长长的坡道。
不要，我现在暂时留在他身边，直到那转瞬即逝的日子到来。
“你没车没房没卡,拿什么和我谈恋爱？”“……我有高达……”
十步做一死，千里不留行，事了拂衣去，深藏功与名~
我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。
每个凉宫都会遇到属于她的John Smith。
仍是那么熟悉的味道，只是用墓土和骨灰作成的身体，已经不再有体温。
比起悲伤来说，无法分享快乐这件事，要更加的寂寞吧。
我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。
一天最大任务莫过于，好好睡觉，好好醒来。
我的眼睛，就是为了寻找你而存在的。
美好的人眼裡映出的世界也是美好的。
没有期盼就不会出现奇迹。
倘若只是为了驱赶心中的寂寞，找谁都可以的。
有被杀的觉悟，才有资格开枪。
虽有遗憾，并无后悔。
越是锐利的小刀切完东西后就越容易变钝。
桑丘，让他们管我叫疯子吧，我还疯得不够，所以得不到他们的赞许。
我想要握紧的并不是匕首或是什么，只不过是他的掌心而已。
如果你死了，那什么也改变不了，可如果你还活着，那就能改变一些事情。
透过孩子的眼神，让我相信这个世界上还有着纯真。
我和我的小伙伴们都惊呆了！
除了爱你，我什么都可以。
观察铅笔和橡皮，哪个是攻哪个是受，请写出它们晚上的对话。
我年轻，我傲娇。
下一次重逢，将是何年何月？天空必将见证。
我是要成为海贼王的男人！
我愿意给你自己所有的快乐，你愿意分担我一半的难过吗？
有一种无奈叫做，你明明是只候鸟，却喜欢上只能给你冬天的人。
廉价的自尊、粗劣的傲气，无论哪个后生小辈都很重视这些东西。
你的心可以属于耶稣，但你的屁股永远属于陆战队！
雨，何时停？
那天放学的时候人很多。楼道很挤，你的手不小心碰到了我的手背，这是我漫长而又短暂的初恋。
心之所愿，无所不成。
XX什么的，最讨厌了！
工程穷三代，考古毁一生。
你知道雪为什么是白色的吗？因为她忘记了本来的颜色。
最终让你难以忘怀的，并不是某个谁，而是当初为之倾心，不顾一切的自己。
用番茄Lu过…比香蕉好←那是你没领悟到香蕉的正确用法
我们的夏天仍未结束。
愿我等之誓言，超越姓名与身份而永存。
无法逃避的是自我，而无法挽回的是过去。
败者死于绝望，胜者死于渴望。
情深不寿，强极则辱，谦谦君子，温润如玉。
我的一生，无怨无悔！
那双紧握不放的手⋯⋯抓住的是希望⋯⋯亦或是絕望⋯⋯
知道活着的痛苦处的人就能对人温柔，这和软弱是不一样的。
生活就像愤怒的小鸟，失败后总有几只猪在笑。
忘记一个人，并非不再想起，而是偶尔想起，心中却不再有波澜。
我没有梦想，但是我能保护！
树上的鸟儿成双对，对面的冤家你想掐死谁。
能够原谅女人的，才是男人。
我会继续等着你，就算是一万二千年。
Yesterday is a history, tomorrow is a mystery, but today is a gift.
年华无多时，恋爱吧男子！
贫乳是社会地位的象征。是具有稀有价值的！
今天的早餐是：早苗的面包、秋子的果酱和观铃的果汁~
承君此诺，必守一生。
历史虽然会一再重演，但人类却无法回到过去。
即使如此，我也有我想保护的世界！
患了中二病，等于有了一种信仰。
呐，知道么，樱花飘落的速度，是每秒五厘米哦~
如果我拥有如同小狗一样的尾巴的话，肯定会高兴得遮掩不住地摇来摇去吧。
男人从小的时候就是无药可救的。
懂得认输是非常重要的，不尝到失败的不甘，也就不会明白跌倒后怎么爬起来，更不可能再向前迈进。
树大必有枯枝，人多必有白痴。
请叫我女王大人~
不能哭！唱歌吧！继续唱下去吧！不是为了赞美神，是为了向神挑战而唱！
前天是小兔子，昨天是小鹿，今天是你。
只要微笑就可以了。
我觉得你很幸福，因为你可以选择爱我或不爱我，而我只能选择爱你或更爱你。
我们都在命运之湖上荡舟划桨，波浪起伏着而我们无法逃脱孤航。但是假使我们迷失了方向，波浪将指引我们穿越另一天的曙光。
繁花落尽，明月映着谁老去……
我会跟她结婚，并不是因为她是计算机，而是因为她就是她。同样的，我会喜欢你，也是因为你就是你。
旅行的意义在于找到自己，而非浏览他人。
扎古不论怎么化妆都不可能变成高达的。
只要一息尚存，就还有希望。
你制定的计划是.txt还是.exe?
重要的是无论我们选择哪条路，都要担负起选择的责任。
如果不能忠于自己的心，胜负又有什么价值呢？
一个人吃饭，太寂寞了。
我在未来等你。
爱迪生说过：“要把BOSS打倒就要准备足够的等级。”
大地母亲在忽悠着你。
我一直都在你身边 ，一直都在。
智商是硬伤。
问君能有几多愁？恰似一部新番没看头。
应该可以了吧，我已经很努力了，应该可以抵达终点了⋯⋯
谎言不一定是谎言，被发现的谎言，才算是谎言。
就算鼻血流尽，也不能放弃妄想。
世界并不完美，却因此而美丽。
无论在哪里遇到你，我都会喜欢上你。
没有谁能够永远坚强下去的，每个人都会有疲累的无法站起的时候。世间的故事，就是为了这一刻而存在的哦。
那种亲密的人突然陌生，希望完全落空的感觉，就好像喝口凉水居然被烫到。
一直保持微笑是有诀窍的，那就是，在想哭的时候放声大哭。
恋ではなく、爱でもなく、もっとずっと 深く重い。
邂逅本身，就是一种奇迹啊。
过去的事情可以不忘记，但一定要放下。
要相信同伴，拯救同伴。
如果能够重生的话，我想，我想成为水母。想成为只是在海里自由地摇摇摆摆的水母。
我相信十年后的八月，我们还能再相遇。
想你想到手都断了…
当朋友是不需要什么资格的。
像平常的你一样引发奇迹吧-
我的内心就和厕纸一样单纯！
如果我是那雨滴的话，那么，我能够像把不曾交汇的天空与大地连接起来那样，把某人的心串联起来吗？
只要能努力，就应当去努力；只要还能前进，就要向前走去。
梦总是有会醒来的时候，不会醒的梦总有一天会变成悲伤。
胜而不灭，霸而不辱，这才是真正的征服。
私だって今日こそ… 遠野くんに告白するんだ。
活着就是为了改变世界。
我不会接受我不要的未来，哪怕是命中注定。
我的船上没有手下，只有伙伴。
生尽欢，死无憾。
岁的阿升你好，我是岁的美加子，我现在也还是非常、非常的喜欢阿升哦！
勇气，就是即便害怕也会去做。
人经历风浪是会变得更强，可是船不同，日积月累的只有伤痛。
君生我未生，我生君已老。 君恨我生迟，我恨君生早。
代表月亮消灭你！
我们的心就像那天空一样，永不分离。
时间可以治愈？如果时间也病了怎么办？
真可悲，你什么都不知道，在这个世界上没有什么是不重要的！
不管怎么样，未来都是可以改变的。
有些事情我不看透，不是我笨，只是我太善良。
成熟不是人的心变老，是泪在打转还能微笑。
我除了投三分，就什么都没有了⋯⋯
最近困扰我的是小小的分别，总会带来一丝寂寞。短暂的相遇和分别那一分一秒的时间都让我想要无比珍惜。
小孩子看了根本把持不住！
对不起，风太大，我没有听清楚⋯⋯
不敢正视你的眼睛，是怕我每一个眼神都在告白。
在回忆里留下微笑是为了不让你哭泣…
能哭的地方只有厕所和爸爸的怀里。
拿着刀并且可以让人们变得幸福的只有料理人。
我只是做了我能做的事，没有时间想将来。
为错误停驻是件可悲的事。
你不会死的，因为我会保护你.
阳光灼热，数不尽夏日繁华；蝉鸣幽幽，道不完苦辣酸甜。
我们在年少时并不知道，有些乐章一旦开始，唱的就是曲终人散。
哼！悔改吧，你们这群死宅，人家可是身价四千万的大小姐。
“像你这样的白痴是怎么活过来的？”“因为我很自信。
要是因为烦恼很痛苦，就选择了轻松的选项，将来一定会后悔。
隐约雷鸣，阴霾天空，即使天无雨，我亦留此地。
即使无法掌握未来，也请不要忘了明天。
我如朝露降人间，和风樱花随春谢。四十九年一朝梦，一期荣华一杯酒。
我在人生的道路上迷失了。
就算一次也好，我想在这颗星球上尽情奔跑。
因为我喜欢你，喜欢得想吃掉你啊！
只要有你，我便无所不能。
隐约雷鸣，阴霾天空，但盼风雨来，能留你在此。
取少量学生放入试管，加入过量作业，生成学霸溶液和不溶于水的学渣。过滤，在学渣中加入过量浓试卷，学渣迅速溶解且产生气泡，学霸则无明显现象。
其实，恋爱这种东西，当你看上人家的那一刹那就已经失败了。
一年、两年、三年⋯⋯十年、百年、千年⋯⋯即使用永恒的时间来等待，我也想再见你一面。
这是傻瓜的血脉使然啊。
在我年轻的时候，不知道什么是恐惧，可偏偏是你的温柔，让我害怕。
羁绊是那不可切断的深切联系。即使分离，心与心也紧紧的连在一起。
一句话，不足以讲述一个故事，却可以让我们回味那些个动人的瞬间。
你需要找出面对明天的力量。
与众不同的生活方式很累人呢，因为找不到借口。
安心地睡吧，就算你将遗忘一切，我也会永远记得。我将为你而生、为你而死。
和我定下契约，成为魔法少女吧！
是金子一定会发光，是银子一定会花光，是裙子一定会走光，是节操一定要丢光。
你的那双手呢，是为了紧紧抓住什么而存在的哦。
人は一生、中二病なんだ。
低头不是认输，是要看清自己的路；昂头不是骄傲，是要看清自己的天空。
一个人走在路上，形单影只/回首望去，大家都留在远方/回过头来继续前行，这便是所谓坚强
你还是这么冷漠啊。不过，仅此而已的话，我是不会泄气的。
龙儿是我的，谁都不准碰！
错误可不是为了别人才改的过来的，要为了自己才能改正。
只要你还记得我，我就会一直在你的身边。
既然我无法停留，那么就飞到我再也不能飞的那一天吧。
愿风指引着你的道路，愿你的刀刃永远锋利。
流浪去吧，总会在世界的一角找到愿意懂你的人。
就算你已经不在，就算你身边的人已经不再是我，我也会坚强的活下去，为了你。
我对普通的人类没有兴趣，你们只要是有外星人、未来人、异世界人、超能力者, 就尽管来找我吧！以上！
堕入黑暗裏的可怜影子啊，停止伤害他人的行为吧，犯下罪行的灵魂⋯⋯想死一次么？
花开花落，再灿烂的星光也会消失。
要么忙着生存要么赶着去死，人总要做点什么。
不能逃避，不能逃避，不能逃避，不能逃避⋯⋯
记性太好，有时候是一种负担。容易忘记往事的人，是幸福的。
你有学校也有朋友，但对我来说，我的生活中就只有你。
世界上没有偶然，有的只是必然。
我裤子都脱了你就给我看这个！！！
我们也许再也不会见面了吧，因此我绝对不会忘了你的声音，你的眼眸，与你一起看到过的所有的景色，以及，与你一起度过的那个耀眼的夏天。
用你的笑容去改变这个世界，别让这个世界改变了你的笑容。
我的愿望是—幸福地活着，幸福地死去。
我不会让任何人看到我软弱的一面。
人能够在心里郁积那么多的事情，而他们又会忘记那么多的事情，真是不可思议⋯⋯
有时语言就像把利刃，使用不当，就会成为凶器。
一定没有问题的！
我不渴望什么在别的城市迎来的春天，只要和你在一起的春天就好，只要和你在一起就好⋯⋯
你再怎么称赞我，我也不会高兴的，你这个混蛋~
我到底要以怎么样的速度生活才能与你再次相遇？
如果没什么好事发生的话，就把没有发生坏事的每一天当作好事吧。
你还欠我一句对不起，可我不会再说没关系了。
窃人者，自失其宝。
就连一直都无容身之地的我⋯⋯也不是可以任意舍弃的生命。
我决定以人类的一个方法来感激你，我打算以身相许！
在你最冷的时候，有人不顾自己寒冷抱着你，这就是幸福。
正义不会因为无人歌颂而变成非议。
魔非魔，道非道，善恶在人心。欲非欲，情非情，姻缘由天定。
也许我们都没有长大，只是世界变小了。
记得当时年纪小，你爱卖萌我爱笑。
缘起，在人群中，我看见你。缘灭，我看见你，在人群中。
(」・ω・)」うー！(／・ω・)／にゃー！
女人的武器不是眼泪，而是微笑。
此时此刻一切都是静寂的，只剩下我与你的世界，这就是爱？
选择道路的时候怎么犹豫都没有关系，但决定之后就一定要坚持到底！
面对无知的嘲笑，我只能为他们默哀。
空山新雨后，兵长一米六。
明天，不是你想要就能有的。
每当对这个世界感到绝望的时候，买一包泡面，然后告诉自己：我们的泡面是有酱包的。
万书皆下品，唯有萌最高！
如果你不能击败你的敌人，那么就加入他们。
当世界背叛你的那天到来时，我会为你背叛全世界。
真相只有一个！
用我的左手将你那个不可理喻的幻想粉碎掉！
我问你：你是我的Master吗？
人不能一个人活下去，不需要任何人的孤独和需要人但得不到的孤独是不一样的。
悲伤教会了我喜悦。
一起去看星星吧。
在走廊上跌倒会流鼻血，在人生中跌倒会流眼泪。
天下哪有真情在？只要够萌咱都爱！
就算是自私⋯⋯我也希望那些人能够永远都有笑容⋯⋯
比希望更炙热，比绝望更深邃，这就是爱啊。
去死两次！
我是最强的！
没有什么过不去，只是再也回不去。
找不到路，就自己走一条出来。
Hello World!
梦+想=梦想，这个等式是不成立的。
无论你在哪里，就算我看不见你，我也会一直注视着你。
你是我的，那是曾经。我是你的，直到现在。
成功率不到%，那剩下的用勇气来补足吧！
我发过誓，再也不装作没察觉，再也不逃避。
握不住的沙，不如扬了它。
人生在世何其痛苦，所以咖啡至少该甜一点。
恋爱什么的，无非就是大脑的电波式活动造成的bug的一种~
但是，这一次你将不再孤独。
算了，和你说话感觉就像是大姨妈来了。
我们不应该根据背负的罪孽来选择道路，而应在选择的道路上背负自己的罪孽。
求你，保护那孩子，消除灾厄，抹除祸事。哪怕⋯⋯那是我自己⋯⋯
那是，未满秒的邂逅。
要让一群人团结起来，需要的不是英明的领导，而是共同的敌人。
求求你，不要对我这么温柔！
地球只有一个，而欧派有两个。
(눈눈)
你在颓废的时候别人都在努力哦~♪
梦想是什么，梦想是现实的延续；现实是什么，现实是梦想的终结。
如果我不会飞，那我就只是一只普通的猪。
只要你在，我便无所不能。
少女祈祷中⋯⋯
再强的敌人在最后一集的主角面前也是渣渣。
我爱的人也爱着我，对我来说这简直是个奇迹。
这一路上有你的陪伴，我不再孤单。
姑娘们啊，要在该认真的地方全力认真，当你不想认真的时候不妨笑笑。
越是试着忘记，越是记得深刻。
过分的神圣，往往比恶魔更加恶质。
一支穿云箭，千军万马来相见。
离别并不痛苦，因为我们都微笑着。
来，让叔叔检查一下身体。
不记得了也好，忘却也是一种幸福。
这世上所有的不利状况，都是当事者的能力不足导致的。
别低头，王冠会掉。别流泪，贱人会笑。
能力越大，责任就越大，你避不了的。
我喜欢你们！超喜欢的！大家和我交往吧！绝对会让你们幸福的！
以盐水作配菜，糖水做主食，就有种奢侈的感觉呢。
给，一辈子朋友劵。
真正的危机不是机器人像人一样思考，而是人像机器一样思考。
我们擦身而过，是为了相识或者遗忘。
燃烧吧，我的小宇宙！
不习惯的事越来越多，但我仍在前进⋯⋯就算步伐很小，我也在一步一步的前进。
孙大圣，快收了神通吧！
会长和往常一样挺着小小的胸部一副自以为了不起的样子套用某本书的内容说道⋯⋯
世界上没有一个人能代替另一个人。
就算是对我抱有敌意的人，也是被某个人深爱着而降生在这个世界上的。
红茶的温度和女人心在任何时代都是难以琢磨呢。
你若盛开，清风自来。
所谓的人类，可是连短短的十分钟也等不起的。
我们都很擅长口是心非，但又希望对方能有所察觉。
リア充死ね！
乔巴，一个男人，有时候是不能逃避战斗的，尤其是当伙伴的梦想被人嘲笑的时候。
时间是伟大的作家，总会写下完美的结局。
我们虽然距离很远很远，非常非常的远，但是思念或许真的可以穿越时间和距离。
受尽苦难而不厌，此乃阿修罗之道。
江湖可能因为少了谁而失色，却不会因为少了谁后就不再是江湖。
在茫茫人海中，同样是高中生，同乘点分的电车，看着同一片海⋯⋯那个瞬间不就是如奇迹般的邂逅吗。
到底该怎么做，你才会重新喜欢我呢？
做出一副温柔的样子来折磨人不是更令人难受吗？
救救我啊奥特曼，哪怕你只能撑三分钟⋯⋯
无知而又纯洁的岁月是任何人都曾拥有的，世界上没有一成不变的事物，所以只要以其他方式找到自己的快乐就行了。
那么，问题来了…
念念不忘，必有回响。
不疯不魔不成活
Write the Code. Change the World.
Across the Great Wall, we can reach every corner in the world.
好，支持，威武，有希望了！（）#(滑稽)
一个人，连尊严是什么都不知道，那将是可悲至极。
no time no long.
人之所以活得累，是因为放不下架子，撕不开面子，解不开情节。
真心等你的人，他总会真心等下去，不愿意等你的人，总是一转身就牵了别人的手。
人的一生要疯狂一次，无论是为一个人，一段情，一段旅途，或一个梦想。
如果说我懂的道理比别人多一点，那是因为我犯的错误比别人多一点。
人生最精彩的不是实现梦想的瞬间，而是坚持梦想的过程。
就算不快乐也不要皱眉，因为你永远不知道谁会爱上你的笑容。
//佛祖保佑，永无BUG
如果你愿意一层一层地剥开我的心，你会发现，里面有二尖瓣、三尖瓣、隔缘肉柱、乳头肌，但就是没有你。
发生了什么事情，好像很激烈的样子==||
天行健，君子以自强不息。
无论发生什么，都请不要后悔与我的相遇⋯⋯
Time waits for no one.
Connecting the world…
没有光明是不幸的吗？需要光明才是真正的不幸。
绝望是虚假的，但希望亦是如此。
悲哀的不是不能复仇，而是不能在仇恨中活出自己。
我们只得，一边失去，一边生存。
人的生存只有俩种：“美丽的活着”，亦或“为美丽的人活着”。
如果我闭上双眼看到的是黑暗，那么当我睁开眼睛的时候是否会是一片光明？
使人成熟的是经历，而不是岁月。
每个人出生的时候都是原创，可悲的是很多人渐渐都成了盗版。
让未来过去，让过去过去。
我只能目送着幸福的末班车远去—不是我没赶上，而是压根儿都挤不上去。
我希望躺在向日葵上，即使沮丧，也能朝着阳光。
记忆就像是握在手中的水，不管你握紧还是摊开都会慢慢的消失。
智者把放下当前进，愚者把放下当绝望。
一个人幸运的前提，是他有能力改变自己。
人生如天气，可预料，但往往出乎意料。
再长的路，一步步也能走完；再短的路，不迈开双脚也无法到达。
你要相信，没有到不了的明天。
你可以不去选择，但永远不能放弃选择。
不炫耀，因为不自卑。
走你正在走的路，不要怕没人与你分享。
你在乎谁，就给了谁一把刀；你让谁靠近你，就等于打开了自己的铠甲。
你扔下的石头，绊倒的往往是你自己。
强者并非赢家,赢家方为强者
I promise you，if I am still alive，I will wait for you，here。
如果我身边最重要的人始终要离开我，我宁愿一辈子从来都没有拥有过。
如果不真正放下过去，就不会有明天。
不悔梦归处，只恨太匆匆。
我们总是在开始时毫无所谓，在结束时痛彻心非。
繁华只是散场的开始。
好好生活，狠狠做梦。活得真诚，笑的简单。
没什么是不可以的！
一般来说，时间会把悲伤冲淡，可是在人的生命中，会有那么一两个特殊的存在，他们的逝去，你永远也不会习惯。
等来年，秋风起。
心要滚动一下，才能变成石子。
宽厚不是容忍，宽厚是把你放在我的心里，我也像你这样活一遍，我就知道了什么是因果。
心怀定见，六辔在手。
真相常流失于涕泪交加中。
川流不息，无始无终，这不也是人生。
自由就是脑子里没有障碍。
一息尚存,不容稍懈。
所谓不朽，就是在后人心中引起共鸣。
他心中有愤怒么？有的，但他却从愤怒出发，向远处走去了。
未来不迎，当下不杂，既往不恋。
小时侯，幸福是很简单的事；长大了，简单是很幸福的事！
一个积极的小想法，可以让很多美好的事情发生。
心之向往，身亦能至。
Yesterday you said tomorrow.
人类并不是那么会改变，可是时间却一点一点的流逝。
走路太骚必摔跤，得瑟过劲会闪腰。
不约，不约，叔叔我们不约~
放弃也是需要勇气的。
时间带着明显的恶意，缓缓在我的头顶流逝。
不要因为结束而哭泣，微笑吧，为你的曾经拥有。
你走！
hhhhhhhhhhhhh
比任何人都要了解自己，比任何人都要关爱自己。喜欢上这样的人，并没有什么奇怪的呢。
没有事是绝对的。但这句话不已经是绝对的了吗？
这是最好的时代，也是最坏的时代。
像我这种牛人，想找个人佩服一下的时候我就去照镜子。
niconiconi~
你在南方的艳阳里大雪纷飞，我在北方的寒夜里四季如春
人能够在心里郁积那么多的事情，而他们又会忘记那么多的事情，真是不可思议??
命运的红线一旦断了，就再也不会接上。
你一直这个样子，活着不累吗？你这样做到底有什么意义呢？
不要以为抹消过去，重新来过，即可发生什么改变。
所谓的「改变自己，世界就会随之改变」这种事，是不可能的。
让你觉得我看起来像笨蛋，真是抱歉！
我们虽然没有在写给对方的信中发泄对这些日常生活的不满与牢骚，但是知道在这个世界之中有另外一个人能够理解自己，使我们都变得坚强起来。
如果不了解自己是一个会许下什么愿望的人，想要得到什么，想要成为什么样子，了解自己是什么样的人。那么很有可能会迷失在人生的路上。
有一天遇上过去的自己，我一定一巴掌扇上去。
与其最后变卦，最初就别冠冕堂皇。
我想用我的全部，换取一条接近你的路。
不过真是太可惜了，好女人一定都已经名花有主了。
心，一旦离开了，就再不会回来。
我一如既往，怎么会变呢
我想成为一个温柔的人，因为曾被温柔的人那样对待，深深了解那种被温柔相待的感觉。
摇曳在心头的身影，是时间洪流中最浓烈的一抹思念。
没有什么东西是永恒的，如果非要说有的话，大概就是“失去”本身吧。
咱这对耳朵从不曾漏听任何灾祸或谎言，从危机中解救过无数同伴。说到约伊兹的贤狼，除了咱没有第二人。
他不知道说什么好，大脑自动拒绝思考。
这和游戏还是现实无关，只是因为你是我的搭档。
每个人都有属于自己的一片森林。
因此没有弱点、没有必须守护的东西、和别人没有联系的人才是最强的。
吾铸刀剑几星霜，自比干将莫邪心，天鸟遮日滂沱雨，雨过晴天犹可慰。
光顾着追天上的月亮,错过了地上的风景,也很可惜嘛！
被质疑的时候，才是证明自己的好机会啊。
总有一天一定会……有站在你身边与你展望着同样的未来的伙伴出现。
有的人虽然没有自己的梦想，无法自己奔跑，但是努力追随有梦想的人，对他们来说也就是他们自己的梦想。
创造未来的不是命运。
大人们谁都很辛苦，所以才可以喝酒。
我下定了决心。
活着本来没有什么意义 但是只要活着 就可以找到 有趣的事情。就像你发现了花 我又发现了你一样
武者之死，在侠，在义，不在己身。
行动被评价和人格被评价完全是两码事。
即使熬过了紧张的现在明天也无从得知，但是这些人知道，他们说，被现实击垮和放弃是两回事。
如果羽衣狐当了魑魅魍魉之王，老子超越魑魅魍魉之王就是了 。
当我们在事后回顾历史的时候，往往会发现，在历史的滚滚洪流之下，即使再英明的领袖也难免有头脑发昏的时候。
世界对弱者的无情，比任何盾牌都要坚固
若不知晓相同的痛楚，就无法真正理解他人，而且就算能够理解，也不可能相互体谅，这就是不变的道理
亏本王还是对同是半神的你抱有期待，没想到竟愚蠢至此。
蜘蛛的网早已于四方张开，越挣扎就越无法从这束缚中逃脱，不论是怎样的猎物。
在火烧云与习习清风的包围下，我感觉到了夏天的气息。
人类真矛盾，平时杀牛杀猪脸色都不会变，现在轮到自己了反而那么紧张。
我情愿在你的记忆里淡忘，也不愿你为我受伤。我情愿在你的记忆里淡忘，也不愿你为我受伤。
光只有救赎，是无法领导的。
就算知道方法，也绝对不能去改变过去，绝不能将存在的可能性转变为既定的现实，未来是没有人能预测的，是无法重来的，正因如此人们才能接受各种痛苦，不幸与飞来横祸，迈步前进。
出生是死亡的开始,死是现实的延续,生是梦的结束,喜欢我么?微笑是虚伪的,真实是痛苦的
被留到最后的，可不一定是希望啊。
夕阳在西边的天空渐渐散开。那下面巨大的高楼大厦鳞次栉比，不仅如此，它们周边还伫立着大大小小的建筑物。这就是怀有过野心和希望的人建造的街道。
那年，未来遥远得没有形状，我们单纯得没有烦恼。
所有的突然之前，都伴随着漫长的伏笔。
做任何事都是有风险的。
无论是现实还是虚拟，都没有多大的区别，只要知道自己活在那里。你是活着的。
这个世界再怎么广阔，也掩饰不了它狭窄的一面
因为他和自己重叠了，被明明不带感情却假意笑脸相迎，和我自己。
为什么呢，逃了那么久，好不容易找到个非守护不可的人，就是你。
到家了，一定要叫醒我，我怕我醒不过来。
在茫茫人海中相遇相知相守无论谁都不会一帆风顺，只有一颗舍得付出懂得感恩的心才能拥有一生的爱和幸福。
我是要毁掉地球没错，但是在那之前我也是你们的老师，认真地对待你们比终结地球要来得重要得多
你喜欢的人已经心有所属不是正常的吗，因为你喜欢他，所以你的眼中就只有她。人啊，总是盲目地去爱。
太天真了，人类只有从他人那里夺取自己没有的东西，才能生存下去。
即使无法实现愿望，在某个地方也会有其他小小的幸福，等待著我们吧。
或许就是这样为了生存，而一点点忘记了最初的本意。
当经历了背叛亲离，生死一线，失而复得，才明白不再逃避.
感情久了，就不是爱了，而是依赖。然后当失去时，那并不是痛，而是不舍。
一直一来都久久的注视着 若即若离 仿佛咫尺天涯 无论如何 总是伸手不及
怎么可能有令人痛苦，悲伤的正义呢。
解开它,试试的话也许能行,但是,不尝试的话就绝对办不到。
有时候不打上一架，对方是不会明白，自己有多么的认真的！
如果将梦想作为信仰,不放弃地追求下去,一定会梦想成真的。
寂寞的人总是记住生命中出现的每一个人，正如我总是意犹未尽地想起你！
忍者的才能不在于所掌握忍术的多少，而在于永不放弃的毅力.笔直向前绝不违背自己的誓言，还有不管何时都不放弃.
八云这个词，本来是用来形容重重叠云的。
逻辑的尽头,不是理性与秩序的理想国,而是我用生命奉献的爱情。
讨厌悲伤，讨厌痛苦，讨厌麻烦。
我们所看到的星光，它们奔跑了几百万甚至几千万年才来到地球。可是发出光的星，或许早已凋亡了。
我动身踏上旅程，是为了与你道别。
就像都市里大多数人一样，一辈子也不会认识，却一直生活在一起……
自己不信任别人的话，又怎么能让别人来相信自己。
既不是情侣又不是朋友，免费帮你有违常理吧？
比起简单得到的答案，他们更相信辛苦查到的结果。
骄傲的小孩子，总是需要敲打敲打的。而挫折，是成长最好的方式。
老师很烦人，听课都想睡觉。
远的不是距离，而是次元啊。
不过算了，你爱怎样就怎样吧。照你自己的意思去做，然后使劲后悔吧。
对你的思念之情与日俱增，明白的说吧，我被你迷得神魂颠倒，璎姬，成为我的妻子吧
我不再孤独，也不再痛苦，无论哪里都能一个人走下去。
人的一生就是如此，只能一声叹息，可生命结束得也实在太仓促，没有留下一点生的余音。
我们这群孤独的人拥有不同于凡人的思维，不时会出现超乎常人的想法。
个人喜好之类，有时候只有自己才知道。
尽管在今后，我有时会变得懦弱、没用、原地踏步不前、因心爱的女孩的一句话而兴奋得忘乎所以，但我们的生活会充满诗意。
呐，士道，在狂妄的笑容背后，我也会感觉很寂寞的呢。
说得好！认识你这么久终于听到你说了一句智商上线的话。
就算背负着堕落天使的污秽，我也要在胸中怀抱着花与月，像朝着圣地前行的巡礼者那般继续走下去。
友情，恋爱，神秘，只因为有当初的约定才可以坚持到底……
我们每天的生活，都在重复着一张张地图。
最近，开始喜欢用喜欢这个词了，这是什么现象呢。
过去虽然重要…无法从头来过的，并不是只有过去！任何时刻，包括现在，每分每秒都是无法取代、不能从头来过的。而我们，就活在这样的时间里！
被隐藏的所谓真实 不管在何种场合下 大多都是残酷的
旧的伤口又受伤了，比记忆中更疼。但贴上，就可以假装只发生了一次。
回望当初，那时我一定也一直在训练自己迈步，如果有一天，能够走得更稳更远了，就去见她吧。
怀着梦想不放弃是实现梦想的第一步。
末日动荡，人性泯灭，这真是一个令人绝望的世界。
请留意兔子的巢穴，不要让它绊住您如疾风般飞驰的脚步。
哪里有人喜欢孤独，只不过不乱交朋友罢了，那样只能落得失望。
你简直是对我一往情深的跟踪狂。
和我做一切疯狂大胆不计后果的事情吧，趁我们都年轻，死去还能活，趁我们都勇敢，趁我还爱你。
本王也不知道如何安慰你的哀伤，原谅我吧。
毫无保护的地面，将会被风化，总有一天会被人遗忘的吧。
每当有什么东西出现的时候。就会有一些东西就此失去。这样一来。一来一去就等于抵消了。
天空之所以叫天空，是因为天很空……
我不认为依赖一个人有什么不对，在你的身边有许许多多的人，人与人之间总是紧密相连的，只要你伸出手我们就在你的身边。当你发现一个人很寂寞的时候，人就会变得温柔起来。
因为你心怀期待，在对方的言行中混入了自己的愿望。
他们都是内心破了个洞，重要的东西正在从破洞逐渐流失。
大家即将各自展开旅程，挥别这个没落的城镇。
Follow your heart，翻译成中文就一个字:怂。
正因为没有意义才有其存在的意义。
知识不会给予人幸福。
我不是经常说吗 ，在不被对手察觉到的情况下看清未来的走势而设下的才叫布局。
其实就在眼前，明明就在伸手可及的地方，但那距离却总让人觉得像是永远。
生死门虽繁星灿烂，但活着的人才是最重要。
从那天开始，我就一直在撒谎，活着是谎言，名字是谎言，经历也是谎言，都是谎言。我早已厌倦了这个号不改变的世界，但这谎言让人绝望到想放弃都不行了，但我得到了力量。
若是没有未来，那就把未来抢到手。
梦话还是要留到梦里说。
与其如此，不如永远像孩子一样。
若我们再次遇见，已各自生活在各个领域的大家又能否像以往般的要好？
活着的人才是最重要的。
我可是发自内心地爱着这一名为人生的游戏。所以，无论何时,我也要以玩家的身份继续下去。
我们都曾经历那样纯粹、易碎的青春，只是时光的磨砺已让我们懂得逃避与忍气吞声然后慢慢遗忘自己曾经的青春。
你只要活着，就会发现许多好事。
迷失的人迷失了，相逢的人会再相逢。
这世上的所有事情都是有始有终的，好的行为有好的结果，等待坏的行为，只能是坏的结果，人们称其为因果。
我也知道会受到大家奇怪的目光，但我并不在意。因为这是我自己决定要做的事。
掌中之物，未必在掌握之中。
人们往往会否定无法理解，无法掌握的事，不合乎自己所期盼世界的事物，就会被认定为不好的，实事求是的说不知道，明明是那么简单的事。
把逞强转换成认真，把无敌转换成美丽，把精神转换成勇气。
你是我的…太阳，火热的太阳，不放弃在明天继续升起，这是我唯一的希望。
虽然迷茫与痛苦过，但也曾天真的笑过。
赌上我的生命为你所拥有。
你不用刻意的去改变，因为无论你变成什么样子，我都会一直喜欢你，也会一直陪在你的身边的。
无论失去什么，都不要失去好心情。拥有一颗安闲自在的心，让心境清净，洁白，安静。
不是别人，是我，承认了你的价值。
用善意的心情去理解别人的话，会让世界单纯美好容易。世界如此之大，我却能幸运地遇见一些人。
要享受有趣的事情，首先就是不能违背自己的感情。
看得见的世界和看不见的世界，让我痛苦的事物总是由看不见的世界而来。
不做做看怎么知道，并不需要什么理由，只是因为想做所以去做。自己真正想做的事情不就是这样开始的吗。
活着不是为了别人而是为了自己，这是我所拥有的骄傲。
人的梦想，是不会终结的。
紧贴地面，单是偶尔跳一下都要倾尽全力的青蛙，看见轻松飞翔在天际的鸟会是什么感受呢？我的意思是飞翔在天际的鸟没有罪过，但是鸟展翅飞翔的身姿也会划伤他人
痛苦的回忆会成为明天的粮食，使我们变得坚强。
可能是我的性格过于消极吧，只要是那些忧伤而凄美的，我都喜欢。
和你在同一个时间出现在相同的地方，不是奇迹吧，不是偶然吧。我可以认为这是“命运”吧。
从一开始你就输了，因为你所说过的每一句真心话都是谎言。
因果循环的纺车，辗转织出的红线。
能与她在冬天里相会真是太好了。
不管发生什么绝对不要碰我哦，说好了哦。
温柔正确的人总是难以生存，因为这世界既不温柔，也不正确。
道歉无用！我可不是绿茶！没有再来一瓶的机会！
夜晚的意识不会变，从血脉觉醒的那刻起。 所有妖怪都在我身后，去百鬼夜行吧。
当你想要的只是你真正需要的，你就是成功的。
即便再悲伤也要勇敢活下去，这是人类的诅咒，但一定，也是一种祝福。
现在想哭就尽情的哭吧，以后有很多时候是你想哭也哭不出来的了。
因为生活很俗，每个人都需要一个虚拟的去处，每个人都想要假装和世界脱离。
要拼就要趁现在。
她希望自己永远都是女人。
人生就像一场无成果的游戏，幸福的分量是固定的，假设世上存在的幸福和不幸的总量是固定的，那这就是“有人获得幸福，势必会有人遭遇不幸”的游戏，任谁都觉得自己是世上最不幸的人，认为自己的这般不幸，肯定会有人获得了巨大的幸福。
暗弱，面对未知却不怀有敬畏之心却用好奇心来对待。
你走之后，我身边又有了很多人，只是没再对谁那么上心。
考试的话，努力学习就能通过；金钱的话，努力赚，就会有。
我曾经空空如也的手心，现在突然有了一个小小宝藏，那么快就装满了很多美好的回忆。
一个人要坚强的活下去，是很难的吧。想战胜心里的不安，也是很辛苦的吧。
人与人到底是什么样的关系，这是谁都很难回答的事情
爱情只不过是脑电波活动所产生的BUG而已
跳过过场动画，不配做游戏玩家！
世界这个东西，不是只对你一个人温柔。
只是沉浸在快乐中，期望着这样的日子可以永远持续下去
如果全世界都否定你的话，那么我就要超过他们更加的肯定你!
我的怒火不止如此，就看你是否承受的住！
付出胜利者的努力，收获胜利者的骄傲！
没有谁比谁更不幸福，只有谁比谁更不知道幸福。
就算发现过去都做错了也无法重头再来。
这里死了太多的人，他们的痛苦使我成长。无知愚昧的孩童也只有知道痛苦后才能长大成人。
对于我来说，工作的价值就在于执行过程中它给我带来的乐趣。
越是虚弱的人，越会用虚张声势来强调自己的强大。
何况所谓后悔，那不过是笨蛋打发时间用的说辞。
我只做应做之事，无须向任何人解释。
即使再平凡无奇的人生，在走过的道路上都会留下自己的痕迹。
小时候，天空分明触手可及，于是喜欢上雨，因它带来天空的气味.经常在下雨的早晨，不再换乘地铁，转身走出车站
重要的是拿出结果的能力，与种族、手段都没有关系。结果优先于一切！
己所欲者，杀而夺之，亦同天赐
西岛，他是唯一对我说过那句话的人，我不能放下他不管！
哲朗想要恳求她，但同时也感到这种心情无法传达的空虚。
与输赢没关系，这是愿望。
一开始我只要看著他就满足了，可是不知不觉间我便开始追逐著他
人生的某些障碍，你是逃不掉的。
除去不可能的,不管多么不合情理,但那就是真相……
世间凡人皆庸于懒，天下才子皆毁于傲。
存在于我世界中的物体，气味，声音，味道和触感，那就是全部，那样就足够了。
I do not know go where,but I have been on the road.
和我一起组队成为漫画家吧。
一切都一成不变。
以为是永远的事，从某种程度上来说也是现实，总有一天会结束的呢。
“大家”的意思，不是像团子一样的一团，而是像米饭那样，一粒一粒稀稀拉拉的，却总是凑在一起。
无法心想事成，是人之常情。
记忆不是一整团的，而是一个一个的抽屉，抽掉的便忘掉了。
只要自己没有想去了解对方，就不会知道别人的真正姿态。
在实现梦想之前，我要不断挑战。
明知道这次危险，还要继续，你为什么总是要这样自作主张啊！
人心是件奇妙的东西，大部分的时候，总是愉快而又平静的生活着。
如果只有一种表情的话，那就笑吧。
万物皆是生灵，又哪里有注定的贵贱善恶之分呢？
就算现在正看着你的时候，也好想要你继续那些温柔的话语，但愿让我们两的关系长久的继续下去。
无论什么人都应该飞向天空，不管什么人，都有一对看不见的翅膀
人的心声是绝对不能无视的。
其实美丽的故事都是没有结局的，只因为它没有结局所以才会美丽。
从来没有想过这个背影我会用一辈子去眺望
虽然至今为止的道路绝非一片坦途，但想到正因为活着才有机会感受到痛楚，我就成功克服了种种困难。
苹果是禁果。以前亚当和夏娃吃过后，就被逐出了伊甸园。所以它是“明辨是非的知识果实”。
你从以前开始就只会扯那些，嫉妒心又强，功利心又重，还满嘴的讥讽挖苦。但是，你的忠诚心值得尊敬，虽然我非常讨厌你，但是你不该有这种下场。
除了网球我什么也没有，网球就是我的全部。
如果你自己不行动的话，那么可能性就是零了。
如果你记得从前曾跪在那人面前，这一回，你要把脚搁到他的头上去。
如果我知道你在骗我，那我宁愿骗自己你没有。
人哪，为了消磨时间，硬是鼓唇摇舌，笑那些并不可笑、乐那些并不可乐的事，此外便一无所长。
爱，不是寻找一个完美的人，而是学会用完美的眼光，欣赏那个并不完美的人。
有三样东西无论如何都无法容忍。命令我的家伙，反抗我的家伙，还有辜负我姐姐的笨蛋！
努力不一定能实现梦想，但是曾经努力过的事实却足以安慰自己。
我认为你很幸福，因为你可以选择爱或不爱我。而我只能选择爱或更爱你。
草菅人命的杀戮……永无止境的憎恨…不可治愈的痛苦……这就是……战争…
错过，不是错了，而是过了
今后你也会喜欢各种各样的人，正因为活着才能这样。
一无所知的世界，走下去，才有惊喜。
在珍惜着某个人时，有时候会很难过，有时候会感到寂寞，但是，有时候也会觉得非常快乐。
多年后，再回想年少时的迷茫和执着，或许原因都不记得了。
这不是自大，是自信
用善意的心情去理解别人的话,会让世界单纯美好容易.世界如此之大,我却能幸运地遇见一些人。
许多时候，让我们放不下的，其实并不是对方，而是那些逝去的共同回忆。
这里不向高处伸出手，什么时候，才能够得到啊！
有些人，才遇见一下子，就好像认识了很久似的，什么事都想和他说。
正气和狂气，理性和知性，自信和确信，在悲剧性的不合理世界，故事开始了。
有多少人是为了不让别人看出心事，装出疯疯癫癫，嘻嘻哈哈。
畏惧死亡比死亡更可怕。
没有比看不见人的恶意更恐怖的了。
我可以接受失败，但绝对不能接受未奋斗过的自己。
抚养小孩这种事一开始谁都会不知所措。
有思念你的人在的地方,就是你的归处。
假如我们拥有的东西只能给我们造成烦恼，那么我们拥有它的意义就值得怀疑。
就像罐装饮料自动售货机，你投入钱它就会为你解渴，可是你不往里面头钱它就什么也不会提供给你靠钱是买不了人的心灵的。
在瞬间之下，明白所有真相，只要开始，就不会停止……
有时我沉默，不是不快乐，只是想把心净空。
相遇了真的是太好了。
轮回的是故人，不变的是初心！
笑是对身边的事物感到一瞬间的幸福而表现出来的东西。
最爱的是什么，要等失去了以后才知道。
因为有了黑暗才焕然;黑暗，因为有了光明才神秘。
不是强者必胜，而是胜者必强，他们比我们强，仅此而已。
我们这种平凡之人在面对胜负关键时，总需要找寻某种倚靠，但，在比赛中乃是孤独的，无法倚靠任何人。
对于虚伪而已，真实的光明或许过于耀眼了
时间对于人来说，是最温柔的，也是最残酷的。要想愈合受伤很深的心，只能转移对你的思念，你所祈求的永遥。
因为绿叶太漂亮了，所以眼泪就落下来了？
如果我爱一个人，我可以为他舍弃一切，包括我的生命。
无论发生什么都不要停下。无论到什么时候都要继续前进。要一直走下去，直到生命终止的那一刻。很多无言以对的话。记得不要停下。
你以为每天看到的东西，就会抓得住吗？
奇迹不是商店里的促销品。
你知道吗?得不出结果就是所谓的无能。
为了信仰，必须有人牺牲，无论是谁。
美丽的花朵终会凋零，那是所有生命的宿命，那么不如在盛开之时将时间停止，会这么想也难怪。
我不在乎过程有多累，我只在乎结果是否完美。
不管雪怎么覆盖 恋爱的花朵开放的春天都是会来的。
看到女人掉眼泪还无动于衷的话，就太不男人了。
人的价值高低并不取决于他的力量大小，只要好好的自食其力，力量大小有什么关系，为什么要羡慕他人，又为什么要蔑视他人。
有时候，生活就是要逼自己变得逆来顺受，宠辱不惊。
大丈夫说言而无信就言而无信！
因为太痛苦，害怕看清事实，所以不愿去面对。
理所当然的事，只要接受就好了。
自作多情这种毛病谁都控制不住。
对不起，你一直在等我，但是我却现在才来。
当人类用感情和希望去创造一样东西，那一样东西就会被赋予灵魂。
这份悲伤，总有一天会连接到坚强的彼方。
让别人知道是谁第一个爬上山顶固然重要，但只要当事人自己明白其中的真味，也就足够了。
如果不强行抢夺，安稳的日子就不会造访，如果不加以保护，幸福的生活就无法延续。
即使交不到个朋友也没有关系，只要交到一个比个朋友更重要的朋友。
喜欢的人喜欢别人不是很正常吗。
即使你已经习惯了受伤害，也有人看了会心疼的。
过去是无法取回的，已经失去的东西，是无法取回的。
正因为单纯，绝望时的反抗才会更激烈。
刚好一分钟，你做了一场噩梦吗？
将所有人类当成玩偶的神,本身居然也是个小丑啊。
无数个小小的选择，慢慢地指向同一个方向。看起来有很多可能，最后却只得一个答案。
既是背叛了主，伪善者依旧倾听着别人的不幸，然后嘲笑这一切，宛如倨傲的恶魔。
不被任何事物束缚，随心所欲地活下去。
曾经发生过的事情不可能忘记,只不过是想不起而已。
真正重要的东西，就算失去自己珍贵的生命，也要用双手保护到底。
人生平凡无奇，才能在故事中做一场美梦。
今生情尽空悲切， 来世再续未了缘。
装逼只是瞬间，不要脸那才是永恒！
往往幻想能够置身云端。
我想确定，从这双手，诞生出有形的东西。
伤口有多痛，只有受伤的人自己知道。
这个世界上没有完美的人类，所以，人无法自己一个人活著。
这个世界,是无限的
能像个笨蛋般尽情的欢笑，那是多大的快乐。
失去只是一瞬，一瞬的疏忽
为何我会再次执笔呢？那是因为在那天，在木莲树下，与她邂逅了…
那样不叫做梦想，不是自己的事就不叫做是梦想
我在人生道路上迷失了方向。
其实只要意气相投，又何必计较身世有别。
明明只要打开门，明亮的世界就等在外头了啊
你既然已经做出了选择，又何必去问为什么选择。
黎明之神披着嫣红的衣裳，已踏上了东边的山麓
与你在这最后的夏天，抹不去的思念，斜阳里的微笑，渐行渐远，六月的微风吹散你的泪光，深深的铭刻心间难以忘却
看吧，他再怎样表现得冷漠，到最后都会像那样充满善意。
我有那么一帮好朋友，没混熟的时候一个比一个文静，混熟了各个都跟疯人院跑出来似的。
你原本打算吃掉我，所以就算被我吃掉，也没资格抱怨吧。
我既没有超乎常人的幸福，也并非不幸。
明明只是保持着人形的人偶，却能和自然生命体一样。
我深知，这之后我们无法一直守在一起，挡在我们面前的是巨大庞然的人生，阻隔在我们中间的是广阔无际的时间，令我们无能为力。
我允许你比眷属更长久的跟随侍奉我。
我明白，恋爱是不能假设的。
世界上没有一种鸟能够一直飞翔，永远不需要落地。
如果把向我咨询的人比喻做迷途的羊羔，那么他们通常手中都拿着地图，却没去看。
世上人外有人，但是偶尔也该看看下面，他也许已经追到脚边了。
即使相隔千万光年，你已不愿相信。我也会冲破重重阻碍，守护你！
是谁都不要紧，因为这里没有人在乎你是谁，在这个地方任何人都可以自由地生活。
堆积在地板上的古旧书籍，也因为失去了读者，而变成了毫无用处的纸张。
如果你以为那么简单就可以把我甩掉，就大错特错了。
我落日般的忧伤就像惆怅的飞鸟，惆怅的飞鸟飞成我落日般的忧伤。
吟唱幸福的歌谣，令少女沉醉向往。童话堕入黑夜，是谎言还是幻梦，无声终结
对，兔子其实就是怪物的心脏，怪物和兔子是不可分割的整体。兔子死了。所以怪物也死了。
到最后你才会懂得，所谓相爱，只是想要相互看见。
我们要在敌方擅长的地方打败对手，因为这样才够痛快。
人不犯我我不犯人，人若犯我，我就灭他满门！
所谓的自卑，除了自己之外，谁也无法理解。
凡事都会出现破绽,何世都会诞生迷惘,在内心慢慢沉积的名为友谊的沉重石头,是通往明日的基石吗?还是直至昨日的淤塞呢?应去面对的答案,就在我自己心中。
永恒不变的心，随着时间而变幻的心，这些都没有错，欢迎回来。
悲伤的秋千总有微风陪伴，孤寂的夜，总有繁星点点，蓦然回首，而你却不在我身边。
只要还有别的登场人物，就会有别的故事存在。
没关系，我明白。一切都是我的自我满足，是我一个人的相扑游戏。永远的单恋，可这对于我来说也很重要。
慢慢走过你的人生就好了，跑得太快的话，是会摔跟头的哟。
我们本应并肩而立，却离得这么遥远。温柔只会让心彷徨，你可曾为我感到悲伤
我说不出来为什么爱你，但我知道，你就是我不爱别人的理由。
妹妹哟，我们总是把世界看做是游戏，这次终于出bug了。
幸福是，牵你的手，从此两双眼睛，看一个未来。
我们大笑看看，可怕的东西它就跑掉了。
每一秒的天空都不一样。
丝毫没有喜欢成分的亲吻，我一点都不会觉得高兴的！
就算只有一周的记忆，我也永远不会忘记你
笨蛋是死了也治不好的。
所谓的人类，是连短短十分钟也等不起的！
蛮横暴力，性格又差，印象糟糕透底。但是……她好美。
人类就是为了知道自己是为了什么而活在这个世界上才会诞生在这里的。
外表强势的人，内心通常是相反的。
想要试着去相互接近，但最后还是无法敞开心扉，结果就是擦肩而过??
不请自来而又不告而别的事物，然而即使彼此之交汇过一次，即使微弱得不会被人注意，那也是能够支撑心灵的，重要的邂逅。
梦里不觉秋已深，余情岂是为他人。
有生之年，绝不负你。
即使再怎么勉强、再怎么不自量力、再怎么厚颜无耻，也要用自己的双手，保护最珍惜的东西
人的记忆是不可靠的，自顾自的上色美化，给予高出事物本身的存在意义。
这无关经验和立场。
我已经什么都没有了，没有才能，没有存在的理由，也没有活着的价值。
丰苇原中国，在此引起骚乱之者，吾夜斗神降临于此，臣服于雪器之威，佛除种种污秽障壁，斩！
强者的天敌是弱者，但是弱者的天敌却不是强者——而是更弱者。
即使想放弃，也没法放弃最想要的东西，这就是人
做想要做的事和做擅长的事、以及做会做的事是完全不同的，为了实现自己的愿望，就算不擅长也要去做。
就像木炭本是木头变来的，虽然变了样子，不过一想起以前是木头是就会燃烧起来哦。
我从出生到死亡的为止，永远只站在自己这一边
如果有什么毒药能轻易杀人，我也想要呢，因为不知道什么时候会用到，也没准是自己要用。
拿起武器，无论顺从还是逃跑，都无法得到自由，既然如此，我们只能战斗，为了自由，站起来吧。
父母不可能永远都保护你。
逆境不是可以令人燃烧起来吗？
你以为这个世界上只有你一个人与众不同么？
我这份不断涌现的思念之情，不想让你知道，但却又不能停止。
除了死亡，其他的离开都是背叛。
要是别人说怀有希望是错误的事，无论多少次我都一定会反驳这句话。
所谓长大成人，就是不断聚了散，散了又聚。为了让彼此不会受伤害而保持一个适当的距离。
人死之后，就只能活在别人的回忆当中了。
尽可能预想所有残酷的可能性、因为现实永远让你无法预警，而且又吝于给人慈悲。
为了守护必须守护的事物,无论光与暗,凡是能利用的就利用到底。
就算犯规也无所谓，比赛就是要进行到被罚下场的那一刻。
左舷弹幕太薄了！
是啊，温柔的世界就近在咫尺。即使为虚伪的记忆所玷污，却更显出透明的琉璃色彩，一直 永远 永远···
被绝对没有胜算的挫折感击垮的人，因为不想承认事实，反而会瞧不起对方，藉此谋求心的平静。
世上本没男神，装的人多了，也就有了。
我是不相信这个世界上是有上帝的。如果有的话，哪里还会有那么多的不幸，不幸的人和不幸的事。至少天使从没有对我笑过，一次也没有……
人不是任何人的奴隶,不是为了做奴隶而生。
纵使喝醉酒满嘴胡话，也有一句好想你发自肺腑
早上的五分钟等于白天的三十分钟。
死去的人最想看到的不是亲人为他报仇,而是亲人能够幸福的活下去.你这双纯洁的小手,没有人愿意看到它被鲜血玷污.
每个华丽的转身，都有旁人参不透的情深。
如果说怪盗是一个技艺精湛，盗取财宝的艺术家，那么侦探就只是跟在怪盗后面吹毛求疵，充其量不过是个评论家。
不惧怕伤害，这是什么强悍！
有血缘关系也好，就算是兄妹也好，我都会一直喜欢你的。
人只要有了感情就能把别人美化
忘记最喜欢的人，究竟算什么幸福！
在黑暗中回想着光明生活下去也没有什么不好的。
死记硬背是那些没有能力自我思考的人最好的逃避方式。
任何人都有想抹掉的过去，估计大家心中也都隐藏着一个梦想，完全变成别人，体会和完全不同的人生。
山吹花开千百重，堪怜竟无籽一粒。
依赖数量的战术会使个体的思想变得草率
能够选择性取舍人际关系，也能依照心情选择是否与人交流。
“没有什么大不了”这句话，只有当事者才有资格说
你会为那些事发愁，不正是你想要改变自己的证据吗？所以我觉得你比我认真多了。
这么多年过去，网友变成了朋友，朋友变成了网友。
我不相信人类……但是，我相信人类的“可能性”
在这丑陋荒废的世界中，并未失去重要之人的人，已经不存在了吧？
你是我的…太阳，虚假的太阳，你燃尽了自己照亮了前路，你是我唯一的光芒。
不管何时，王只要善用手上的棋子，活到最后就可以了。利用骑士，也利用女王。尽管他的王座下面，棋子的尸体堆积如山，也绝不能倒下。因为王倒下的话，这个”游戏”就结束了。
皇权的过于集中才是导致腐败的根源。
赢者会被肯定，败者会被否定。
这个世界，只需要一把剑就可以去往任何地方。
人老了的好处就是再也不会大惊小怪了。
回避一次，就有可能成为一种恶习。
合不合群是个人的自由，谣言更是无关紧要。
即使作为代价要夺走我什么，即使接下来等待我的是什么，即使那样，我无论如何都不想失去他。
人的成长，就是战胜自己不成熟的过去。
所有的事情在变化，都有终结
善恶之分其实只不过是一种主管的对正邪之间的判断
人的心有反面也有正面，不能说有反面就连带认定其正面也失去意义了。
反正横竖都是死，那就死得荡气回肠吧！
不放弃的人，才能获得成果。
总在快乐的时候，感到微微的惶恐。在开怀大笑时，流下感动的泪水。我无法相信单纯的幸福。对人生的起伏悲喜，既坦然又不安。
我不要没有未来的未来！
我是冷静之人的伙伴，喜欢无谓争斗的笨蛋们的天敌。你是哪个？
但是，我也不再是孩子了。
因为我是幸福的，所以觉得随时死去也没有关系。
寂寞，就是当你一个人内心空虚地时候，却无人能和你分享。
所谓的料理啊，就是把自己的一切都盛进盘子里。
人类灵魂的本质是黑暗……
我站在树上，学习像鸟一样飞翔，虽然知道这不可能，可还是要试一试，风来了，临风飞舞，我感到无比幸福。
要好好收在心里，往前走下去。
没有脚踏实地建立起来的东西，就无法形成精神和物质上的支撑。
大声的笑出声来，就不再害怕了。
惊喜是个双黄蛋，绝望就是个双黄连。
被一个人深深地爱著将给你力量，深深地爱著一个人将给你勇气。
不管是住在清水中还是在臭水沟中，只要向前游鱼儿就能好好成长。不管是住在清水中还是在臭水沟中，只要向前游鱼儿就能好好成长。
你觉得被圈养的鸟儿为什么无法自由地翱翔天际？是因为鸟笼不是属于它的东西。
忘川之上，桑梓之下。一半是光，一半是影。
或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前途。
有些梦想虽然遥不可及，但不是不可能实现。只要我足够的强。
我们大概像两只嗅到同类气味的小动物，用最粗糙的方式靠近，用最笨拙的方式疗伤。
想逃的话随便你，逃几次都没关系，但是…无论逃多少次我都会去接你。
我只是一个人，这就是为什么所有有关我的事有我自己决定！
永往直前的努力是好事，偶尔也得回眸走过的路。
梦总是突然醒的，就像泡沫一般，越吹越大，最后啪地破灭，什么也没有，除了空虚。没有脚踏实地的建立起来的东西，就无法形成精神和物质上的支撑。
很容易就被小小的事而影响，对曲折的人生一无所知仍然还选择活着，这就是人类啊。
孤独的人不会伤害别人，只会不断地伤害自己罢了。
我们的相遇是很多年以前就已经注定的命运。
不管你曾经被伤害得有多深，总会有一个人的出现，让你原谅之前生活对你所有的刁难。
每一个人都有让梦想成真的能力！
现实当中，累得精疲力尽的人们只是在这些建筑物的缝隙之间匍匐打转地苟且偷生而已。而我，也只是其中的一个。
大人们越是辛苦越是开心哦！
人与人之间是无法完全相互了解的。
但当他将其从口袋里拿出递过来时，我竟恍惚觉得是有人在向我兜售同人杂志。
这种事，害羞你就输了，热情冷却什么，还是等变成爷爷奶奶了再说吧！
我们会，慢慢长大成人，随着季节的不停变换 路边盛开的鲜花也在不断变化。
即使过了千年，世界上也有许多事情没有改变。
传说人死后，将会去往天堂。
时间荒诞了肆意的青春，那份纯真也开始变的悸动不安。
这世上有一条路无论如何也不能走，那就是歧途，只要走错一步结果都会是粉身碎骨。
恋爱之花火，心灵之花火，仲夏夜之梦，寄托着多彩的思念，愿其不会悲婉凋零
年轻的好处，是可以在没有看清楚这个世界之前，做率性的事。荒唐也好，可笑也好，那都是无悔的青春。
我虽然讨厌被嘲笑，但是不会停止说这件事。因为比起被嘲笑，我更讨厌说不出口。
我只是发现了比钱还重要的东西。
据说之所以有人出现在梦中，是因为对方想见你的心情穿过身体，飞进了你的梦中。
好梦向来易醒。
如果长大意味着失去梦想，我宁可不要长大
所谓孤零零指的不是周围的人口密度，而是指个人的精神层面了。
学会长大，学会承受，学会哭过之后，还可以微笑地拥抱爸爸妈妈。
无所谓正义或者邪恶，历来拳头硬的就是正义，拳头硬的就有道理。
我们曾经那么盼望的未来，正以惊人的速度流逝着。现在，只希望可以慢一点，偶尔停下来看看路边的风景。
我每次读完一本书的时候，也会有种从梦中醒来一般的哀伤感觉呢。
你能明白无法重返天空的星星的悲伤吗？
既不回头，何必不忘。既然无缘，何必誓言。
啊啊，无论什么，都在此刻，显得如此透明。宛如——青空。
命运是掌握在自己手里的！
追逐梦想的人比抓住梦想的人更能发挥实力。
她走了，一位风一般的佳人。
如果对所有的人都公平对待尊重他们的生命的话，那和不爱任何人是一样的。
一生中会遇上很多人，真正能停留驻足的又有几个，生命是终将荒芜的渡口，连我们自己都是过客。
真正的我，早在以前，就已经死了。
各位，希望你们能记住，只要相信自己，谁都可以在那片广阔的天空中，飞翔。
你很久没有和你爸爸在一起了吧，好好玩就对了
只有狡猾之人才能生存的世界才让人觉得可悲…正直，坦率，努力…这并非是愚蠢。
是因为遗憾，所以美好，还是因为美好，所以才遗憾。
因为我是我，所以喜欢我；因为他是他，所以喜欢他。
我始终相信，在这个世界上，一定有另一个自己，在做着我不敢做的事，在过着我想过的生活。
虽然有种被他戏弄的感觉，可我怎么就被萌到了呢！？难道是因为我心理变态？
莫作昙花一现，勿失勿忘！
谢谢你为我回来了。
我们虽然不能抹掉过去，可是却可以超越它
终究只是一场自编自演的独角戏，唯一的观众也只有自己。
没办法，谁都会出错，重要的是不要老犯同一个错误。对吧？
走到如今，孤身一人
我们今日一别，让我们十年后再相见，不见不散！
只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。
天亮的时候请你打开窗，对我说晚安。因为我要走了，我真的要走了。
当一次坏人，并不代表她以后永远都是坏人
孤零零三原则——不抱有希望、不创造心灵的空隙、不接受甜言蜜语。
年轻又怎么样 我们明天也许就会死……只是概率的问题吧
就算活着感受到痛苦，也要重视起生存下去的重量。
假若，在这染满鲜血的刀，以及成为牺牲品的生命背后，有个谁也可以安心生活的新时代，我会——替天行道，仗义杀人 .
人生就是一个挣扎的过程。
只要一天活著,难过的事总有一天会让你笑著说出来。
一个人有自由选择开始一段感情的权利 但却没有自由结束的权利
你应该要学着做你自己，面对真实的自我，只要做到这一点你就什么都不用惧怕。
谁也没有办法把过去发生的事情一笔勾销，要记住教训，勇敢的活下去。
当你从一个世界，来到另一个世界的时候，你将唱响最后的悲歌。
光芒是不可能照遍所有的地方的，有光的地方就一定有影子。
就算有一天，离别的时刻来临，但那也不一定意味着永别。
我马上去，我会用跑的！
没有王子的命，就要有争帝王的心。
人生只有一次，所以按照自己的意愿，努力活下去！
我的心是永冻土，一辈子都不会原谅所受的怨恨和屈辱！
网球就是网球，接到球然后打回去。
遇到你的那天，是我最幸运的一天。
人在直面恐惧的时候，自身的灵魂将会受到考验。降生于这世界，究竟有何所求，要成何事，其本性会暴露无遗。
罪？那是人类们以自己的标准任意决定的。
至少，那个时候你向我伸出了手，我紧紧地握住了它。
猫是可爱的，狼是很帅的，就是说，孤独又可爱又帅。
在这个信仰即将崩溃的时刻，我要坚守最后的信念。
时间再拉长一点，让我有时间收拾一下心情。
就好像看透了我的心思一般，你总是突然出现。
从身为小孩的自由与不自由中毕业，晋级为承受大人的自由与不自由。
纵然如斯，亦候永世。
到不了的地方都叫做远方，回不去的世界都叫做家乡，我一直向往的却是比远更远的地方。
放不下过去的话，不会有什么好事的。
看起来最容易陷入恋爱的人，其实是最喜新厌旧的人呢。
无法逃避的就是自我，无法挽回的就是过去。
字迹模糊，纸张发黄，上面还有花盆边缘流下的水渍，印成一个残缺的半圆环。
我们最为喜欢的事情之一就是对自认为站在绝对有利位置上的对手断然地以一句‘NO’来拒绝！
世界上也许有人喜欢孤独，但却没有人能承受孤独。
任何背叛时间的人，都是会遭到报应的。
在人际交往中，有些人能获得能量，有些人却会一直损耗。天性使然，强求不来。
最远的旅行，是从自己的身体到自己的心，是从一个人的心到另一个人的心。
做了美满好梦的人也许是我，虽然没有那种资格
完美啊完美，正中下怀呢！
俗话说愚者学经验，贤者学历史，我祈祷你不是愚者。
因为世界并不如你想象的那样坏。
无论什么人看到天空飞翔的鸟, 都会想去旅行吧?
如果一个人感到寂寞的时候，就读书吧。想象一下，那个人在思考什么，想传达什么。那样的话，或许就会找到绝美的宝藏。
真实这种东西，就和生日一样，每个人都会有一个。不能只因为和事实不一致，就指责是谎言。
人生无论何时都无法重新来过。
当你年岁渐老，你会看懂这一切都是时光的调教，把随风易逝而又不可移动深情，麻木成无所不能的一生。
我认为在这世上，有些事必须亲身经历才会理解。
如果神舍弃了这个世界的话，那么我要拯救这个世界。
谁是敌人谁是朋友这种事，不需要别人来告诉你，也不是由别人决定的，这是自己决定的。
随随便便的过来，随随便便的离去，但是，只要相互接触了一次，即使微弱得不被人注意，那也是能够支撑心灵的重要的邂逅。
人还是应该活得明朗、正直才对。
只有一个人在旅行时，才听得到自己的声音，它会告诉你，这世界比想象中的宽阔。
突然之间，我还想再在这个世上多活几天。
人的命运总是按照既定的方向在前进。
痛苦的话，就依靠我们，因为我们是你的伙伴啊！
有一种病很容易恶化，它叫“你想太多”。
人可以为了别人而变得温柔，反之为了自己也可以变得残酷无比。
再没有什么比幸福的回忆更妨碍幸福的了。
不受伤的话，就看不到各种各样的世界。
当你知道自己被爱著的时候就不会自卑了
我喜欢的人，如果喜欢我，当然最好。
骄傲,因为我是独一无二的。 卑微,因为我守了半世空城。 阳光,因为我喜欢独自悲伤。 痛恨,因为白天不懂夜的黑。
回到一个人的宫殿，又重新沉入无尽的追悔，我越来越明白，不可能的，失去的再也不可能找回来了
在这个世界上，重要的不是你到底做了什么；更重要的是，你如何让别人完全相信你真的做了什么。
剑是凶器,剑术是杀人术,无论用多么华丽的词语来掩饰,那始终是事实。
香正好，无奈西风吹香渺，更令多情恼。
原谅我的脆弱不堪却依旧冷艳高贵。
没有放不下的人，你放不下只是因为认为他也如此放不下你。
如果不试着斩断过去，就无法迈向未来！
人生就像一杯茶，不会苦一辈子，但总会苦一阵子。
知道吗？人这个字啊。并不是人和人之间相互扶持的意思，而是在没有任何人的帮助下，一个人立足的姿态。
我喜欢的女孩，很会吃醋，又性急，爱哭，易怒，但是，她的微笑，就是我最大的幸福。
这个世界，只需要一把剑就可以去往任何地方
平时随波逐流，关键时刻则会出于自我保护而露出獠牙——然而正是因为这样才可怕，才不能大意。
在我背后，微笑地活下去吧
一个人觉得寂寞，是因为害怕踏出最初的一步。
因你所见，光由心生。
我们今天战胜志志雄，不是表明我们有多厉害，只不过时代站在了我们这边。
无所谓好或不好，人生一场虚空大梦，韶华白首，不过转瞬。
他在走一个圆圈，弧线是他的决心，没有终点。
别迷惘，别烦恼，加速吧，只要行动就好，别停下，迷惘什么的一点都不像你，像那样纵身轻跃，拾级而上，就像那一天一样，让我再次追逐你的身影，我的英雄。
眼泪的蔚蓝中，小鸟在飞翔。
我不是普通的侦探，是尼特族侦探。搜寻全世界，找出死者的话语。
国者，无民不立，无王不兴。
虽然很不甘心，但是并不是全部做的正确就能得到HAPPY END的，反而大家都相信自己是对的才走进死胡同，却让幸福远去了。
男人和男人之间的约定不能不遵守。
眼瞅着我这就要奔三了，可是，我还没二够呢！
提高你的适应力，去接受这一切
人一旦摆脱了时钟反而会把日子过得跟时钟一样准确。
可能因为我自己也比较单细胞的缘故，所以更喜欢简单和直接的人。
一个故事的阅读方法，绝对不只有一种。
想成为强者，就不要回避心理的恐惧。
如果你能看到我的世界里那些渐渐消逝的美好，你就能体会到现在所拥有的幸福。
命运的红线一旦断了，就再也接不上了。
永远有多远？比时间多一秒就是永远。
对于“喜欢”这种情感，我一直懵懵懂懂。
他们正热烈地讨论着别人的秘密，但是，一个不说，一个不听，还有一个不看。
不可以逃避！活下去！活下去也是一种战斗
人只会看到自己想看到的、听到自己想听到的，我也并不例外。
游戏的最终季的获胜方式是不战而胜。
会努力就是最棒的才能啊！
拥有的太少，才需要珍惜。
任何时候、任何年月、任何时代，事物的发展方式都如出一辙。
有时候，上帝会抽出一张名为绝望的牌，因为他对人类很失望啊。
人偶，没有任何请求，没任何感情的只是慢慢在腐朽。
你的地图是一张白纸，所以即使想决定目的地，也不知道路在哪里。
美丽的不是这个世界，而是接受了这个世界的你的眼睛。
愿望这东西实不实现都没关系。
善恶是由人决定的，而不是神
所谓永恒的爱，是从花开一直到花落，从红颜一直爱到白发。
她仿佛代言了这整个世界的秘密。
自保与欺人只隔一线，要区分是多难啊。
因为欲望是任何人出生就有的，所以很好理解。
伴随着痛苦的经验才能让人牢记在心!
我相信雨是云的尸体，埋葬人间。
不想失去的东西存在的话，那么一旦失去了的东西是再也回不来了……
汝为有缘人，亦我所爱之人。
故事的结束总是满载而归，就是金榜题名。
要拿去的东西只有记忆和作为职人的自尊，仅此而已。
我要用什么样的速度，才能与你相遇。
如果黑洞能吞下一百亿个太阳，我，就是一百亿零一
梦想不会逃跑，会逃跑的只有人
如果要牺牲的话，让我来吧。
是怪物也无所谓。即使假的感情，我要保护集。因为我就是我。哪怕是假的，但是对我来说那就是唯一的真实！
人类，就是一直在重复过去的道路。
时间是一枝向前延伸着的绚丽藤蔓，我们是这藤蔓上遥遥相对的花朵。我想接近你，又怕你飘飘摇摇地慢慢凋落。
在聚光灯的背后是付出血汗的努力，凭借善良作为软弱借口的你，即使是输了也不会感觉到任何失落。
大概 大家只能办到力所能及的事 就算你勉强自己做办不到的事 也只会让自己痛苦罢了
在已经做好觉悟的男人面前，不管是同情还是悲伤，都是对他的侮辱。
如果无法深入了解，只要试着去深入了解就行了。如果交情太浅，不知道未来会怎样，只要让感情深厚到永远都能当朋友就行了。连尝试都不肯的人，没有资格说自己办不到。
我要像一株在太阳的引导下绽放的花朵，总有一天绽开我美丽的花盘。
如果没有如果，时间是否会为我们停留？曾经看过的夕阳，听过的潮落，都被时间掩埋，幻成泡沫。
人类或是组织这种东西，只有在危机，迫在眉睫之时才能注意到眼前的现实，真是愚蠢。
告诉你我最喜欢的一句话吧！要是被处于下风就要以牙还牙！
事情在还没开始做之前，千万不要放弃。
就算此刻能欢笑的，也许明天就笑不出来了。
不管是怎样的回忆，都是我们活过的人生。
我的刻薄话使用铜四十克、锌二十五克、镍十五克、害羞五克、再加上恶意九十七公斤配成的。顺便说一下,害羞是骗人的。
有些烦恼，丢掉了，才有云淡风轻的机会。
这样说的话，你不是也一样，让人分不清你到底是懦弱还是坚毅。
不安时，过去便会向我袭来。
可以是男人也可以是女人，可以使鬼也可以是天女，当太阳本该升起之时，就是淡岛闪耀之刻。
理想是气球，但现实是铅球。
无论在什么地方，什么时候，在我们的头顶都是同样悠远的天穹，就好像是永远都无法分开的羁绊。
以错误的的方式获得的结果只有扭曲的空虚和后悔
已经发生的事情与其每天叹息，还不如从容面对。
不管输赢，打完不许记仇啊。
我是喜欢盖着被子睡觉的人，热了就把被子踢掉，冷了又把被子裹上，其实潜意识里一直都在照顾自己。
忍受不了自己变得毫无用处的人是我。
她相信着希望，相信着未来，继续翻开着故事的下一页。
每个人都有成功的机会，所以不要忽略任何一个人！
大家来实现的故事
我只是一个飞得累了，停下来梳理羽毛的魔法师。
只是生活著，悲伤的事物就会逐渐累积。
傻与不傻，要看你会不会装傻。
抱歉，本王对贫穷的概念不太了解，正因本王有用之不尽的财产之故。
看起来是几何问题，实际上是函数问题。
我虽然并没有忘记你，但也没有精力去想了。
正因为寸步不让，所以才称之为荣耀！
不管凶犯是抱着什么样的欲望去接近死者，人的本能是不会改变的。
钻石很硬，但越硬就越脆。
为了保护同伴拯救红颜，赌上自己吧！
我该不会是被讨厌了吧？
误会，是源于以为了解。
知识就是力量，了解是最大的喜悦。
判断一个人，不是看他的外在或内在，而是看他的行为。
做任何一件事都要尽情享受它 这是人生的秘诀哦。
不到最后一刻，绝不放弃！
但是现实与想象完全不同，即使现在，我也从来没有清晰地认识到自己是大人。
要逃避！先改变你自己，要不然什么也改变不了！
尽管也曾有消沉的时候，我还是过得佷好。
恕我无礼，我觉得这世上唯一能够信任的人就是我自己。
谁都讨厌孤单一人 把离自己最近的那个人当做最特别的存在也是人之常情
不要对外表过分在意，心灵才是最重要的。
一切安乐，无不来自困苦。
觉得不甘心的话就好好活下去，靠自己的力量活下去。
胜者为王 就这么简单
你能忘怀吗？不，肯定不能吧。我们就是为了那一瞬间而出生的啊。
干燥的冷气，尘埃的味道，我在其中……踏上旅途。
伤害别人的人，就有要被伤害的觉悟。
如果提出的问题本身就有问题，那么答案又有什么用呢？
别扯淡了。别随随便便就要去死。我们这样的人，没到该死的时候绝不能死。
不要去等谁，所有的不期而遇都正在路上等你。
你看你浪费了多少流星，哈哈……不牵个手也很浪费这样的夜晚呢。
人生，总会有不期而遇的温暖，和生生不息的希望。
涩泪一滴，洗去铅华，不再倔强。叹息一声，掩去痛伤，留下坚强。苦笑一抹，隐去伤痛，从此图强！
不能慌……人是不可以逆转时间的……如果特意去扭转它的话，人类就会受到惩罚。
一条路不能回头,就是一生要走许多路,有成长之路.很多事情不能自己控制,即使再孤单再寂寞,仍要继续走下去,不许停也不能回头。
所以说，把你的身和心全部交给我吧！为了我，冰丽，把畏解放吧
与你一起的那个夏天已经结束 将来的梦想 一起许下的愿望 我永生难忘 十年之后的八月 请相信我们一定能再见
一只狮子率领的羊群，可以打败一只羊率领的狮群。
春雨绵绵褪花色，容颜不在忧思中。
责任者是为了背负责任而存在的。
每个故事都是合理的。主角演完完整的故事，配角在片段里充当过客。
语言是误解的源泉。
曾经如此真切的情感，最后竟然彻彻底底地消失了……
我为什么一定要向三次元的女生表白。
最真实的感情，是没有打扮的自然。
都是老中医，少给我开偏方。
既然人类都不救高贵之物了，为什么高贵之物非得救人类不可呢
生命是黑暗中闪烁的光。
神不为者，人为之
有些东西得不到才显得越发美丽 。
满脑子天真想法的人，在社会上吃点苦头也是好事。
学校就是社会的缩影，就像把人类放在盆景中一样，所以诸如弱肉强食，还有种姓制度其实都是存在的。
假若真心相爱，绝对会情不自禁。
不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。
没有游戏就没有人生，依靠手段与才能，引领我走上不败的道路。
能实现梦想的只有你自己啊。
向很多人传达到自己的音乐时，和很多人心心相印时,音乐或许可以超越语言
在理所当然的地方，过着理所当然的日常生活。
一举一动，都是承诺，会被另一个人看在眼里，记在心上的。
神秘在比其更高的神秘面前，会失去效果。
虽然丢人，虽然这样做让我觉得很想死，即便如此我现在还不能死，因为我在和你和好之前是不能死的
怎么可能会成为漫画家，能当上漫画家的仅仅只是很少的一部分真的拥有才能的天才而已，剩下的就是赌徒。
每个人都只能活在无法违抗的潮流之中，只有一种命运，是每个人都平等拥有的，那就是死。
每个人都是活在以自己为主角的世界中。
其实世界上没有那么多的如果，有时候，我们一瞬间失去的东西就是永恒。
我不知道将去何方，但我已在路上。
高中三年级的时候能想明白将来要什么的人，那是凤毛麟角。
来到这个世界上，即使是天使都会做坏事。
也许你最最喜欢的人已经不存在了，但最最喜欢你的人不是还在吗?这样正负一抵消不就等于了吗？
以星星和睿智之名，吾等只追求真实。
人总有一天都会死的，但正因为生命是有限的，才能够欢喜和悲伤。
长生之法，人人艳羡，却又有几人真正明白自己想要什么。
人就是这样 越是没有实力越爱说大话 世界上只有没有实力的人 才整天希望别人赞赏。
没问题的，别担心，一切都会好的。
我朋友不多，你算一个，所以你死了我会不喜！
我们来做张地图吧，那样就算在宇宙失散了，也能再找到对方。
幸福是如此的短暂，但是我的心已满足，也许一刹那的美才是永恒。
它不会害人，也没什么好要怕的，对它们笑笑，它们不会害你的。
只要能让我喜欢的人们，明天依然笑着活下去，我是傻还是愚蠢都无所谓。
人生之所以难，是因为每个人的人生都不一样
比起已经实现梦想的人，正在追求梦想的人有时更能发挥实力啦！
人类因为畏惧黑暗，所以用火消除黑暗以求生存。
除非事态非常严重，否则就不要多管闲事。
那些青春期的脆弱自尊，轻易不得触碰，那极有有可能成为对他或她一生的打扰。我们都曾经历那样纯粹、易碎的青春，只是时光的磨砺已让我们懂得逃避与忍气吞声然后慢慢遗忘自己曾经的青春。
我在这个世界寻找希望，却一直寻找不到；所以我只有在另一个世界中得到绝望。
归根到底人类啊，是不会回报你们纯粹的心灵的。
人生中遇到的磨难很多，我们愈是成熟，也愈是胆小，反倒在绝境中才激发出内存的潜质，从而变的坚强和勇敢。
一个人的浪漫，是送给这个城市最温暖的礼物。
青春只剩一段未完的爱恋，偶而像被风卷起的黄叶，落在心口上像一滴被忍住的泪。
不知身处何地, 向着梦想的地方前进. 到达梦想的地方, 却又不知身处何地.
耐心点，坚强点；总有一天，你承受过的疼痛会有助于你。
我也非常喜欢……烟火
炙热战火刺痛双眼，生命宛如流星般陨落。就算这身躯遭到毁灭，我也将化为利剑刺向黑暗
光说漂亮话，是无法改变世界的。
难以应对的未来、不安、迷茫、没能传达的思念、无法实现的梦想、还有无论如何都得不到答案的那些日子。
今后无论发生什么事也好，这个左手上的??都是同伴的记号！
在这个熟悉而陌生的城市中，无助地寻找一个陌生而熟悉的身影
一个人，不会因为所在位置的不同，灵魂就因此而受到玷污。
要变得坚强。如果很软弱的话，终有一日会连悲鸣都无法发出，活得像行尸走肉一般。
啊啊，还真是，干不下去了啊。
为什么现充们喜欢披露自己的恋爱辛苦谈啊？
最怕你一生碌碌无为，还安慰自己平凡可贵。
不管那个宣言有多不可能，我希望有一天能再听到一次
王保卫了国家，可国家没有保卫王，仅此而已。
我们勾勾手，盖上印章，一辈子都不可以忘记。
对的人终究会遇上，美好的人终究会遇到，只要让自己足够美好。
真正强大的人不会在意周围的眼光，靠自己就能毅力不倒。
对不起，在这种时候，我不知道该用什么表情来面对你。
前进一步，幽暗中朦胧地浮现出女孩子的轮廓。前进两步，可以隐约辨识出那张脸庞。前进三步，便看见了笑容。而我，也跟着笑了。
生与死的价值是同等，只有自己选择的死亡才是真正的自由。
请为你我仍活在世上举杯痛饮,请在逝去的亲人的坟头献上一杯甜甜的美酒,请为在世的亲人献上一个真诚的拥抱,请为珍视你我所拥有的一切,当死神的歌谣轻轻的响起在你我的耳边时，请微笑的迎接她。
然某一天，有些不同的东西，出现在了我所熟知的、理所当然的天空之中……
人正是因为度过了一段阴暗岁月，才会更渴求黎明的曙光。
你什么也不肯放弃，又得到了什么？
这是初次见面时说的话吧？
我不说不代表我不了解，我不哭不代表我不伤心。
孤独的人其实非常擅于思考。
场所不同命运也不会改变。
记忆想是倒在掌心的水，不论你摊开还是紧握，终究还是会从指缝中一滴一滴流淌干净。
开玩笑的啦！
要超越不可能。
所谓女生啊，就是温柔体贴，笑容会治愈人心灵的飘浮着灵气的存在
即使明天会失去笑容，即使手中残留着失落感，也要面带微笑。
对于为何要学习某种东西抱有疑问，是理所当然的。唯有当这个疑问解除了，才会产生求学的目的，也才能通往理解数学本质之路。
即使走错路也要共同前进，犯下罪过的话就一起承担，这才叫朋友！
信赖就要用行动来回应。
有些事就是无可奈何的，没错，就是这样！
因为没有事要找你，所以没法打电话啊，就算想打也打不了。
相信即是幸福！
当人们了解爱的时侯,就会背负憎恨的风险。
一只烟燃不到天亮，而远方早已没了黎明。
也许我们都曾勇敢而坚毅，只是，在与时间老人的对峙中，我们从来都不是赢家
舍弃那种感情，利用你所能利用的一切。
喜欢一个人就要真心对她好，哪怕她不喜欢你，甚至不认得你都没有关系。
就算明白得知真相后会让自己变得不幸，但人们还是会想要去追寻呢……
若不想输给任何人，就得先认清自己的弱小！
人不是为了世界而生存的,而是人所生存之地,才称之为世界。
做任何一件事都要尽情享受它，这是人生的秘诀哦。
让我榨干你的每一滴血,再把你像破抹布一样抛弃。
如果害怕，就闭上双眼。
人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。
所谓生活就是一半是幸福，一半是痛苦。
快乐越大,随之而来的痛苦越大。
真正喜欢跑步的人，绝对会跑的很快的！
嗯，我和你一样，我喜欢过你。只是已经回不到从前了，因为时过境迁了，你和我都变了，那些事都已经过去了。
总有一天，人类会意识到乱扔垃圾是比杀人更重的罪。
我想在有生之年，得见盛世大唐。
既然无论怎样都会痛苦的话，我宁可选择守护它而痛苦。
人生的选择是对是错，没有人知道.
这是一个规则与目的皆不明确的无聊游戏，多达七十亿的玩家恣意地进行着自己的回合，赢得太多或输得太多都会收到处罚，没有PASS的权利。说的太多会被疏远，没有数据，游戏类型也不明，这样的世界，无非就是一个……渣游戏。
失去的东西往往是最重要的东西，重要的东西往往会在无意间失去。
吾问汝：汝是吾之master否？
舞台上演员不能无视剧本随便演，华丽地退场才是完成使命。
也许我是想知道，是否有某样东西……没有我，就不会存在。
好了，笑一笑吧，你的国家不是有这句俗语吗，笑容是福至之门。
回忆这东西毫无意义，我不是已经证明了吗
心疼的时候其实连身体都会感到强烈的疼痛。
无论如何，我想和你一起看到人生尽头的风景呢。
我每天都在数着你的笑，可是你连笑的时候，都好寂寞。他们说你的笑容，又漂亮又落拓。
何人懂我心中寒？何人看穿我无言？
牵挂着一人 就会害另一人哭泣 一定要某人做出牺牲 受到伤害…如果这就是所谓的【喜欢】的话 那么喜欢上别人的这件事 就太恶劣了
纵使失去了一切，倘若有半点迷茫的话，也舍不得放弃，惟有真实的自己才最重要！
不管是游戏还是现实，如果踏出一步就前进，不踏出就原地踏步，这决定权是在自己手上。
即使是吊车尾，在拼死努力后，也有可能超越精英。
生命是短暂的，在它结束以前，就让我们相互依偎。
我愿意忍受今天的我的寂寞，来代替忍受比今天更寂寞，未来的我的寂寞。
没有利齿的狼，要么饿死，要么被吃掉。
永远不要为了迁就谁而改变自己，爱的时候勇敢爱，散的时候大步走，别回头。
就算记忆被消除了，还是请你和我做朋友吧。
回到家，吃热腾腾的食物吧，然后，蜷起身子睡觉。
我啊，只是想证明。这样的我，就算是这样的我，也有能够靠自己的双手争取到的东西。
如果这是你的希望的话，我就随你到天涯海角吧。即使王座崩坏，金光闪闪的王冠腐朽，数之不尽的尸体堆积如山，我会留在静静横卧的，小小的王的身边，直到将军的声音响起，之时。
不到最后关头，就决不放弃。
大人的事情终究还是要长大才会懂
学到很多东西的诀窍，就是一下子不要学很多。
说文了叫“关心则乱”，说白了就是喝醋。
能遇到你，我是幸福的，我希望留在你身边。
人世间 酸甜苦辣 若长良川。
这世上真正的好人和坏人都很少，大部分都是普通人。
在我六岁的时候听到的爸爸的三个教诲：其一，自己保护自己；其二，正确答案不止一个；然后，其三，不要以为爸爸说的都是正确的。
无法去坦率爱别人的你，真是可悲。
真正拥有力量的人，不管是命运还是宿命都可以自己创造！
算了吧，向你这样的即使把土豪两个字贴在脸上，别人也会从右读起。
人类很容易受到诱惑，当被迫身处如地狱般绝望的深渊时，眼前要是出现了逃生的蜘蛛丝，一定会紧紧抓住不放的，无论是怎样的人。
活着就会遇到讨厌的事，也就是说活着本身就是让人讨厌的，但不能因此就放弃活着。
只顾着追求新事物，却不回顾历史，怎么会有未来。
人类的敌人，最终还是人类。
不管夜晚多么黑暗，黎明总是会到来。
一直以来，我都在听从你的引导。然后我才发现，你所引导的道路，是一条没有出口的隧道。
无论是丢下还是被丢下，这两者都是一样痛苦的。
最初就不期待，中途也不会期待，直到最后也不会期待。
为什么妈妈就不明白无所事事的忙碌呢。
在不知道该选哪一边时，就选自己应该做的那一边。
我随时都可以死，那就是我的未来。
看着我的眼睛,这像是说谎的人的眼睛吗?
虽然你那个世界我是不大了解，不过我能理解你所怀有的恐惧，毕竟你要走的是跟别人不一样的路啊。
就算不知明天会变得如何也无所谓，我们是为了活在当下而全力以赴。
根本不需要害怕梦想结束，因为…这个世界是无限的！
人生之所以难，是因为每个人的人生都不一样.
至少对我来说，那感觉似乎永远会延续下去的高中生活的结束，是一个大大的休止符。
人类是无论如何都不会互相理解的愚蠢生物。
自己觉得不错的东西，就会想要和自己觉得不错的伙伴们一起观赏
人能够在心里郁积那么多的事情，而他们又会忘记那么多的事情，真是不可思议…
真正重要的东西，肉眼是看不到的。
你已经是我心脏的一部分了。因为借走的是糖，还回的是心。
有些路注定是要孤身一人走的，想要到达繁华，必经一段荒凉。
我是为了保护我需要的人而战。
在这个世界上别太依赖任何人，因为当你在黑暗中挣扎时，连你的影子都会离开你。
我只要静待机会降临就行了！
从今以后，我要像小丑那样藏起悲哀而笑着。
真实的谎言，是假装快乐，谎言的真实，是无可奈何。
我们是活在瞬间里的，我们是活在瞬间里的生物啊。
真正让我难受的，大概是因为让你看到如此狼狈的自己。
如果自己不想积极认真地生活，不管得到什么样的回答都没有用。
不可能这三个字，你说的太多了
你能够停止哭泣 那是因为你在于悲伤相抗衡啊。
强大的信念能够超越计算！
人只会看到自己想看见的东西，只相信自己的希望相信的东西。
绵长而又不甘，细碎的絮语，是在泣涕那抽丝剥茧的绝望么？
十九岁以前把这辈子没机会看的书看了，十九岁以后把以前没机会看的电视补上。
当有一天你觉得除了钱没有什么能让你快乐的时候，那你的生活注定是悲催的—曼曼。
并不是只有你一个人，所以不要消失。
只要全家同舟共济，一起回到正路上也完全有可能。
当那句话跃入眼帘的瞬间，我的胸口扑通一声为之悸动。
我从没有后悔过。无论发生什么事，就只有「后悔」我绝对不会。
老师，我们每个人都需要一个能给自己道别之吻的人
我愿意做你的最佳听众，看着你装逼从始至终。
好红，每当想起你，枫叶就会被染红。
狮子神子，高神剑巫，诚心祷祝，破魔曙光，雪霞神狼。以钢之神威，助我讨尽恶神百鬼。
所谓社会并非一定要完全正确，所以我们必须保持我们的正确性。
夏天，那个夏天，还有那个夏天，即使经历无数次夏天，我还是说不出口。
有时候你需要退开一点，清醒一下，然后提醒自己，我是谁，要去哪里。
无论是小孩还是大人，感情的痛苦都是难以忍受的。
天地之间，能够称得上王的英雄就只有我一人而已，剩下的就只是些杂种而已。
那有一天，是不是我也会被你们忘记呢。
在这里放弃的话，比赛就结束了。
滚圆的东西咕噜咕噜往哪滚去都不费力，四棱的东西想要让他滚，不但费力还很痛的。
知道传言为什么只是传言吗，那就是因为没人知道是不是真的。
人能够按自己的意愿选择生死，不管对错，都是一件了不起的事。
现实就是你很周全的考虑了种可能性，偏偏出现第种。
伟大的美好的只有死去的他们，我们都是渺小、愚笨，在这地面上努力的求生存，只是如此而已。
每个人都会突然喜欢上一个人，就算没有勇气，也会踏上这条艰难的道路吧。
一个人因为遭遇失败，才会拥有从那里再站起来的强悍。
最痛的伤口,是从外面看不到的。
既然这样，我就会一直往前走。一直走到他望尘莫及的地方，不让他接近一步。
因为与你相遇之后，我的身边都是好事。
去发现自己的弱小，去承受失败带来的打击！
我一直想要…一直想要，那时的明天…能向面码道歉的明天，一直想要…
仿佛叶公好龙一般。隔岸观火地单恋着。
我是马戏演员，只会让人笑，不想看人掉眼泪。
我为了不受将来的侮辱，所以要拒绝今天的尊敬。
谁是谁生命中的过客，谁是谁生命的转轮，前世的尘，今世的风，无穷无尽的哀伤的精魂。
第一印象是很重要的。
你TM感动了我
与别人交往，有时伤害人，有时被伤害，却不懂得学习别人的话，在某种意义上，你是无法成为一个能体谅他人的人。
木叶飞舞之处，火亦生生不息.
这个世上，胜者生，而败者亡，在世事的胜负面前，生与死不过是必然的因果。
过度的无知有时候也是种幸福呐。
没有翅膀的家伙是飞不起来的，凡是向天空发出挑战的故事，总逃不过那坠落的终末。
正因为生来什么都没有，因此我们能拥有一切。
若不知晓相同的痛楚，就无法真正理解他人，而且就算能够理解，也不可能相互体谅，这就是不变的道理.
但体贴却是每个人手制的，所以很容易被误解，被认为是伪善。
我心里有一个小孩，每当她觉得与世界格格不入，她就躲进角落。
人有棱角是要吃亏的。
就像自己是一个怎么都做不了的孩子, 要承认是非常难和可怕的。
无论谁的心中，都有自己的歌。
人类总是给自己那么多束缚，连自己至亲都不能相容，反而为妖族所悦纳，也真是奇特啊。
食物有很强大的治愈力量。
人生不只是离别，邂逅使人生更精彩
生死是自然规律。
瞳凝秋水剑流星，裁诗为骨玉为神。
人不敢面对自己的懦弱，被戳中痛处时就会恼羞成怒，反咬对方。
肯定是因为我没有真正喜欢过一个人，所以才一直在想，真正喜欢上一个人的话，会是什么感觉呢？
就算此刻存在的东西，也许明天就消失了。
只要活着，哪里都是天堂
有时候，一个人只要好好活着，就足以拯救某个人。
觉得人的哭有两种:觉得自己可怜的哭和单纯……伤心的哭.
希望一直都在，只是你不曾察觉而已，未来的希望，一直在你手中！
认为自己没听说过的事情就不存在于世，这可是无可救药的傲慢啊
假装自由，受困于自由，被自由所左右，只不过是逞强而已。
就算前路被深邃之暗阻扰，也要使之臣服于己。
只会哀叹不幸的人，连猪都不如！
我会扔下你，所以你要追上来哦。
有人曾说，那里是可以吞噬一切的黑暗，但却并不是说没有一点光亮。
人们要是没有回忆就活不下去，但是只有回忆的话也活不下去。梦总是有会醒来的时候，不会醒的梦总有一天会变成悲伤。
坦率，是个和我无缘的词。
你们杀了多少人，放过多少人
都不关我的事
你们触到了我的逆鳞
仅此一条，就是你们消失的理由
你们杀了多少人，放过多少人,都不关我的事 ,你们触到了我的逆鳞,仅此一条，就是你们消失的理由
因为和你们在一起，实在太高兴了。
是我来决定我旁边坐谁。
不是所有的鱼都会生活在同一片海里
我们只是活着，然后堕落而已
人因为有难忘的记忆而变得坚强，这就是所谓的成长吧。
精神方面充实了就一切都满足了这是不可能的。
嗯，我的愿望是每天吃饱了睡睡饱了吃，啥事也不用干。
也许正义并非太阳，而是如同星星一般的东西，天空中有无数的星星，彼此不断抵消着其他星星的光芒。
思想，语言是会束缚人的东西，不但自己的会束缚自己，别人的也会束缚自己。
网球，不是用来制造仇恨的工具。
得来不易的机会，会让所有的动物去做原来不喜欢做的事。
让你陪我疯了这么久，真是抱歉，这是我最后一次的任性。
已经走到尽头的东西，重生也不过是再一次的消亡。
如果聚集负的感情, 世界就会陷入负的洪流; 反之聚集正的感情, 世界就会循着正道而行。
起风了,唯有努力生存。
我们会死很久，所以活着的时候一定要开心。
青春就是让你张扬地笑，也给你莫名的痛。
无他，凭心而行，后果自负而已
每个人的优点就像是梅干一样。
会隐藏在心底，这份心意不会告诉任何人，包括他，会一直隐藏下去，直到那份恋情终有一天彻底消散为止。
总有一个人会举着戒指对你笑，说着余生请你多指教。
不管痛苦还是难受，都应该感受到生存的力量。
说好了大伙儿要一起笑着再见，你在这里死了不就没意义了吗！
你走在我所陌生的黑夜中，如果至今还在黑夜中踱步，我们会努力成为出口的路标。
我站在天堂向你俯身凝望，就像你凝望我一样略带忧伤。
从来没有人问过我这个问题 “独自一个人的时候都在做什么呢？”
人啊，在想保护最珍贵的东西的时候，会成为真正的强者。
信念，是会化不可能为可能的
坚持下来了啊，到最后。
最最好的，与最最痛苦的，是一样的。
一条路不能回头，就是一生要走许多路，有成长之路。很多事情不能自己掌控，即使再孤单再寂寞，仍要继续走下去，不许停也不能回头。
相见不如不见，有情还似无情。
我们不是也曾有过乐观得不得了的年轻岁月吗？
如同那时的爱情，让人期待,也充满着无奈
如果你找不到一个坚持的理由，你就必须找到一个重新开始的理由。
希望你有一天你可以完全的信任我,能成为你忠诚的朋友,是我最大的幸福.
谁都不可能和谁在一起一辈子。人就是这样，必须去习惯失去。
有着似曾相识后发际的他，却说着陌生人一般的话语。总觉得…有点想哭。
减等于多少
世界上最大的谎话，莫过于在最难的时候说一了句：“我没事。”
无论人生变得多么悲惨，都绝对不会放弃。
时光再美，怎如初见。
不管别人怎么批评她，看到那个人她还是笑得出来。
我喜欢你，但不是真正的我自己。
我讨厌放弃，没有任何理由！
我可以握住未来，可以握住冰冷的斧头，也可以握住阻挡在我面前的人的性命…唯一握不住的是你的手。
真正的痛是连痛都不能说得痛。
梦想根本不重要，没有梦也无所谓。前提是要先有取代梦想的东西。
以前高中时，羡慕大学考试只要及格就行；现在大学了，怀念高中考试及不及格都行??
你的烦恼相比起来是那么渺小，简直微不足道。
人只会相信自己意愿相信的东西。
与其费尽周折绕过去，不如勇敢的地攀越，或许这会铸就你人生的高点。
一个人都有自己想保护的人或事物, 但当你保护不了的时候, 就会怪责自己为甚么会这么无用。
如果让我的人活，就要让天下人死，那，那就让天下人死吧。
为了能尽情做自己想做的事情，不想做的事情也必须全力去做才行。
你不必原谅我…不管你今后的路想怎么走，我都一直深爱着你。
时间飞快的流逝，唯独现在，我有一种想对爱因斯坦发牢骚的心情，冈部，时间根据每个人的主观感受，既会变长，也会变短，相对论真是既浪漫又伤感的东西呢。
逃离了痛苦之后还会觉得痛苦。
世界并不都如你所想，很多事物和你的习惯性认识并不一样。
人类并不是你想象中的那么复杂 ，更容易因单纯的简单的事情而悲伤而生气，人类就是这样的存在。
年轻一代才能的创造力！！不要轻视！
如果死了尊严还有什么用。
女人这种动物，分明毫无必要，也爱观察别人。
后悔所带来的苦涩，恰好印证了自己曾经有所作为。
其实，朋友也许就是这个样子：未必要什么天长地久，也未必时时见面联系。在一些时候，可以彼此温暖，彼此慰藉，彼此鼓舞，那就足够了。
如果你一个人把什么都做完了，那我做什么？
身体的冷哪比得上心里的冷，刺骨的疼
自古英雄出少年，似水红颜惹人怜。
三次元的都是渣，我有自己深信的世界。
当有人从心底认同你的时候，那个人对你来说就是最重要的人。
你不被认同，就无法存在了么？
你愿用一生，等待，然后呵护这短暂的光亮吗？即使，明知它会消失。
不管你们的梦想有多么可笑，带上它，给我高高地飞起来。
只有自己真正的朋友，你才会愿意将他牵扯进来。
全神贯注的上吧！不要松懈！
关于自己的生活，我和你都不是读者，而是作者。至少结局，还是能自己说了算的。
只要活着，就该笑着去面对一切的一切。
哈，六界众生，熙熙而来攘攘而去，何人能尽偿所愿。
不管你是天才还是秀才,如果坏掉了就只是一堆破烂而已
比起牺牲自己的圣人,我更愿意成为不明事理的勇者。
没有人可以左右你的人生，只是很多时候我们需要多一些勇气，去坚定自己的选择。
真正的神，这个时间是不存在的。
曾经拥有的东西被夺走，并不代表就会回到原来没有那种东西的时候。
如果有来生，我要当条被子，不是躺在床上就是在晒太阳！
洸。不再是那时候的洸，声音和身高都变了，我终于了解了岁的洸，我是对岁的洸心动。
你们想要的自由，根本就不是属于弱者的词啊！
火在一天之内就能烧尽 ，而水和风却要花百年的时间来造林
世界颠倒前后左右上下黑白，于是我就成为你的倒影，永远活在与你完全不同世界。
现世为梦，夜梦为真。
跟我作对会有什么结果，你应该很清楚的吧。
如果只是对别人言听计从，因为别人说了才去做的话，就算是在有趣的事也不会感到开心哦。
悲哀的不是不能复仇，而是不能在仇恨中活出自己.
我永远也不会忘记那个忘记我的存在的人。
我们必须在失败中寻找胜利，在绝望中寻求希望。
我们要忠于自己的信仰啊。
健全的灵魂，寄居在健全的精神和健全的肉体之上。
我把眼泪送出去了……
只有在放弃的时候，可能性才会变为零，无论别人觉得多么没有意义，我不想让自己认为可能性为零，所以···我绝对不要放弃！
我知道，终有一天，这个世界将被我踩在脚下！
脑子里都是圣诞节的铃声了，那是头痛。
为一个不在的人发牢骚是没有意义的，眼前的敌人才更重要。
走过一段路 回头看 原来那些痛得快要死去的事情是可以一笑而过的。
相信奇迹的人，本身就和奇迹一样了不起。
君子，小人，皆在一念思量。
火在一天之内把森林烧成灰烬，水和风却需要一百年以上的时间来造林。
这世界上没有没意义的事，也没有没用处的人。
死何其容易，只是留下来的人，才是最痛苦的。
只要你微笑,你心里的我就会陪你一起微笑.
正义……并不是随随便便挂在口边摆样子的东西……而是秘密的珍藏在自己心中的东西……
有些事情，可以理解但无法接受！
不管以前或未来，都过著阴影的人生。
人和人在上帝前都是平等的，毫无例外。
梦想是一个天真的词，实现梦想是一个残酷的词。
有时候，我们必须闭上嘴，放下骄傲，承认是自己错了。这不是认输，而是成长。
每个人的身体，都由她们自己保护。
你永远都不会知道自己到底有多坚强，直到有一天你除了坚强别无选择。
我们不管做任何事都不可以半途而废，要坚持到底
夜色里，埋骨鲸诗，多情薄如风。往事烟之，几句问谁愁，只求一杯清风。
城市犹如没有围墙的囚房，令人疲惫、窒息……
我想要拯救我的故乡，我要改变不列颠灭亡的命运。
没有温暖的阳也没有希望的光，世界只是一片狼藉，不要抹灭你最后的希望。
就算是恨，也是一种很抽象的感情。
夏日当空,心如深渊。
生命中充满了巧合，两条平行线也会有相交的一天。
精心计划如何在自己绝不会亏损之下，只让对方去冒获利或亏损的风险，这样的行为也十足算是诈欺。
借走的糖，还回的心。你的世界是我最勇敢的一次冒险。
我永远都不会忘记你和我在一起的时光，所以请你答应我,在我即将离开这个世界的时候，你会陪在我身边。
如果没有遇到她，我会依然无法从消沉中振作起来
若说结局能改变，我为你绝笔阑珊。
忍者要沉着冷静、仔细判断。打破忍者世界规则跟铁律的人，我们都叫他废物。 …可是，不懂得重视同伴的人，是最最差劲的废物!
有伤害人的人存在的话，也会有能抚慰伤痕的人。
少年终将为王。
若有所需，自是不计生死。
未来永劫，我来保护您。
世界这么大，人生这么长，总会有这么一个人，让你想要温柔的对待
最后的最后，竟然超越了自己的神话。
这是我们好不容易才抓住的日常生活，是我自己所做出的决定。
当一件事变成天下大事之时，任何人都无法置身事外。
我有预感事情会变得很有趣呢。
用玲生命为代价的东西根本就不存在。
我们都在梦中，一个叫青春的梦里。梦总有一天会醒来，而回忆会一直闪烁。
想看你的笑颜……却偏偏带来伤害。我多希望这爱的火焰，只有温暖的力量。
爱的反面不是恨，而是无视。如果不感兴趣的话，就不会故意去杀害或者伤害对方。
滚滚红尘终误我，今宵夜月可流连。
人生，是为了什么呢？难道不是为了在这个时刻紧紧握住重要的人的手吗？
人类为什么互相依靠却又再次争吵。
不需要什么窝，有一棵可以停歇的树就足够了。
我的生命只有十年，希望你能多抽出一点时间和我在一起。
谁都有权利幸福，困难的是享受；谁都有权利幸福，困难的是履行；谁都有权利幸福，困难的是妥协。

#NAME?
烦人的家伙身边总有烦人的伙伴呢。
王冠会让戴上它的人高人一头，是地位的象征。但王冠真正的意义是：当灾难从天而降时，我会为你们抵挡一切，永远让你们只看到金色的希望。
如果只是把世界分为清净和污浊两者，是不是就反而看不到真相了呢？
很温暖吧，温暖的双手不是为了伤害别人而存在的，真心想要守护的话就得学会温柔。
笛卡尔说过，无法下决定的人，要么是欲望太大，要么是悟性不足。
死了的话，就什么都没有了！
只要怀着理想而行动，就算结果不尽如人意也没有关系。但是如果失去了理想，那就真的一无所有了，连自己珍视的人都保护不了。
不断的寻找希望，这才是真正的希望。
现在的你要是多学一样本事，以后的你就能少说一句求人的话。
快乐的事，悲伤的事，虽然不能全部承担，但一定程度上是可以共同分担的，这就是行会，个人的幸福就是大家的幸福，个人的愤怒就是大家的愤怒，还有个人的眼泪就是大家的眼泪。
愿你我不失此缘
曾经的喜欢，不管曾经怎样，都会幻化成风，消失在时光的隧道。
所见之物皆美丽动人，这就是所谓的成长吗？
说谎的时候，重点不在于说谎的内容，而在于为何要说谎。
梦总是会醒的，不会醒的梦，总有一天会变成悲伤
说起来,这世界就跟书一样,所有的书都是为了被阅读而存在.书如果没被阅读,故事就无法开始.而没被阅读的故事,就等于不存在.
当一切都随风而逝的时候，那些特别的瞬间都成了永恒。
虚伪的眼泪会伤害别人，虚伪的笑会伤害自己！
所谓“大家”，就是无视并牺牲了一部分弱势群体后所达到的虚伪的和平与共识。
什么都无法舍弃的人，什么都无法改变。
如果你掉进了黑暗里，你能做的，不过是静心等待，直到你的双眼适应黑暗。
多幸运能在消失前抱你一下，只是我始终没能说出那句话，我喜欢你。
只有弱者才喜欢扎堆，问题是绝大部分人都是弱者。
即便大学不是名牌，我也是名牌！
十多年的单恋修成了正果，是很幸福的事。
能与她在春天里相会真是太好了。
在多数时候，我们所看到的都不是事物的本来面目。
谎言就是真实，真实就是谎言。
常胜之王在此高深唱响手中所持奇迹的真名。其名曰： 誓约胜利之剑excalibur
到了世界的尽头，就能找到心之所向，永恒的幸福吗。
时光总有一天会将你我拆散，可是即便如此，在那个时刻之前，也让我们在一起吧
没有任何事情会无缘由地突然发生，你之所以认为它是突然发生只是因为你没有看到它发生的过程罢了。
一心只想达成目的吗？你已经拼命到连目的都看不清了吧？
名为幸福的椅子，总是只准备了比全体的数量要少的把数。
发自内心地想去理解，这份心情就这么不堪吗？
物质和金钱归根结底是必须和必要的。
面码没有为自己着想的时候，仁太一直在为面码着想啊。
只有理解了人之心才能做到，明白羁绊的珍贵，才知道失去的痛苦。
要是什么都按照计划顺利实现，谁还用辛苦打拼？
视千日之练习为锻，视万日之练习为炼。
我不属于这个时间，我不想走，但我不得不走。
世界不灭，我即不灭。
越是拼了命投入，失败时的反作用力越大。
在我安定下来，找到一个合适的伴侣之前，我得先找到我自己。
不要哭，我还没有努力到要哭的程度，不甘心就可以了 。
真正坚强的人，都是越想哭反而笑得越大声，怀揣着一切痛苦和悲伤，即使如此也要带着它们笑着前行。
真是，我本来还想多混吃混喝几年啊。
珍惜今天，珍惜现在，谁知道明天和意外，哪一个先来。
出生到世上，单单因为这个，就该心存感激。
这样不好，别担心。
胆敢对本王出言不逊，可不是这么简单就能一笔勾销的事情。
不断奔跑才是人生。
如果要伤害别人的感情才能实现的话，对那个人来说梦想就已经不能称之为梦想了。
想说的有很多，想做的有很多，最后却什么都没说，什么都没做。
喜欢上一个人是没有理由的！
当我们已经不再信仰神明的时候，我们又成了他们的神。
恋爱就像是把自己不好的一面反射出来的镜子，特别单恋的时候，会嫉妒、产生偏见性格、变怪癖、羡慕别人、真的接触各种各样的感情。但这也不必为此感到羞耻，这都说明你对恋爱如此认真。
无论距离有多远，都能看到彼此努力的身影。
没办法，我没法让你相信，但绝不会让你后悔。
你的败北，早已注定。
我想起那天夕阳下的奔跑，那是我逝去的青春。
迷宫般的城市，让人习惯看相同的景物， 走相同的路线，到同样的目的地；习惯让人的生活不再变。习惯让人有种莫名的安全感，却又有种莫名的寂寞。而你永远不知道，你的习惯会让你错过什么。
我要真心的，亲下去咯。
有朋友的日子，不会孤独，充满着自信和温馨。
活在现实中的人是错的，而那些哭泣的人才是正确的，孤独的我们才有人类的样子
每个人都有自己的个性，只要能把那部分发挥出来就好了
人死之后，一定是去了谁的心房之中，成为那个人的回忆，一直永存在那里。
我不知道死亡的时候，凝望苍穹竟然会那么凄凉，一声一声声霰雪鸟的悲鸣。
我对这个世界绝望过，但从未对自己绝望过。
有些事，想多了头疼，想通了心疼。
没有任何回忆是可以遗忘的。
确也知道那些轻薄的水蒸汽不能托住自己和梦想
有形的东西迟早会凋零，但只有回忆是永远不会凋零的。
就算发了一千条短信，心与心的距离也不会靠近厘米。
孤这一生，无怨无悔。
无论是谁，都会有不想为人所知的一面吧。
会站起来的，为了你的话，即使千百次也会站起来。
能让女人命苦的，哪个时代都是男人啊。
悲观着，叹息着，这么做有什么用，停滞不前，即使是死人也办得到。可是，我活着，用自己的力量站着，终有一天会死的话，还是不要留下遗憾比较好吧。
痛苦只是短暂的一瞬而已。
我们只是守护着自己认为重要的事情，只是因为这样我们不顾生死
在哪里跌倒，就在哪里趴着。
你爸不在家，不想做饭，猫在陪我吃饼干。我妈这条短信我一直存着。
幸福是因人而异的呀！
当你想要征服一样事物时，一旦得到了过后，就会很快失去兴趣甚至随手抛弃。而如果你爱着一样事物，得到过后只会更加珍惜。
不可以窥看咨询者，这也是规则。如果对方觉得自己被发现了，就不会再写信来咨询了。
随着时间的流逝痛苦会变得淡薄，然而我并不想让时间来治愈我的痛苦，就算从痛苦中逃脱，忘记一切，得到的也只是停滞，无法前进。
只要有想见的人，就不再是孤身一人了
如果朋友走上了错误的人生道路，就算破坏友情也要阻止他。
不管是多久以前的事，失去最重要的人总是无法忘怀，总会感到孤独的啊！因为你……寂寞的话，我也……会寂寞。
在那之后干了个爽。
也许我就是为了与你相遇才出生的。
一个人之所以幸福，并不是他得天独厚，只是那个人心想着幸福，为忘记痛苦而努力，为变得幸福而努力。
无论罪犯计划得多么周全，笑到最后的也不会是罪犯。
一个人的心需要了另一个人来点亮。
世上本没有绝对的正义，总认为自己永远是对的一方，偏执与傲慢，能利用的绝不错过。
为了能永存那些人心中，为了让在座的所有人，永远铭记我们，我不会忘记的。
我不会忘记，一直，都留在我的心间。
你重视的东西，我也会放在心上。
你是什么时候说的？哪年哪月哪天，几点几分几秒，地球转到第几圈的时候？
天真烂漫，异想天开，就像坐云霄飞车一样，她总是把我绕得团团转，她本身就是一条不知通往何方的旅途。
等得越长久，重逢时也就更幸福。
因为这一年来，他心里想的，眼里看的都是他。
美好的事物不会降临在傻傻等待的人身上，它只会降临在那些追逐目标和梦想的人身上。
但原来你一直都注视着别的世界
存在与我们大脑中的，只不过是会不断思考的菌类罢了。
所谓的奇迹，要真的发生才有价值。
真正的坚强就是，不以为了别人作为借口，而去勇敢的朝着自己的目标奋斗。
时间带着明显的恶意 缓缓在我的身上流逝
世界上的男人，%都抱有“她是不是喜欢我？”这样的想法而活，正因为如此，我才需要告诫自己“永远都不要以为妹子喜欢你”。
羁绊就这样说不清也道不明。
看着她寂寞的眼神，心中第一次有了做错事的感觉……
为什么还要指责已经如此可怜如此不幸的我。
有一幅无论如何也想看的画，无论多么遥远……无论在什么地方……无论多么危险……都想看的画。在我的时代里，这画已经消失了。在这个时代之前，在什么地方也不知道，知道这画确实存在的，只有这个时代的，这个地方的，这个季节而已。
也许，思念可以超越时间与距离。
走曾经走过的路，唱曾经唱过的歌，爱曾经爱过的人，却再也提不起恨。
随着全都是悲伤讨厌的回忆一个人生活至今的我，孤独地渡过着苦闷的悲惨的青春时代的我，是不可能输给那些一直受到大家支持与帮助的人的。
简直如同童话一般，当恶魔留下眼泪的同时，也就失去了魔力。
有一天我变老了，不知道你会不会像现在这么照顾我。
心怀希望，人才能够努力拼搏。
坚强不是面对悲伤不流一滴泪，而是擦干眼泪后微笑面对以后的生活。
我还没来得及 还没来得及想好 得到的却注定失去 还是一开始就不曾发出?
我仍然很差劲啊。
揭下面具，我的真心也就不过如此而已。
做了之后再后悔，是没有做错事而后悔的，没有责任心的局外人说的台词。
就算如此，我也要去。就算全部的棋子被夺走，棋盘上只剩下了王，也绝对不会投降。
你即是真实，生之证明。
生而为人，活已为人，卒以为人者，于此长眠。
我必须承认生命中大部分时光是属于孤独的，努力成长是在孤独里可以进行的最好的游戏。
只要和你有关的任何事情我都不会忘记。
我早就闭上了双眼，我的目的只在于黑暗之中。
意识开始模糊，突然开始犯困，然而只有孤独感却陡然增强，这就是……死吗……
因为憧憬着看不到的东西，被迷惑，而迷失了那些看得到的东西，我不想这样。
虽然不知道是明天、后天，亦或是数十年后，终点总有一天肯定会降临。
心在哭泣，眼睛却流不出泪水。
已经走到尽头的东西，重生也不过是再一次的消亡。就像所有的开始，其实都只是一个写好了的结局。
那时候我们所待过的地方,就如同向阳之地,将寒冷的冬天或是酷热的夏天,都转化成祥和温暖的地方,从那里出发的我们,不知会并肩走到哪里,又能走多久呢?
我想以没有仇恨的眼睛看世界。
要拒绝空气，就首先要拥有空气；要拒绝世界，就首先要拥有世界
有时候，你问的问题，对方一直在闪躲，那就是委婉的告诉你，真实的回答很残忍。
这个世界真的很现实，每个人都在为着同一个目的，不惜一切代价努力着，心甘情愿的成为金钱的奴隶，死心蹋地的付出。
男人被甩过才会变强，没有度量把这个当笑话说的男人是无能的。而且，幸福什么的也不是男人应该追求的东西。
有时我沉默，不是不快乐，只是想把心净空。有时候你需要退开一点，清醒一下，然后提醒自己，我是谁，要去哪里。
朋友，你要知道，有些东西永远不会改变。
拉过勾的事情，就一定要做到啊！
不清楚的事，却要决定一个结果的现实，我对此感到绝望。
不知不觉之中，我们正是被自己所守护的东西守护着。
人一旦对自己的不足妥协的话，就再也踏不出新的一步了。
时间如负重，我做如是想。
我们别无选择，只能在黑夜的道路上前行。即便四周如白昼一样明亮，也只是不真实的白昼。对此我们早已认命。
我的灵魂一直在黑暗中奔跑，一直。
父亲永远都是不善于表达他的爱，但他总是会默默地用行动告诉我们，他是有多么的爱我们。
关于自己的生活，我和你都不是读者，而是作者。至少结局，还是能自己说了算的吧。
任何人都会有其所爱
剑是凶器，剑技是杀人的伎俩，无论用多么美丽的语言去掩饰，那始终是事实.
只是为了自我满足，而不好好照顾它的人，和抛弃它的人没有区别。
我现在决定了，我要走我自己的忍道，朝着一条绝对不会后悔的路，一直往前走！
所以向前走，向前走，无须回头。
幸福是回到家后敲门，而不是伸手去摸那冰冷的钥匙。
跟你说话，我才发现原来我是个高智商的人。
有一天，蓦然回首，你会发现，那个给你许多痛苦的人，却也是你的救赎。
被逼成的王，孤独的王，温柔的王
最近感到困扰的是，连小小的离别都会觉得有点寂寞。短暂的相遇跟离别，我想重视所有的刹那。
强大能够成为武器，弱小也能够成为武器。
没有期待就没有失望，没有羁绊就不会受伤。
总有一天你会明白的，你要用你自己的双眼来判定来选择自己要走的路
闭上眼睛，好好回想之前的努力，自信会喷涌而出。
默默的忍受，然后就这样变的得越来越胆怯。一边忍耐，一边“为什么我如此不幸啊”这样自我安慰着就过去了。
就像被神明进行着某种试炼一样，但是喜欢的心情，不会再敷衍过去了。
我们的正常之处,就在于自己懂得自己的不正常。
知道把事情搞糟了怎么办吗？很简单，把它搞得更糟一些
赌上性命的家里蹲，这就是人生。
让这个无趣的世界变得有趣起来,这就是我一生的信念.
与你相遇，自从那日开始。我的世界，就连琴键……都开始变得多姿多彩。
时间明显的含着恶意，朝我的头上慢慢的流过，我只好咬紧牙根，拼命的忍住不让眼泪掉下来。
世上大多数人都穿着这样的褴褛。但是谁也不觉得害羞，因为这是他们靠自己双手的劳动得到的最好的衣服。
生我者何人，又岂由得我。
我能遵循自己坚信的道路真是太好了。今天又再次确认了这一点。你也要朝着自己认准的方向不断前进吧。
相似的人适合一起欢闹，互补的人适合一起变老。
一个无法贯彻自己信念的人,无论是生是死,都只能是一场悲剧.
那年的冬天特别寒冷， 整个城市笼罩在阴湿的雨里· 灰蒙蒙的天空，迟迟不见着阳光， 让人感到莫名的沮丧，常常走在街上就有一种落泪的冲动……
我并不是为了得到你的认可而活下去的。
从不放弃信念，一直以自己的力量披荆斩棘，所以，我一直信任着他。
真正的胜利，并不是战胜强者。把自己重要的东西保护到最后一刻，才是胜利。
善于破坏气氛的人，不仅能破坏好的气氛，其实也能把坏的气氛破坏掉。
那孩子在多种意义上都是天然纪念物。
星空之所以美丽，就是因为在无限的宇宙中，不管黑暗如何蔓延， 都有星星的光芒去把它照亮。
世界上每一个人都有属于自己的影子。
总有一天，你们会明白，到底是因为人死会悲伤还是因为悲伤会杀死人。
人的一生如负重远行。也许干脆丢掉行李会比较轻松，但无论怎样也不会那样做，如果没有行李的话，走起路来会多么无趣。
知道什么叫历史吗？生长于真相之下，明白过去，预感未来，知道那就叫历史。
你驻足于春色之中，于那独一无二的春色之中。
要想成为强者，就不要回避心里的恐惧，恐惧并不是弱点。强者，是要让你的敌人比你更恐惧。
只是，当我回头看看，原来你已经在离我那么远的地方，我才知道自己有多舍不得你。
那些关于烦恼的事，我们呆到忘掉吧。
我的汗与血终将化为现实
花就算凋零了只剩下淡淡的香味，也会向着太阳散发出香气。
虽然人生不能reset，人际关系却可以reset。
成长的过程其实就是世界观不断崩塌重建的过程。
所谓生活就是一半是幸福，一半是痛苦，一个人之所以幸福，并不是他得天独厚，只是那个人心想着幸福，为忘记痛苦而努力，为变得幸福而努力。只有这样才能使人真正幸福，反之，再多的幸福也被当成了痛苦 。
我的世界能有你的笑容就足够了！
在自称善意的之时，即存恶意。
是不是现在踏出这一步，下决定的是他。
点赞真是一种非常高冷的表现方式，不给对方任何回复的机会，就只是默默的告诉别人，朕已阅。
纵然千夫所指，只要仍有一丝信任，就能感受到温暖……
我最大的敌人是无聊，但第二大敌人是吵闹。
人生最宝贵的不是你拥有的物质，而是陪伴在你身边的人。
事情都有千万种解决方法，相反，有时也会无法可解。
了解自己真心喜好的东西，认同它并积极乐在其中，这难道不是真正的强大吗？
那个记忆，会在心中慢慢散发着温暖的光芒。
不自弃者天不弃。
当一个人公平公正地去对待每个人的时候， 那便等同于他已经无法爱上任何人。
一个人起码要在感情上失恋一次，在事业上失败一次，在选择上失误一次，才能真正地长大。
历史，不过是由胜利者书写的谎言罢了。
如果你愿意那样的话，我会很开心的。
谁都无法相信未来，谁都无法接受未来。
如今的夜空没有昔日流星的闪烁，没有灯火璀璨的繁华，只剩下我独自一人，心在天边惆怅。
天空微微泛白，让人分不清是深夜还是黎明呢，洸就像这片天空一样，让人分不清你是温柔还是冷漠。
我愿意减寿命一年，让那些人出车祸死掉算了。
受过伤的心灵会提高恢复力而再生，以后就再也不会受伤了。
无论黑夜如何漫长，朝阳终会升起。抚平大地的伤痛，我将为新生歌唱
我会回来，就算拼死也会回来！
你永远也看不到我最寂寞时候的样子，因为只有你不在我身边的时候，我才最寂寞。
我要亲手击杀这乱世，并狠狠地还上一刀。
我也很喜欢,不只是烟火。
善良的人永远是受苦的，那忧苦的重担似乎是与生俱来的，因此只有忍耐。
成长是一笔交易，我们都是用朴素的童真与未经人事的洁白交换长大的勇气。
一个寂寞的人被给予了思念就会显得更寂寞。
人生就好像一颗种子，不管你是否准备好，总是要发芽的。
如果全世界都不要你了，没关系只要你回头就会看见我，可是我忘了你是一个骄傲到从不回头的人
人类为了家人什么都会做，不但可以面不改色地撒谎，而且就算变成鬼或者恶魔都在所不辞。
体会到失去的东西的沉重，无论如何还是要继续下去，为自己而活吧！那才是真正的决心！
如果忘记了，就请沉默直到记起来为止。
每个人都有自己的个性，只要能把那部分发挥出来就好了….
在我们的上方，星星眩目地闪耀着。
自信什么大家都不是一开始就有的。
所谓的英雄啊，总是会死在不合情理的命令之下。
一个冒险者最好的宿命，就是死在一生中最后一次冒险的征途之上。
原来故去的那些事物，就是故事呀。
我们不会嘲笑自己。就像蚯蚓不畏惧黑暗，企鹅不会因为自己不会飞翔而感到羞耻。这就是生存的意义，不是吗？
因为爱你，只要你一个肯定，我就足够勇敢。
纵然越过死谷，亦不惧怕其祸，因及与我同在。
真正痛苦的事不是不能向人求助,而是没有一个可以求助的人吧。
强忍着泪水却笑着说再见如此伤感。
就算对我抱有敌意的人，也是被某个人所深爱着而降生在这个世界上的。
所谓长大成人，就是不断的聚了散，散了又聚，为了让彼此不会受伤害而保持一个适当的距离！
本以为雨水能冲这悲伤郁闷的心情,如今却发现这雨水打在脸上是如此的令人心烦。
横亘在我们面前的是那沉重的人生和漫长的时间，让人望而却步。
能在无尽的时间洪流中与你相遇这件事，比任何事都更令我坚强。
如果你过的不幸福，我所做的一切才是徒劳。
当思念散尽，剩下的，会是什么呢？
原谅你逃避过去，但是，至少不要逃避现在和明天。
不需要什么明天，握住了的拳不要隐藏。
希望你可以记住我，记住我这样活过，这样在你身边呆过。
谎言一旦说出口，就要负起责任一直说下去。
无论别人说什么，你只要坚持自我就好了。
其实我们中的很多人，终其一生都不会找到真爱，而只会找个人互相饲养一生。
路还长呢，怎么能在这里就停下。
我的愿望是，将一位少女拥入怀中，而拯救世界，只不过是顺带罢了。
当一个胖纸没有什么不好，最起码可以温暖其他的人。
这世界上最靠不住的就是人心！自己的命运，总要把握在自己手里才放心，总不能全部寄托指望于别人的仁慈之心。
我不知道怎么待女孩子好,不过,我会试着去做。
现在回想起来，根本就没什么慌乱的必要。
想要操纵别人，就要利用他心中的黑暗。如果没有黑暗可利用，人为创造一个就行了。
跌跌撞撞的成长，又美又疼才是本质。
今天我在人生的道路上迷路了…
母亲……活着的死人和死去的活人，哪个更可笑？
最好打起精神做好该做的事，不然的话你一生都会后悔的。
变的只是年号，只是交椅上的面孔。
即便梦境再怎么精彩，糟糕的现实依旧不会有任何改变，即便明白你依旧选择了逃避，真可悲。
你说的这些事，我已经想了很多遍了，但是，有些心情是无法用道理讲清的。
原以为年岁增长后立刻就会成为大人。
我们坚强得太无意义，以致着天使不伸手拯救我们就无法逃出这世界。
是鸣人改变了我！是鸣人的笑脸拯救了我！所以，如果是为了保护鸣人，就算死，我也无可畏惧，因为我，最喜欢鸣人了。
少年征战，终将为王。
人是要长大的，有天你也会推着婴儿车幸福地在街上行走，而曾经的喜欢，不管曾经怎样，都会幻化成风，消失在时光的隧道。所以向前走，向前走，无须回头。
正因为生命有限，所以才显得更重要，正因为生命有限，所以才更应该努力不懈。
活在只承认实力的世界，可能的确是布满靳棘。
喜欢跑步的人努力的跑步，是理所当然的；喜欢烹调的人，努力的烹调；喜欢唱歌的人，努力去唱歌；拼命做喜欢的事情，与天生就有才能的人相比，哪里像个傻瓜？
一生一念·一念一人
“不可能”“累”“麻烦”，这三点制约了人类所拥有的无限可能性。
总觉得跟你在一起，不管多高的地方都可以到达。
这就是我的人生啊——像这样继续唱歌，那就是我出生的意义啊！就像我被拯救一般，我也如此去拯救他人。终于，终于，找到了……
没有播种，何来收获；没有辛苦，何来成功；没有磨难，何来荣耀；没有挫折，何来辉煌。
幸好姓郝。
从现在开始，从现在开始一点点努力，然后能成为好一点的人就好了。
这座城市太枯寂，没有回忆没有你。
直到理解之前，都要好好考虑。
不管是多坚硬的金属，无法加工就没有利用价值。
朋友相交，相近而非相融，我也不好事事过问。
不要执着于唯一的方法。
当你决定对那小鬼出手的时候，我们的战斗就开始了。
我已经不想再失去什么了,所以,我不会再战斗了。
就算再难以承受，其实到最后我们总能走得过来。
正因为生命有限，所以才显得更重要；正因为生命有限，所以才更应该努力不懈。
只有感到害怕，人才会开始变得坚强。
女生口中的「好人」首先百分之百是「怎样都好的人」的意思，再好也不过止于「方便好使的人」。
即使起风了，也要好好的活下去！
要我去背叛同伴还不如杀了我。我真的无法想象没有同伴的世界是怎样的
天之锁，被这锁链束缚之人，即使是神也无法挣脱。
神是绝对不会惩罚人类的，只是在玩弄而已。
也有语言相通但互相无法理解的痛苦,重要的不是固执于一种观点,而是接纳对方.
这位小姐，你愿意为我生孩子么？
不认输，不逃避，世上没有不停的雨
他觉得一个人奋斗更轻松自在。跟没有干劲的人在一起厮混，只会徒增压力。
重要的东西全部都在半径米之内。
我在这里学到了很多东西，其中最大得收获就是知道了自己多么愚蠢。
我是一只雁，你是南方云烟。但愿山河宽，相隔只一瞬间。
一定要保护自己的梦想，即使牺牲一切。
暴风雨来临之前抓到王牌就行了。
人生不过是一场旅行，你路过我，我路过你，然后各自向前，各自修行。
只看到了好的一面，不是也有人会看到坏的一面么？
不管多艰辛，多悲伤，都是有不可忘却的事情啊。
我们会跑，无论往哪里都靠自己的腿去跑！
伤口一定会有愈合的一天，所以不要隐藏重要的伤口，有我在你身边。
我们将在这个小小的城镇中相互扶持，共同生活下去。
良好的情绪是世界上最美好的情感
无论身在何处,就算再寂寞,再难受,也别忘了有我一直在这里想着你,所以你绝对不是一个人。
这种无聊至极的破烂音乐哪个时代都存在过，且将继续存在下去，如同月有阴晴圆缺一样。
千金之子，坐不垂堂。
灰心丧气是就用手托着下巴，你会为双手能派上用处而感到高兴。
我也不知道为什么会打网球，发现的时候就每天都在打了，想停也停不下来。
如果注定弱小的话，那么就算是死，也不会有任何改变。
两个人一起翘课啊，真是青春啊。
人类害怕的事情有两个，那就是死亡和耻辱。
久闻上官世家，人品武功二流，卑鄙无耻一流，果然名不虚传，领教了。
如果你自己已经决定，那就已经决定了，如果你自己还没决定，那就还没决定！
用了很久的东西不能要。
人这种东西，除了为了永不满足的欲望追求新的刺激之外，也是重视稀少价值之物的奇怪生物。
事情总是突然的，而理由总是事后面加上去的。
人不管出生的时候还是死亡的时候都是一个人，但是，没有那个人是永远一个人站立的，当自己遇到困难的时候最好要学会低头向别人寻求帮哦。
有些东西只会在你的手中流走，无法把它留住。
即使有千难万险横亘在我面前，我也不会扭曲自己的生存之道！
我李逍遥要做天下第一大侠,我要锄强扶弱,我要名流青史。
有时失败的一瞬，也许是最真实的一刻。
她冷酷，无情！我蛋疼，菊紧！
我想保护这个由人类泪水组成的世界
总有一天都会面目全非，时光没有教会我任何东西，却教会了我不要轻易去相信神话。
那是历史上的那些人的极限，不是我们的
你不能等待别人来安排你的人生，自己想要的，自己争取。
为什么美丽的东西总让人联想到的是死亡而非生命？
总有一天我们学会不再忧伤，因为我们已经像蝴蝶一样，完成了既定的相聚。
领袖式人物的三点特质:英雄式的预言者式的资质，能创建愉快共处的空间的能力，能雄辩所有事物的知性。
事到如今装成受害者才更卑劣
就算你将遗忘其一切，我也会永远记得
愚人节并不是给愚人过的节，而是给说谎的人一个说真话的机会。
我好怀念一心想着打倒眼前敌人的时代。
这是一个考验，来自过去的考验
绝望啦，我对灰色的融冰社会绝望啦！
如果真的有造物主的话，那他确实是把这个星球造得太大了。
我渐渐能意会到，深刻并不等于接近事实。
正因为是好朋友，才要坦诚相待。
简单一句话，我们是伙伴。
化妆是女人的战袍，一旦哭泣妆花了人就变丑了，所以不管遇到什么困难，一定不可以哭。
他们彼此深信 是瞬间迸发的热情让他们相遇。这样的确定是美丽的，但变幻无常更为美丽。
只是活着，悲伤就会逐渐堆积。
管他不会说话还是不会交流，只要不放弃就一定能把意思传达给对方。
我没有气馁，这都是因为你鼓励我的缘故吧。
我终于感到了无比的寂寞
如果约会的人迟到了，会跑着去迎接吧。
生病的父亲将一家屠杀，将市松一个人留在那里，大家都死掉了，市松的心也死掉了，变成了人偶。
固执也未尝不可，不过你在坚守这种信念的过程中，既影响自己的学问研究，又给每天的工作带来困难，最后还不是弄得精疲力竭，吃亏的是你自己。
梦里很多摇晃的绿色光晕，后来渐渐看清楚了，那是一整片巨大而安静的树。
正因为有天空，所以云才能自由的地漂浮。
纯氧对生物有害，毫无保留的真相，只会把人的精神击溃。一比五的氧与氮，才是可供呼吸的空气。同样，呼吸著以戏言稀释的少量真实，人才能维持健全的心。
连时间都忘掉，疯狂地解读着职业漫画家的努力。
每当我看天的时候我就不喜欢在说话，每当我说话的时候却不敢在看天。
不会微笑的少女 固禁在时间的尽头 遗失记忆的残片 随风飘散在金色天空
头发越留越长，试着留住的东西，却没有留住。
春观夜樱，夏望繁星，秋赏明月，冻会初雪。
你的出现其实就是为了我的存在
也许正义并非太阳，而是如同星星一般的东西，天空中有无数的星星，彼此不断抵消着其他星星的光芒
没有牺牲就什么都得不到，为了得到什么东西，就需要付出同等的代价。
“喜欢”并非那么轻易就能说出口的，因为知道虽然只有简单的两个字，却溢出了满满的珍惜。
谢谢你，如果没有这样的你，我将不复存在。
决定人生的瞬间，不能对自己说谎。
很辛苦吧，输个不停的现实。
很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。
世界上有些事，还是让它永远成为谜比较好。
我不喜欢游戏半途而废。
当时总觉得再过两三年，自己就会变成一个很厉害的人物呢。
我能遇到你真是太好了 !
隔壁薯片半价！
第一，审判者无法放弃审判，因为他们就我为此而存在的。
第二，审判者无法经历死亡，因为会变得像人类。
第三，审判者无法知晓感情，因为他们是人偶。
第四，审判者不可贴近生命，因为，他们会坏掉的。
不过我也和你一样是笨蛋，一直在犯错。
成功能带来很多东西，比如，给你带来很多不相关的亲戚。
我是一个性格坏到极点，恬不知耻桀骜不驯，骄傲自大，厚脸皮，虚假，可怜，凄惨，并且最喜欢你的女孩子
第一次见面，绝对不可以以貌取人，应该等她卸完妆。
每一次相聚都将是一场离别的盛宴。
觉得自己可怜而哭,是小孩子的泪水,就像在希望有谁能为自己做什么.
当面对两难的抉择时，不妨丢一枚硬币吧，并非是要靠那二分之一的机运来帮你做出抉择！而是因为当硬币被抛上空中，开始旋转的那一瞬间你会突然明白，自己想要的！
人必将诞生，终将死去。
在我们的眼中没有太阳，一直都是夜晚，但却不暗淡，因为有能代替太阳的东西。
和他相遇的瞬间，我的人生改变了。所看，所听，所感 我的风景全部都变得色彩斑斓了，世界变得熠熠生辉。
这样啊，这就是……恋爱啊。
流动的水没有形状，漂流的风找不到踪迹，任何案件的推理都取决于心……
那些事情取决于你本人为此付出多少努力不是吗？跟上天祈求做什么？
虽然这个世上有很多不可思议之事，但不管多么古怪、多么稀奇的事，只要没有人在，只要没有人看见，只要与人无关的话——就只不过是“现象”瞬间即逝的事。人才是这个世界上最不可思议的事物。
应该如何生存下去，她心中有坚定的信念，那就像深埋在地底的岩石一样坚固，绝不会动摇。
生命如果心都萎缩了的话，那残留下来的就只有即将消失的命了。
一旦分隔两地就不配叫朋友，只能算是旧识。和自己的人生不再有瓜葛的通过点，记忆中的陈旧标签。明明都知道，却假装没这回事。
世界本来就不是为了我一个人而转的，但是，你是为了我而存在的，不是吗？
每个人都有跟别人有关、共有某种东西。所以无法自由，正因如此，所以才有趣、才悲伤……才令人怜爱。
让我们不要把过去的不幸重压在我们的记忆上。
出生一事并无任何罪恶，因此，就算是生出恶魔，也要给予诞生的祝福。
我和喜欢我朋友的女孩，像要隐没于银色月光下一般，两人独处在音乐室，就好像这片夜色中，只有我们两人一般。
世界是美丽的 就算充满悲伤和泪水，也请睁开你的双眼，去做你想要做的事情 成为你想要成为的人，去找到你的朋友。不必焦躁，慢慢地去长大。
按照自己的选择来生活，是送给自己最好的礼物。
我一直陪在您身边白日与夜，砂糖与盐圣者与尸骸，污秽与纯洁我是您忠诚的仆人.
活着是没有意义的,但是只有活下去才可能发现有乐趣的事,就像你发现了这朵花,而我发现了你一样。
我喝着一杯不凉不暖的酒，爱着一个不太爱我的人。
如果想得太消极，本该顺利的事情，有时候也会变得不顺呢。
滑头鬼是映于镜里之花 浮与水中之月。
总在不停寻觅你的踪影，无论十字路口抑或梦境之中，明知你不在，却依然不停地找寻。
我也是第一次为自己的电影流泪，送给倾尽全力生活的人。
我的眼泪留了下来，灌溉了下面柔软的小草，不知道来年，会不会开出一地的记忆和忧愁。
你流泪，这世界开始下雨。你伤心，乌云也会遮住太阳。你哭泣，大地也蕴满哀愁！
虽然路不同，但目的地是相同的，不管哪条路， 都不好走。
时光终有一天会将我们分开，但是，即使如此，在那日降临之前，让我们一直在一起吧。
失去故土的花朵，回不去，却也离不开。
现在这个身体、灵魂，甚至每一根头发都是主人的。只要契约还在继续，就必须服从他的命令，这是执事的美学。
迷恋着你，我已经失去自我！
到底要被救多少次，才会甘心啊！？
但不论何时，都会有一根纽带将我们紧密相连：一定要手刃凶手！
我们的身影，背对背着消失在十字街口，沉浸在茫茫人海。
愈是飞扬跋扈地高喊自己没错的人，心中愈是怀著恐惧，不想让人发现。
答应我，无论如何，你一定要比我长寿，我不要再一个人孤零零的活在这个世上。
我经常怀念童年，它经久耐用，质量良好。
如果没有航向，来自任何方向的风都不是顺风。
他偷走了非常贵重的东西，那就是你的心。
人类很脆弱，转瞬，即逝，再度眼睁睁地送终，真的很痛苦，我们的时间，跟人的寿命比起来，流逝得太缓慢，一个人活着又太漫长。我希望，像现在这样的日子，能够一直持续下去就好了。
有空的时候可以来本王这里，本王的新装交给你来也不是不可以。
我死之后，管它洪水滔天！
天生我材必有用，不如兵长一米六。
用卑鄙手法欺骗对手,到底有什么益处?
当生活给你一百个理由哭泣时，你就拿出一千个理由笑给它看。
河川，激流逆流顺流回流，犹如人生前后进退往复不息。
你知道白夜吗？明明是夜晚却有太阳，照得夜晚像白昼一样明亮，就是说一直这么犹豫不前的话，人生就毁了。
逆境不是，可以令人燃烧起来吗?
所谓的王，乃最贪婪，最豪爽，最易怒之人。且清且浊，追求极致人生。为臣者，因之而仰慕，追随其左右。因此，臣民才会有称王之志，追寻自己的理想。
在虚构的故事当中追求真实感的人脑袋一定有问题.
不觉得残忍就没必要同情
我是想被包养，但不会接受施舍。
与其去怀疑别人，不如去相信别人。
这个世界上确实有很多事情，不管你多么努力都实现不了，正因如此，必须努力的时候绝对不能踌躇。
我们每天度过的称之为日常的生活，其实是一个个奇迹的连续也说不定。
您才是我的王，我发誓为您所用，为您而终。
现在的我能明白，只要有想见的人，就不再是孤单一人。
虽然许多话涌上心头，但是无论哪句都显得过于做作。
能者深藏不露。
人看不到现实的本来面目。只能看到想看的、想拥有的现实。
大家都是带着各自的过去，生活在各自的现在，并且打算着各自的未来。
虽然有战斗的意志但根本不够看呢。
像你这么糟糕的女友，也就想我这么糟糕的男友配的上吧！
人就是切断了母亲和自己的联系，才能诞生在这个世上。
只有自己能够挺起胸膛，明白自己到底是怎样的人以后，我，才能够得出答案。
他喜欢装成小丑，逗笑这个世界，更喜欢世界回头以小丑的方式逗笑他。
只要抬头仰望仍看的见夜空中闪烁的星光，那清澈的光辉必定会驻留在我们心中，给予我们持续朝目的地前进的勇气与力量。
你受伤的时候，我永远都在。
绝不能和梦中的人说话,那是与黑暗的国度对话。
从今天开始，我只想好的事情，只做自己开心的事。我要吸引好多好事、奇迹在我身上发生。我是乐观的，从今天开始，我已有乐观的人生。
我曾发誓要保护他，成为他的剑，即使没有契约，这份誓约也不会改变。
在未知的未来将要发生的事，一定有它的意义
我不论何时，都是只会为自己活着的人。
那天，我听到了种子破土的声音，又细微又坚定。
很多人没有意识到自己正处于麦比乌斯环上继续着单恋。
因心怀珍宝，生活应该日渐月染。
COLL的男人是绝对不会花心的！
一旦开始在乎什么，就会变得很辛苦。
琴声悠扬，美丽的蝴蝶翩翩起舞；一曲终了，背叛的阴影如蛇蔓延。
彼此相爱的人，却无法在一起，希望手牵手在太阳下散步，即便付出了那么多人的生命，最后还是办不到。
烟花绚烂绽放，一瞬即是一世。守护之心坚定，千年亦在咫尺。
你不用寻死，因为血溅出来，收拾起来更麻烦。
我要成立美少女后宫！
就算被罪恶污染，也有光对我的裁制
不管对什么事情都不能有先入为主的观念
世上根本没有运气 ，所谓的运气不过就是情况与情况的结合。
完全无法预料接下来发生的事情，所以才有趣，这就是棒球啊。
我们奢望完美的爱情，就像期待一双限量版的高跟鞋，只是常常会忘记，再珍贵的限量版也可能不是唯一。
睡觉可以没有床，饭也可以吃不饱，但我不想低头的时候，是绝对不会低头的。
我们只能在漫长的黑暗里，安静孕育着短暂而灿烂的开放时刻。
你不在的世界里，我无法找到任何意义
之所以会羡慕别人，是因为看到别人背上的梅干。
只要重要的人在身边，两个人在一起，就足够了。
那只萤火虫在很长很长的时间里都是独自一人生活，甚至忘了自己是只萤火虫。
最暗的夜，才能看见最美的星光，人生也是如此。
白啊，有人说人是能改变的，真是那样吗
不管身在何方，我都不会忘记你们。并且，痛苦的回忆会成为明天的粮食，使我们变得坚强。人类拥有这种力量，坚强的迈出步伐，我也会坚定的继续前行。
太阳如此伟大，使众人感到温暖，为何又如此刺眼，使人无法靠近。
即使有千万个哥哥，即便把他们所有的爱都汇集到一起，也比不上我一个人的爱。
我的回答之所以发挥了作用，原因不是别的，是因为他们自己很努力。如果自己不想积极认真地生活，不管得到什么样的回答都没用。
就像所有的游戏都有结局一样 ,故事也有结局
既然生在世界上，就希望自己能够留名于后世，做一些别人做不到的事。
想象力足以改变一切。
瞬间的犹豫可是会丧命的，所以我决不会犹豫。
这段无法倒退的时光，却教会了我它的含义。
只要你现在是有勇气承认的话, 你就一定可以保护身边的所有人和物, 因为你体内有无比的勇气。
最近的烦恼是小小的离别带来的寂寞，一瞬间的邂逅与分别，这一个一个的刹那，我想好好珍惜起来。
你安心地睡吧，就算你将遗忘一切，我也会永远记得。我将为你而生、为你而死。
记忆或会消失，但我的心会记着承诺。
不想死的话，就在这上面留下一个证明。
往事依旧，物是全非。
这个城市整体也跟个玩具没两样。
是回到那无聊的现实中！还是和我一起改变那现实！
世界上不存在误解，无非看法相左。
光芒总会暗淡，星辰也终将陨落，但是在暗淡的光芒背后，定将是更夺目的星光！
已经不想再回到起点了，不想再失去重要的朋友，这本笔记对我来说很重要。
男人的香烟如同女人的口红，有时用来制造幻想，有时用来掩饰寂寞。
一个人就足够了。去寻找属于你自己的独一无二吧。
一点也好，我希望能让你再多知道一点，我期盼着和你在一起的心意。但现在我并不因为和你在一起时间的短暂而感到后悔，因为即使在这寒冬时代，和你一起度过的时光却一点也不虚假。
渐渐知道了洸的事情，洸讨厌芹菜，喜欢猫，只是嘴不饶人，其实很温柔。
这世上没有奇迹，有的是偶然和必然，还有谁做了什么而已！
我快要死了，但是，还能成为你的眼睛继续看到未来，你愿意成为我的眼睛，让我相信有未来吗？
如果基拉被抓住了，那他就是邪恶，如果基拉统治了世界，那他就是正义。
你越来越善解人意，就没人在意你的委屈和计较。
有些时候，当你说你赢了的时候，你就已经输了。
不管什么时候我都会一直等下去
我喜欢樱花，可不知为什么，凋零时反而会有如释重负的感觉。
没有人是傻瓜，只是有时候，我们选择装傻来感受那一点点叫做幸福的东西。
获得成功的人，肯定在人生某个阶段做出了一个重大的决断。
愚蠢的弟弟呀，逃吧，不断地逃吧，带着憎恶，带着仇恨。
如果不好好回头正视自己走过的路，只会迷惘不知去往那。
不过只要身为人类，每个人都能体会被神遗弃的感觉。
你还是老样子啊，事情总是往坏处想。
女人因秘密而美丽。
请不要一厢情愿地下结论。任何事情，不挑战一下是不知道结果的，对吧？
其实……根本就没有什么天堂和地狱吧……
虽说只是虚伪的正义，但力量还是值得称赞的。
你要明白，你爱的不是那段时光，不是那个念念不忘的人，不是那段经历，你爱的只是当年那个羽翼未丰但依然执迷不悔的自己。
已经无法回来的东西，得到和舍弃都很痛苦。
如果你是魔女，我只要化身魔王就可以了。
世界混沌不堪，毫无条理，没有任何意义，注意到了这点却不想承认的人，从他们诚恳的祈求中萌发出了愿望，宛如希望世界变得有趣一点的愿望，这就是都市传说。
回来的时候第一个呼喊的一定是你的名字。
对你，我有隐瞒，但不会欺骗。
狐妖啊，不管男人还是女人，当看到朋友有难的时候就应该出手相助，这才是人之常情啊。
就算是平淡的人生道路，大家也是一边做着各种决定，一边带着不安前行的吧。
追寻天空，渡过天空，想确认自己不是孤单一人，想知道流云去向何方，于是我持续许愿。
可我要怎样做，才能带着现在这不安的情绪，重新走到故事里描绘的我们那幸福的日子里去呢？
他们并非那么有型，他们只是顽强地生存下去而已。
如果我说我来自未来，你会笑我吗？
我一直都是一个人，脑袋空空的，觉得人生就是随波逐流地度过。
雾可以阻挡天空的视线，却不能锁住天空前进的脚步。
幽深之林乃迷惘之林。美丽乃污秽，污秽即美丽。
人生总有许多意，握在手里的风筝，也会突然断了线。
被大家所依赖的人，在自己受伤的时候往往只能独自面对痛苦。
一个人对自己动机的诚实程度，决定着一个人是虚伪还是真诚。
好女孩的朋友不一定都是好女孩哦，有可能因为她人太好才会“被交朋友”。
如果能不长大就好了啊 可是时光在身后挡住退路
如果不是天才的话，成为漫画家需要三个条件。
想打的话就握紧你的拳头，不想打的话就别挡路啊，别用这种半吊子的态度来践踏别人的决心啊！
不断累积就能创造属于自己的必杀技。
每一个生命都是美丽的。再小的花也不会拒绝开放。
人生，就像肥皂泡一样。风一吹就呼呼的飞上了天，注意到的时候，却啪地一下消失了。就在即将破裂的瞬间，想要自己飞得更高。但回过神来的时候，却总是来不及。
不曾得到，谈何放下。既已得到，又如何放下。
世上没有偶然，有的只是必然。
我是傻瓜，但是如果不能相信人，我宁愿当傻瓜。
相互的不理解总有发生摩擦的一天。
要抹去懊悔，终究只有继续不断努力。
隐约雷鸣 阴霾天空 即使天无雨 我亦留此地
青春，青色之春，乘风驰骋，在内心中像暴风般席卷而过。
别把意气用事和同伴放到天平上去衡量。
好吃的东西就是要一起分享才会觉得更美味！
虽然结局很悲惨，但只要过程中没有半点瑕疵，就根本没有必要去奢求。
世界有多大？你走到哪里，世界就有多大。
你认真起来的那一瞬间，真的有点像路边贴膜的。
有一种沉默不叫无言以对，叫懒得理你。
对别人抱有期待，只能让自己受伤。
这所谓的人世间，为什么总是天不从人愿呢？
不是为了保护自己，而是为了保护自己的灵魂。
也许生存在世间的人们都只是在等待一种偶遇，一种适时的相遇，时间对了，你们便会遇上。
也许道歉根本不重要，我只是想再见你一面而已，黑猫。
为什么我明明什么坏事都没有做，却要被那样看待？
如草之兰，如玉之瑾，匪曰熏琢，成此芳绚。
虽然谦虚是种美德，可千万不要贬低自己，这是你的坏习惯。
已经没有什么好怕的了。
你苍白了我的等待，讽刺了我的执着。
幸运并不是别人给予的，只有自己创造的才叫真正的幸运。
任何人都可以变得狠毒，只要你经历过嫉妒。
不要欺骗自己最喜欢的东西。
手机这东西是一种能够加速人的孤独化的设备。
我们为了保护自己而战，如果不战斗就无法保护的话，那就只有战斗了！
人活着最重要的事情，最大的价值就是恋爱。
人如其名，小巧玲珑，娇蛮可爱。
像花那样的娇弱而不坚强，即使能够保持着外表躲避风雨，却依然恋着阳光。而且也会枯萎，暴风雨来临时无论多么华丽的外表都无法遮挡。
你买过的最贵动漫周边是什么？答曰：海尔冰箱。
每种首创事业的成功，最要紧的还是所有当事人的基本训练。
当你注视着黑暗的时候,黑暗也在注视着你.
历经漫漫岁月，两人一起思考吧，时间即负重，我做如是想。御狐神给予我的时间。今后我也会多次回想起，这漫漫时光里的故事。两人共同编织出的漫漫时光。
奇迹只会降临在不言放弃的人身上，不要小看奇迹！
等价交换啊！我把我的人生给你一半，你的人生也给我一半吧！
如果时光可以倒流 我还是会选择认识你 虽然会伤痕累累 但是心中的温暖记忆是谁都无法给与的 谢谢你来过我的世界
我可以陪在你身边吗？永远永远，陪在你身边好吗？
这个世界上，充满了许多我们不知道的生物。
不管对什么事情都不能有先入为主的观念。
无论最终的结果是什么，只要这是自己选择的道路。
不管有多痛多受伤，真正受伤的人一定不是你自己。
那些坚定决心的人们，会展现出好脸色。
氛围和气氛是无法违抗的，人只能被迫采取违背本意的行动。
所谓世界，是指活着的人们。
烦恼着迷惑着痛苦着，而最后得到的答案却简单到让我不禁想笑出来。
不管是好人还是坏人，能活到最后的就是有毅力的人。
长大后，这个社会教会了我，没心没肺，没感觉，不痒不疼，不在乎。
当然是不会原谅你了，要杀我就得彻底杀死，未来永远，我都不允许你死。
曾经发生过的事情不可能忘记，只不过是想不起而已。
一朵花坠落的速度 , 连时间都放慢了脚步.
竟敢愚弄本王，你以为这是新年福袋吗？！
人类总是惧怕未知事物，因为恐惧，就要想办法消灭它。所以无论性别认同障碍这个词被关注到什么程度，也无法改变什么。
仅只一次，万般怜爱。
如果自己说着做不到，而什么都不去做的话，那就更是什么都做不到，什么都不会改变！
那你那个要照顾她一生的承诺呢?
在面对这些强敌之前…一定要先将眼前敌人逐个打败吧。
你的所言所行，全部闪耀着光芒，太过刺目，于是我闭上双眼，但内心还是无法停止对你的憧憬。
我也许能再一次找到活着的目的，也许能再一次找到活着的意义，为了那些人，奉献出我的人生的话……
未来的事情，谁也不知道。正因为如此，就如同再次相见本身，未来才有无限的可能
注意到失去的东西，为什么……总是……在失去之后才能注意到呢？
人工的星空，不知何时变成了真实的星空。
不管什么事，只要是认真想做的人，就是大家最值得信赖的人。
单纯的死亡不会让人从这个世界消失，当被活着的人忘记时，人才算真正死亡
犹豫不决的人闪边去，不要说什么为了谁，那只是软弱的人乱找的借口，重要的是你想怎么样。
就是因为这种种经历, 我才会才能成为我要成为的那个我, 感谢磨难.
把该尽的责任都尽完，才能叫真正的结束。
等某天，雨水停歇，泪水滴落，就在土地上扎根吧，在那之前就和雨一同如浮云般流浪。
存在本身就是如同都市传说……梦幻般的大钞。
可能我不是最强的一个，但我一定是最努力的一个！
不相信自己的人 连努力的价值都没有。
隐藏真相很痛苦，就算怀着秘密抓住了幸福，想必也不会有真正的幸福感受。肯定会终生抱着自负的念头，没有片刻得到安宁。
现实中，有人幸福，就必定有人被抛弃，有人光鲜，就必须有人满身泥泞。
是为了在哪天回想起来的时候，对于一起经历过的同伴们来说，能成为相同温度的，快乐的回忆。
终点不知道什么时候到……在到终点前会持续下去……
确信自己喜欢的人能好好地活着，即使面对死亡，也看到了未来。
我不是死肥猪！我只是比较丰满而已！
不会游泳就乖乖不要动，自然就会浮起来了。可是对著快溺死的人来说，是想不到这些的。
自由分组什么的最讨厌了！
世界不完美 所以才显得美丽
即使相处的时间不多，但所谓的友情是不在乎相处的时间长短的。
被知道名字，就等于被对方掌握了灵魂的一部分，被知道了生日，就等于是被知道了过去的经历和未来的前程。
无意义的理想,迟早会在现实面前崩溃。
人力虽然微渺，可是人的相争之心，却比任何东西都要可怕。
我要写出只属于半田清舟的字。
即使匍匐在地，也要持续前进，这才是你的作风。现在的你只靠一些漂亮话当借口，在高墙前使性子，不过是个小鬼罢了。
绝情的话语犹如利剑，刺向心口，纠缠的记忆宛若梦境，脆弱易碎。
在我的眼睑里，还有第二层眼睑。我闭上眼睛，能看到光河流动的耀眼光芒。可是，我想念黑暗。
能与她在秋天里相会真是太好了。
对不起，让你久等了。
我是影子，但是光越强，影子就越浓，更加衬托出光的闪亮。
对于凌驾命运之上的人来说，信心是命运的主宰。
我一点也不好吃，瘦小又贫胸，而且也单薄，身体测评也是班级里最差的那个呢.所以，请留下我的清白之身，两年后.我会变得更好吃的。
年轻人，要看清自己，看清世界，才能变得更强
看遍天下美景,尝遍天下美味。
看吧，星星只有在夜里才璀璨夺目啊。
我能遇到你真是太好了!
身为冒险者，如果安静的老死在床上，那简直就是耻辱！
王位的正统性并不在于血统，只能靠统治的正确来保证。
物转星移，花开花落，周而复始，生生不息，但今昔已非昨日，然今日花容依旧。
天明明是这么的蓝，前途却是一片黑暗。
我的生活就像在白夜里行走。
无论你遇见谁，他都是在你生命中该出现的人。
每次你离开，我都想拨开人海去见你。春天也想见你，秋天也想见你，冬天也想见你。有一天，我会在你不知道的地方死去。 和每一个循环往复却飞快终焉的夏天。
别否定自己，通过认同自身，你才会变得更强
自己的归宿自己来决定
勇气这个词是形容人挺身而出的正义字眼，不能用来当作杀人的理由。
如果十多年的单恋有了结果，一定很幸福。他们两人现在可是一条心。如果他们过得幸福，我们当年玩球也就有了意义。
如果你没有水分，就从我的枝头汲取，如果你失去了养料，就从我的茎脉上摄足。如果你开花不结果，我愿为你招蜂引蝶
人不是十全十美的，所以，一个人因为遭遇失败，才会拥有从那里再站起来的强悍！
我是不会输给昨天的我的！
虽然可能赢不了，但是绝对不可以放弃，到最后一刻都要尽力而为！
我希望成为的幸福，仅仅为此我会在你身边。
我想在这里改变我自己。
月亮跑到哪儿去了？我和里香的月亮跑到哪儿去了？
原来，天底下有这么多事，我都没办法做到，不是所有事情，尽全力去做就会好的…………
无论何时总是相信着自己的孩子，这就是父母啊。
迷失于黑暗中的可悲身影，伤害鄙视他人，沉溺于罪恶的孽魂。来死一次吧！
带上信仰,去寻找属于你自己的国吧！哪怕倾尽一生。
而我，也跟着笑了。
站起来，站起来啊，给我站起来啊！
我的前面是聪明的敌人，后面是无能的同伴，我必须同时与这两者搏斗。而且我自己也不是众望所归的目标。
我就是光，不必凭借谁发光。
我还以为是春天的关系，你的轮廓一直在，沙沙地抖动着。
世界上所有的事都是有意义的。
我不听话的时候，在你责备我之前，能不能想一下自己对我做了什么。
那个男人如果舍弃自己的生命而拔剑的话，你和卡珊都根本无法还手，他正就是拯救了这个世界的杀死始祖的英雄。
人生最重要的是时机，时机对了，凡事都有可能。
大而骨节分明的手，是钢琴家的手呢。
青春不能回头，所以青春没有终点。
人类才是这个世界上最神秘有不可思议的生物。
只要抗争下去就能带来奇迹，这是恐怖分子的教诲，给我记清楚了。
隐藏的是心中的秘密，照耀两人的是star和snow……
命运是任何人也无法改变的，但他可以决定是等死还是面对。
无论你如何渴望过去，那里都没有你的未来啊！
山高路远，你好走，我不送。
只要知道你还活在这个世上，我就可以了无牵挂。
与恶魔最接近的东西，是人类。
成不了药就成为毒，不然你只是普通的水而已。
王本就是民献给国的祭品，领受民之膏血，是为以王之牺牲换取国之昌盛。
人类最强烈的感情就是憎恨！
等到那时候，我已经把你大卸八块了。
人们以为，最伤心的回忆来自痛苦的经历，其实最伤心的回忆莫过于，那些无法再现的幸福的经历。
能够改变一个人的，就只有邂逅而已。
从进入厨房的瞬间开始，你们就肩负着烹饪美食的责任。
因为难为情而哭泣的内心，是很美丽的。
能与她在夏天里相会真是太好了。
奔跑吧，怀抱着重要的东西。
我房间里堆满了情人节礼物， 我不是高富帅， 我只是个懒惰的快递员。
我想笑着送你走，可是眼泪却流个不停。
不知道该做什么，所以即使是知道了也没用的事情还是想知道，心里总是很焦急、很焦急，焦急得不得了。
这里有与图书馆无异的大量书籍，大量知识。但是，这里，没有你。
坚强不是结果，是朝某个目标努力的过程！
有一朵花忽略了季节的月季，天真得哼着歌白色的花儿翩然降临在一个属于他们的秘密基地。
放弃未来对我们来说这还太早了点， 幸福的未来一定是在永不放弃的前方！
听说旅行的意义就是逃离，逃离的不是一座城，而是一段记忆。
永远无法从梦境中清醒和永远无法做梦，你觉得那个更不幸？但是，被认为是永远的梦境，或是现实，终究会结束的呢。
这对你来说，也许是最糟糕的结果了。
翼，唯有飞翔才能成长；拳，唯有战斗才能坚强；心，经历了抉择，忘却了迷茫
踏上战场的人都是为了自己的正义而置敌人于死地，敌人也一样。
你必须了解的是，无论它们离得多近，它们并没有融合在一起而形成一个新的事物。
都已经等了他十年，无所谓再等上十年。
什么叫喜欢一个人，就是你在看星座的时候，总是顺便把他的也一起看了。
当我们还是个孩子的时候，就可以很勇敢，无论将怎样被伤害，都不会感到害怕，因为那时候的我们，不知道痛到底是一种怎样的感觉。
比起不做而后悔，不如做了再后悔。
，是一切的开始
成长就是你将哭声调成静音的过程。
守住一方平安，尽力而为，问心无愧就好。
每个女孩心里都有一片萤火之森，那里住着一个少年。
我拒绝。我的蔷薇圣母，还没有被玷污到一定要交给一个垃圾。
少罗嗦，你还不如虫子呢!
或许人们所说的幸福 正是自己刚刚领悟的瞬间 用这份感动铭刻下自己崭新的一页。
我不会为了你的离开而准备，绝对不会。
我一定是为了与你相逢而来的
啊啦啊啦，原来是你。还以为公园长椅上被谁扔了一条死狗的尸体，原来，是阿良良木同学啊
或许人和人之间的缘分，都是注定的。
悲伤中产生的是温柔，愤怒中产生的是力量，但是憎恨中产生的东西，通常都是愚昧。
“不能逃避”什么的只是强者的思考方式，强求这种事情的世界才是有问题的。
抱着必死的决心去做吧！
生活坏到一定程度就会好起来，因为它无法更坏。
我也不懂，我怎么会，如此的在意。
有形的事物总有一天会消亡不代表有形的事物毫无价值。
养狗用饲料，养人用金钱！养我斋藤一，谁也不可能！
只要有人肯相信我,我就会继续保护自己。
时间过得越久，人心的距离就越远。
从一个城市到另一个城市，只有靠自己努力。
欣赏夏日雨后的天空，在花园里为你摘下一朵小花。穿过小径，那里是另外一个世界，蝴蝶在空中飞舞，然而有人在那里等我吗？
当你决定了要向前迈进的那一刻, 你就已经踏出前进的一步了。
是不是就算解散已经近在眼前，一起演出时还是能找回过去的感觉呢？
咱家是猫。名字嘛……还没有。
不要以为爸爸说的都是正确的。
怀着理想溺死在现实中吧！
一过岁，不就是老女人了嘛！
今天的失败将会化作明天的胜利。
轮廓和外表并不是问题，关键的是灵魂！
人很弱小，因此有时会舍弃矜持放任自行。
不管你去哪，哪怕是天涯海角我都能把你找到的
没有值得不值得，只有愿意不愿意。
心存善意，定能途遇天使。
这算什么，不是说好玩捉迷藏吗？
如果感到迷惑的话，先巴手伸长些，那样的话可以某种程度的触及到。
其实越是简单的东西，我们却往往反而无法深刻的解答，我们的认识只停留在表面的了解上！
知冷知热的，才是心；相守相望的，才是眼；不离不弃的，才是情；一生一世的，才是爱。
不抵抗就不会死，为什么就是不明白！？
感情这种东西，并不是用数字来衡量的，再怎么异常，再怎么矛盾，如果说这就是真心的话，那也没办法。顺从真心吧，坦率面对现在的自己吧
把你所有的心事都告诉我,我虽然不会说，但我听得懂。
在梦里 我长成了一棵大树，有着长长的等待淡淡的欢心和浅浅的失落。
在记忆深处里，自己，早已经不存在了。
没错，不管是谁都是如此。
不是已经告别这个世界，不再回头了吗？
向着这污秽不堪丑陋不堪的世界中所相遇的奇迹致谢
但愿所有的负担都将变成礼物，所受的苦都能照亮未来迷茫的路。
没有任何回忆，即使遗忘也好的。
你曾经是谁的英雄呢？
下定决心，即意味着寄托自己的命运与此之上。
当你感到恐惧而躲起来，世界就会变得越来越小。
对于欺负别人的人不要想着去报复他，而是勇敢的去面对！
利己主义，自我中心，有什么不对？
正因为是最弱，所以才理解智慧之强。
唯有你愿意去相信，才能得到你想相信的。
我爱他，深深爱著他。原本一无所有的我，只要这样就已经非常的幸福了。
我们只能走在幻夜的路上，即使四周明亮如白昼，那也仅是假象。
能轻松地说出“我在努力”这种话，就是还在放纵自己的证据，这样根本不能算是在努力。
这下子就有戏看了。
就算被打得遍体鳞伤，内心也不会简单屈服。
适度的恐怖会是人生的香辛料，像是吊桥会成为回忆一样，人心奇妙而不可思议
或许这么做是错的，但是这是我所做出的选择啊。
就算我是笨蛋好了，不管怎么说也是努力去做才比较好。
巡礼者们朝着心中描绘的圣地，继续前进着。
教练，我想打篮球！
有个人我想让她幸福，但是，那个人真的得到幸福的话，在这个世界上就没有人在需要我了，没有人会再叫我的名字了。
我们现在看到的这些星星可能只是一个幻象，世界上从来就没有过永远，即使最美的星。
你就这么憎恨我吗，挚友啊……即使变成这副模样也恨著我吗，湖之骑士！
那是个温暖的时空，没有战争，没有饥饿，也没有冷暖人情，只有点点萤火虫映衬着节子可爱的脸。
人在保护自己最重要的人时就会变得很强
这里，就是人类最后的阵地。
愚昧总是会先压着真理。
当你无限接近死亡的时候，你才能真正体会生的意义。
明明就在眼前却看不到，明明已随时间走得很远，但疼痛感却异常清晰犹如切肤。
如果有人疼爱我，待在我身边，如果有这么一个人的话……我会想，能出生在这个世界上真是太好了。
生命可以随心所欲，但不能随波逐流。
不管眼前有怎么样的障碍，那也无法阻止我前进的脚步。
凭少数服从多数来解决问题，换言之 就是多数表决，多数表决，甚至能将错误转化为真相的唯一方法。
和他相遇一定是命中注定，如果不是的话，我就不再相信命运了.
刚要成熟，又要老去。时光，好不经用。
车站与车站之间的距离难以置信的远，电车每到一站停留时间难以置信的长
和王位什么的无关，我只为了这位殿下本人而挥剑。
自由不是无法无天，而是遵循自己的规则而活。
尘世光影缭乱，只留一人独醉于心
利益创造正义，正义产生利益。
或许我该祝福你，在经历了漫长的巡礼之后，终于要到达目的地了。
如果自己都说做不到，而什么都不去做的话，那就更是什么都做不到，什么都不会改变，什么都不会结束。
明明喜欢的不得了，可是看到对方幸福洋溢的表情，却觉得很难过、很痛苦，胸口发疼。
为了总有一天会死去的自己，现在要活的没有遗憾。
No game No life
最重要的是当事人的努力。之前为了我的回答会不会让谁不幸而烦恼，真是想想都可笑。
这样不是很好吗？可以忘记一切，远走高飞，逃到一个听不见任何嘘声的，遥远的地方。
对与错，应该由历史来决定。我们能做的，就是相信自己认为是对的事，然后为此战斗……不过我认为那个强者生，弱者死的……弱肉强食时代，绝对是错的！绝对错！
之前我应该也说过，他重视的是逻辑性，感情次之。只要他判断哪个方法对于解决问题有效，他什么事都干得出来。
因为每个人或多或少，背负着不幸来到这个世界上。
与其装点自己的终焉，不如漂亮地活到最后。
没有人能独自解决所有发生在自己眼前的事哦
虽然咱长久以来被尊为神，且被束缚在这块土地上，但咱根本不是什么伟大的神。咱就是咱。咱是赫萝
我也认为对万物抱有敬意是非常重要的,所谓的敬意,也就是不轻视.而对持敬意的对像,想必也包括自己在内.
只能在回忆里看着你，希望记忆中的你不要离我远去。
很多时候，心里明明不是那样想的，却控制不了自己而说出相反的话。
没有罪过的人生也是一种罪过。
何时何地，你都要明白，你是活给自己看的，别把别人的评价看得太重，凡事只要于心无愧，就不必计较太多。
就为了整个孰强孰弱这件事真是让人感叹万分，但你们情报收集方面的无能更是让我惊叹啊。
只顾仰望着星空的人注定不会留意到自己下一步是否会跨入深渊。
现在我会继续奔跑，以远方为目标的话，总有一天，理想也会触手可及。
谣言难过月，过月无人传。不管人们怎么评论，但只要想到这一切终将又被人们遗忘，就不会这么在意。
赌上性命和白白送死是两回事！
因为某事、总把自己当成悲剧的主人公一样不断流泪，就说的过去了么？你呀，看上去就像个白痴一样哭个没完呢，爱哭的可怜虫！
人生是没有正确答案的，也就是说，人生只有错误。
神永远都是一言不发的，并且神的沉默和生死根本无关。
明明不想知道真相，但却还是会忍不住去追寻它，人类的好奇心真是太没道理了。
就算被人背叛，那也只是背叛别人的人变得卑鄙！
谁看见过风？我和你，都不曾看见过。
我再也不要看见她哭的样子了，就算我从此从她心目中消失。
少年就是在妄想中成长的。
我们都是好朋友吧，所以你的东西就是我的东西，我的东西还是我的东西。
人这种生物，太过幸福就会渐渐完全感受不到幸福。
无限接近于零，却又不等于零的可能性。
幻影，就如梦境一般，确实存在于那里。但梦醒之后，就会渐渐从记忆中消逝……
我们这种平凡之人在面对胜负关键时，总需要找寻某种倚靠，但，在比赛中乃是孤独的，无法倚靠任何人，那么，该倚靠什么呢？我想，只有自己曾经努力过的事实。
无论世界多么让我们失望，都不能放弃梦想。如果这个世界变得不太好了，那就让我变的更强，让这个世界变的更好，哪怕只有一点点
今夜我不关心人类，我只想你。
对！错的不是我，是世界！
立华浮于世，奏出天使之章。
因为无理当道，所以正理去死吧！
你看，不倒翁站起来了，大雄也可以自己站起来啊！
在悲剧性的不合理世界，故事开始了。
人与人的邂逅充满了神奇，各种刑案更是迷题重重，能够遇到你真是有缘……
只注意自己的人是无法取得成功的.
为那场初恋所流下的泪水 融进了温暖的大海中。
据说人类从拥有了光明起,就忘记了闭上第二层眼睑的方法。
我不知道离别的滋味是这样凄凉，我不知道说声再见要这么坚强。
这个世上没有无用的齿轮，也只有齿轮本身能决定自己的用途。
在你眼里，我始终不够好，原来，你就是没爱过我而已。
就算昨天吵架，明天也许就能和好不是吗？
如果你遇到了有点不可思议又让你困扰的事，不妨去探一探究竟。
幸运不是寻找出对方的漏洞，造出契机才是真正的幸运。
樱花下落的速度，依旧是秒速五厘米。而不论我们之间通过千条短信，我们之间的距离也不会拉近一厘米……
我不需要朋友，朋友只会削弱身为人类的强度。
我们的距离是这么近，但是我却不了解你的心。
与其伤害别人，我宁愿被伤害。
一想到要和你分别，就算拨开人群，我也想去见你。
就像晚上也有光明一样，就像午间也有黑暗一样，黑暗从未离开世界，同时，世界也从未被黑暗所掩盖，就在这暧昧的颜色之中，接下来的一切依然会在注定命运齿轮中缓缓前行。
每周每次，我们重新认识
没有人可以抵抗命运的轮回。
你是沐浴着阳光的木之叶，而我是埋在黑暗中的根
我不相信任何人，所以也不想被任何人信任，这样子最轻松了。
离去，让事情变得简单，人们变得善良，像个孩子一样，我们重新开始。
神奇的小精灵，是属于我的啦。
他喜欢她，无关爱情。她幸福了，于是他也幸福了。
哈，所谓愿望能靠法宝就实现，也太廉价了吧？
不仅仅是太少，就算说没有也不为过。
很多时候，你骄傲的以为你已经掌控了命运，其实，一直以来，你根本还是被命运掌控着。
我不需要理解！不需要怜悯！不需要原谅！不需要救赎！这就是我！我是个魔鬼！
冲一杯咖啡，并时常小声地哼唱着怀旧歌曲。
就让我用这只手，将你那无聊的幻想杀得片甲不留。
照片上的影像不过是幻像，即使是幻像，也想要将其留下，这就是人可悲的梦想吧。
失败的人只有一种。就是在抵达成功之前放弃的人
这就是我，和中学的同学一个人也没联系过……这不叫reset，叫delete，呵呵。
还有什么比活着更可怕？
也许我们 从来不曾去过，但它一直在那里，总会在那里。
我希望每个人从依然抬起头一事做起。
珍贵的东西，要紧紧的抓住。
淑女只让她心仪的人摸她的头发。
两个人相遇，是小概率的事，两个人相爱，是最美好的事。遇见的都是天意，拥有的都是幸运。
在维护所谓的正义时候，也许我们已经走上了邪恶的道路。
为什么重要的东西总是在察觉到的时候就已失去了。
我终于发觉了自己迷茫的原因。我并不是缺少地图，我缺少的，是目的地。
自己站起来，勇敢往前去。你不是有健全的双腿嘛！
在这个世界里，只要灵魂不灭,就不会死。所以,只要心不认输,就不会输。
我颠倒了整个世界，只为摆正你的倒影。
每次我最痛苦的时候你总是能看透我的心，虽然很不甘心，但是我好高兴
就算一切徒劳无功，就算结果不过如此，我仍然选择我自己认为最好的决定
这个世上每个人的背上都黏了各种形状各种口味的梅干。
孤身一人的在那里徒劳，但结果却总是事与愿违
我们的生命太短，来不及见证那些遥远到令人恍惚的词语，比如天长地久，海角天涯，碧落黄泉，沧海桑田。 所以，要活下去。
我们只要做好现在能做好的事情就行了。
很抱歉，前面是单行道，你就乖乖的夹着尾巴耸拉着脑袋返回原点吧！
那断断续续的嘶哑声音中，满溢着深深的哀愁。
其实只要意气相投，又何必计较身世有别。即便他日因立场不同而刀兵相见，这份情谊还是在的。
当有十个人下决心要完成某事，只要有一个人能完成那个愿望就算很好了。
我们不能让这次冒险之旅没有意义没有收获
今天的风儿有点喧嚣
当夜幕降临，黑暗笼罩全身，在一片漆黑的路上独自前进，也许会感疲惫，也许会感胆怯，只要抬头仰望仍看的见夜空中闪烁的星光。那清澈的光辉必定会驻留在我们心中，给予我们持续朝目的地前进的勇气与力量。
我们总是在注意错过太多，却不注意自己拥有多少。
再见，新一，我们就此永别了，新一，真庆幸我遇到的是你 没能夺取你的大脑，为此才能作为朋友，收获那么多愉快的回忆
努力是不会背叛自己的，虽然梦想会背叛。
这种熟悉的，心痛的感觉……喜欢上一个遥不可及的人，却不喜欢那个卑微的自己……
人生是属于自己的，自己在一生当中会做下许多选择。
已经发生了的事情是命中注定无法改变的，重要的是，不能被悲惨的现实击垮，要坚信自己比能克服这样的悲剧。
我一直在等一个你，希望那天，不早不晚，风景刚好。
齿轮总有卡住的地方,如果勉强让它动起来,最终是要让一切都化为泡影,还是要从头来过,恢复正常,努力追回落后的部分,你只是害怕,害怕从头来过!
大人真可怜，没人能让自己依靠、撒娇和骂自己的人。
葬礼是为活着的人准备的，他们需要一个宣泄伤感的场所。
一边嘲笑着，一边欺骗着自己。
如果我闭上了双眼，看到的是黑暗的话，那么当我睁开眼睛去看这个世界的时候，是否会是一片光明？
妈妈就像是做着离开人世的准备，一天天地消瘦下去，陪在这样的妈妈身边的我有何感想，你一定不懂吧！
对于大海，除了敬畏，你别无选择。
信仰到底是什么呢，就是纵身一跃，就是我们跟神之间一个永远的约定，是舍弃旧的去开始新的生活；信仰就是从今以后，再也不要放开你的手
失望了吗？没错，世上或许有些东西别打开比较好，真正把心打开的人多么麻烦啊！
心存泰安愿，身若逐波萍。生逢乱世，谁得幸免？若只杀一人便能遂愿，那可真是轻松太多了。
升上高中之后，人生的难易度突然提升了，现在应该是进入困难模式。
我不知道流星能飞多久，值不值得追求；我不知道樱花能开多久，值不值得等候。
不是每次相聚都充满欢笑，不是每次分别都眼含泪水，一个人的毕业照，所有人的纪念日。
不请自来而又不告而别的事物，然而即使彼此只交汇过一次，即使微弱得不会被人注意，那也是能够支撑心灵的，重要的邂逅。
越是拼命争扎，我们的处境越是狼狈。
这次我希望能对大家说，你们并不是孤独的，被遗弃的感觉真不好受啊。
不能放弃呀，不放弃的话一定能找到对手的弱点的。
我听到了他的心跳声，温暖得不真实。也许，这只是一个梦吧。
一个故事的阅读方法，绝对不只有一种。只要还有别的登场人物，就会有别的故事存在。
越是美好的梦境越是能将你撕碎。
喜欢你，因为我喜欢你，比世界上的任何一个人都喜欢你。
花是纤弱而短命的，即使维护起来，它们依然因喜恋阳光而枯萎，一旦暴风雨袭来，再金贵的栅栏也保护不了它们。
没有拒绝孵化的蛋，更没有不想盛开的花朵，这不是意志的问题。
青春的羽翼，划破伤痛的记忆；昨日的泪水，激起心中的涟漪。
不能害怕未来，不能讨厌世界。今后的世界不再是我的空想，而且对我们而言唯一的真正的未来。
世界是属于你的，你也将成为世界的一部分，出生于此，就一定有你存在的意义。
看起来像假的，其实却是真的；而看起来像真的，其实却是假的。
小孩子迈向成熟的第一步就是对老师产生不信任感。
那双手那么温暖，呼唤如此真切。然而这颗心本不属于这里，终将远去
在弱者眼里可能是这样，不过，我的确很强。
无论你有多强，也别想着独自背负所有，因为那样一来，你必然失败。
某处的某人说着愚蠢的人类，那些人类当然也包括说话人自己。要是想了解人类的话，只看着人类是远远不够的。必须将注意力放在人类究竟在看什么上，你们在看什么呢？
人类的伟大，莫过于面对恐惧和绝望时的镇定。
我们停留在时光的原处，其实早已被洪流无声地卷走。
有些东西，失去了就不能回来。
人生在世只有一次 不必勉强选择自己不喜欢的路 随性而生或随性而死都没关系 不过 无论选择哪条路 都不要忘记保护自己所珍惜的人。
对于人来说，重要的不是钱也不是地位名誉，而是不留遗憾地坦诚生活。
时间能冲淡痛苦，但是，我并不想用时间来治愈一切.
人还是无法忍受孤独的。
一旦有个留恋，就不算是旅行者了。
寄一份心情给久违的青春，想念那个敢爱敢恨的人，相信忠于感觉会快乐一些，宁可受伤不肯说谎言。
愉快地度过人生的秘诀之一，就是不忘童心。
雨为什么要下呢？如果是晴天就好了。
令人怀念的声音，是在呼唤我吗？
来，跑起来吧，在大家为你们开辟的道路上。
为什么喜欢音乐，因为它能替我表达我的悲伤。
人老的唯一好处就是，少了的东西越来越少了。
凭借不服输的勇气，一口气享受当下吧。
谁告诉你黑暗的尽头是光明，黑暗的尽头只有一块你的小小的葬身之地而已……哀伤之子，注定没有救赎……
抛弃了尊严而生活到现在有意义吗？
许多真实的谎言都是假装欢乐，许多谎言的真实都是无可奈何。
没人会嘲笑竭尽全力的人。
错误不是为了别人才改的过来的，要为了自己而改正。
后悔是一种耗费精神的情绪，后悔是比损失更大的损失，比错误更大的错误，所以不要后悔。
以智者之名，为愚者代辩。
神话之战，由此重现。
这个社会的基本构造就是出人投地，就是因为你的自卑感和优越感取得了相对平衡，所以你才能在这里悠闲地吃着蛋糕
哭也不会改变什么，这个世界从来不会对任何人温柔。
能够为最重视的人出一份力，真的是非常高兴。
什么都不知道，不是好事。我就是因为什么都不知道，才会伤害了人。
有政治抱负和留恋权力是两回事。
也许某天在喧闹的城市中，你我擦肩而过，我会停住脚步，凝望着远去的背影，告诉自己那个人我曾经爱过。
当失去一种东西时，并不会回到没有它的时候。
只要还活着，无论去哪里，争斗都随处可见。
只会躲在后方摇旗呐喊的人，注定不会有追随者。
没有人只属于自己，每个人都与他人相连，与他人分享着某些东西。这就是为什么人始终无法自由，为什么人会有喜悦，悲伤，以及爱。
奇迹不是免费的，如果你祈求了希望，同时也会散播出同等的绝望。世上就是这样互相抵消取得平衡的。
不论是过去还是未来，我都会保护你！
如果我讨厌她，就不会这么烦恼了!
你不过是活出了属于自己的青春而已。
不可原谅明明什么都没做却有所期待的自己。
我并不是什么了不起的人，但是，绝对不允许你诋毁我父亲。
你知道吗？当一个话唠突然沉默的时候是最可怜的时候。
总有那么一个人，藏在心底，消失在生活里。
想再坚强一点，这样有什么不好，即使被敲诈，就算不务正业又怎么，我还能这样笑自己还想再走下去一点，肯定没有到尽头的白天。
再会了，你曾是我，最最重要的那个人。
人类可以通过内心的阴暗面，正视到隐藏在内心的残暴性，从而能培养出制约它们的良知、理性和善意
责难无以成事.
明明只是一具行尸走肉，却编造着，活着的谎言。
我可以不被暗夜的黑、不被光芒的耀眼所迷惑，只捕捉到你的眼眸。
一切都是从那天开始的，年前，失去太阳的那天开始的。
我们是如此的担心着未来会发生的事情，因此忘记了慢下来享受现在。
就算悲伤难抑，遍体鳞伤地处于谷底。也不能停下演奏，只有这样，我们才是真正活着的。
凡事都不能无中生有，实现愿望一定是要有补偿，或者说是付出代价
无论在任何时代，所谓的规则都是由被视为神者所制定的。
我不想回首过去，为什么过去还要追着我不放。
大家不是约好了吗？要一起，活到老爷爷、老奶奶的年纪。在那之前，不是要一直，一直在一起的吗？
改变的东西，一定有其意义。
人生可没有暂停哦。
战争就是这样，双方都认为自己是好的一方。
为什么没有人关注我呢？为什么没有人想念我呢？
我啊，每到周一，就会失去所有快乐的记忆。
好的定理必然有美妙自然又简单的证明。
要是穿着廉价货，人也会跟着廉价了。
与其害怕面对现实还不如享受现状。
就算再不起眼肯定也会遇到好事的
输了不感到悔恨的人，没资格当游戏玩家，不过正因为如此，才会第一次觉得快乐。
战斗不以胜利告终就没有意义！
你能做到的，只要认真去做！
诚如「人是一根有思想的芦苇」所言，我们无时无刻不在思考。
孤灯点亮了寂寞燃烧了孤单，岁月走过了年轮留下了回忆。
就算与你共度的每个夜晚都是幻夜，我也愿为你化身为影，至死不渝！
起风了，必须好好活下去。
再过三年毕业了，我想在这里找工作呢，这样的话我就有更多的时间可以和你在一起了，秋天、冬天、春天、一直都可以呢。
人真的容易和其他人竞争不幸呢。
不用介意了，这种事我已经习惯了。
绝对没问题的！
误解是解不开的。
痛苦，是保持清醒的最好方式。
不管有怎样的烦恼，现在也不过化为了点点无痕。
现实有时会让你窥视到另一个陌生的现实
胜利女神喜欢不放弃的人。
寂寞往往不是来自于孤单，而是来自于话不投机的陪伴。
那些美好的回忆便寂静地躺在那里，被岁月覆盖。飘落后才发现这一地的幸福碎片，要我怎么拣。
空想这种东西用不着力气,把重要的事搁在一边,什么也没做,当然空虚了.
看着大海，在堆积如山的瓦砾中流淌汗水，我才发现，原来我的烦恼如此渺小，因为那种事寻死觅活真是差劲，为自己感到难为情。
人们渴求着永恒赋予的美好，畏惧着时间带来的衰老
自觉是笨蛋的笨蛋——比自以为聪明的笨蛋更为难缠喔
所有受过的伤害，都证明曾经拥有过。
没有变……现在还是喜欢钱。
我不会输给同一个对手第二次。
最终能幸存下来的人，既不是强者也不是智者，而是能适应变化的人。
我们仰望著同一片天空却看著不同的地方。
像你这样的人想要活下去，最好练习吸入二氧化碳，呼出氧气怎么样？
未来之梦已经醒转，喧闹与欢笑描绘出现实，碧蓝眼眸的深处，映照出失落在另一时空的记忆
某些东西，明明知道没有意义，但依然很在意——谁都会有这样的东西。
以前似乎也曾有过类似的心情，但想不起来了，或许自己已经自暴自弃了吧。
失去了翅膀的鸟儿，是不能在名为记忆的蔚蓝天空上飞翔的。但是，我深信，只要自己活着，回忆就会像流逝的时间一样，会有崭新的诞生。
即便是这样的我也能挺起胸膛帮助到别人，如此活下去便是我最大的梦想。
不要想一味的改变现在，这只会让过去变得面目全非罢了。
我浑身伤痛，跋涉万里，疲倦地寻找，只为来与你相见。
我要你快乐，让你的生命充满欢笑，我不知道能为你做些什么，但是，我会永远留在你身边。
现在的你，就是那时的我。
不要同情自己，同情自己是卑劣懦夫干的勾当。
我认为在这世上，有些事必须亲身经历才会理解
逃避有两种：我们把有目的的逃避叫做飞翔，把没有目的的逃避叫做漂浮。
没关系，我有无论再发什么都不会被打扰到的自信。
所谓的英雄，到酒吧去要多少有多少。相反的，在牙医师的治疗台上可一个也没有。
我很清楚自己的无力，但是正因如此，想留在他人身边，希望他人留在自己身边。大家都深知活在世上，能够实现这个愿望，是多么的珍贵。
跟母上大人长聊一番后，发现人民币才是我的生死劫。
不管你遭遇过什么，飞船就是飞船，能做到，只是让想飞的人飞上天而已。
我能遇见你，实乃三生有幸
如果我像玛丽皇后一样化作断头台上的露水的话，它会不会像她的爱犬迪比一样追随我投身于塞纳河里呢？
想要跟她一起死去，借由这个举动，得到所谓的永远，永远属于两个人的世界。
你口中的永恒，究竟牺牲了多少个瞬间？
这是为了培养独自一人，振翅高飞的勇气。
拥有梦想也没有用,如果无法实现,还不如普普通通活着。
不放弃，直到失去那一刻。
一旦失去的东西 就再也拿不回来了
对那时的我来说，你是有多么的重要，你知道吗，我可是几乎和所有男生为敌了啊，做到这个地步都是为了守护和你在一起的场所啊，那时的我只有你啊
有事情是要说出来的，不要等着对方去领悟，因为对方不是你，不知道你想要什么，等到最后只能是伤心和失望，尤其是感情。
你以为只有自己一个人在支撑着这个世界吗？自以为是也要有个限度，不要忘记，不管你身处哪一条世界线，你都不会孤独。无论你身处何方，我都会找到你，我会一直观测着你，就像你一直以来观测着我一样。
我相信，因为是你啊！
他知道过去是改变不了的，但也无法袖手旁观。
每次在我觉得快忘了你的时候。真的就在快要忘了你的时候，你又出现了。
明明想要杀死某种生物，却没有做好被杀死的觉悟，你不觉得这种心态很奇怪吗？所谓的将枪口对准生命，就是这么一回事哟！
原以为只要踏入社会，成家立业，就会与现在的自己不同 ，变得成熟 。
只有在必需时才去做，不必须就不会去做。
胜利女神只会对相信自己一定会获胜永不放弃的人露出微笑。
人，是要靠忘掉回忆才能活下去的。但有些事，是绝对不能忘记的。只要活着，哪里都是天堂。
无论在哪里遇到你，我都会喜欢上你
所谓朋友就是，如果误入歧途就要一起走下去，如果犯了罪就要一起背负，这才是真正的朋友啊！
最终，我们会剩下无穷无际的孤独！
今天我要赢了你，然后把所得到的一切都化为我的血肉，凯旋！
我生而为洛昭言,是无可选择之事。不过,我至少可以选择如何生活!
或许人们所说的幸福，正是自己刚刚领悟的瞬间，用这份感动铭刻下自己崭新的一页。
即使与世界为敌,我也会保护她和她所在的世界。
本来我们应该把记忆注入这些只有形式的东西里去而获得新生的。
向前走就好了，不管等待着你的是什么，即使前面尸横遍野也要勇往直前。
给你一句忠告…世上有些事最好还是让它永远成迷…
好！吃到老，玩到老。
世间遍满巧合。
我们仰望著同一片天空却看著不同的地方
不想理你的人总是很“忙”，在意你的人小时都很“闲”
我其实，根本不把现实世界当一回事。因为我，有我相信的世界存在。
觉得只要认真努力就会胜利，这世上哪有这么天真的事。
蝴蝶小小的心思比叹息更短暂，偶遇和别离比风带落花瓣还简单
不就是打输了，别这么垂头丧气。我们是妖精的尾巴，永不停歇的公会。只要活着就要勇往直前的奔跑去。
女人这种动物，如果不放在身边的话就不知道会跑到哪里去。
不要把感谢和责任混淆在一起。
大概第一次认准的字，和第一眼记住的人一样，很难遗忘，不可撤消。
一旦坠入恋爱，就会不自觉的注意细节。投入在这些事中…竟如此开心。
他的手指触碰到琴键的那瞬间，我的未来就此决定。
离别就像是硬币的正反面，纸质邂逅方才成立，预期为离别惋惜，不如为邂逅喜悦。
痛苦是生活的一部分
既然连死的觉悟都有了，就一定能找到活下去的方法。
我的剑所能触及的地方，就是我的国家。
如果把童年再放映一遍，我们一定会先大笑，然后放声痛哭，最后挂着泪，微笑着睡去。
人不是十全十美的 所以 一个人因为遭遇失败 才会拥有从那里再站起来的强悍 我觉得那种强悍就是真正的强悍 所以我觉得 你是个非常强悍的人。
比起一直躲在初始之街，慢慢腐朽，还不如到最后一刻都保持自身的存在。即便是死在怪兽手上，我也不想对这个游戏，这个世界认输……无论如何也不会!
机会无处不在，我们要相信自己的力量!
所谓正义的动机，多数情况下不过是对恶的嫉妒而已。
什么样的心，怎样的感受，表达力度差距如何巨大的情感，最终都指向同一结局。
不要到处向别人展现你的懦弱，抱怨你的痛处。
无法获得胜利的对决，简直毫无价值。
世上有两样东西不可直视，一是太阳，二是人心。
不断重复的相遇与离别，那些如秘密般沉重的事情，想要说出来的时候，却又因为太过闪耀，而无法顺利地用语言表达出来。
你说你会爱我一辈子，我真傻，居然忘了问是这辈子还是下辈子。
团队不是单个人单个人的守护，而是每个人互相守护，这才叫团队。
即使她的生命短暂，即使结束的哪一天会立刻降临。
活着的时候要尽欢，死的时候才没有遗憾。
我们三人就像流星，毫无目标地飞逝，不知将在何处燃烧殆尽。
谢谢你对我笑，谢谢你和我说话，谢谢你对我好，谢谢你让我体会到许多没有感受过的心情。
平庸这东西犹如白衬衣上的污痕，一旦染上便永远洗不掉，无可挽回。
时间的沙漏沉淀着无法逃离的过往,记忆的双手总是拾起那些明媚的忧伤。
将爱形容为美丽的，是不了解爱的人；将爱形容为丑陋的，是自以为了解爱的人。
讲白一点，你造成我们的困扰了。
把什么都算成自己的错是很傲慢的。
我是不会放弃的，只要能见到亚丝娜就算是神我也要打败他.
只要活在世上，就免不了会遇上分离。
如果说真实是残酷的，谎言绝对是温柔的吧。
就算是自己被淋湿了，也会把伞借给别人吧。
等待，不是为了你能回来，而是找个借口不离开
如果想帮助他人实现愿望，那么首先必须要弄清自己心中的愿望。
当你拥有一个和自己很亲密的人，也可以说，你又多了一个可以指使你的人。
绝对，不再哭泣了。
就这样，那天晚上，我和秋人朝着叔叔的工作室奔去。
最终只会被他和她们当做方便好用的交流素材，快乐的使用着。
以后，不知道那将会是距离现在多远的未来。
自顾自地期待自顾自地误会，我已经不想再来了。
真正的惩罚是会留在心和记忆里面的。
年轻人总是急于求成，就连等待一匙砂糖彻底溶解的耐心也没有，后悔所带来的苦涩，恰好印证了你曾经有所作为，这一点一滴都将成为点缀人生的各种味道。
并不是我想当主角，我就是主角。
当你无法再拥有时，你唯一能做的就是不要再忘记
人哪有好的 只是坏的程度不一样而已。
孤独者不需要跟人分享思考内容，所以能想得更深入。
给自己多一点疼爱，对生活多一点信心，爱每分每秒的自己。
不过真是太可惜了，好女人一定都已经名花有主了。那么，好男人呢？就是在荒野朝西方旅行去啦。
时光流逝，总有一天，一切都将变成回忆。
只要他握着我的心脏，我就不是风，被束缚着命悬他人之手。
我可是水银灯,是沉浸在黑夜之中,背负着逆十字刻痕,蔷薇少女最凶少女啊,这样的我会被爱束缚,很可怜…?
人不是十全十美的，所以，一个人因为遭受失败，才会拥有从那里再站起来的强悍。
祈祷幸福吧，哪怕接下来是何等的悲伤也好。
愿望要靠自己的双手去实现，所以也许会实现不了。
悲观也没用。谁都想生在好人家，可无法选择父母。发给你什么样的牌，你就只能尽量打好它。
那时候的我因为没有力量，所以有借口不去插手。借口说因为我太弱了，所以没有帮上忙。可是现在，我已经失去了借口。
忧伤是嵌在心里不可名状的灼热，不可言说。能说出来的就不叫忧伤了。
我无法抗拒泡面这种没营养又廉价的口感。
死神，应该是安静的夺走人类的灵魂；执事，应该是如影随形的跟着主人；违反这两者的美感的恶趣味，说清楚了，真令我作呕。
我们的本质就是血，一层层地重复，然后世代脉脉相传的血才是黑血的真实。
自以为是永远都是大敌，因为本可看到的东西也会视而不见。
如果没有遇到她，我将会无法前进。
虽然现在还在黑暗中摸索，但是总有一天会重现光明的，一定会的。
无法舍弃两个方中的任何一方，那不是温柔，那不过是软弱罢了。
这个世界里没有什么规则，就算有，那也是由我创造的。
志在高原，梦在争霸，这股热情值得赞赏，可你是否知道，所谓梦！，终究有一天会醒来的
胆敢质疑本王的能力，没办法，明天就开始动真格的！
鹜然雪化，且静候，飞雪再临之时。
自己的过去会被当做笑话或者捏他的形式，被他人随随便便的共有化。
有多少为什么没有答案，有多少动听的承诺没有将来。
我不介意啊 反正所谓人类多多少少都有些不正常
和学校，头衔什么的无关，无论出于清流中还是污泥中，只要激流勇进，鱼就能坚强美丽地成长。
一个个的声音肯定有各自的意义，可无数个一齐聚集起来就无意义了。
这虽然是游戏，但不是闹着玩的。
妈妈是不会忘记养育自己孩子的经历的。
人总是活在矛盾当中，对人类的绝望以及信赖，我们在这夹缝间求生存。
即使再可怕的困境，也只有冲上去才能解决。
虽然也曾情绪低落，但我现在很好。
越是得不到的东西，越加美丽。
人是一种只要想做就一定成功的生物，人只有在说放弃的时候才无论怎么做都不行。
因为没有胜算就放弃抵抗服从于别人，这种事谁也做不到吧，重要是为了什么而战。
只要是抓住了的东西，任何一样都放不开
人说稻荷之神敬畏惶恐，现身之处有所祈愿全得实现。
活着比死去更加艰苦。
无论你多么的喜爱他仅仅是一个转瞬便已逝去，我们只能目送他们的离去，抱着对他们的喜欢的心的悲伤继续努力坚强的活下去。
就算有一天，你们必须踏上各自不同的道路，也绝不会有什么薄情或是寂寞的事，因为一定会有让你能继续下去的事物。
学会忘记，懂得放弃。
失去的在夺回来就好了，不是吗？这么一来就没有人在伤心了。
人与人之间情断义绝，并不需要什么具体理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。
人的眼睛为什么要长在前面，是为了要向前看。
一曲孤雁归巢，道不尽枯草斜阳的落寞；一抹红颜薄笑，舞不出灯火阑珊的终场。
如果没有英雄的话就自己成为英雄好了
与你相遇，我发现自己看到的全是美丽的东西。
我们的生命太短，来不及见证那些遥远到令人恍惚的词语。
是努力还是放弃，这时就轮到他们选择了。
不是这个世界变得有趣了。而是你，变成了有趣的人哦
因为要承认自己的错误是一件很难而可怕的事,因为你不知道承认会带来怎么后果, 所以很多人会选择逃避。
今年的这个夏天，我邂逅了我的命运。
要活下去，总有一天我们能笑着缅怀过去的艰辛
在喜欢上你的时候，已经踏上了旅程
因为等待的越久，重逢时就越幸福啊。
有些真相注定是要小心翼翼深埋心底的，因为答案揭晓的那一刻，也是灰飞烟灭的开始。
不要掺杂自己莫名其妙的主观臆断，你只要阐述事实，否则就会看不到真相。
不服气的话就证明自己不是笨蛋，到时候你说不定会得到自己想要的东西
人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完。
身旁的体温 既温暖又悲伤的安全感
每天清晨的第一道曙光，可以神奇地治愈昨日的伤痛。
所谓的正义，还许並不像太阳，而是像星星一般…天空中有著无数繁星，相互掩盖彼此的星光…我们都认为自己才是正确的…
我是绝对的开始的王，英雄中的英雄王，吉尔伽美什。
有时，爱也是种伤害，善良的人，总是选择伤害自己。
人家明明在和我说重要的事情，我却把它弄没了。
那些青春期的脆弱自尊，轻易不得触碰，那极有有可能成为对他或她一生的打扰。
我没办法把有趣的东西说成无聊
没什么意义啊，无论做什么，都没有任何意义啊。可以一次次重头来过的你可能无法理解。
你带上罪恶之冠，即使背负上所有罪恶和孤独，绝不让你受伤
对于你，我永远都是你的朋友。然后，总有一天能告诉你，我是你的朋友。
虽然是理所当然的事，可我却没有发觉。
Yes,my lord.
没关系，由乃会保护小雪的。对吧，小雪~
你复杂的五官掩饰不了你朴素的智商。
班里大部分人的手，没有任何事前说好或商量，也没有任何眼神交流就同时举起的瞬间，决定真相的瞬间，决定正义的瞬间，我从未见过那样可怕的瞬间。
没有人会知道，在这表面光鲜亮丽的天才形象下，我真实的想法，我一直在追寻失误，没有失误就不是游戏了。
锻炼自己也好，绞尽脑汁也好，自己想办法解决。
替一朵花微笑，是一种繁华落尽后的淡泊与清宁，花的冬天，人的冬天，但是在冬季到来之前，有一朵花忽略了季节的月季，天真得哼着歌白色的花儿翩然降临在一个属于他们的秘密基地。
要不是老师说不能乱扔垃圾，我早把你扔出去了。
能够许下愿望其本身就是一种价值。
人生就像是在布满地雷的房间里过着家里蹲的生活。
他们只是想保护自己的灵魂，结果，雪穗从不以真面目示人，亮司则至今仍在黑暗的通风管中徘徊。
高奏凯歌离去的话．那就是征服王的掠夺。
我曾经也拥有过爱，只是，我放弃了。
我要是找个女朋友的话，真琴不就变成了一个人了。
世界看起来像是又复杂又荒唐的，但其本质意外地就像小孩的感观所感受到的那般单纯——空和白两个人，也是这样想的，是吧？
就算因为恐惧而害怕得浑身颤抖，却依然向前迈出一步——这便是勇气。
如果有一天，我变成了你随便遥控的节目，我就不再是我，而是你塑造的影子。
一个受过伤的人，他的内心是否就像这秋日里的树木一般，即使尚有残存的绿色，却也终将在秋风中枯黄凋零？
荣耀就在彼方，遥不可及才要挑战，歌颂霸道，展现霸道，为了守护我背影的臣子。
当一个生命与另一个生命相遇的时候，会孕育出什么呢。
我们在一起的时候,希望你能耐心一点，给我时间去理解你.
无论身边围着多少人，我永远都是那么孤独。
总是认定自己不行，这辈子就真的办不到了.
就算我看不到你的身影，就算我远离你的身旁，我也会一直注视着你，你是我永远守护的人
原来，你是货真价实的蠢货啊。
究竟是我们太执着于所谓的自尊，还是我们都已经习惯了口是心非。
明知没意义，却无法不执着的事物——谁都有这样的存在。
请不要再侵入到我的心里去了
我总是爱蹲下来看地上时光的痕迹，像一行一行蚂蚁穿越我的记忆。
跟老外聊天的时候，对方一旦开始高谈阔论，就想盯着他腰部期待字母出现。
记忆深处，幼小的双眼闪烁犹如繁星。真相被时间侵蚀，如今为何映出漆黑光芒
人心谁也无法预测，随心所欲的行动难以预料，运是随著自己的作为而产生。
因为总是回头，所以哪里也去不了……
我一直想听哦，你为我所演奏的那首月光。
星星为什么看起来如此渺小，是因为它把自己放得太高
以为我百毒不侵八风不动、不畏一切吗？没错我就是。
每当心情郁闷的时候，用手托腮就好，手臂会因为帮上忙而开心的。
恶的动机，不过是对正义的反感罢了。
成为我作品中的女主角吧。
能够用故事里的语言拯救现实中的人能够成为现实里的英雄。
终于放弃了虚伪的正义，手握真正的杀意了吗？
不是蛮力就能解决一切问题，你要学习的道理还有很多呢
忍者最强的力量不是在学会所有忍术之后得到，而是在保护自己最珍贵的东西时才会显露出来 。
解救自己软弱的，一定不是眼泪 ，而是打破现实的决心。
用不能飞的身体，找出飞上天空的方法
我们一直用相册来收集记忆，或许它还可以存放爱的幻想
自己总说着相信我的那种人反而是不能信任的
一定要努力活下去，因为有美好的人生在等着你。
一去不复返，一生仅此一次的真正告别。
我不知道，难道这命运是仁慈的神灵规定地吗？难道我们的悲惨命运，就无法改变吗？
活着本身就是一种价值，因为还有明天。
我不明白，天空的阴霾，是你的伤怀还是我的悲哀？
你所追求的东西不仅难以得到，并且毫无意义，就算得到了，也不会让你变得幸福。
上辈子我们一定是无家可归的人，这一辈子才会这么宅。
被抓到的小鸟，只要够聪明，就会用自己的嘴打开鸟笼的门。因为它们还没有放弃，想要自由得翱翔在空中的希望。
我和你不一样，不做实现不了的梦。
即使你改变了过程，也改不了结果。
不过傲慢分为两种。一种是能力过于低下，还有一种是志向异常远大的。
我在时光斑驳深处，聆听到花开的声音。
把剑放下，成为本王的妻子吧。
时间冲淡的，是存在感，而不是存在。
努力过后，才知道许多事情，坚持坚持，就过来了。
未知绝不会转变成已知，因为已知又会转变成未知，那里没有终点，昨日的常识并非今日的常识。
但是 我不愿再这样什么都不做什么都不变地结束
追寻起源，追寻终焉，思考的同时，只是在一步步的行走，或许走再远都只能看到同样的风景，或许放弃行走也是个不错的选择 ，即使被宣告一切就此结束
人，只有在放弃战斗的时候才算输，只要坚持战斗，就还没输。
承认吧，我们是最弱的种族，正因为生来什么都没有，因此我们能拥有一切，以身为最弱种族为傲吧。
人的道路是不会中断，是会一直联系下去的，即使是多么小的事情，无论是多么短的时间，即使不会留在记忆里，也不会留在记录中，被缔结的缘是不会消失的！
总是留恋失去的东西，只是向着死胡同奔跑而已。
千年沧桑，世事变迁，不变的是棋盘上惊心动魄的撕杀，棋士内心的执着，还有……对围棋恒古不灭的热情!
大家互相帮助，一起成功，一起幸福什么的，不过是种理想。
虽然不想承认，都是因为年轻犯下的错啊。
我们之所以觉得岩壁上的花很美，那是因为我们就站在岩壁上的缘故。
当太阳到达最高点，影子就会消失。
如果你愿意的话，让我带您去吧，这座小镇，愿望实现的地方??
世界也是这样，有绝望的地方，就会有希望产生。
当你无法再拥有时，你唯一能做的就是不要再忘记。
因为失去，所以明白。
有个人经常面带笑容陪伴在身边，那是多大的救赎。
花朵在绽放前无法预知自己的色彩
有了她灿烂的笑脸,有了活下去面对每一天的勇气。
如果不能对喜欢的东西说喜欢的话，那肯定是这个世界有问题吧。
你们也别太着急,有些事啊,是急不来的。
咱们还是先把人当好吧，先做到自己行事问心无愧，再尽己所能去帮别人一把，就已经很是了不起啦。
直到界限——超越界限，赌上自己。
空谈之类，是谈不久，也谈不出什么来的，它终必被事实的镜子照出原形，拖出尾巴而去。
最好的，与最痛苦的，是一样的。
输给谁都可以，唯独不能输给自己。
这么说这些寒酸、贫弱、简陋、可怜的积蓄就是你的全部财产？
话说回来，现充还真是麻烦啊。
谁都没错，正因为每个人都是正确的，才酿成了悲剧。?
能够教你读书。可爱的学妹和生硬的父亲。还有……这片星空。我现在拥有的东西，只有这样。我能够给阿良良木你的，只有这些。这些就是，全部。
从那里落下了一轮红色的花瓣。那是，抚子花……
梦存高远，志在争霸，这股热情确实值得赞许，但所谓梦，终有一天是要醒来的。
夕阳，将世界像血一样染红了的，太阳的最终宿命，我还可以看多少次，这种悲哀的天色。
然虽不曾落败，却也不被理解。
把手拿开，想传染笨蛋菌给我吗，笨蛋……
所谓用功学习，就是获得让人生不走歪路的知识。
人生如戏，导演是自己。
实际上萌马尾辫，忘记是什么时候看到的了，你绑马尾辫的样子简直合适到犯规！
无论是网络还是手机，能用来的只是联络而不是交流。
我们首先是厨师，其次才是学生。无论如何都要把菜做出来。
我们的征途是星辰大海。
虽然是这样，不过回想起来，以前的我也许是一直受着眷顾。
呐，你曾说过想要妹妹对吧？
当美丽、纯粹、真实的事物被破坏，重视的回忆和梦想被摧毁时，恨意便开始萌发，恣意蔓延开来……
杀了上帝，我就是神！
这算什么，不是说好玩捉迷藏吗？那么我们没找到你，又怎么能算结束
因为渴望改变，所以必须努力。
只是想着的话是不会改变任何东西的，不管怎么样都要加以行动。
区区一只趴在地上的蝼蚁，谁允许你抬起头的，虫子就要有虫子的样子，低头伏地然后去死。
重逢的时候没想到我会这样喜欢他，虽然你不是我交往的第一人，可却是我的初恋，虽然你可能并不知道。
发挥想象力，避开危险。
有资格被称为英雄的，既不是仗剑之人，也不是疗伤止痛之人，而是能赌上自己性命的人。
我只是，希望至少自己所熟知的这片世界，可以没有人流泪而已。
生命是买不到，给不了的。但是，却可以养育。
自己来选择，不会后悔的道路。
云端的日子，虽然令人期待，但是也充满了无奈。
你说你被诅咒了，活在世上就是个诅咒。
走着走着，就散了，回忆都淡了；回头发现，你不见了，忽然我乱了。
你喜欢用遥控器控制，而我，喜欢用遥控器选择。
在这鸦雀无声的地方集中精力学习吧。
与其说花开不如说花狂乱的散落一地，反正这世界本就是妄想与自私的培养皿。
你的名字那么普通也就我听到会心头一怔。
我想要的的不是死去这么简单，而是拥有着幸福的死去啊
被骗时只懂得生气的人根本不成对手。应该要懂得佩服这种手法，才算是真正的商人。
你，可以流血流汗，但是，你没有流泪的权利。
有形之物终将走向灭亡。
深海里的鲨鱼 看到海面上 阳光下跳跃的海豚 总会不自觉的害怕
啊啦啊啦，你们在做的事情我好感兴趣啊，不要摆出这种姿势啊，也让我加入吧，别看我这样，枪的使用我可是很在行的。眼下我有一个提案，我们来换换规则吧，不是什么困难的事情哦，只是换换目标而已~
讨厌自己的人不能够喜欢和信任别人。
就这点程度，还不足以折断我的灵魂。
王来承认，王来允许，王来背负整个世界。
趁着黑暗逃跑的话只是匹夫的夜盗而已。
友情其实和爱情一样，很多的时候，距离才可以让彼此更懂得彼此。
连一次冒险都没有的人生很无聊，至少也要有些事能在人心上掀起些波澜。
只要没有放弃，就没有失败!
所谓组织，人才济济的话是长久不了的。
你还是不知道，什么也不知道，不过我也不想让你知道
我早上照镜子的时候，都会感到一股寒意，你到底是什么人？是谁？镜子能反映出所有真实的东西，但它却不能照出真正的你。你的正义之眼看得穿邪恶之心，却看不透女人的心意。
既然难逃一死，最后把负担放下来如何
不管你未来会走什么样的道路，你一定要照自己的意思活下去。
别觉得你被世界抛弃了，世界根本没空搭理你。
虽然不知道可能会走到哪一步，但是我一定会坚持下去的。
现实原本就是最索然无味的答案，这便是真实。
A Secret Makes A Woman Woman.
我承认躲避时的难受比面对时的更多。
最不忍的恨中藏有最深沉的爱，最残酷的死亡源于最悲悯的审判！
一心想要通过圣杯改变历史的人，简直就是对创造历史的英雄们的侮辱！
天予不取，必遭天谴。
人类之所以会去照顾其他生物，是因为他感到空虚。之所以会想保护环境，是因为他不想被环境毁灭
正因为我看不见所以才能赢。
不要为自己的努力道歉，这样太对不起自己的努力了！
其实所有纠结做选择的人心里早就有了答案，咨询只是想得到心里内心所倾向的选择。最终的所谓命运 还是自己一步步走出来的。
这个世界里，是没法隐藏泪水的啊。想要哭的时候，谁都忍不住的
每一次与老朋友的偶遇，都是在邂逅当年的自己。
拥有广阔退路的人总是能显得很高尚……当你第一步走错了之后，就无法再回头。
即使是像遥远的梦想般存在的她，只要握住一支笔……就能触及！！
所谓长大成人，就是不断聚了散，散了聚。
为他人幸福而撒的谎，就不再是谎言。
我果然是化不可能为可能的男人。
结束演奏的小提琴手，向等待她的人飞奔而来，穿越层层人潮，手中怀抱鲜花，就好像……电影的特写镜头一般。只不过，我是路人角色友人A罢了。
只是有一点，我不想失去你。
如今我们仅有的默契，就是安静的躺在对方的好友列表里，不闻不问，各自过活。
有了喜欢的人，就会在意各种小事，感觉很不自由，但是，为了那些小事左思右想，心里竟然会这么快乐。
如果一次也不回头，我能走到哪里呢？
我不属于任何人！我也有选择自己生活的权利！
不需要怜悯，不需要理解。勿要靠近，勿要探究。弱者是群居动物，风雨和艰险，我只一人独当。
如果在意上头的眼光，就不能向魔道前进，不要怕评议会的一群笨蛋。朝自己相信的路前进这才是妖精尾巴的魔法师。
不能害怕未来，不能讨厌世界。
所谓正确，就是即使做错也不后悔。
一同离去吧，绝不会让你孤单一人。
做一个微笑挂在嘴边，快乐放在心上的人。
哪里会有在真正的战争中等待对方回合的蠢货啊。
每个人总有他不想提的过去，一点也不出奇.
我觉得……除了衰老以外，你绝对不会因为其他原因死去。
低头要有勇气，抬头要有底气。
童年时的一场旅途是不是真的很短暂，距离缩短了，时间拉长了，我们迷失了。
人会老去、花会衰败，但花开罢一季又一季，人却再也不会归来。
过去是过去，你就是你。
就算世上有着所谓的“好女人”，也不会有着“和我关系好的女人”。
破牛仔裤怎么和晚礼服站在一起，我的吉他怎么可以和你的钢琴合奏。
无论是谁，都会有不想为人所知的一面吧。只要自己没有想去了解对方，就不会知道别人的真正姿态。
我宁可一开始就不认识那个人，也好过相识以后却要生死离别。
追求又失去，多少往昔的梦。 一边嘲笑自己 一边继续向前。
最后呢，在这片沙漠之中，至少我能知道还会有一个，珍爱这朵花儿的人。有一个人就足够了。
晴朗的早晨 我会按部就班 换乘地铁来这里 但总觉得自己根本不属于这里
我相信这世界上,有些人有些事有些爱,在见到的第一次,就注定要羁绊一生,就注定像一棵树一样,生长在心里,生生世世。
如果因为害怕失败，而不去努力，那就不会有能够成功的人。
从你进来的时候起，你的败北就是定数了。
想不被别人踩在脚下有两种途径：变更强，变成翔。
妹妹呦，人生就是个坑爹的游戏，我一直当做自虐游戏，现在终于出BUG了！
人傻不能怨社会
我和你们不是同伴，我和你们不一样。
逃离自己的无力感，逃离因为我的无用而持续失去的世界……但即使如此，我还是找不出答案。
万物潜息之时，拟春之物萌发，与此春同长憩，此身终将冻结。
十六岁，我就不相信这个世界了。
我本身以及这戒指都是碎后重生的，事到如今早已不畏惧粉碎的威胁。
要成为一个优秀的刑警，首先要成为一个优秀的罪犯。
干燥的空气，尘埃的味道，我在其中…踏上旅途
死去的人无法哭泣,就让我替他们泣泪吧。
习惯了边活边问的你，到最后也会带着疑问死去。
如果一个男人相信爱情能让女人死心塌地地话…那么这个男人不是疯子就是傻子！
永远年轻，永远装嫩，永远不知好歹，永远热泪盈眶。
到底是幸运还是不幸呢? 你眼中的世界 大概是最它纯粹的摸样吧?
离景似是昨日，转眼却已经年。
年时间可以是一瞬，也可以是永远。
都无所谓，这就是我的生存方式。
我们人这一辈子不是别人的楷模，就是别人的借鉴。
永远维持的关系只会出现在天真的童话里，如果轻易相信这种东西又遭到背叛，只会让人受到伤害。
我讨厌一会充满希望一会变成绝望，我们已经受够了期待落空了。
就像从不会分开地等待明天，就像永不曾离去地度过那年。
人在步入社会之前，究竟在哪呢？
恼人的气味必须从根源去除。
有时候，朋友就像一把伞，雨天挡雨，晴天遮阳，遇到再多困难，都会为你撑起一片天空.
成长，是每个孩子的权力，也是他们必经的征程，或平坦、或崎岖，有悲欢，有离合
我喜欢雨。因为它带来天空的味道。
只要是亲生父母，除非你去犯罪，否则你干什么他们不支持你呢。
只希望能手牵手在太阳下散步。
回过神来的时候，早已紧追不舍。
我被你遗忘，只好换一个包装，用另一个身份重新陪在你身旁。
大海的颜色 大地的颜色 风的颜色 心的颜色 你的颜色
无论你期望或者不期望，清晨依旧来临。
小时候，我不明白摩天轮是为什么而存在的 。
大丈夫立世无所畏惧。
世间的活动，缺点虽多，但仍是美好的
要不得谦词是废话
毁灭一个人只要一句话，培植一个人却要千句话，请你口下留情
把希望建筑在意欲和心愿上面的人们，二十次中有十九次都会失望
三人行，必有我师焉
还有什么不快乐？
学在苦中求，艺在勤中练
内心让一个人真实地了解自己，一旦了解了自己也就了解了世界
学问渊博的人，懂了还要问；学问浅薄的人，不懂也不问
一个人只有一个命运
有所成就是人生唯一的真正乐趣
真正没有资格谈明天的人，是那个不懂得珍惜今天的人
无事莫把闲话聊，是非往往闲话生
志当存高远
君子忧道不忧贫
宝剑不磨要生锈；人不学习要落后
请教别人不折本，舌头打个滚
只要你明白要为自己的贪念计算和付出代价，你的心便会释然。困难是自己种出来的
这个世界本身就没有所谓的清白而言，你能坦言，你从来就没说过慌，这是自欺欺人
友谊可以筑起一道坚实的防线
你若要喜爱你自己的价值，你就得给世界创造价值
宁可自己去原谅原谅别人，莫让别人来原谅你
走自己的路，让别人去说吧
积累知识，胜过积蓄金银
同时赶两只兔，一只也捉不到
我们嘴里的别人的事听起来就像是自己的事；我们说自己的事的时候，却又在像说一段不相干的故事
奈何一个人随着年龄增长，梦想便不复轻盈；他开始用双手掂量生活，更看重果实而非花朵
一艺之成，当尽毕生之力
时间总是会过去的，让时间流走你的烦恼吧！
长风破浪会有时，直挂云帆济沧海
读一书，增一智
书山有路勤为径，学海无涯苦作舟
试试并非受罪，问问并不吃亏
选择只是短短几秒钟的事，然后用余下的时间来还债
我们的能力，只能够伤害那些离我们最近的人
我们从没有忘记真相，只是我们越来越会说谎
苟利国家生死以，岂因祸福避趋之
生命是如此的美丽……
不懂得自爱的人，是没有能力去爱别人的
十日画一水，五日画一石
学而时习之，不亦乐乎
三军可夺帅也，匹夫不可夺志也
学无前后，达者为师
最淡的墨水，也胜过最强的记性
汗水和丰收是忠实的伙伴，勤学和知识是一对最美丽的情侣
离你的朋友近些，但离你的敌人要更近，这样你才能更了解他
坐而论道，不如起而行动
一个不是我们有所求的朋友才是真正的朋友
与人相处之道，在于无限的容忍
君子喻于义，小人喻于利
达人远见，不与物争。视利犹粪土之污，视权如鸿毛之轻
博学而笃志，切问而近思
勤勉是成功之母
修行就是修正自己错误的观念
和你一同笑过的人，你可能把他忘掉；但是和你一同哭过的人，你却永远不忘
志不立，天下无可成之事
天行健，君子以自强不息；地势坤，君子以厚德载物
到了熟透的年龄，即使在群众的怀抱中，你都可能觉得寂寞无比
不要浪费你的生命在你一定会后悔的地方上
如何能得到快乐：抛弃仇恨、远离烦恼、生活简单、淡泊名利、为人着想、笑口常开、心中有爱
只有面对现实，才能超越现实
谁给我一滴水，我便回报他整个大海
其实爱美的人，只是与自己谈恋爱罢了
朋友就是另一个我
广结众缘，就是不要去伤害任何一个人
智者千虑，必有一失；愚者千虑，必有一得
仁者无忧，智者无惑，勇者无惧
戏言不能伤敌但能伤友
夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远
All things are difficult before they are easy.
知识好象砂石下面的泉水，越掘得深泉水越清
伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的
这个世界只有圆滑，没有圆满的
若能一切随他去，便是世间自在人
如果爱情是个手指，把它剁掉就行了
只要功夫深，铁杵磨成绣花针
茂盛的禾苗需要水分；成长的少年需要学习
使生活变成幻想，再把幻想化为现实
超越自我
寻找本身就是一种幸福
逆境是成长必经的过程，能勇于接受逆境的人，生命就会日渐的茁壮
世界不是天才创造的
你希望掌握永恒，那你必须控制现在
嫉妒就是承认己不如人
己所不欲，勿施于人
要得惊人艺，须下苦功夫
好问不须脸红，无知才应羞耻
快乐是吞咽的，悲伤是咀嚼的；如果咀嚼快乐，会嚼出悲伤来的
劳动是知识的源泉；知识是生活的指南
不自由，毋宁死
睡觉是为了踏实地工作，工作是为了踏实地睡觉
原谅别人，就是给自己心中留下空间，以便回旋
上不忧天，下不忧人
有时候解释是不必要的，敌人不信你的解释，朋友无需你的解释
一个不能为自己挺身而出的孩子，长大之后只能是个懦夫
所谓心事，不过是不如己意，那就是我执，执著于自己描画的理想，一有落差，即生烦恼
一个吻，你就知道了我所有沉默的心事
书籍备而不读如废纸
上台阶尽管费力，却一步比一步高
你什么时候放下，什么时候就没有烦恼
造烛求明，读书求理
怕问路，要迷路
讳疾忌医的人找不到良药
不向前走，不知路远；不努力学习，不明白真理
寸寸河山寸寸金，瓜离分裂力谁任？杜鹃再拜忧天泪，精卫无穷填海心
今天的执着，会造成明日的后悔
我的世界有我的真理，正义的立场由我决定
当你对自己诚实的时候，世界上没有人能够欺骗得了你
常说口里顺，常做手不笨
想象力比知识更重要
日日行，不怕千万里；时时学，不怕千万卷
不招人妒是庸才
创造机会的人是勇者；等待机会的人是愚者
人生的每一步，都可能成为另一个错误；可却不能因为错误，而不迈出下一步
来是偶然的，走是必然的。所以你必须，随缘不变，不变随缘
我坚信，人应该有力量，揪着自己的头发把自己从泥地里拔起来
当你宽恕的时候，等于释放了一个囚徒，然后你会发现，那个囚徒就是你自己
不要在智慧中夹杂着傲慢，不要使谦虚缺乏智慧
学如驾车登山，不进就退；学如逆水行舟，不进则退
勇于接受别人的批评，正好可以调整自己的缺点
与其事过境迁还不时地感叹，不如用心地好好珍惜所有
随缘不是得过且过、因循苟且，而是尽人事听天命
对人恭敬，就是在庄严你自己
塞翁失马，祸兮福倚。得丧荣辱，奚足介意
God helps those who help themselves.
不吃饭则饥，不读书则愚
树不修，长不直；人不学，没知识
不问的人永远和愚昧在一起
我要发表心灵，而不公开隐私
认识自己，降伏自己，改变自己，才能改变别人
我已经发现了，无论两条腿怎样努力也不能使两颗心灵更加接近
必须洗净一切往事，否则你永远无法清楚自由地看这个世界
在被遗忘以前，我们会变为媚俗。媚俗，是存在与遗忘之间的中转站
知识是智慧的火炬
苦心中，常得悦心之趣；得意时，便生失意之悲
不是某人使我烦恼，而是我拿某人的言行来烦恼自己
我们确实有如是的优点，但也要隐藏几分，这个叫做涵养
勿以恶小而为之，勿以善小而不为。惟贤惟德，能服于人
你的言语，我爱听，却不懂得，我的沉默，你愿见，却不明白
为天地立心，为生民立命，为往圣继绝学，为万世开太平
站在光明中看到的只是黑暗，站在黑暗中却拥有光明
自知不自见，自爱不自贵
不听指点，多绕弯弯
谁游乐无度，谁没空学习
学习如钻探石油，钻得愈深，愈能找到知识的精髓
粮食补身体，书籍丰富智慧
人生得一知己足已，斯世当以同怀视之
大鹏一日同风起，抟摇直上九万里
正人行邪法，邪法亦正，邪人行正法，正法亦邪，一切唯心造
生活给了我想要的东西，又让我认识到那没什么意义
青春如果太切合实际，就不配叫做青春了
一分耕耘，一分收获
人生的真理，只是藏在平淡无味之中
室雅何须大，花香不在多
学问勤中得，富裕俭中来
百艺通，不如一艺精
不能则学，不知则问，耻于问人，决无长进
我们必须接受失望，因为它是有限的，但千万不可失去希望，因为它是无穷的
多练多乖，不练就呆
没有艰苦的学习，就没有最简单的发明
沉默是诽谤最好的答复
井淘三遍吃好水，人从三师武艺高
善于发问的人，知识丰富
学问之根苦，学问之果甜
注意力是智慧的门户
君子在下位则多谤，在上位则多誉；小人在下位则多誉，在上位则多谤
欲速则不达
星星之火，可以燎原
拳不离手，曲不离口
孤独的人有他们自己的沼泽
搓绳不能松劲，前进不能停顿
心专才能绣得花，心静才能织得麻
诸恶莫作，众善奉行
学历代表过去，学习力掌握将来
如果你能像看别人缺点一样，如此准确地发现自己的缺点，那么你的生命将会不平凡
人生的价值，并不是用时间，而是用深度去衡量的
羞耻心是所有品德的源泉
一切出发点和落脚点都该是：胸怀坦荡和问心无愧。阳光底下留不住秘密
如果一个人很慷慨，那他就必须把自己的慷慨表现得充满感情
灵感，不过是顽强地劳动而获得的奖赏
一身报国有万死，双鬓向人无再青
目标愈高，志向愈可贵
生活的理想，就是为了理想的生活
自以为拥有财富的人，其实是被财富拥有
君，当如竹，坚韧挺拔显气概
真正的男子渴求着不同的两件事：危险和游戏。
你要感谢告诉你缺点的人
Nothing is impossible to a willing heart.
才华是刀刃，辛苦是磨刀石
瞄准还不是射中，起跑还不算到达
人类最大的错误，在于不敢承担圣人的心
不经过琢磨，宝石也不会发光
让朋友低估你的优点，让敌人高估你的缺点
不是事业为了思想，而是思想为了事业
无论怎么样，一个人借故堕落总是不值得原谅的，越是没有人爱，越要爱自己
把自己当傻瓜，不懂就问，你会学的更多
创新一点点
不要因为小小的争执，远离了你至亲的好友，也不要因为小小的恐惧，忘记了别人的大恩
最艰苦之时，便是胜利将到之日
边学边问，才有学问
心坚石也穿
不能以道德、学问和修持的力量，来使人受益，就等于欠了一份债
针越用越明，脑越用越灵
无情未必真英豪
安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山
学习如赶路，不能慢一步
最远的旅行，是从自己的身体到自己的心，是从一个人的心到另一个人的心
心之所愿，无所不成
难得糊涂
好记性不如烂笔头
重要的不是治愈，而是带着病痛活下去
人并不逃避别人，人逃避他自己
我们即使发了一千次短信，心与心的距离大概也只靠近了一厘米。
不要说不可能，没有什么不可能
快并快乐着！
心是最大的骗子，别人能骗你一时，而它却能骗你一辈子
人家怕你，并不是一种福；人家欺你，并不是一种辱
生如夏花之绚烂，死如秋叶之静美
爱人者，人恒爱之。敬人者，人恒敬之
春蚕到死丝方尽，人至期颐亦不休。一息尚存须努力，留作青年好范畴
顺从灼热的激情，这既是最容易的，又是最困难的
我想象我们能够彼此看上一眼，然后对着黑压压的血淋淋的整个世界说：我呸
当你劝告别人时，若不顾及别人的自尊心，那么再好的言语都没有用的
嘴勤不走冤枉路
手指有长有短，知识有高有低
要学蜜蜂采百花，问遍百家成行家
污则欲避，轻则易弃。避则无憾于人，弃则无累于己
心里有个人放在那里，是件收藏，如此才填充了生命的空白。 太阳尚远，但必有太阳
只要自觉心安，东西南北都好。如有一人未度，切莫自己逃了
能为别人设想的人，永远不寂寞
生活中的万事万物，无不可以吸收教益，无不可以成文，只要“求思之深而无不在”，定能有所得益
我为人人，人人为我
一个不想蹚过小河的人，自然不想远涉重洋
不怕学问浅，就怕志气短
生当作人杰，死亦为鬼雄，至今思项羽，不肯过江东
老姜辣味大，老人经验多
自己不曾拥有，就快乐地欣赏别人的拥有
心中装满着自己的看法与想法的人，永远听不见别人的声音
天若有情天亦老，人间正道是沧桑
教育不是灌输，而是点燃火焰
蜂采百花酿甜蜜，人读群书明真理
情话的温度有多热，幻灭就可以有多剧烈
只要是有益的话，小孩的话也要听
一个人如果不能从内心去原谅别人，那他就永远不会心安理得
多用心去倾听别人怎么说，不要急着表达你自己的看法
宠辱不惊，看庭前花开花落。得失俱忘，观天上云卷云舒
不懂装懂，永世饭桶
不要憎恨你的敌人，那会影响你的判断力
Where there is a will there is a way.
没有行动的构想是白日梦，没有构想的行动是恶梦
自由的目的是为了为他人创造自由
说一句谎话，要编造十句谎话来弥补，何苦呢？
人生在世界是短暂的，对这短暂的人生，我们最好的报答就是工作
若要精，人前听
好高骛远的一无所得，埋头苦干的获得知识
最足以显示一个人性格的，莫过于他所嘲笑的是什么东西
愚痴的人，一直想要别人了解他。有智慧的人，却努力地了解自己
星星使天空绚烂夺目；知识使人增长才干
二十岁不狂是没有志气，三十岁犹狂是没有头脑
任何你失去的事物，价值自动倍增
活在别人的掌声中，是禁不起考验的人
你的谦逊会使别人感到高兴
老骥伏枥，志在千里；烈士暮年，壮心不已
只有努力攀登顶峰的人，才能把顶峰踩在脚下
有个等待也不错
遗忘完全可以是记忆的一种深沉的形式
每一天都是一个全新的开始
忌妒别人，不会给自己增加任何的好处；忌妒别人，也不可能减少别人的成就
一天一苹果，疾病远离我
那时你还年轻，肾上腺素在血管里拥挤得像一袋跳跳糖
太过于欣赏自己的人，不会去欣赏别人的优点
一个人的价值，应该看他贡献什么，而不应当看他取得什么
如果你不和家人在一起，你就永远无法成为真正的男人
能说不能行，不是真智慧
用宝珠打扮自己，不如用知识充实自己
事业常成于坚忍，毁于急躁
古之君子如抱美玉而深藏不市，后之人则以石为玉而又炫之也
困难是人的教科书
很多时候，冲动里面有一种快感，而另一些时候，远离则是一种操守
每一种创伤，都是一种成熟
独立的人格，自由的精神
精神里需要的东西，超出现实的负荷，是失败的一个原因
人和人的心最远又最近，真诚便是中间的通道
逆境中不自弃，顺境中不张扬
天生我才必有用，千金散尽还复来
人没有自由，犹如木偶
拥有一颗无私的爱心，便拥有了一切
知识需要反复探索，土地需要辛勤耕耘
巨大财富的背后，都隐藏着罪恶
你的选择是做或不做，但不做就永远不会有机会
要知道你用食指指着别人大骂时，手中另外三个指头是指着自己的
打死不上弹窗广告
Pain past is pleasure.
如果你不给自己烦恼，别人也永远不可能给你烦恼。因为你自己的内心，你放不下
一个人的生活方式决定一切，甚至人的思维]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>929</wp:post_id>
		<wp:post_date><![CDATA[2018-09-09 23:10:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-09 15:10:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e8%a8%80-hitokoto]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<category domain="category" nicename="wordpress"><![CDATA[wordpress]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[275]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[custom_permalink]]></wp:meta_key>
			<wp:meta_value><![CDATA[hitokoto]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>noip2018能力提升训练一解题报告</title>
		<link>http://sycstudio.com/archives/933</link>
		<pubDate>Wed, 26 Sep 2018 01:54:07 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=933</guid>
		<description></description>
		<content:encoded><![CDATA[<h1> A.「HDU6129」Just do it</h1>

<h2>Decription</h2>

给定一个数组\(a\),定义一次变换为把\(a_i\)设为\(a_1..a_i\)的异或前缀和，求变换\(m\)次后的\(a\)数组。

<h2>Solution</h2>

~~打表~~可以发现，变换\(2^k\)后，\(a_i=a_{i} xor a_{i-k} xor ...xor a_{i \mod k}\)。

知道这个性质后对\(m\)二进制拆位直接做即可。

<h1> B.「Codeforces814E」An unavoidable detour for home</h1>

<h2>Decription</h2>

求满足以下条件的图的方案数。

 1. 第\(i\)个点的度数为\(d_i\)
 2. 第\(i\)个点到\(1\)号点的距离\(\leq\)\(i-1\)号点的距离(边权为1)
 
<h2>Solution</h2>
 
 设\(f_{i,j}\)表示当前总共有\(i\)个点，有\(j\)个点与\(i\)号点在同一层。
 \(g_{i,j,k}\)表示当前层有\(i\)个点,有\(j\)个点还可以连出\(1\)条边,有\(k\)个点还可以连出\(2\)条边.
 \(N_i\)表示\(i\)个点组成的项链数.
 
 \(f_{i,j}=\sum_{k=1}^{i-j}f_{i-j,k} \times g_{j,c1,c2}\)
 
 1. \(g_{0,0,0}=1\)
 2.  当\(i=j=0\),\(k>0\)时,\(g_{i,j,k}=\sum_{l=2}^{k-1}C_{k-1}^lg_{i,j,k-l-1}N_{l+1}\)
表示从\(k-1\)个点中选出\(l\)个点与最后一个点配成环(由于题目要求不能有重边所以大小为\(2\)的环不符要求)
 3. 当\(i=0\),\(j>0\)时,\(g_{i,j,k}=(j-1)g_{i,j-2,k}+kg_{i,j,k-1}\)
前者表示从剩余点度为\(1\)的点与最后一个点(设最后一个点剩余点度为\(1\))连边,后者表示选出一个剩余点度为\(2\)与最后一个点连边,剩余点度为\(1\)的点没有变化,剩余点度为\(2\)的点减少\(1\).
 4.  当\(i>0\)时,\(g_{i,j,k}=jg_{i-1,j-1,k}+kg_{i-1,j+1,k-1}\)

<h1>C.「POJ3685」Matrix</h1>

二分水题，咕咕咕。

<h1>D.「CF576C」Points on Plane</h1>

按莫队算法的方法排序即可。~~当然你也可以写曼哈顿最小距离生成树~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>933</wp:post_id>
		<wp:post_date><![CDATA[2018-09-26 09:54:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-26 01:54:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[__trashed]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[192]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「BZOJ1808」「IOI2007」训练路径-DP</title>
		<link>http://sycstudio.com/archives/949</link>
		<pubDate>Wed, 26 Sep 2018 16:14:16 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=949</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一张图与该图的一张生成树，每个点度数不超过10。
其中可以删去非生成树上的边。每条边有一个权值，求代价最小的删边方案使得图中不存在偶环。

<h1>Solution</h1>

显然可以删去在两点树上路径长度为奇数的边。

之后可以发现图中存在存在偶环的充分必要条件为存在一个环经过了两条非树边(因为两个有公共边的奇环删去公共边后得到了一个偶环)

把答案转化用总权值前去可以留在图中的最大权值，所以题目转化为一个图的最大生成仙人掌。

这时候发现一个点的度数不超过&#92;(10&#92;),所以我们可以在生成树上状压DP。

设&#92;(f_{i,s}&#92;)表示以&#92;(i&#92;)为根的子树，不考虑&#92;(s&#92;)集合中的儿子的最大权值。

转移看这张图吧，讲的很清楚。

<a href="http://sycstudio.com/wp-content/uploads/2018/09/20171211134651684.png" title="转移"><img src="http://sycstudio.com/wp-content/uploads/2018/09/20171211134651684.png" alt="转移" title="转移" /></a>

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 2005;

int n, m, g[maxn][1 &lt;&lt; 11], sum;

struct edge {
    int to, next;
} e[maxn * 2];
int h[maxn], tot;

struct Edge {
    int u, v, w;
} E[maxn * 5];
int Tot;

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

int son[maxn], siz[maxn], f[maxn], dep[maxn];
void dfs1(int u, int fa)
{
    siz[u] = 1; f[u] = fa; dep[u] = dep[fa] + 1;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa) {
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[v] &gt; siz[son[u]]) son[u] = v;
        }
}

int gf[maxn];
void dfs2(int u, int fa)
{
    if (son[u]) gf[son[u]] = gf[u], dfs2(son[u], u);
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; v != son[u]) gf[v] = v, dfs2(v, u);
}

int lca(int u, int v)
{
    while (gf[u] != gf[v]) {
        if (dep[gf[u]] &gt; dep[gf[v]]) u = f[gf[u]];
        else v = f[gf[v]];
    }
    return dep[u] &lt; dep[v] ? u : v;
}

int Id[maxn], s[maxn], cnt;
vector&lt;int&gt; vec[maxn];
void dfs(int u, int fa)
{
    static int sum;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next) if (v != fa) dfs(v, u);
    cnt = 0;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next) if (v != fa) Id[v] = 1 &lt;&lt; cnt, s[cnt++] = v;
    for (int i = 0; i &lt; (1 &lt;&lt; cnt); ++i)
        for (int j = 0; j &lt; cnt; ++j) if (!((i &gt;&gt; j) &amp; 1)) g[u][i] += g[s[j]][0];
    for (int i = 0, a, b, t, len = vec[u].size(); i &lt; len; ++i) {
        t = vec[u][i]; sum = E[t].w;
        if ((a = E[t].u) != u) {sum += g[a][0]; while (f[a] != u) sum += g[f[a]][Id[a]], a = f[a];}
        if ((b = E[t].v) != u) {sum += g[b][0]; while (f[b] != u) sum += g[f[b]][Id[b]], b = f[b];}
        for (int j = 0; j &lt; (1 &lt;&lt; cnt); ++j)
            if (!(j &amp; Id[a]) &amp;&amp; !(j &amp; Id[b])) g[u][j] = max(g[u][j], sum + g[u][j | Id[a] | Id[b]]);
    }
}

int main()
{
    n = gi(); m = gi();
    for (int u, v, w, i = 1; i &lt;= m; ++i) {
        u = gi(); v = gi(); w = gi();
        if (!w) add(u, v);
        else E[++Tot] = (Edge) {u, v, w};
    }

    dfs1(1, 0);
    gf[1] = 1; dfs2(1, 0);

    for (int u, v, w, i = 1; i &lt;= Tot; ++i) {
        u = E[i].u; v = E[i].v; sum += E[i].w;
        if ((dep[u] + dep[v] - (dep[w = lca(u, v)] &lt;&lt; 1) + 1) &amp; 1) vec[w].push_back(i);
    }

    dfs(1, 0);
    printf("%d\n", sum - g[1][0]);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>949</wp:post_id>
		<wp:post_date><![CDATA[2018-09-27 00:14:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-26 16:14:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cbzoj1808%e3%80%8d%e3%80%8cioi2007%e3%80%8d%e8%ae%ad%e7%bb%83%e8%b7%af%e5%be%84-dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[状态压缩动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[134]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「Codeforces960G」Bandit Blues-分治FFT+第一类斯特林数</title>
		<link>http://sycstudio.com/archives/953</link>
		<pubDate>Thu, 27 Sep 2018 14:53:22 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=953</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Decription</h1>

求满足以下条件的长度为 &#92;(n&#92;) 的序列方案数

<ol>
<li>从左贪心选最长上升子序列长度为 &#92;(a&#92;)</li>
<li>从左贪心选最长上升子序列长度为 &#92;(b&#92;)</li>
</ol>

<h1>Solution</h1>

考虑把序列分成 &#92;(a+b-2&#92;) 组，从 &#92;(i&#92;) 被选取的数到第 &#92;(i+1&#92;) 个被选取的数前一个位置为一组。那么每一组除了最大值为外都是随意排列，方案数为 &#92;((k-1)!&#92;) 。那么方案数就是用&#92;(n-1&#92;)个数拼出出&#92;(a+b-2&#92;)个环(第一类斯特林数)，还要乘上从&#92;(a+b-2&#92;)个环中选出&#92;(a-1&#92;)个放在左边的方案数。

分治FTT即可。

ps:这题的暴力&#92;(O(n^2)&#92;)预处理&#92;(O(1)&#92;)回答询问在hdu4372.这样你就可以连A两题了。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 500005;
const int mod = 998244353, phi = mod - 1, G = 3;

int n, m, L, R[maxn], A[maxn], B[maxn];
vector&lt;int&gt; vec[maxn];

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int getdif(int a, int b) {return a - b &lt; 0 ? a - b + mod : a - b;}
inline int getsum(int a, int b) {return a + b &gt;= mod ? a + b - mod : a + b;}

inline int Pow(int x, int k)
{
    int ret = 1;
    while (k) {
        if (k &amp; 1) ret = (lint)ret * x % mod;
        x = (lint)x * x % mod; k &gt;&gt;= 1;
    }
    return ret;
}

void NTT(int *a, int n, int f)
{
    for (int i = 0; i &lt; n; ++i)
        if (i &lt; R[i]) swap(a[i], a[R[i]]);
    for (int i = 1; i &lt; n; i &lt;&lt;= 1) {
        int wn = Pow(G, phi / (i &lt;&lt; 1)), t;
        if (f == -1) wn = Pow(wn, mod - 2);
        for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) {
            int w = 1;
            for (int k = 0; k &lt; i; ++k, w = (lint)w * wn % mod) {
                t = (lint)a[j + i + k] * w % mod;
                a[j + i + k] = getdif(a[j + k], t);
                a[j + k] = getsum(a[j + k], t);
            }
        }
    }
    if (f == 1) return ;
    int Inv = Pow(n, mod - 2);
    for (int i = 0; i &lt; n; ++i) a[i] = (lint)a[i] * Inv % mod;
}

void solve(int l, int r)
{
    if (l == r) return vec[l].push_back(l), vec[l].push_back(1);
    int mid = (l + r) &gt;&gt; 1;
    solve(l, mid); solve(mid + 1, r);
    vector&lt;int&gt; &amp;a = vec[l], &amp;b = vec[mid + 1];
    m = r - l + 1;
    for (n = 1, L = 0; n &lt;= m; n &lt;&lt;= 1) ++L;
    --L;
    for (int i = 0; i &lt; n; ++i) 
        R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; L), A[i] = 0, B[i] = 0;
    for (int i = 0; i &lt; a.size(); ++i) A[i] = a[i];
    for (int i = 0; i &lt; b.size(); ++i) B[i] = b[i];
    NTT(A, n, 1); NTT(B, n, 1);
    for (int i = 0; i &lt; n; ++i) A[i] = (lint)A[i] * B[i] % mod;
    NTT(A, n, -1);
    for (int i = 0; i &lt; a.size(); ++i) a[i] = A[i];
    for (int i = a.size(); i &lt;= m; ++i) a.push_back(A[i]);
}

int C(int n, int m)
{
    int res1 = 1, res2 = 1;
    for (int i = n - m + 1; i &lt;= n; ++i) res1 = (lint)res1 * i % mod;
    for (int i = 1; i &lt;= m; ++i) res2 = (lint)res2 * i % mod;
    return (lint)res1 * Pow(res2, mod - 2) % mod;
}

int main()
{
    freopen("blues.in", "r", stdin);
    freopen("blues.out", "w", stdout);

    int n, a, b;
    n = gi(); a = gi(); b = gi();
    if (n == 1) return printf("%d\n", (a == 1 &amp;&amp; b == 1)), 0;
    if (a + b - 2 &gt; n - 1 || !a || !b) return puts("0"), 0;

    solve(0, n - 2);

    printf("%lld\n", (lint)vec[0][a + b - 2] * C(a + b - 2, a - 1) % mod);

    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>953</wp:post_id>
		<wp:post_date><![CDATA[2018-09-27 22:53:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-27 14:53:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8ccodeforces960g%e3%80%8dbandit-blues-%e5%88%86%e6%b2%bbfft%e7%ac%ac%e4%b8%80%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[132]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「BZOJ3451」「Tyvj1953」Normal-点分治+FFT</title>
		<link>http://sycstudio.com/archives/954</link>
		<pubDate>Sat, 29 Sep 2018 01:44:30 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=954</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

求随机点分治的操作次数期望。定义操作次数为每次分治时子树的大小之和。

&#92;(n \leqslant 30000&#92;)

<h2>Solution</h2>

考虑每个点的贡献为它在点分树上的深度。

对于一个点对&#92;((x,y)&#92;)的贡献即&#92;(x&#92;)是&#92;(y&#92;)父亲的概率，那么点&#92;(x&#92;)必须是&#92;(x&#92;)到&#92;(y&#92;)路径上最先被选择的点。概率是&#92;(\frac{1}{dis(x,y)}&#92;)。

所以统计每一种长度路径的条数即可，用点分治+FFT解决。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 1000005;

int n;
long long ans[maxn];

struct edge {
    int to, next;
} e[maxn * 2];
int h[maxn], tot;

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

namespace FFT
{

    typedef complex&lt;double&gt; cpx;
    const double pi = acos(-1);

    int n, m, L, R[maxn * 2];
    cpx A[maxn * 2], B[maxn * 2];

    void FFT(cpx *a, int f)
    {
        for (int i = 0; i &lt; m; ++i)
            if (i &lt; R[i]) swap(a[i], a[R[i]]);
        for (int i = 1; i &lt; m; i &lt;&lt;= 1) {
            cpx wn(cos(pi / i), sin(f * pi / i)), t;
            for (int j = 0; j &lt; m; j += (i &lt;&lt; 1)) {
                cpx w(1, 0);
                for (int k = 0; k &lt; i; ++k, w *= wn) {
                    t = a[j + i + k] * w;
                    a[j + i + k] = a[j + k] - t;
                    a[j + k] = a[j + k] + t;
                }
            }
        }
    }

    void fft(lint *a, lint *b, int l1, int l2, lint *c)
    {
        n = l1 + l2;
        for (m = 1, L = 0; m &lt;= n; m &lt;&lt;= 1) ++L;
        for (int i = 0; i &lt; m; ++i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1));
        for (int i = 0; i &lt; m; ++i) A[i] = a[i];
        for (int i = 0; i &lt; m; ++i) B[i] = b[i];
        FFT(A, 1); FFT(B, 1);
        for (int i = 0; i &lt; m; ++i) A[i] = A[i] * B[i];
        FFT(A, -1);
        for (int i = 0; i &lt;= n; ++i) c[i] = (int)(A[i].real() / m + 0.5);
    }
}

int root, Siz, siz[maxn], mxsz[maxn], dep[maxn], mxdp;
lint cnt[maxn];
bool vis[maxn];

void getroot(int u, int fa)
{
    siz[u] = 1; mxsz[u] = 0;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) {
            getroot(v, u);
            siz[u] += siz[v];
            mxsz[u] = max(mxsz[u], siz[v]);
        }
    mxsz[u] = max(mxsz[u], Siz - siz[u]);
    if (mxsz[u] &lt; mxsz[root]) root = u;
}

void getdep(int u, int fa)
{
    ++cnt[dep[u]];
    mxdp = max(mxdp, dep[u]);
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) {
            dep[v] = dep[u] + 1;
            getdep(v, u);
        }
}

void calc(int u, int d, int f)
{
    mxdp = 0;
    dep[u] = d;
    getdep(u, 0);
    FFT::fft(cnt, cnt, mxdp, mxdp, cnt);
    for (int i = 0; i &lt;= FFT::n; ++i) ans[i] += cnt[i] * f, cnt[i] = 0;
}

void dfs(int u)
{
    Siz = siz[u];
    root = 0; getroot(u, 0);
    vis[root] = 1;
    calc(root, 0, 1);
    for (int i = h[root], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) calc(v, 1, -1);
    for (int i = h[root], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) dfs(v);
}

int main()
{
    freopen("normal.in", "r", stdin);
    freopen("normal.out", "w", stdout);

    n = gi();
    for (int i = 1; i &lt; n; ++i) add(gi() + 1, gi() + 1);

    mxsz[0] = n; siz[1] = n;
    dfs(1);

    double Ans = 0;
    for (int i = 0; i &lt; n; ++i) Ans += (double)ans[i] / (i + 1);
    printf("%.4lf\n", Ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>954</wp:post_id>
		<wp:post_date><![CDATA[2018-09-29 09:44:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-29 01:44:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cbzoj3451%e3%80%8d%e3%80%8ctyvj1953%e3%80%8dnormal-%e7%82%b9%e5%88%86%e6%b2%bbfft]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[185]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>163</wp:comment_id>
			<wp:comment_author><![CDATA[flashhu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1258661899@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/flashhu/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[182.84.110.34]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-09-30 21:07:01]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-09-30 13:07:01]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[复活啦qaq
latex咕了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>11</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>164</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-03 15:37:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-03 07:37:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[现在是我在维护，根根还是在咕咕咕]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>163</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>166</wp:comment_id>
			<wp:comment_author><![CDATA[flashhu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1258661899@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/flashhu/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-03 17:48:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-03 09:48:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<code>写点汉字吧，博主外语很捉急。You should type some Chinese word.
</code>

假]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>11</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>「LOJ6119」「2017 山东二轮集训 Day7」国王-点分治</title>
		<link>http://sycstudio.com/archives/956</link>
		<pubDate>Wed, 03 Oct 2018 07:37:25 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=956</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

在某个神奇的大陆上，有一个国家，这片大陆的所有城市间的道路网可以看做是一棵树，每个城市要么是工业城市，要么是农业城市，这个国家的人认为一条路径是 exciting 的，当且仅当这条路径上的工业城市和农业城市数目相等。现在国王想把城市分给他的两个儿子，大儿子想知道，他选择一段标号连续的城市作为自己的领地，并把剩下的给弟弟，能够满足两端都是自己城市的 exciting 路径比两端都是弟弟的城市的 exciting 路径数目多的方案数。

&#92;(n\leqslant 10^5&#92;)

<h1>Solution</h1>

首先可以发现如果限定了右端点，那么左端点的可取范围是以1开头的一段区间，且右端点单调不降。

设&#92;(A&#92;)表示两端点都在区间&#92;([l,r]&#92;)内的路径条数，&#92;(B&#92;)表示两端点都在区间外的路径条数，&#92;(C&#92;)表示一端点在区间内一端点在区间外的路径条数，&#92;(S&#92;)表示总路径条数&#92;(\times 2&#92;)

那么&#92;(A>B \Leftrightarrow 2A+C>2B+C \Leftrightarrow 2A+C>S-2A-C&#92;)

设&#92;(f_i&#92;)表示以&#92;(i&#92;)为端点的路径条数，点分治统计即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;

int n, w[maxn], f[maxn];

struct edge {
    int to, next;
} e[maxn * 2];
int h[maxn], tot;

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

int root, siz[maxn], mxsz[maxn], Siz;
bool vis[maxn];
void getroot(int u, int fa)
{
    siz[u] = 1; mxsz[u] = 0;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) {
            getroot(v, u);
            siz[u] += siz[v]; mxsz[u] = max(mxsz[u], siz[v]);
        }
    mxsz[u] = max(mxsz[u], Siz - siz[u]);
    if (mxsz[u] &lt; mxsz[root]) root = u;
}

int cnt[maxn * 2], mnds, mxds, dis[maxn];
vector&lt;int&gt; vec[maxn * 2];
void getdis(int u, int fa)
{
    mnds = min(mnds, dis[u]);
    mxds = max(mxds, dis[u]);
    ++cnt[dis[u] + n];
    vec[dis[u] + n].push_back(u);
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) {
            dis[v] = dis[u] + w[v];
            getdis(v, u);
        }
}

void calc(int u, int d, int s)
{
    mnds = mxds = dis[u] = d;
    getdis(u, 0);
    for (int i = mnds; i &lt;= mxds; ++i)
        for (int j = vec[i + n].size() - 1; ~j; --j)
            f[vec[i + n][j]] += cnt[-i - w[root] + n] * s;
    for (int i = mnds; i &lt;= mxds; ++i) {
        cnt[i + n] = 0;
        while (!vec[i + n].empty()) vec[i + n].pop_back();
    }
}

void solve(int u)
{
    root = 0; Siz = siz[u];
    getroot(u, 0);
    vis[root] = 1;
    calc(root, 0, 1);
    for (int i = h[root], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) calc(v, w[v], -1);
    for (int i = h[root], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) solve(v);
}

int main()
{
    //freopen("kings.in", "r", stdin);
    //freopen("kings.out", "w", stdout);

    n = gi();
    for (int i = 1; i &lt;= n; ++i) w[i] = gi() ? 1 : -1;
    for (int i = 1; i &lt; n; ++i) add(gi(), gi());

    mxsz[0] = n; siz[1] = n;
    solve(1);

    long long sum1 = 0, sum2 = 0, ans = 0;
    for (int i = 1; i &lt;= n; ++i) sum1 += f[i];
    for (int i = 1, j = 1; i &lt;= n; ++i) {
        sum2 += f[i];
        while (sum2 - f[j] &gt; sum1 - (sum2 - f[j]) &amp;&amp; j &lt;= i) sum2 -= f[j++];
        if (sum2 &gt; sum1 - sum2) ans += j;
    }

    printf("%lld\n", ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>956</wp:post_id>
		<wp:post_date><![CDATA[2018-10-03 15:37:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-03 07:37:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cloj6119%e3%80%8d%e3%80%8c2017-%e5%b1%b1%e4%b8%9c%e4%ba%8c%e8%bd%ae%e9%9b%86%e8%ae%ad-day7%e3%80%8d%e5%9b%bd%e7%8e%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="loj"><![CDATA[LOJ]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[106]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-09-29]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「SDOI2013」随机数生成器-BSGS</title>
		<link>http://sycstudio.com/archives/958</link>
		<pubDate>Wed, 03 Oct 2018 09:33:50 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=958</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定随机生成数种子 &#92;(x_1,a,b&#92;),&#92;(x_i=ax_{i-1}+b(mod P)&#92;)，求最小的&#92;(i&#92;)使得&#92;(x_i=t&#92;)。

&#92;(P \leq 10^9&#92;)

<h2>Solution</h2>

&#92;(a^{i-1}x_1+a^{i-2}b+a^{i-3}b+...+b\equiv t(mod p)&#92;)

等价与

&#92;(a^{i+1}x_1+a^{i}b+a^{i-1}b+...+b\equiv t(mod p)&#92;)

&#92;(a^{i+1}x_1+b \frac{a^{i+1}-1}{a-1}\equiv t(mod p)&#92;)

&#92;(a^{i+1}\equiv \frac{t(a-1)+b}{x_1\times a - x_1+b}(mod p)&#92;)

BSGS即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

#define inv(x) (pow(x, p - 2, p))
inline int pow(int x, int k, int p)
{
    int ret = 1;
    while (k) {
        if (k &amp; 1) ret = (lint)ret * x % p;
        x = (lint)x * x % p; k &gt;&gt;= 1;
    }
    return ret;
}

const int mod = 5007449;

struct edge {
    lint to1, to2;
    int next;
} e[mod * 2];
int h[mod], tot;

inline lint find(lint u)
{
    int x = u % mod;
    for (int i = h[x]; i; i = e[i].next)
        if (e[i].to1 == u) return e[i].to2;
    return -1;
}

inline void add(lint u, lint v)
{
    if (~find(u)) return;
    int x = u % mod;
    e[++tot] = (edge) {u, v, h[x]};
    h[x] = tot;
}

lint BSGS(lint a, lint b, lint p)
{
    if (b == 1) return 0;
    if (!a &amp;&amp; b) return -1;
    memset(h, 0, sizeof(h));
    tot = 0;
    lint S = sqrt(p), q = 1;
    for (int i = 0; i &lt; S; ++i)
        add(q * b % p, i), q = q * a % p;
    lint x = 1, j;
    for (int i = 1; i &lt;= S + 1; ++i) {
        x = x * q % p; j = find(x);
        if (~j) return i * S - j;
    }
    return -1;
}

int main()
{
    int T = gi(), p, a, b, x1, t;
    lint ans;
    while (T--) {
        p = gi(); a = gi(); b = gi(); x1 = gi(); t = gi();
        if (t == x1) puts("1");
        else if (a == 0) puts(t == b ? "2" : "-1");
        else if (a == 1) printf("%lld\n", b ? (lint)(t - x1 + p) % p * inv(b) % p + 1 : -1);
        else printf("%lld\n", (ans = BSGS(a, (((lint)t * (a - 1) % p + b) * inv(((lint)x1 * a % p - x1 + b) % p + p) % p + p) % p, p)) == -1? -1 : ans + 1);
    }

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>958</wp:post_id>
		<wp:post_date><![CDATA[2018-10-03 17:33:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-03 09:33:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8csdoi2013%e3%80%8d%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e5%99%a8-bsgs]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bsgs-%e6%89%a9%e5%b1%95bsgs"><![CDATA[BSGS/扩展BSGS]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[112]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「BZOJ4361」ISN-树状数组+DP</title>
		<link>http://sycstudio.com/archives/961</link>
		<pubDate>Wed, 03 Oct 2018 12:15:39 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=961</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给出一个长度为&#92;(n&#92;)的序列&#92;(A(A_1,A_2...A_n)&#92;)。如果序列&#92;(A&#92;)不是非降的，你必须从中删去一个数，
这一操作，直到&#92;(A&#92;)非降为止。求有多少种不同的操作方案，答案模&#92;(10^9+7&#92;)。

&#92;(n \leqslant 2000&#92;)

<h1>Solution</h1>

设&#92;(f_i&#92;)表示长度为&#92;(i&#92;)的不降序列数，这个可以用树状数组&#92;(O(n^2logn)&#92;)求。

把答案按最后剩下的长度分类，&#92;(ans=\sum_{i=1}^n f_i \times (n-i)!&#92;)

由于当序列非降时会停止，所以会有一部分算重。

考虑每种长度为&#92;(i&#92;)的不合法情况是由一种长度为&#92;(i+1&#92;)的序列删去一个数得到，所以答案减去&#92;(f_{i+1}\times (i+1) \times (n-i-1)!&#92;)

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int mod = 1000000007;
const int maxn = 2005;
int n, ans;
int A[maxn], *q[maxn], f[maxn], g[maxn], fac[maxn];

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline void inc(int &amp;a, int b) {a + b &gt; mod ? a += b - mod : a += b;}
inline void dec(int &amp;a, int b) {a &gt; b ? a -= b : a -= b - mod;}

int sum[maxn];
inline void insert(int x, int a)
{
    while (x &lt;= n) {
        inc(sum[x], a);
        x += x &amp; (-x);
    }
}

inline int query(int x)
{
    int ret = 0;
    while (x &gt; 0) {
        inc(ret, sum[x]);
        x -= x &amp; (-x);
    }
    return ret;
}

inline bool cmp(int *a, int *b)
{
    return *a &lt; *b;
}

int main()
{
    freopen("isn.in", "r", stdin);
    freopen("isn.out", "w", stdout);

    n = gi();
    for (int i = 1; i &lt;= n; ++i) A[i] = gi(), q[i] = &amp;A[i];
    sort(q + 1, q + n + 1, cmp);
    for (int tmp = -1, cnt = 0, i = 1; i &lt;= n; ++i)
        if (*q[i] == tmp) *q[i] = cnt;
        else tmp = *q[i], *q[i] = ++cnt;;

    for (int i = 1; i &lt;= n; ++i) f[i] = 1;
    g[1] = n;
    for (int i = 2; i &lt;= n; ++i) {
        memset(sum + 1, 0, sizeof(int) * n);
        for (int j = 1; j &lt;= n; ++j) {
            int tmp = f[j];
            f[j] = query(A[j]);
            insert(A[j], tmp);
        }
        for (int j = 1; j &lt;= n; ++j) inc(g[i], f[j]);
    }

    fac[0] = 1;
    for (int i = 1; i &lt;= n; ++i) fac[i] = (lint)fac[i - 1] * i % mod;
    for (int i = 1; i &lt;= n; ++i) {
        inc(ans, (lint)g[i] * fac[n - i] % mod);
        dec(ans, (lint)g[i + 1] * (i + 1) % mod * fac[n - i - 1] % mod);
    }

    printf("%d\n", ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>961</wp:post_id>
		<wp:post_date><![CDATA[2018-10-03 20:15:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-03 12:15:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cbzoj4361%e3%80%8disn-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[121]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「JSOI2008」最小生成树-krukal+矩阵树定理</title>
		<link>http://sycstudio.com/archives/965</link>
		<pubDate>Thu, 04 Oct 2018 14:50:20 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=965</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一张图，求他的最小生成树个数。

&#92;(n \leqslant 100, m \leqslant 1000&#92;)

<h1>Solution</h1>

最小生成树具有这样两种性质：

<ol>
<li>最小生成树中，每种权值的边的条数固定。</li>
<li>不同的最小生成树中，某一种权值的边在加完后，图的联通情况相同。</li>
</ol>

所以把添加某种权值的边的过程看做生成一棵生成树的过程(每种边的权值一样)，可以直接用矩阵树定理求解。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int mod = 31011;
const int maxn = 105, maxm = 1005;
int n, m, c[maxn][maxn], a[maxn][maxn], f1[maxn], f2[maxn], vis[maxn], ans = 1;
vector&lt;int&gt; vec[maxn];

struct edge {
    int u, v, w;
    bool operator &lt; (const edge &amp;a) const {
        return w &lt; a.w;
    }
} e[maxm * 2];

int find(int x, int *f)
{
    if (f[x] == x) return x;
    return f[x] = find(f[x], f);
}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

int deter(int a[maxn][maxn], int n)
{
    int ans = 1;
    for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = (a[i][j] + mod) % mod;
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = i + 1; j &lt;= n; ++j) {
            while (a[j][i]) {
                int t = a[i][i] / a[j][i];
                for (int k = i; k &lt;= n; ++k) a[i][k] = (a[i][k] - t * a[j][k] % mod + mod) % mod;
                for (int k = i; k &lt;= n; ++k) swap(a[i][k], a[j][k]);
                ans = mod - ans;
            }
        }
        ans = (ans * a[i][i] % mod + mod) % mod;
        if (ans == 0) return ans;
    }
    return ans;
}

int main()
{
    n = gi(); m = gi();
    for (int u, v, w, i = 1; i &lt;= m; ++i) {
        u = gi(); v = gi(); w = gi();
        e[i] = (edge) {u, v, w};
    }

    for (int i = 1; i &lt;= n; ++i) f1[i] = f2[i] = i;

    sort(e + 1, e + m + 1);
    for (int u, v, x, y, t, lst = e[1].w, i = 1; i &lt;= m + 1; ++i) {
        if (e[i].w != lst || i == m + 1) {
            for (int i = 1; i &lt;= n; ++i)
                if (vis[i]) {
                    vec[find(i, f2)].push_back(i);
                    vis[i] = 0;
                }
            for (int i = 1; i &lt;= n; ++i) {
                if (vec[i].empty()) continue;
                memset(a, 0, sizeof(a));
                for (int j = 1; j &lt;= vec[i].size(); ++j)
                    for (int k = j + 1; k &lt;= vec[i].size(); ++k) {
                        t = c[vec[i][j - 1]][vec[i][k - 1]];
                        a[j][k] -= t; a[k][j] -= t;
                        a[j][j] += t; a[k][k] += t;
                    }
                ans = ans * deter(a, vec[i].size() - 1) % mod;
                vec[i].clear();
            }
            for (int i = 1; i &lt;= n; ++i) f1[i] = find(i, f2);
            lst = e[i].w;
            if (i == m + 1) break;
        }
        u = e[i].u, v = e[i].v;
        x = find(u, f1); y = find(v, f1);
        if (x == y) continue;
        f2[find(x, f2)] = f2[find(y, f2)];
        ++c[x][y]; ++c[y][x];
        vis[x] = vis[y] = 1;
    }

    int cnt = 0;
    for (int i = 1; i &lt;= n; ++i) cnt += find(i, f1) == i;
    printf("%d\n", cnt == 1 ? ans : 0);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>965</wp:post_id>
		<wp:post_date><![CDATA[2018-10-04 22:50:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-04 14:50:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cjsoi2008%e3%80%8d%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91-krukal%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86"><![CDATA[矩阵树定理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[128]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「BZOJ4894」天赋-矩阵树定理</title>
		<link>http://sycstudio.com/archives/966</link>
		<pubDate>Fri, 05 Oct 2018 09:23:34 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=966</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

求一个有向图的不同树形图数量。

&#92;(n \leqslant 300&#92;)

<h2>Solution</h2>

还是Matrix-tree定理。

求入度矩阵减去邻接矩阵的行列式值即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int mod = 1000000007;
const int maxn = 305;

int n, a[maxn][maxn], g[maxn][maxn], d[maxn][maxn];
char s[maxn];

int deter(int a[maxn][maxn], int n)
{
    int ans = 1;
    for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = (a[i][j] + mod) % mod;
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = i + 1; j &lt;= n; ++j)
            while (a[j][i]) {
                int t = a[i][i] / a[j][i];
                for (int k = i; k &lt;= n; ++k) a[i][k] = (a[i][k] - (lint)a[j][k] * t % mod + mod) % mod;
                for (int k = i; k &lt;= n; ++k) swap(a[i][k], a[j][k]);
                ans = mod - ans;
            }
        ans = (lint)ans * a[i][i] % mod;
        if (!ans) return 0;
    }
    return ans;
}

int main()
{
    freopen("talent.in", "r", stdin);
    freopen("talent.out", "w", stdout);

    scanf("%d\n", &amp;n);
    for (int i = 1; i &lt;= n; ++i) {
        scanf("%s", s + 1);
        for (int j = 1; j &lt;= n; ++j) g[i][j] = s[j] - '0';
        for (int j = 1; j &lt;= n; ++j) d[j][j] += g[i][j];
    }

    for (int i = 2; i &lt;= n; ++i)
        for (int j = 2; j &lt;= n; ++j)
            a[i - 1][j - 1] = d[i][j] - g[i][j];

    printf("%d\n", deter(a, n - 1));

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>966</wp:post_id>
		<wp:post_date><![CDATA[2018-10-05 17:23:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-05 09:23:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cbzoj4894%e3%80%8d%e5%a4%a9%e8%b5%8b-%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86"><![CDATA[矩阵树定理]]></category>
		<category domain="category" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[108]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「Codeforces914D」Stranger Trees-矩阵树定理+拉格朗日插值</title>
		<link>http://sycstudio.com/archives/969</link>
		<pubDate>Fri, 05 Oct 2018 15:04:40 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=969</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一棵有&#92;(n&#92;)个节点的无权无向树。

求对于这&#92;(n&#92;)个点，以及每个&#92;(k=0,1,2...n-1&#92;)，有多少棵由这&#92;(n&#92;)个点之间的边构造成的树，与给定的树恰好有k条边重复。

答案&#92;(mod 10^9+7&#92;)输出。

&#92;(n \leqslant 100&#92;)

<h2>Solution</h2>

考虑矩阵树定理求出的每棵生成树边权(重边条数定义为边权)的乘积的和。

设出现在给定的树的边的边权定义为&#92;(x&#92;)，那么答案就是&#92;(\sum_{i=0}{n-1} x^i ansi&#92;)，其中&#92;(ans_i&#92;)表示与给定的树有&#92;(i&#92;)条重边的生成树个数，即答案。

发现当&#92;(x&#92;)确定时，这个多项式可以用矩阵树定理求出。所以把&#92;(x=1..n&#92;)带入多项式，用拉格朗日插值法求出&#92;(ans_i&#92;)即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int mod = 1e9 + 7;
const int maxn = 105;

int n, fac[maxn], ifac[maxn], len, p[maxn], a[maxn][maxn], g[maxn][maxn], ans[maxn];

inline int inc(int &amp;a, int b) {return a + b &gt;= mod ? a += b - mod : a += b;}
inline int dec(int &amp;a, int b) {return a &lt; b ? a -= b - mod : a -= b;}
inline int getsum(int a, int b) {return a + b &gt;= mod ? a + b - mod : a + b;}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int pow(int x, int k)
{
    int ret = 1;
    while (k) {
        if (k &amp; 1) ret = (lint)ret * x % mod;
        x = (lint)x * x % mod; k &gt;&gt;= 1;
    }
    return ret;
}

int det(int a[maxn][maxn], int n)
{
    for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = (a[i][j] + mod) % mod;
    int ans = 1;
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = i + 1; j &lt;= n; ++j) 
            while (a[j][i]) {
                int t = a[i][i] / a[j][i];
                for (int k = i; k &lt;= n; ++k) dec(a[i][k], (lint)a[j][k] * t % mod);
                for (int k = i; k &lt;= n; ++k) swap(a[i][k], a[j][k]);
                ans = mod - ans;
            }
        ans = (lint)ans * a[i][i] % mod;
        if (!ans) return 0;
    }
    return ans;
}

int main()
{
    n = gi();
    for (int u, v, i = 1; i &lt; n; ++i) {
        u = gi(); v = gi();
        g[u][v] = g[v][u] = 1;
    }

    fac[0] = 1;
    for (int i = 1; i &lt;= n; ++i) fac[i] = (lint)fac[i - 1] * i % mod;
    ifac[n] = pow(fac[n], mod - 2);
    for (int i = n - 1; ~i; --i) ifac[i] = (lint)ifac[i + 1] * (i + 1) % mod;

    for (int x = 1; x &lt;= n; ++x) {
        memset(a, 0, sizeof(a));
        for (int t, i = 1; i &lt;= n; ++i)
            for (int j = i + 1; j &lt;= n; ++j) {
                t = g[i][j] ? x : 1;
                a[i][j] -= t; a[j][i] -= t;
                a[i][i] += t; a[j][j] += t;
            }
        memset(p + 1, 0, sizeof(int) * n);
        p[len = 0] = (lint)det(a, n - 1) * ifac[x - 1] % mod * ifac[n - x] % mod;
        if ((n - x) &amp; 1) p[0] = mod - p[0];
        for (int t, i = 1; i &lt;= n; ++i) {
            if (x == i) continue;
            t = mod - i; ++len;
            for (int j = len; ~j; --j) p[j] = getsum((lint)t * p[j] % mod, j ? p[j - 1] : 0);
        }
        for (int i = 0; i &lt;= len; ++i) inc(ans[i], p[i]);
    }

    for (int i = 0; i &lt; n; ++i) printf("%d ", ans[i]);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>969</wp:post_id>
		<wp:post_date><![CDATA[2018-10-05 23:04:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-05 15:04:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8ccodeforces914d%e3%80%8dstranger-trees-%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc%e6%b3%95"><![CDATA[拉格朗日插值法]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e7%9f%a9%e9%98%b5%e6%a0%91%e5%ae%9a%e7%90%86"><![CDATA[矩阵树定理]]></category>
		<category domain="category" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6-%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[157]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「JLOI2016」成绩比较-DP+拉格郎日插值法</title>
		<link>http://sycstudio.com/archives/970</link>
		<pubDate>Fri, 05 Oct 2018 16:01:17 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=970</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

太长了，咕咕咕

<h1>Solution</h1>

设&#92;(f_{i,j}&#92;)表示考虑前&#92;(i&#92;)门课程，总共有&#92;(j&#92;)个人被碾压的方案数。

&#92;(f_{i,j}=\sum_{k=j}^{n-1}f_{i-1,k} \times C_{k}^{k-j} \times C^{n-R_i-1-(k-j)}_{n-k-1}\times d_i&#92;)

&#92;(d_i&#92;)表示第&#92;(i&#92;)门功课分数合法分布的方案数，有&#92;(d_i=\sum_{k=1}^{U_i}k^{n-R_i}(U_i-k)^{R_i-1}&#92;)。容易发现&#92;(d_i&#92;)是一个次数不超过&#92;(n&#92;)的多项式，用插值算法求&#92;(d_i&#92;)即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int mod = 1e9 + 7;
const int maxn = 105;

int n, m, k, U[maxn], R[maxn], g[maxn];
int f[maxn][maxn], C[maxn][maxn];

inline int getsum(int a, int b) {return a + b &gt; mod ? a + b - mod : a + b;}
inline int inc(int &amp;a, int b) {return a + b &gt; mod ? a += b - mod : a += b;}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int pow(int x, int k)
{
    int ret = 1;
    while (k) {
        if (k &amp; 1) ret = (lint)ret * x % mod;
        x = (lint)x * x % mod; k &gt;&gt;= 1;
    }
    return ret;
}

int lagrange(int U, int R)
{
    for (int i = 1; i &lt;= n + 1; ++i) {
        g[i] = 0;
        for (int j = 1; j &lt;= i; ++j)
            inc(g[i], (lint)pow(j, n - R) * pow(U - j, R - 1) % mod);
    }
    int ans = 0;
    for (int i = 1; i &lt;= n + 1; ++i) {
        int A = g[i], B = 1;
        for (int j = 1; j &lt;= n + 1; ++j)
            if (j != i) {
                A = (lint)A * (U - j + mod) % mod;
                B = (lint)B * (i - j + mod) % mod;
            }
        inc(ans, (lint)A * pow(B, mod - 2) % mod);
    }
    return ans;
}

int main()
{
    n = gi(); m = gi(); k = gi();
    for (int i = 1; i &lt;= m; ++i) U[i] = gi();
    for (int i = 1; i &lt;= m; ++i) R[i] = gi();

    C[0][0] = 1;
    for (int i = 1; i &lt;= n; ++i) {
        C[i][0] = 1;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = getsum(C[i - 1][j - 1], C[i - 1][j]);
    }

    f[0][n - 1] = 1;
    for (int i = 1; i &lt;= m; ++i) {
        int d = lagrange(U[i], R[i]);
        for (int j = k; j &lt;= n - 1; ++j)
            for (int k = j; k &lt;= n - 1; ++k)
                if (R[i] - 1 &gt;= (k - j)) inc(f[i][j], (lint)f[i - 1][k] * C[k][k - j] % mod * C[n - k - 1][R[i] - 1 - (k - j)] % mod * d % mod);
                else break;
    }

    printf("%d\n", f[m][k]);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>970</wp:post_id>
		<wp:post_date><![CDATA[2018-10-06 00:01:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-05 16:01:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cjloi2016%e3%80%8d%e6%88%90%e7%bb%a9%e6%af%94%e8%be%83-dp%e6%8b%89%e6%a0%bc%e9%83%8e%e6%97%a5%e6%8f%92%e5%80%bc%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc%e6%b3%95"><![CDATA[拉格朗日插值法]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[154]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「BZOJ2212」「POI2011」Tree Rotations-线段树合并</title>
		<link>http://sycstudio.com/archives/974</link>
		<pubDate>Sun, 14 Oct 2018 06:39:23 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=974</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有&#92;(n&#92;)个叶子节点，满足这些权值为&#92;(1..n&#92;)的一个排列)。可以任意交换每个非叶子节点的左右孩子。

要求进行一系列交换，使得最终所有叶子节点的权值按照遍历序写出来，逆序对个数最少。

<h1>Solution</h1>

考虑交换一个节点的左右儿子对子树外的逆序对没有影响，所以只要考虑子树内的逆序对即可。

那么只需要计算交换前后的逆序对个数然后去&#92;(min&#92;)即可。

所以可以考虑维护左右子树的权值线段树，线段树合并时计算答案即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 200005;

int n;
lint ans, res1, res2;

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

#define mid ((l + r) &gt;&gt; 1)

int sum[maxn * 40], lch[maxn * 40], rch[maxn * 40], tot;

int build(int l, int r, int w)
{
    int s;
    sum[s = ++tot] = 1;
    if (l == r) return s;
    if (w &lt;= mid) lch[s] = build(l, mid, w);
    else rch[s] = build(mid + 1, r, w);
    return s;
}

int merge(int l, int r, int s1, int s2)
{
    if (!s1 || !s2) return s1 | s2;
    if (l == r) return sum[s1] += sum[s2], s1;
    res1 += (lint)sum[lch[s1]] * sum[rch[s2]];
    res2 += (lint)sum[rch[s1]] * sum[lch[s2]];
    lch[s1] = merge(1, mid, lch[s1], lch[s2]);
    rch[s1] = merge(mid + 1, r, rch[s1], rch[s2]);
    sum[s1] = sum[lch[s1]] + sum[rch[s1]];
    return s1;
}

int dfs()
{
    int w = gi();
    if (w) return build(1, n, w);
    int s = merge(1, n, dfs(), dfs());
    ans += min(res1, res2);
    res1 = res2 = 0;
    return s;
}

int main()
{
    freopen("rotations.in", "r", stdin);
    freopen("rotations.out", "w", stdout);

    n = gi();
    dfs();

    printf("%lld\n", ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>974</wp:post_id>
		<wp:post_date><![CDATA[2018-10-14 14:39:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-14 06:39:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cbzoj2212%e3%80%8d%e3%80%8cpoi2011%e3%80%8dtree-rotations-%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6"><![CDATA[线段树合并]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[119]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2011 年各省省选选做</title>
		<link>http://sycstudio.com/%E7%9C%81%E9%80%89/2011</link>
		<pubDate>Sun, 21 Oct 2018 13:29:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=977</guid>
		<description></description>
		<content:encoded><![CDATA[简单复习一下

详细题解和代码可以参见 Github

顺序按照各省字典序排序

<h2>[BJWC2011]禁忌</h2>

禁忌串的分割肯定是贪心地从前往后直接割是最优的，那么预处理转移，矩阵快速幂优化。

<h2>[BJWC2011]元素</h2>

排序后线性基贪心搞搞。

<h2>[BJWC2011]最小三角形</h2>

类似平面内最近点对的分治来做。

<h2>[BJWC2011]双端队列</h2>

注意到最后的操作是把所有的队列排序后得到一个非降的序列，那么也就是说，队列内部是有序的，且队列之间也是有序的，所以每一个双端队列都是原整数序列排序后的一段连续区间。<br />
那么由于是双端队列，所以这个连续区间要求其关于原序列的位置编号是先下降再上升的。贪心地选取。<br />
注意有数值相同的情况，把它们放在一起考虑，记录最大位置和最小位置来考虑。

<h2>[BJWC2011]神秘好人</h2>

线段树维护两边端点之间的最小值。

<h2>[BJWC2011]符环</h2>

考虑括号匹配的方式，把前后断开，那么前面只能多出未匹配的左括号，而后面只能多出未匹配的右括号，故设 F[i][j][k][l] 表示当前在第 i 格，前半部分多出来的未匹配的左括号为 j 个，后半部分多出来的未匹配的左括号为 k 个，右括号为 l 个。转移的时候呀，前面要求右括号不能超过左括号的个数，而后面的右括号优先与左括号匹配，否则才计入 l 中。最后枚举前面多多少个左括号统计答案。

<h2>[CQOI2011]分金币</h2>

设$C _ i$表示$i$给$i+1$的金币数，设每一个人最后得到的金币数为$S$，初始金币数为$A _ i$，那么对于第$i$个人有$A _ i+C _ {i-1}-C _ i$，设$x=C _ 1$，那么剩下的$C$都可以用$x$来表示，即$C _ i=x+\sum _ {j=2}^i A _ j-(i-1)S$，那么我们要最小化的就是$\sum |C _ i|$。相当于是多个一次函数取绝对值的和最小值，求出中位数即可。

<h2>[CQOI2011]动态逆序对</h2>

把时间也看作一维，求出删掉每个点减去的贡献， CDQ 分治。

<h2>[CQOI2011]放棋子</h2>

若知道了对于某一种颜色的棋子 x ，刚好占据 i 行 j 列的方案数为 $G[x][i][j]$ ，则若设 $F[x][i][j]$ 表示前 x 种金币刚好占据 i 行 j 列的方案数，可以得到一个较简单的 DP $F[x][i][j]=\sum _ {p,q}F[x-1][p][q] \times G[x][i-p][j-q] \times C[i][p] C[j][q]$ 。<br />
如何得到 G[x][i][j] 呢，可以采用容斥的方式，有 $G[x][i][j]=C[ij][Cnt[x]] - \sum _ {p,q}G[x][p][q] \times C[i][p]C[j][q]$ 。

<h2>[HAOI2011]向量</h2>

有用的向量只有 (a,b),(a,-b),(b,a),(a,-b) 这四个，分别设四个的参数为 k,w,q,c ，可以得到两个方程 (k+w)a+(q+c)b=x,(k-w)b+(q-c)a=y ，根据裴蜀定理， 方程 ax+by=c 有整数解当且仅当 gcd(a,b)|c ，但是 (k+w) 有整数解并不一定代表着 k,w 也有整数解，对于 (q+c) 同理，那么要求 (k+w),(k-w) 同奇偶， (q+c),(q-c) 同奇偶，对于 gcd 讨论一下，四种情况只要有一种满足即有解。

<h2>[HAOI2011]防线修建</h2>

倒着做，相当于每次在当前的上凸壳上加上一个点。如果本来就被包含，就不用管理，否则加入这个点然后向两边弹出不合法的。周长可以实时维护。

<h2>[HAOI2011]problem a</h2>

通过每个人可以得到一个区间表示该区间内的人分数相同。那么问题转化为在若干个带权区间中选择不相交的若干使得权值之和最大。线段树优化 DP 。

<h2>[HAOI2011]Problem b</h2>

莫比乌斯反演。注意 n,m, 不同所以最好容斥一下。

<h2>[HAOI2011]Problem c</h2>

归纳可得，若记 Sum[i] 表示编号小于等于 i 的人的数量，当出现任意一个 Sum[i]&lt;i 的时候，一定不合法。开始的时候没有编号的人可以看作是编号为 0 ,统计一遍编号已经确定了的人的前缀和，判断是否已经无解，否则一定有解。<br />
接下来的问题就只要求合法方案数了，设 F[i][j] 表示编号小于等于 i 的人有 j 个的方案数，那么从 i-1 转移过来的时候枚举 k 表示有 k 人编号为 i 。注意这里 j 和 k 的枚举上下界， 由于 Sum[i] 要大于等于 i ，故 j 下界为 i 上界为 n ；记已经确定编号一定为 i 的人有 num[i] 个，则 k 的枚举下界为 num[i] 上界为 sum[i] 。转移的时候，由于没有确定的人都是相同的，所以要乘以组合数 C[sum[i]-j+num[i]-k][num[i]-k] 得到方案数，前面一项即代表的剩余自由人的数量，而第二项则是需要选择的自由人个数。

<h2>[HNOI2011]XOR和路径</h2>

直接求 xor 的期望无法做到很方便的计算，那么就对每一位分开来做。设为 1 的概率为 P[i] ，那么看边是 0 还是 1 建立方程，然后高斯消元。

<h2>[HNOI2011]任务调度</h2>

首先把在 A,B 都可以运行的确定一个运行位置，然后模拟退火，每次贪心得到解。

<h2>[HNOI2011]勾股定理</h2>

首先把合法的勾股数对拿出来，这不会太多。那么相当与是求一张图上独立集的个数。考虑如果是树的话，直接设 F[i][0/1] Dp 转移即可。但是在图上的话，先把图上的所有返祖边拿出来，暴力枚举这些边的两边是选择哪一个。
复杂度是假的，要知道图的独立集个数是 NP 的。

<h2>[HNOI2011]卡农</h2>

先把排列顺序考虑进去，设 F[i] 表示当有 i 个片段时的方案数。因为当前 i-1 个片段都确定的时候，由于要求任意每一个音阶的出现次数为偶数，所以第 i 个其实是确定的。若不考虑第 i 个与之前的重复或者第 i 个为空集的情况，  记 $N=2 ^ n-1$ ，则 F[i]=A[N][i-1] 。<br />
然后要把上面提到的两种不合法情况减去。首先是空集的情况，意味着 i-1 个片段已经满足了每一种的出现次数都为偶数，即 F[i-1] ；然后是第 i 个与前面 i-1 个重复的情况，因为两者一样，所以同时去掉两个之后，依然满足每一种的出现次数为偶数，即 F[i-1] 。与 i 重复的那个元素有 i-1 个位置可以放，同时有 N-(i-2) 中集合的选择。所以综上可以得到递推式 F[i]=A[N][i-1]-F[i-1]-F[i-1] * (i-1)(N-i+2) 。最后再除以 m! 就是除去顺序的方案数。

<h2>[HNOI2011]括号修复 / [JSOI2011]括号序列</h2>

Splay 搞搞

<h2>[HNOI2011]数学作业</h2>

分段矩乘

<h2>[HNOI2011]数矩形</h2>

把每一对点放在他们的中点上。枚举中点，把距离中点相同的枚举一下，组合答案。

<h2>[HNOI2011]赛车游戏</h2>

乱搞贪心。先把假设速度为 0 的费用算了，然后用堆每次取出一个最小的速度，把它提到与第二小一样，然后合并。

<h2>[JLOI2011]飞行路线</h2>

分层图最短路

<h2>[JSOI2011]序的计数</h2>

首先把 K 个点单独拿出来，并全部连向一个虚拟节点  K+1 ，这样强制  K+1 为第一个走的点就可以得到所有的 dfs 序了。设 F[i][S] 表示当前在 i ，经过的点集为 S 的 dfs 序数。由于 dfs 转移的时候，进入一棵子树，如果需要回溯的话一定是从这棵子树里转移出来了，那么提前预处理 G[i][S] 表示当前在 i ，经过的点集为 S ，接下来要经过的点的集合是哪些。转移的时候，进入子树就直接从 G 得到转移的系数。需要注意的是，当某棵子树内存在连向不在 K 个点中的边时，不能再向外转移，因为此时是不能回溯的。

<h2>[JSOI2011]柠檬</h2>

如果一个位置要与前面合并，一定是选择与当前颜色一样的最优。有方程，$F[i]=max(F[j]+A[i] * (S[i]-S[j]+1)^2)\quad$ 其中A[i]是i处的大小，j是i前面一个与i同大小的柠檬
由于$S[i]$都是非负的，所以我们可以发现，当决策点$j$不动的时候，随着$i$的增大，$(S[i]-S[j]+1)^2$这个值会增长得越来越快。由于二次函数的性质，S[j]更小的j虽然一开始可能比更大的j劣，但它增长得更快，所以决策点是向左移动的。

<h2>[JSOI2011]分特产</h2>

考虑容斥，所有同学都至少有一个的方案数=总方案数-至少有一个没有+至少有两个没有-至少有三个没有。计算至少有 i 个没有的时候，从 n 个同学中选出 i 个人，即 C[n][i] ；把每一种特产 num 分成可以为空的 n-i 组，方案就是 C[num+(n-i)-1][n-i-1] ，累加计数。

<h2>[JSOI2011]棒棒糖</h2>

区间众数，那么离线下来枚举右端点维护左端点的答案。

<h2>[JSOI2011]任务调度</h2>

可并堆模拟一下。

<h2>[SCOI2011]地板</h2>

考虑一个 L 型，转换成插头相当于若干横向插头+竖插头，然后中间一个转折点。那么先把列交换成小的那一维，然后插头 DP ,每一次有 m 个纵向插头和一个横向插头，设 0/1/2 分别表示没有插头，有一个未转向的插头和有一个已经转向的插头，讨论 6 种情况转移。

<h2>[SCOI2011]棘手的操作</h2>

可并堆搞搞

<h2>[SCOI2011]糖果</h2>

差分约数的做法实际上是假的，因为 spfa 复杂度太高。正确姿势是先把有等于号的边连上，tarjan 缩点得到应该相等的点，然后再连边 DAG 上 DP 。

<h2>[SCOI2011]飞镖</h2>

分类讨论题，首先讨论不包括红心的情况。<br />
可以证明，如果前两张牌是 2a+3b 的形式，可以凑出 [1,2a+3b] 中除了 2a+3b-1 的所有数，同时若让第三张尽量地大，那么就判断能否用这种方式凑出来 x-2k 。然后如果还需要更大，只能是 3a+3b 的形式，这样一定是 3 的倍数，枚举最后那个 2k 的最大的 k 满足使得 x-2k 是 3 的倍数，若此时 x-2k&lt;=6k ，说明有解。<br />
然后把红心考虑进去，总共分为六种情况。<br />
第一类：m,i,i 和 2m,i,i ，首先减去 m/2m ，剩下的转换为判断 i,i 其中要求一个是 2 的倍数，那么类似上面，判 2a+3b 的形式<br />
第二类：m,m,i 和 m,2m,i 和 2m,2m,i ，首先同样还是减去若干个 m ，然后判断剩下的 i 是否是 2 的倍数。<br />
第三类：i,i,2m，减掉 2m 后，剩下的判 2a+3b 或 3a+3b<br />
第四类：m,i,2m 和 2m,i,2m，减去 m 的相关项，剩下的判断是否小于等于 K ，否则是否是 2 的倍数并小于等于 2K ，否则是否是 3 的倍数并小于等于 3K 。<br />
第五类：m,m,2m 和 m,2m,2m 和 2m,2m,2m ，直接判断是否为 4m,5m,6m 。

<h2>[SDOI2011]打地鼠</h2>

行列分开，对每一行和每一列单独求出可行的最大解，然后求出行和列分别的 gcd 即为答案。因为如果 i 有解那么 i 的约数也一定有解，并且反过来能成为解的一定是最大的可行解 x 的约数。求的时候，枚举宽度或长度，然后从第一个位置开始构造，前缀和得到每一个的操作次数，从而判断是否合法。

<h2>[SDOI2011]计算器</h2>

快速幂+逆元+BSGS

<h2>[SDOI2011]染色</h2>

树链剖分+线段树，注意一下标记合并的顺序

<h2>[SDOI2011]拦截导弹</h2>

每一个导弹被消除的概率就是在所有合法方案中，它出现的次数/总方案数。那么求出包含每个点的方案数。由于转移是个 DAG ，相当于是求经过某一个点的路径条数，那么前后两边二维数点求和再求积。

<h2>[SDOI2011]工作安排</h2>

费用流建模

<h2>[SDOI2011]黑白棋</h2>

题目需要加上限制 A 只能向右移动， B 只能向左移动。那么由于 A,B 是相间的，每一对黑白棋子可以看作是一个石子堆，每次相当于是在最多 D 堆石子中选取，由 Nimk 游戏知道，先手必败当且仅当石子堆的二进制的每一位之和都是 D+1 的倍数。那么现在的问题就是选出若干堆石子使得二进制的每一位之和都是 D+1 的倍数。<br />
动态规划，设 $F[i][j]$ 表示现在从低到高 DP 到第 i 位，已经选择了 j 枚石子使得二进制每一位之和都是 D+1 的倍数的方案数，枚举一个 k 表示这一次要让 k(d+1) 堆石子在这一二进制上有 1 ，那么这样就可以满足限制。由于石子是无序的，所以需要乘以一个组合数 C(堆数，这一次选择的堆数) 。<br />
最后统计答案。注意在中间的计算过程与最后统计答案的时候要时刻注意不能超过石子数的上界 n 。这样得到的就是先手必败的方案数，用全部的方案数 C(n,K) 减去必败的就是先手必胜的了。

<h2>[SDOI2011]消防</h2>

看到这种树上路径最值就要想到直径。<br />
可以证明是放在直径上，然后尺取区间，两边的相当于是取树中最深的，而中间则是取区间最大值，两边的可以提前预处理一下，而中间的就可以用单调队列来维护了。

<h2>[SDOI2011]保密</h2>

最优化比值，那就分数规划。
但是不能直接分数规划，因为求的是若干个比值的和最小。但同时注意到每个出入口的答案是独立的，那么就分别分数规划+最短路求出到达每一个出入口的最小危险性。然后问题就转化为一个二分图，求最小权点覆盖。费用流建模即可。

<h2>[SDOI2011]消耗战</h2>

如果是单次询问就树型 DP 即可。多次询问就建出虚树 DP 。

<h2>[SHOI2011]双倍回文</h2>

一个回文串要求双倍回文也就是说其一半的地方也应该是回文串，增量构建回文自动机，同时维护 fail 树的倍增数组，找到长度为一半的地方看是否存在这样的回文串。

<h2>[TJOI2011]书架</h2>

容易想到一个 $O(n^2)$ 的 DP ，设 F[i] 表示前 i 本书的最小层宽度之和，则 F[i]=min(F[j]+max(Bk[j+1..i])) 。每一次增量一个点，相当于是修改前面某一段区间的最大值，然后求这个最大值与 F 的和区间最小值。用线段树来维护这个信息，每个节点维护 mnkey 表示区间最小答案，mn 表示区间最小的 F 值，lz 表示区间最大值覆盖懒标记。而需要更新的区间可以用一个单调队列得到。

<h2>[TJOI2011]树的序</h2>

直接建立出二叉搜索树的最坏复杂度是 $O(n^2)$ 的，由于这里要求生成序列的字典序最小，所以考虑直接构造出解。同样的一棵二叉查找树的中序遍历是相同的，那么就把序列按照键值排序，以原下标作为小根堆参数，构建笛卡尔树。由于笛卡尔树的中序遍历已经能够满足与原二叉查找树相同，那么笛卡尔树的先序遍历就是最小的生成序列。

<h2>[ZJOI2011]最小割</h2>

最小割树

<h2>[ZJOI2011]看电影</h2>

根据概率=合法方案/总方案，首先可以知道总方案是$K^N$，那么关键在于如何求出合法方案。<br />
考虑添加一个空座位使得所有的座位成为一个环，那么方案数为$(K+1)^N$，由于是环，每一种方案被算了$K+1$次，所以要除掉一个$K+1$，即$(K+1)^{N-1}$。再从环中去掉一个空座位变成一个合法的序列，环中有$K-N+1$个空座位，那么就是$(K+1)^{N-1}(K-N+1)$，所以答案为$\frac{(K+1)^{N-1}(K-N+1)}{K^N}$。由于$K,N$均不超过$200$，所以直接分解质因数，然后再高精度求积。

<h2>[ZJOI2011]礼物</h2>

枚举行列相同的那一维是哪一个面，然后单调队列得到每一个点的最大延伸宽度，接下来的问题就是求序列上区间长度乘以区间最小值最大了，求出每一个值的最大值覆盖范围，这个也可以单调队列，然后组合但。

<h2>[ZJOI2011]细胞</h2>

质量的限制实际上是没用的，因为不会有相同的情况发生。<br />
先考虑如果最后分出来 m 个小球，有多少种断链的方式。设 F[i][0/1] 表示前 i 条链，第 i 条链是否断开的方案数，则容易得到递推 F[i][0]=F[i-1][1],F[i][1]=F[i-1][0]+F[i-1][1] ，合并一下得到 F[i][1]=F[i-1][1]+F[i-2][1] ，最后需要的便是 F[n-1][1] 因为最后的一定要割，发现其实就是斐波那契数。<br />
如果设 Fab[1]=Fab[2]=1 ，则答案就为 F[m-2] ，因为两边的是一定要去掉的。<br />
但是，由于不知道 m ，而直接求 m 的话方案数过大，甚至无法用矩阵快速幂，所以考虑一位一位地进行，设 G[i] 表示从高位到低位的第 i 位，则枚举前面的一个 j-1 让 [j..i] 形成一个在第一次分裂中的完整的数，则 $G[i]=\sum G[j-1] \times Fab[num _ {j..i}]$，关键就在于 $Fab[num _ {j..i}]$ 怎么求，可以预处理一个十进制的斐波那契矩阵以方便快速幂，让 j 从 i 枚举到 1，这样实时维护 j..i 的值，每次移动 j 的时候相当于补充一个最高位，直接作快速幂。<br />
需要注意，由于矩阵乘法不具有交换律，所以要时刻注意矩阵的乘法顺序。<br />
为了方便最后不要求 n-2 ，可以把 G[0] 设置实际的 G[1] 的 -2 次方为 $[1,1] ^ {-2}$  即 $[1,0]$。

<h2>[ZJOI2011]营救皮卡丘</h2>

只能从小标号走到大标号，这个构成了一个 DAG 。预处理两点之间只经过不超过当前标号的点的最短路，在这个图上跑费用流。

<h2>[ZJOI2011]道馆之战</h2>

类似堵塞的交通的做法，线段树维护两边端点之间的连通性以及最长路，同时维护两边端点能延伸出去的最长距离，这样就可以得到最长路了。由于是在树上的，所以再套一个树链剖分。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>977</wp:post_id>
		<wp:post_date><![CDATA[2018-10-21 21:29:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-21 13:29:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2011-%e5%b9%b4%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89%e9%80%89%e5%81%9a]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%bb%bc%e5%90%88"><![CDATA[综合]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[specs_zan]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[custom_permalink]]></wp:meta_key>
			<wp:meta_value><![CDATA[%E7%9C%81%E9%80%89/2011]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[355]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>170</wp:comment_id>
			<wp:comment_author><![CDATA[Cyhlnj]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1806599497@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjoieryl</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-22 16:07:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-22 08:07:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[鸽子syc更博了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>171</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-22 17:15:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-22 09:15:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[鸽子syc更博了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>172</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-22 21:04:40]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-22 13:04:40]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[鸽子syc更博了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>「ZJOI2010」贪吃的老鼠-二分+最大流</title>
		<link>http://sycstudio.com/archives/979</link>
		<pubDate>Sat, 20 Oct 2018 13:12:12 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=979</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

有 $m$ 个老鼠，$m$块奶酪，第$i$块奶酪耐久度为$p_i$，要求在时间$[l_i,r_i]$内吃完。第$j$个老鼠每秒可以吃$s_j$蛋糕。要求保证

<ol>
<li>在任一时刻，一只老鼠最多可以吃一块奶酪。</li>
<li>在任一时刻，一块奶酪最多被一只老鼠吃。</li>
</ol>

可以施加一次魔法，使得每块奶酪的$r_i$延长$T$,求最小的$T$。

<h1>Solution</h1>

很容易想到二分$T$.

$S$向蛋糕连边，容量为$p_i$。

考虑时间线上只会发生两种事件：一块蛋糕可以被吃或者一块蛋糕变质，而只有当发生了某种事件后老鼠吃蛋糕的状态才会改变。所以可以把时间划分为$2 \times m$段，每段时间内每个老鼠向它能吃的蛋糕连边，同时每个老鼠向$T$连$tim \times s_i$容量的边。

但是这样没有考虑题目要求的两个条件。

这时可以把老鼠吃的速度再拆点。把$S$从大到小排序做差分，老鼠到蛋糕的边容量为$d_i \times tim$。老鼠到$T$的容量为$i \times d_i \times tim$。这样当老鼠$x$吃了蛋糕$Y$，则$x~m$的点到$y$都会有$d_i$的流量。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const double eps = 1e-6, Inf = 1e20;
const int maxn = 35;

int n, m, L[maxn], R[maxn], p[maxn], s[maxn];
long long sum;

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int dcmp(double a)
{
    if (-eps &lt; a &amp;&amp; a &lt; eps) return 0;
    else if (a &gt; 0) return 1;
    else return -1;
}

const int Maxn = 3005, Maxm = 100005;

struct edge {
    int to, next;
    double cap;
} e[Maxm * 2];
int h[Maxn], cur[Maxn], cnt, tot, S, T;

inline void add(int u, int v, double w)
{
    e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
    e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
}

bool vis[Maxn];
int q[Maxn], d[Maxn];
inline bool bfs()
{
    static int l, r;
    l = 0; q[r = 1] = S; vis[S] = 1;
    while (l &lt; r) {
        int u = q[++l];
        for (int i = h[u], v; v = e[i].to, ~i; i = e[i].next)
            if (dcmp(e[i].cap) &gt; 0 &amp;&amp; !vis[v]) {
                d[v] = d[u] + 1;
                vis[v] = 1; q[++r] = v;
            }
    }
    return vis[T];
}

double dfs(int u, double a)
{
    if (u == T || !dcmp(a)) return a;
    double flow, f = 0;
    for (int &amp;i = cur[u], v; v = e[i].to, ~i; i = e[i].next)
        if (d[v] == d[u] + 1 &amp;&amp; dcmp(flow = dfs(v, min(a, e[i].cap))) &gt; 0) {
            e[i].cap -= flow; e[i ^ 1].cap += flow;
            f += flow; a -= flow;
            if (!dcmp(a)) break;
        }
    return f;
}

double dinic()
{
    double sum = 0;
    memset(vis, 0, sizeof(bool) * (cnt + 1));
    while (bfs()) {
        memset(vis, 0, sizeof(bool) * (cnt + 1));
        memcpy(cur, h, sizeof(int) * (cnt + 1));
        sum += dfs(S, Inf);
    }
    return sum;
}

double t[maxn * 2];
inline bool check(double x)
{
    memset(h, -1, sizeof(h)); tot = -1;
    for (int i = 1; i &lt;= n; ++i) {
        t[(i &lt;&lt; 1) - 1] = L[i]; t[(i &lt;&lt; 1)] = R[i] + x;
    }
    sort(t + 1, t + (n &lt;&lt; 1) + 1);

    S = 1; T = 2; cnt = 2;
    for (int i = 1; i &lt;= n; ++i) add(S, ++cnt, p[i]);
    for (int rat = 1; rat &lt;= m; ++rat) 
        for (int i = 2; i &lt;= (n &lt;&lt; 1); ++i) {
            if (!dcmp(t[i] - t[i - 1])) continue;
            ++cnt;
            add(cnt, T, rat * s[rat] * (t[i] - t[i - 1]));
            for (int j = 1; j &lt;= n; ++j)
                if (dcmp(L[j] - t[i - 1]) &lt;= 0 &amp;&amp; dcmp(R[j] + x - t[i]) &gt;= 0)
                    add(j + 2, cnt, s[rat] * (t[i] - t[i - 1]));
        }

    if (dcmp(sum - dinic()) &lt;= 0) return 1;
    return 0;
}

int main()
{
    freopen("mouse.in", "r", stdin);
    freopen("mouse.out", "w", stdout);

    int T = gi();
    while (T--) {
        n = gi(); m = gi(); sum = 0;
        for (int i = 1; i &lt;= n; ++i) p[i] = gi(), L[i] = gi(), R[i] = gi(), sum += p[i];
        for (int i = 1; i &lt;= m; ++i) s[i] = gi();
        sort(s + 1, s + m + 1, greater&lt;int&gt;());
        s[m + 1] = 0;
        for (int i = 1; i &lt;= m; ++i) s[i] = s[i] - s[i + 1];

        double l = 0, r = 1e9, mid;
        while (dcmp(l - r)) {
            mid = (l + r) / 2;
            if (check(mid)) r = mid;
            else l = mid;
        }

        printf("%.4lf\n", l);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>979</wp:post_id>
		<wp:post_date><![CDATA[2018-10-20 21:12:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-20 13:12:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8czjoi2010%e3%80%8d%e8%b4%aa%e5%90%83%e7%9a%84%e8%80%81%e9%bc%a0-%e4%ba%8c%e5%88%86%e6%9c%80%e5%a4%a7%e6%b5%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[128]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>168</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.1.189]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-20 22:47:56]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-20 14:47:56]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嘿，Latex 可以用了吧]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>169</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-10-22 14:06:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-10-22 06:06:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[可以呀]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>168</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>「Codechef」PRUNING-树形DP</title>
		<link>http://sycstudio.com/archives/992</link>
		<pubDate>Thu, 25 Oct 2018 06:16:02 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=992</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一棵树，要求砍去边权总和最小的边，使得这分割出的每棵树满足：

在这棵树能找到一个点，使得其他点到它的距离 $\leq d$。

$n \leq 100, d \leq 10^7$

<h1>Solution</h1>

考虑如何合并两个合法的状态，肯定与这两个子树中最深的点有关。

设 $f_{i,j,k}$ 表示在原树中以$i$为根的子树，当前选定为根的节点是$j$，最深的节点是$k$的最小删除边权。

每次合并两个合法的状态得到新的合法状态即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 105, Inf = 1 &lt;&lt; 30;

int n, d, ans;

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

struct edge {
    int to, next, w;
} e[maxn * 2];
int h[maxn], tot;

inline void add(int u, int v, int w)
{
    e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
    e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
}

#define dis(u, v) (dep[u] + dep[v] - (dep[lca[u][v]] &lt;&lt; 1))

inline void chkmin(int &amp;a, int b)
{
    if (a &gt; b) a = b;
}

int siz[maxn], p[maxn][maxn], lca[maxn][maxn], tmp[maxn][maxn], f[maxn][maxn][maxn], dep[maxn];
void dfs(int u, int fa)
{
    siz[u] = 1; p[u][1] = u;
    f[u][1][1] = 0;
    for (int i = h[u], v, weight; v = e[i].to, i; i = e[i].next)
        if (v != fa) {
            dep[v] = dep[u] + e[i].w; weight = e[i].w;
            dfs(v, u);

            for (int i = 1; i &lt;= siz[u]; ++i)
                for (int j = 1; j &lt;= siz[v]; ++j)
                    lca[p[u][i]][p[v][j]] = lca[p[v][j]][p[u][i]] = u;

            for (int i = 1; i &lt;= siz[u] + siz[v]; ++i)
                for (int j = 1; j &lt;= siz[u] + siz[v]; ++j)
                    tmp[i][j] = Inf;

            for (int i = 1; i &lt;= siz[u]; ++i)
                for (int j = 1; j &lt;= siz[u]; ++j) {
                    if (f[u][i][j] &gt;= Inf) continue;
                    for (int a = 1; a &lt;= siz[v]; ++a)
                        for (int b = 1; b &lt;= siz[v]; ++b) {
                            if (f[v][a][b] &gt;= Inf) continue;
                            chkmin(tmp[i][j], f[u][i][j] + f[v][a][b] + weight);
                            if (dis(p[u][i], p[v][b]) &lt;= d) {
                                if (dep[p[u][j]] &gt; dep[p[v][b]]) chkmin(tmp[i][j], f[u][i][j] + f[v][a][b]);
                                else chkmin(tmp[i][b + siz[u]], f[u][i][j] + f[v][a][b]);
                            }
                            if (dis(p[v][a], p[u][j]) &lt;= d) {
                                if (dep[p[u][j]] &gt; dep[p[v][b]]) chkmin(tmp[a + siz[u]][j], f[u][i][j] + f[v][a][b]);
                                else chkmin(tmp[a + siz[u]][b + siz[u]], f[u][i][j] + f[v][a][b]);
                            }
                        }
                }

            for (int i = 1; i &lt;= siz[u] + siz[v]; ++i)
                for (int j = 1; j &lt;= siz[u] + siz[v]; ++j)
                    f[u][i][j] = tmp[i][j];
            for (int i = 1; i &lt;= siz[v]; ++i) p[u][siz[u] + i] = p[v][i];
            siz[u] += siz[v];
        }
}

int main()
{
    int T = gi();
    while (T--) {
        tot = 0; memset(h + 1, 0, sizeof(int) * n);
        n = gi(); d = gi(); ans = 0;
        for (int u, v, w, i = 1; i &lt; n; ++i) {
            u = gi() + 1; v = gi() + 1; w = gi();
            add(u, v, w);
            ans += w;
        }

        for (int i = 1; i &lt;= n; ++i) lca[i][i] = i;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= n; ++j)
                for (int k = 1; k &lt;= n; ++k)
                    f[i][j][k] = Inf;
        dfs(1, 0);

        int Min = Inf;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= n; ++j)
                chkmin(Min, f[1][i][j]);

        printf("%d\n", ans - Min);

    }

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>992</wp:post_id>
		<wp:post_date><![CDATA[2018-10-25 14:16:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-25 06:16:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8ccodechef%e3%80%8dpruning-%e6%a0%91%e5%bd%a2dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codechef"><![CDATA[Codechef]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[124]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「Codechef」STREDUC-DP</title>
		<link>http://sycstudio.com/archives/995</link>
		<pubDate>Thu, 25 Oct 2018 08:54:19 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=995</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一个字符串 $s$ 和一个字符串集合，每次操作是在$s$中找到一个在字符串集合出现过的子串，然后删去这个子串。剩下的串会拼在一起。

求删去后的最短串 $s$。

<h1>Solution</h1>

首先为了方便，将给定的字符串集合构一棵$Trie$树。

设 $f_{i,j,k}$ 表示下标为 $[i,j]$ 的子串，目前未被删去的部分在字典树上的节点为 $k$,  $w_{i,j}$表示下标为 $[i,j]$ 的子串是否能被消掉。

有两种转移。

$$f_{i,j,k}=f_{i,l-1,k} | (w[l][j]=true)$$

$$f_{i,j,ch[k][c]}=f_{i,j-1,k}$$

第一种转移表示消去$w[l][j]$的一段，第二种转移表示不消去任何子串，添加一个字符。

当$k$代表一个字符串集合中的串时，$w_{i,j}=true$

最后写一个$O(n^2)$的DP即可。

<strong>p.s:</strong> 由于第一种转移复杂度较高，要用bitset优化。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 265, maxt = 615;

char s[maxt], t[maxt];
int n, m;
bitset&lt;maxt&gt; f[maxn][maxn]; 
int g[maxn], w[maxn][maxn];

int ch[maxt][26], tot, vis[maxt], d[maxt];
void insert(char *t)
{
    int len = strlen(t + 1), u = 0;
    for (int i = 1; i &lt;= len; ++i) {
        int c = t[i] - 'a';
        if (!ch[u][c]) ch[u][c] = ++tot, d[tot] = d[u] + 1;
        u = ch[u][c];
    }
    vis[u] = 1;
}

int main()
{
    scanf("%s\n", s + 1); n = strlen(s + 1);
    scanf("%d", &amp;m);
    for (int i = 1; i &lt;= m; ++i) {
        scanf("%s\n", t + 1);
        insert(t);
    }

    for (int i = n; i; --i) {
        f[i][i - 1].set(0);;
        for (int j = i; j &lt;= n; ++j) {
            for (int k = i + 1; k &lt;= j; ++k)
                if (w[k][j]) f[i][j] |= f[i][k - 1];
            int c = s[j] - 'a';
            for (int k = 0; k &lt;= tot; ++k)
                if (f[i][j - 1][k]) {
                    int x = ch[k][c];
                    if (vis[x]) f[i][j].set(0);
                    if (x) f[i][j].set(x);
                }
            if (f[i][j][0]) w[i][j] = 1;
        }
    }

    for (int i = 1; i &lt;= n; ++i) {
        g[i] = g[i - 1] + 1;
        for (int j = 1; j &lt;= i; ++j)
            if (w[j][i]) g[i] = min(g[i], g[j - 1]);
    }

    printf("%d\n", g[n]);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>995</wp:post_id>
		<wp:post_date><![CDATA[2018-10-25 16:54:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-25 08:54:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8ccodechef%e3%80%8dstreduc-dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[103]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Vnote online mirror.</title>
		<link>http://sycstudio.com/archives/1000</link>
		<pubDate>Sun, 25 Nov 2018 11:09:27 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1000</guid>
		<description></description>
		<content:encoded><![CDATA[The vnote online mirror on sycstudio.com now completed.

Vnote 在线版本现已登录 sycstudio.com 。

You can visit <a href="http://sycstudio.com/vnote">vnote</a> to learn the latest notes posts by SYCstudio.

你可以通过 <a href="http://sycstudio.com/vnote">这里</a> 访问博主的最新文章。

Because of the technical reason, this webside may not usually the latest version. I will upgrade it maybe once a week.

由于技术上的原因，这里或许不会是最新版本。但博主会尽量保证每周一更。

To learn more, please visit <a href="https://github.com/SYCstudio/VNote">Github</a>.

可以到 <a href="https://github.com/SYCstudio/VNote">Github</a> 了解更多信息。

At last, thanks to @tamlok for his fantastic <a href="https://github.com/tamlok/vnote/">Vnote</a> and <a href="https://github.com/tamlok/viki">Viki</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1000</wp:post_id>
		<wp:post_date><![CDATA[2018-11-25 19:09:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-25 11:09:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[vnote-online-mirror]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[54]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「Codeforces 1080F」Katya and Segments Sets-主席树</title>
		<link>http://sycstudio.com/archives/1005</link>
		<pubDate>Tue, 27 Nov 2018 03:54:46 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1005</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定$n$个线段集，求$[a,b]$中的每个线段集中是否都存在一条线段$[l,r]$满足$[l,r] \in [x,y]$。

<h1>Solution</h1>

用主席树维护将所有左端点 $\leq x$ 的线段插入后，每个集合的右端点的最小值的最大值。

查询时判断$[a,b]$的最大右端点是否小于等于$y$即可。

<pre><code class="language-cpp ">#include&lt;bits/stdc++.h&gt;
#define mid ((l+r)&gt;&gt;1)
using namespace std;
const int N=3e5+10,M=2e7+10,inf=0x3f3f3f3f;

int n,m,K,mn[N],st[N];
int rt[N],ls[M],rs[M],vl[M],cnt;

struct P{
    int l,r,p;
    inline void ini(){scanf("%d%d%d",&amp;l,&amp;r,&amp;p);}
    bool operator&lt;(const P&amp;ky)const{
         return l&lt;ky.l;
    }
}le[N];

void mk(int pre,int &amp;k,int l,int r,int pos,int vv)
{
    if(k==pre){k=++cnt;ls[k]=ls[pre];rs[k]=rs[pre];}
    if(l==r) {vl[k]=vv;return;}
    if(pos&lt;=mid) mk(ls[pre],ls[k],l,mid,pos,vv);
    else mk(rs[pre],rs[k],mid+1,r,pos,vv);
    vl[k]=max(vl[ls[k]],vl[rs[k]]);
}

int ask(int k,int l,int r,int L,int R)
{
    if(!k) return inf;
    if(L&lt;=l &amp;&amp; r&lt;=R) return vl[k];
    if(R&lt;=mid) return ask(ls[k],l,mid,L,R);
    if(L&gt;mid) return ask(rs[k],mid+1,r,L,R);
    return max(ask(ls[k],l,mid,L,R),ask(rs[k],mid+1,r,L,R));
}

int main(){
     int i,j,a,b,x,y,re;vl[0]=inf;
     memset(mn,0x3f,sizeof(mn));
     scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
     for(i=1;i&lt;=K;++i) le[i].ini();
     sort(le+1,le+K+1);
     for(i=1;i&lt;=K;++i) st[i]=le[i].l;
     for(i=K;i;--i){
        rt[i]=rt[i+1];
        if(le[i].r&lt;mn[le[i].p]){
            mk(rt[i+1],rt[i],1,n,le[i].p,le[i].r);
            mn[le[i].p]=le[i].r;
        }
     }st[K+1]=inf;
     for(;m;--m){
        scanf("%d%d%d%d",&amp;a,&amp;b,&amp;x,&amp;y);
        re=lower_bound(st+1,st+K+2,x)-st;
        if(re==K+1) re=inf;
        else re=ask(rt[re],1,n,a,b);
        puts(re&lt;=y?"yes":"no");
        fflush(stdout);
     }
     return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1005</wp:post_id>
		<wp:post_date><![CDATA[2018-11-27 11:54:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-27 03:54:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8ccodeforces-1080f%e3%80%8dkatya-and-segments-sets-%e4%b8%bb%e5%b8%ad%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeforces"><![CDATA[Codeforces]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[73]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「nowcoder 271C」左方之地-概率期望</title>
		<link>http://sycstudio.com/archives/1009</link>
		<pubDate>Wed, 28 Nov 2018 07:31:08 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1009</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

左方之地是全宇宙最帅的男人，由于有人嫉妒他的帅气，他决定出一道题考一考这些嫉妒他帅气的人。

左方之地现在手上有$n$件不同的灵装，第$i$件灵装有一个帅气值$a_i$ ，现在他将灵装随机摆成一个排列，并将这个排列映射到一棵二叉树上，这棵二叉树的中序遍历是原排列，且每一个节点上的灵装编号都要小于其子树中的所有点的灵装编号。可以证明对于一个排列，这样的二叉树的形态是唯一的。

这棵树会产生一个总的帅气值等价于树上每个节点的灵装的帅气值乘上该节点的深度（根节点的深度为$1$）之和，左方之地想让你求出期望能获得的总帅气值在膜$998244353$意义下的结果是多少

<h1>Solution</h1>

题意可以转化为对$1-n$随机排列，以原排列为$key$，随机后的排列为$value$的笛卡尔树上的深度乘权值的期望。根据期望的线性性：

$$dep_i=\sum_j[j \ \ is \ \ an \ \ ancestor \ \ of \ \ i]$$

设随机后的排列为$p$,考虑在笛卡尔树$i$为$j$的祖先当且仅当$p_i$是区间$[i,j]$中是最小的元素。反过来考虑即$i$是区间$[p_i,p_j]$中是最小的元素。只考虑不大于$i$小的元素，先插入比$i$小的元素再插入$i$和$j$。由于只有$i+1$个空位，所以概率是$\frac{2}{i+1}$。所以

$$ ans=\sum a_i + \frac {2} {i+1} \sum_{j>i} a_j $$

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 100005, mod = 998244353;

int n, a[maxn];

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int pow(int x, int k)
{
    int res = 1;
    while (k) {
        if (k &amp; 1) res = (lint)res * x % mod;
        x = (lint)x * x % mod; k &gt;&gt;= 1;
    }
    return res;
}

int main()
{
    n = gi();
    for (int i = 1; i &lt;= n; ++i) a[i] = gi();
    sort(a + 1, a + n + 1);

    for (int i = 1; i &lt;= n; ++i) {
        a[i] += a[i - 1];
        if (a[i] &gt;= mod) a[i] -= mod;
    }

    int ans = a[n];
    for (int i = 1; i &lt; n; ++i) {
        ans += (lint)2 * pow(i + 1, mod - 2) % mod * (a[n] - a[i] + mod) % mod;
        if (ans &gt;= mod) ans -= mod;
    }

    printf("%d\n", ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1009</wp:post_id>
		<wp:post_date><![CDATA[2018-11-28 15:31:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-28 07:31:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cnowcoder-271c%e3%80%8d%e5%b7%a6%e6%96%b9%e4%b9%8b%e5%9c%b0-%e6%a6%82%e7%8e%87%e6%9c%9f%e6%9c%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="nowcoder"><![CDATA[nowcoder]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[36]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「nowcoder 271D」风斩冰华-DP+贪心</title>
		<link>http://sycstudio.com/archives/1019</link>
		<pubDate>Wed, 28 Nov 2018 10:06:22 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1019</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

咕咕咕。

<h1>Solution</h1>

设$f_{i,0,1,2}$分别表示以$u$为根的子树中$u$没有删除,在其父亲之前删除,再其父亲之后删除的答案。

$f_{u,0}$很好求。

$$f_{u,0}=\sum max(f_{v,0},f_{v,2})$$

$f_{u,1}$与$f_{u,2}$有点麻烦。要把儿子节点分为再$u$之后删除/保留以及再$u$之前删考虑。

<ul>
<li>在$u$之后删的贡献$max(f[v][0],f[v][1])$</li>
<li>在$u$之前删的贡献$f[v][1]$</li>
</ul>

设$v'$为在$u$之后删除的儿子，所以答案为$\sum f_{v,1}+(\sum max(f_{v',0},f_{v',2})-f_{v',1})$

所以在满足度数要求的情况下贪心即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 500005;
const lint Inf = 1ll &lt;&lt; 40;

int n, l, r, val[maxn];

struct edge {
    int to, next;
} e[maxn * 2];
int h[maxn], tot, d[maxn];

lint f[maxn][3];

inline int gi()
{
    char c = getchar(); bool f = 1;
    while ((c &lt; '0' || c &gt; '9') &amp;&amp; c != '-') c = getchar();
    if (c == '-') c = getchar(), f = 0;
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return f ? sum : -sum;
}

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
    ++d[u]; ++d[v];
}

lint calc(int u, int fa, int l, int r)
{
    static lint p[maxn], sum;
    static int cnt;
    if (d[u] &lt; l) return -Inf;
    sum = cnt = 0;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa) {
            sum += f[v][1]; p[++cnt] = max(f[v][0], f[v][2]) - f[v][1];
        }
    sort(p + 1, p + cnt + 1, greater&lt;lint&gt;());
    for (int i = 1; i &lt;= l; ++i) sum += p[i];
    for (int i = l + 1; i &lt;= r &amp;&amp; i &lt;= cnt; ++i)
        if (p[i] &gt; 0) sum += p[i];
    return sum;
}

void dfs(int u, int fa)
{
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa) {
            dfs(v, u);
            f[u][0] += max(f[v][0], f[v][1]);
        }
    f[u][1] = calc(u, fa, l - 1, r - 1) + val[u];
    f[u][2] = calc(u, fa, l, r) + val[u];
}

int main()
{
    n = gi(); l = gi(); r = gi();
    for (int i = 1; i &lt;= n; ++i) val[i] = gi();
    for (int i = 1; i &lt; n; ++i) add(gi(), gi());
    for (int i = 2; i &lt;= n; ++i) --d[i];

    dfs(1, 0);

    printf("%lld\n", max(f[1][0], f[1][2]));

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1019</wp:post_id>
		<wp:post_date><![CDATA[2018-11-28 18:06:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-28 10:06:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cnowcoder-271d%e3%80%8d%e9%a3%8e%e6%96%a9%e5%86%b0%e5%8d%8e-dp%e8%b4%aa%e5%bf%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="nowcoder"><![CDATA[nowcoder]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%9e%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[树型动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>鸽子syc更博</title>
		<link>http://sycstudio.com/archives/1021</link>
		<pubDate>Wed, 28 Nov 2018 13:00:01 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1021</guid>
		<description></description>
		<content:encoded><![CDATA[趁萝卜不在催他更博。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1021</wp:post_id>
		<wp:post_date><![CDATA[2018-11-28 21:00:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-28 13:00:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%b8%bd%e5%ad%90syc%e6%9b%b4%e5%8d%9a]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[79]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>174</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.30.19]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-12-02 21:48:32]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-12-02 13:48:32]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[在更了在更了.pg]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>「CTSC2008」图腾-树状数组</title>
		<link>http://sycstudio.com/archives/1023</link>
		<pubDate>Thu, 29 Nov 2018 06:41:27 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1023</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一个$１～n$的排列，至于求什么看下面。

$n \leq 200000$

<h1>Solution</h1>

$$f[1324]-f[1243]-f[1432]&amp;=(f[1x2x]-f[1423])+(f[12xx]-f[1234])+(f[14xx]-f[1423])$$
$$=f[1x2x]+f[1234]-f[12xx]-f[14xx]$$
$$=f[1x2x]+f[1234]+f[13xx]-f[1xxx]$$

设$l_i,r_i$分别表示$i$位置左边/右边比它小的数的个数，这些东西都可以用$l_i,r_i$表示。

<ul>
<li>$f[1x2x]$：枚举中间的$2$的位置$i$，则右边的位置的方案数为$n-i-r_i$。左边选两个数$(x,y)$瞒住$a_x&lt;a_y,x&lt;y$的方案数为$l_i \times (i-1)$。然后有两种不合法情况1.两个数都小于$x&lt;y,a_y&lt;a_i$。2.$y&lt;x$分别减去即可。</li>
<li>$f[1234]$：枚举中间$2$的位置$i$。方案数为$l_i\times\sum_{j>i,a[j]>a[i]}n-j-r[j]$</li>
<li>$f[1xxx]$：$\sum \binom {n-i-r_i} {3}$</li>
<li>$f[13xx]$：枚举$3$的位置$i$，$l_i\times r_i \times (n-r_i-1)-(\sum_{j&lt;i,a_j&lt;a_i}r_j-(\frac{l_i\times (l_i-1)}{2}-\sum_{j&lt;i,a_j&lt;a_i}l_j))$</li>
</ul>

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 200005, mod = 16777216;

int n, ans, a[maxn], l[maxn], r[maxn];
int sum[maxn];

inline void inc(int &amp;a, int b)
{
    a += b;
    if (a &gt;= mod) a -= mod;
}

inline void dec(int &amp;a, int b)
{
    a -= b;
    if (a &lt; 0) a += mod;
}

inline int gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

#define lowbit(x) (x &amp; (-x))

inline void insert(int x, int a)
{
    while (x &lt;= n) {
        inc(sum[x], a);
        x += lowbit(x);
    }
}

inline int query(int x)
{
    int res = 0;
    while (x) {
        inc(res, sum[x]);
        x -= lowbit(x);
    }
    return res;
}

int main()
{
    freopen("picture.in", "r", stdin);
    freopen("picture.out", "w", stdout);

    n = gi();
    for (int i = 1; i &lt;= n; ++i) a[i] = gi();

    for (int i = 1; i &lt;= n; ++i) {
        l[i] = query(a[i]); r[i] = a[i] - l[i] - 1;
        insert(a[i], 1);
    }

    //1x2x
    memset(sum + 1, 0, sizeof(int) * n);
    for (int i = 1; i &lt;= n; ++i) {
        inc(ans, (lint)(n - i - r[i]) * (i - 1) % mod * l[i] % mod);
        dec(ans, (lint)query(a[i]) * (n - i - r[i]) % mod);
        dec(ans, (lint)(l[i] - 1) * l[i] / 2 % mod * (n - i - r[i]) % mod);
        insert(a[i], i);
    }

    //1234
    memset(sum + 1, 0, sizeof(int) * n);
    for (int i = n; i &gt;= 1; --i) {
        inc(ans, (lint)l[i] * (query(n) - query(a[i])) % mod);
        insert(a[i], n - i - r[i]);
    }

    //1xxx
    for (int t, i = 1; i &lt;= n; ++i) {
        t = n - i - r[i];
        if (t &gt;= 3) dec(ans, (lint)t * (t - 1) / 2 * (t - 2) / 3 % mod);
    }

    //13xx
    memset(sum + 1, 0, sizeof(int) * n);
    for (int i = 1; i &lt;= n; ++i) {
        inc(ans, (lint)l[i] * r[i] % mod * (n - i - r[i]) % mod);
        inc(ans, (lint)l[i] * (l[i] - 1) / 2 % mod * (n - i - r[i]) % mod);
        dec(ans, (lint)query(a[i]) * (n - i - r[i]) % mod);
        insert(a[i], l[i] + r[i]);
    }

    printf("%d\n", ans);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1023</wp:post_id>
		<wp:post_date><![CDATA[2018-11-29 14:41:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-29 06:41:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cctsc2008%e3%80%8d%e5%9b%be%e8%85%be-%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「清华集训2016」汽水-二分+点分治</title>
		<link>http://sycstudio.com/archives/1031</link>
		<pubDate>Sat, 01 Dec 2018 12:16:46 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1031</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定一棵树，有边权。

找到一条路径，使得经过的平均边权与$k$最接近。

$n \leq 50000,5s$

<h1>Solution</h1>

二分答案。设当前二分值为$p$,一条路径满足条件当且仅当

$$-p \leq \frac{\sum(w-k)}{len}\leq p$$

把边权减去$k$,移项得$-len \times p\leq\sum w\leq len\times p$

把条件拆成两条

$$-len \times p\leq\sum w&lt;0$$
$$0\leq\sum w\leq len\times p$$

分开统计小于$0$的路径与大于等于$0$的路径，然后就可以点分治直接做了。

时间复杂度$O(nlog^2n)$，所以这题似乎可以开到$100000$,$1s$？

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

namespace IO {
    const int maxn((1 &lt;&lt; 21) + 1);

    char ibuf[maxn], *iS, *iT, obuf[maxn], *oS = obuf, *oT = obuf + maxn - 1, c, st[55];
    int f, tp;

    char Getc() {
        return (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++);
    }

    void Flush() {
        fwrite(obuf, 1, oS - obuf, stdout);
        oS = obuf;
    }

    void Putc(char x) {
        *oS++ = x;
        if (oS == oT) Flush();
    }

    template &lt;class Int&gt; void Input(Int &amp;x) {
        for (f = 1, c = Getc(); c &lt; '0' || c &gt; '9'; c = Getc()) f = c == '-' ? -1 : 1;
        for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = Getc()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);
        x *= f;
    }

    template &lt;class Int&gt; void Print(Int x) {
        if (!x) Putc('0');
        if (x &lt; 0) Putc('-'), x = -x;
        while (x) st[++tp] = x % 10 + '0', x /= 10;
        while (tp) Putc(st[tp--]);
    }

    void Getstr(char *s, int &amp;l) {
        for (c = Getc(); c &lt; 'a' || c &gt; 'z'; c = Getc());
        for (l = 0; c &lt;= 'z' &amp;&amp; c &gt;= 'a'; c = Getc()) s[l++] = c;
        s[l] = 0;
    }

    void Putstr(const char *s) {
        for (int i = 0, n = strlen(s); i &lt; n; ++i) Putc(s[i]);
    }
}

typedef long long lint;

const int maxn = 500005;

int n;
lint k, ans = 1ll &lt;&lt; 60;

struct edge {
    int to, next;
    lint w;
} e[maxn * 2];
int h[maxn], tot;

int siz[maxn], mxsz[maxn], Siz, root;
bool vis[maxn];

struct node
{
    int x;
    lint y;
    int z;
    bool operator &lt; (const node &amp;a) const {
        return y &lt; a.y;
    }
} p1[maxn], p2[maxn];
pair&lt;lint, int&gt; A, B;
int cnt1, cnt2;

inline void add(int u, int v, lint w)
{
    e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
    e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
}

void get_root(int u, int fa)
{
    siz[u] = 1; mxsz[u] = 0;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) {
            get_root(v, u);
            siz[u] += siz[v]; mxsz[u] = max(mxsz[u], siz[v]);
        }
    mxsz[u] = max(mxsz[u], Siz - siz[u]);
    if (mxsz[u] &lt; mxsz[root]) root = u;
}

void get_dis(int u, int fa, int dep, lint dis, int bel)
{
    if (dis &gt;= 0) p1[++cnt1] = (node) {dep, dis, bel};
    else p2[++cnt2] = (node) {dep, dis, bel};
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa &amp;&amp; !vis[v]) get_dis(v, u, dep + 1, dis + e[i].w, bel);
}

inline void chkmin(pair&lt;lint, int&gt; p)
{
    if (p.first &lt; B.first) {
        if (p.first &lt; A.first) {
            if (p.second != A.second) B = A;
            A = p;
        }
        if (p.second != A.second) B = p;
    }
}

inline void chkmax(pair&lt;lint, int&gt; p)
{
    if (p.first &gt; B.first) {
        if (p.first &gt; A.first) {
            if (p.second != A.second) B = A;
            A = p;
        }
        if (p.second != A.second) B = p;
    }
}

inline bool find1(lint k)
{
    register int i, j;
    A = B = make_pair(1ll &lt;&lt; 60, 0);
    for (i = 1, j = cnt2; i &lt;= cnt1; ++i) {
        while (p1[i].y + p2[j].y &gt;= 0 &amp;&amp; j)
            chkmin(make_pair(p2[j].y - p2[j].x * k, p2[j].z)), --j;
        if ((A.second != p1[i].z ? A.first : B.first) + p1[i].y - p1[i].x * k &lt; 0) return 1;
        chkmin(make_pair(p1[i].y - p1[i].x * k, p1[i].z));
    }
    return 0;
}

inline bool find2(lint k)
{
    register int i, j;
    A = B = make_pair(-1ll &lt;&lt; 60, 0);
    for (i = cnt2, j = 1; i; --i) {
        while (p2[i].y + p1[j].y &lt; 0 &amp;&amp; j &lt;= cnt1)
            chkmax(make_pair(p1[j].y + p1[j].x * k, p1[j].z)), ++j;
        if ((A.second != p2[i].z ? A.first : B.first) + p2[i].y + p2[i].x * k &gt; 0)
            return 1;
        chkmax(make_pair(p2[i].y + p2[i].x * k, p2[i].z));
    }
    return 0;
}

void solve(int u)
{
    root = 0; get_root(u, 0); u = root; vis[u] = 1;

    cnt1 = cnt2 = 0;
    p1[++cnt1] = (node) {0, 0, u};
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) get_dis(v, u, 1, e[i].w, v);
    sort(p1 + 1, p1 + cnt1 + 1);
    sort(p2 + 1, p2 + cnt2 + 1);

    lint l = 1, r = ans - 1, mid;
    while (l &lt;= r) {
        mid = (l + r) &gt;&gt; 1;
        if (find1(mid) || find2(mid)) r = mid - 1;
        else l = mid + 1;
    }
    ans = min(ans, l);

    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (!vis[v]) Siz = siz[v], solve(v);
}

int main()
{
    using namespace IO;
    Input(n); Input(k);
    lint w;
    for (int u, v, i = 1; i &lt; n; ++i) {
        Input(u); Input(v); Input(w); w -= k; ans = min(ans, abs(w) + 1);
        add(u, v, w);
    }

    Siz = n; mxsz[0] = n;
    solve(1);

    printf("%lld\n", ans - 1);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1031</wp:post_id>
		<wp:post_date><![CDATA[2018-12-01 20:16:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-01 12:16:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8c%e6%b8%85%e5%8d%8e%e9%9b%86%e8%ae%ad2016%e3%80%8d%e6%b1%bd%e6%b0%b4-%e4%ba%8c%e5%88%86%e7%82%b9%e5%88%86%e6%b2%bb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[41]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「51Nod1132」覆盖数字的数量V2&amp;「Ural1797」 Summit Online Judge.Version 2-类欧几里得</title>
		<link>http://sycstudio.com/archives/1034</link>
		<pubDate>Wed, 05 Dec 2018 09:58:19 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1034</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

<a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1132">链接</a>

<h1>Solution</h1>

只需求$[0,n]$的答案然后相减即可。

考虑$gcd(a,b)=1$的情况(如果$gcd(a,b)>1$那么$a,b,n$同除以$gcd(a,b)$即可)

对于一组询问$(a,b,n)$如果$n>(a-1)(b-1)$，那么$>(a-1)(b-1)$的部分肯定可以凑出来(小凯的疑惑)。

$\leq (a-1)(b-1)$的部分最多只有一组非负整数解，用类欧几里得统计$ax+by\leq n$的方案数即可(同BZOJ2987)。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;

lint a, b, x, y, g;

inline lint solve(lint a, lint b, lint c, lint n)
{
    if (!c) return 0;
    lint ans = 0;
    ans += a / c * (n + 1) * n / 2 + b / c * (n + 1);
    a %= c; b %= c;
    if (a) ans += ((a * n + b) / c) * n - solve(c, c - b - 1, a, (a * n + b) / c - 1);
    return ans;
}

inline lint calc(lint a, lint b, lint n)
{
    lint sum = 0;
    a /= g; b /= g; n /= g;
    if (n &gt;= (double)(a - 1) * (b - 1)) sum += n - (a - 1) * (b - 1), n = (a - 1) * (b - 1);
    sum += solve(a, n - a * (n / a), b, n / a) + n / a + 1;
    return sum;
}

int main()
{
    int T;
    scanf("%d", &amp;T);
    while (T--) {
        scanf("%lld%lld%lld%lld", &amp;a, &amp;b, &amp;x, &amp;y);
        g = __gcd(a, b);
        //a /= g; b /= g; x /= g; y /= g;
        printf("%lld\n", calc(a, b, y) - calc(a, b, x - 1));
    }

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1034</wp:post_id>
		<wp:post_date><![CDATA[2018-12-05 17:58:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-05 09:58:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8c51nod1132%e3%80%8d%e8%a6%86%e7%9b%96%e6%95%b0%e5%ad%97%e7%9a%84%e6%95%b0%e9%87%8fv2%e3%80%8cural1797%e3%80%8d-summit-online-judge-version-2-%e7%b1%bb%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[24]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「学习笔记」Min25筛</title>
		<link>http://sycstudio.com/archives/1036</link>
		<pubDate>Mon, 10 Dec 2018 01:41:59 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1036</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>前言</h1>

$Min25$筛是一种能够用于求解积性函数$f(x)$的前缀和的方法，其前提条件是$\sum_{x\leq,nx是质数} f(x)$可以用$\sum_{x\leq,nx是质数} h(x)$简单表示。其中$h(x)$为完全积性函数。

<h1>过程</h1>

首先，对于每一个$\lfloor \frac{n}{x}  \rfloor$，我们求出$\sum_{x\leq,nx是质数} h(x)$。

设$p_i$表示第$i$小的质数，$g(N,i)$表示$\sum_{x\leq n,x的最小质因子\geq p_i}h(x)$。即$N$以内的数进行$i$轮埃氏筛后未被筛掉的数的$h(x)$之和（质数未被删去），则所求即为$g(N,|P|)$（$|P|$为$\leq n$的质数个数）。

考虑如何由$g(N,i-1)$得到$g(N,i)$。考虑第$i$轮埃氏筛所筛去的数。当$p_i^2 > n$时，第$i$轮不会筛去任何数。否则，将筛去最小质因子$\geq p_i$的合数，所以

$$g(N,i)=g(N,i-1)-h(p_i)\times(g(\lfloor \frac {N} {p_i}\rfloor,i-1)-\sum_{j=1}^{i-1}h(p_i))$$

因为$p_i^2\leq N$，所以$p_i \leq \lfloor \frac {N} {p_i}\rfloor$，所以$\leq p_i$的质数也会被包含在$g(\lfloor \frac {N} {p_i}\rfloor,i-1)$里，要加回来。

综上，

$$g(N,j)=\begin{cases}    g(N,j-1)&amp;p_j^2\gt n&#92;
g(N,i-1)-h(p_i)\times(g(\lfloor \frac {N} {p_i}\rfloor,i-1)-\sum_{j=1}^{i-1}h(p_i))&amp;p_j^2\le n\end{cases}$$

这部分的时间复杂度是$O(\frac {N^{\frac {3} {4}}} {log \ \ N})$

接下来考虑如何用上述信息求$\sum_{i=1}^n f(x)$。

设$s(N,i)$表示$\sum_{j=1,j的最小质因子\geq p_i}^n f(j)$。

由定义最终答案为$s(N,1)+f(1)$。

经过上面的计算，我们已经可以快速计算$\sum_{x\leq n,x是质数} f(x)$。

考虑合数的贡献，枚举质因子个数及其出现次数，因为$f(x)$为积性函数，所以贡献为

$$\sum_{j\geq i}^{p_j^2 \leq N}\sum_{e=1}^{p_j^{e+1}\leq N} s(\lfloor \frac {N} {p_i}\rfloor,j+1)\times f(p_i^e)+f(p_i^{e+1})$$

综上，

$$s(N,i)=\begin{cases}    0&amp;p_j\gt n&#92;    \sum_{j\geq i}^{p_j^2 \leq N}\sum_{e=1}^{p_j^{e+1}\leq N} s(\lfloor \frac {N} {p_i}\rfloor,j+1)\times f(p_i^e)+f(p_i^{e+1})+\sum_{x\leq n,x是质数} f(x)-\sum_{j=1}^if(p_i)&amp;p_j \le n\end{cases}$$

这部分的时间复杂度不用记忆化也会快，是$O(\frac {N^{\frac {3} {4}}} {log \ \ N})$。

<h1>模板</h1>

<a href="简单的函数">LOJ6053</a>

考虑如何用$\sum_{x\leq,nx是质数} h(x)$表示$\sum_{x\leq,nx是质数} f(x)$。

可以发现，对于质数$p$

$$f(p)=\begin{cases} p+1 &amp; p=2 &#92; p-1 &amp; p \neq 2\end{cases}$$

所以，当$i>1$时，$\sum_{x\leq n,x是质数} f(x)-\sum_{j=1}^if(p_i)$实际计算了$x$以内质数的和减去减去质数的个数，筛单位函数与恒等函数即可。当$i=1$时，给答案加上$2$即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define int long long 

typedef long long lint;
const int maxn = 200005, mod = 1e9 + 7, inv2 = (mod + 1) / 2;

lint n, w[maxn];
int m, S;

int id1[maxn], id2[maxn];
int vis[maxn], p[maxn], sum[maxn], tot;
int h[maxn], g[maxn];

inline lint gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    lint sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

void pre(int n)
{
    for (int i = 2; i &lt;= n; ++i) {
        if (!vis[i]) p[++tot] = i, sum[tot] = sum[tot - 1] + i;
        for (int j = 1; i * p[j] &lt;= n; ++j) {
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
}

int s(int x, int i)
{
    if (x &lt;= 1 || p[i] &gt; x) return 0;
    int k = x &lt;= S ? id1[x] : id2[n / x];
    int res = ((g[k] - h[k] - (sum[i - 1] - (i - 1))) % mod + mod) % mod;

    if (i == 1) res += 2;
    lint p1, p2;
    for (int j = i; j &lt;= tot &amp;&amp; (lint)p[j] * p[j] &lt;= x; ++j){
        p1 = p[j]; p2 = p1 * p[j];
        for (lint e = 1; p2 &lt;= x; p1 = p2, p2 *= p[j], ++e) {
            res += ((lint)s(x / p1, j + 1) * (p[j] ^ e) + (p[j] ^ (e + 1))) % mod;
            if (res &gt;= mod) res -= mod;
        }
    }

    return res;
}

signed main()
{
    n = gi(); S = sqrt(n);

    pre(S);

    for (lint i = 1, j; i &lt;= n; i = j + 1) {
        j = n / (n / i);
        w[++m] = n / i;
        if (w[m] &lt;= S) id1[w[m]] = m;
        else id2[n / w[m]] = m;
        h[m] = (w[m] - 1) % mod;
        g[m] = (lint)(w[m] + 2) % mod * ((w[m] - 1) % mod) % mod * inv2 % mod;
    }

    for (int j = 1; j &lt;= tot; ++j)
        for (int i = 1; i &lt;= m &amp;&amp; (lint)p[j] * p[j] &lt;= w[i]; ++i) {
            int k = (w[i] / p[j] &lt;= S) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];
            h[i] = ((lint)h[i] - h[k] + j - 1 + mod) % mod;
            g[i] = (g[i] - (lint)p[j] * (g[k] - sum[j - 1]) % mod + mod) % mod;
        }

    printf("%lld\n", s(n, 1) + 1);

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1036</wp:post_id>
		<wp:post_date><![CDATA[2018-12-10 09:41:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-10 01:41:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8c%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e3%80%8dmin25%e7%ad%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[28]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「UOJ188」Sanrd-Min25筛</title>
		<link>http://sycstudio.com/archives/1039</link>
		<pubDate>Mon, 10 Dec 2018 08:12:25 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1039</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

求$[l,r]$的次大质因子之和。

$l,r \leq 10^10$

<h1>Solution</h1>

题目就是求所有数的次大质因子之和。

考虑在计算$s$时，答案为当前枚举的质因子的数只可能是除去当前质因子后为质数或$1$的数，则把$s(N,i)$的返回值设为一个$pair$，表示$s(N,i)$的质数个数以及$s(N,i)$的合数的答案。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef unsigned int uint;
typedef unsigned long long ull;

const int maxn = 700005;

ull n, m, S, tot;
ull p[maxn], sum[maxn], w[maxn], id1[maxn], id2[maxn];
ull g[maxn], h[maxn];
bool vis[maxn];

inline ull gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    ull sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline void pre(ull n)
{
    for (uint i = 2; i &lt;= n; ++i) {
        if (!vis[i]) p[++tot] = i, sum[tot] = sum[tot - 1] + i;
        for (uint j = 1; j &lt;= tot &amp;&amp; p[j] * i &lt;= n; ++j) {
            vis[p[j] * i] = 1;
            if (p[j] % i == 0) break;
        }
    }
}

pair&lt;ull, ull&gt; s(ull x, ull i)
{
    if (x &lt;= 1 || p[i] &gt; x) return make_pair(0, 0);
    pair&lt;ull, ull&gt; tmp;
    int k = x &lt;= S ? id1[x] : id2[n / x];
    ull res1 = h[k] - (i - 1), res2 = 0, p1, p2;
    for (uint j = i; j &lt;= tot &amp;&amp; p[j] * p[j] &lt;= x; ++j) {
        p1 = p[j]; p2 = p1 * p[j];
        for ( ; p2 &lt;= x; p1 = p2, p2 *= p[j]) {
            tmp = s(x / p1, j + 1);
            res2 += tmp.first * p[j] + tmp.second + p[j];
        }
    }
    return make_pair(res1, res2);
}

inline ull calc(ull x)
{
    if (!x) return 0;
    tot = 0; m = 0;
    memset(vis, 0, sizeof(vis));
    n = x; S = sqrt(n);

    pre(S);

    for (ull i = 1, j; i &lt;= n; i = j + 1) {
        j = n / (n / i);
        w[++m] = n / i;
        if (w[m] &lt;= S) id1[w[m]] = m;
        else id2[n / w[m]] = m;
        h[m] = w[m] - 1;
        g[m] = (w[m] + 2) * (w[m] - 1) / 2;
    }

    for (uint j = 1; j &lt;= tot; ++j)
        for (uint i = 1; i &lt;= m &amp;&amp; p[j] * p[j] &lt;= w[i]; ++i) {
            int k = w[i] / p[j] &lt;= S ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];
            h[i] = h[i] - h[k] + j - 1;
            g[i] = g[i] - p[j] * (g[k] - sum[j - 1]);
        }

    return s(n, 1).second;
}

int main()
{
    ull l, r;
    l = gi(); r = gi();
    printf("%llu\n", calc(r) - calc(l - 1));

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1039</wp:post_id>
		<wp:post_date><![CDATA[2018-12-10 16:12:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-10 08:12:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cuoj188%e3%80%8dsanrd-min25%e7%ad%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>「WC2018」通道-边分治+虚树+DP</title>
		<link>http://sycstudio.com/archives/1043</link>
		<pubDate>Wed, 12 Dec 2018 15:09:36 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1043</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

给定三棵树，最大化$dista(x,y)+distb(x,y)+distc(x,y)$。

$n \leq 100000$

<h1>Solution</h1>

先考虑两棵树怎么做。

点对$(x,y)$的贡献为$depa_x+depa_y-depa_{lca(x,y)}\times 2 + distb(x,y)$。

对于第二棵树上的每个节点$x$，连一个点$x'$，边权为$depa_x$。那么$distb(x',y')=depa_x+depa_y+distb(x,y)$。结合上式，那么我们的目标是最大化$dist(x',y')$其中$x',y'$属于$lca$的不同子树。

对于边权非负的图，有这样的性质：跨越集合$A,B$的最长链的端点一定可以是$A$中最长链的端点和$B$最长链的端点中的某两个。可以用类似证明树的直径的方式来证明这一结论。

因此，在第一棵树上进行树形DP，维护当前集合中最长链的两个端点，在合并时更新答案即可。

现在考虑三棵树的情况。

在第三棵树上进行边分治，对于当前边分治的点集在第二棵树上建立虚树，对于第一棵树上的每个节点$x$，新建点$x'$与其相连，边权为$depb_x+distc_x$，$distc_x$为点$x$在第三棵树上到当前分治中心的距离。

所以，在第二棵树上的虚树进行树形DP，分别维护属于第三棵树上两个分治联通块的点集的两个端点，在合并时更新答案即可。

<pre><code class="language-cpp ">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 200005;

int n, Log[maxn];
int cnt1, cnt2, q1[maxn], q2[maxn], typ[maxn];
lint w[maxn], k, ans;

inline lint gi()
{
    char c = getchar();
    while (c &lt; '0' || c &gt; '9') c = getchar();
    lint sum = 0;
    while ('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

namespace t1
{

    struct edge 
    {
        int to, next;
        lint w;    
    } e[maxn * 2];
    int h[maxn], tot;
    int dep[maxn], Time, ord[maxn], dfn[maxn], Min[21][maxn];
    lint dis[maxn];

    inline void add(int u, int v, lint w)
    {
        e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
        e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
    }

    void dfs(int u, int fa)
    {
        dep[u] = dep[fa] + 1;
        w[u] += dis[u];
        ord[dfn[u] = ++Time] = u; Min[0][Time] = u;
        for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
            if (v != fa) {
                dis[v] = dis[u] + e[i].w;
                dfs(v, u);
                ord[++Time] = u; Min[0][Time] = u;
            }
    }

    void prest()
    {
        for (int j = 0; (1 &lt;&lt; (j + 1)) &lt;= Time; ++j)
            for (int i = 1; i + (1 &lt;&lt; (j + 1)) - 1 &lt;= Time; ++i) {
                if (dep[Min[j][i]] &lt;= dep[Min[j][i + (1 &lt;&lt; j)]]) Min[j + 1][i] = Min[j][i];
                else Min[j + 1][i] = Min[j][i + (1 &lt;&lt; j)];
            }
    }

    inline int lca(int u, int v) 
    {
        static int k;
        u = dfn[u]; v = dfn[v];
        if (u &gt; v) swap(u, v);
        k = Log[v - u + 1];
        if (dep[Min[k][u]] &lt;= dep[Min[k][v - (1 &lt;&lt; k) + 1]]) return Min[k][u];
        else return Min[k][v - (1 &lt;&lt; k) + 1];
    }

    inline lint t1dis(int a, int b) {return w[a] + w[b] - (dis[lca(a, b)] &lt;&lt; 1);}

}

namespace t2
{

    struct edge 
    {
        int to, next;
        lint w;
    } e[maxn * 2];
    int h[maxn], tot;
    int dep[maxn], Time, ord[maxn], dfn[maxn], Min[21][maxn];
    lint dis[maxn];

    inline void add(int u, int v, lint w)
    {
        e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
        e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
    }

    void dfs(int u, int fa)
    {
        dep[u] = dep[fa] + 1;
        w[u] += dis[u];
        ord[dfn[u] = ++Time] = u; Min[0][Time] = u;
        for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
            if (v != fa) {
                dis[v] = dis[u] + e[i].w;
                dfs(v, u);
                ord[++Time] = u; Min[0][Time] = u;
            }
    }

    void prest()
    {
        for (int j = 0; (1 &lt;&lt; (j + 1)) &lt;= Time; ++j)
            for (int i = 1; i + (1 &lt;&lt; (j + 1)) - 1 &lt;= Time; ++i) {
                if (dep[Min[j][i]] &lt;= dep[Min[j][i + (1 &lt;&lt; j)]]) Min[j + 1][i] = Min[j][i];
                else Min[j + 1][i] = Min[j][i + (1 &lt;&lt; j)];
            }
    }

    inline int lca(int u, int v) 
    {
        static int k;
        u = dfn[u]; v = dfn[v];
        if (u &gt; v) swap(u, v);
        k = Log[v - u + 1];
        if (dep[Min[k][u]] &lt;= dep[Min[k][v - (1 &lt;&lt; k) + 1]]) return Min[k][u];
        else return Min[k][v - (1 &lt;&lt; k) + 1];
    }

    namespace virtual_tree
    {

        struct edge 
        {
            int to, next;
        } e[maxn];
        int h[maxn], tot, x[maxn], in[maxn], cnt, stk[maxn], top;

        struct node 
        {
            int u, v;
            lint dis;

            node() {u = v = dis = 0;}
            node(int a, int b) {u = a; v = b; dis = t1::t1dis(a, b);}
            node(int a, int b, lint d) {u = a; v = b; dis = d;}
            bool operator &lt; (const node &amp;a) const {return dis &lt; a.dis;}
            friend node operator + (node a, node b) {
                if (a.u == 0) return b;
                if (b.u == 0) return a;
                node res = max(a, b);
                res = max(res, max(node(a.u, b.u), node(a.v, b.v)));
                res = max(res, max(node(a.u, b.v), node(a.v, b.u)));
                return res;
            }
        } f[maxn][2];

        inline lint merge(node a, node b)
        {
            if (a.u == 0 || b.u == 0) return 0;
            return max(max(t1::t1dis(a.u, b.u), t1::t1dis(a.v, b.v)), max(t1::t1dis(a.u, b.v), t1::t1dis(a.v, b.u)));
        }

        void add(int u, int v)
        {
            e[++tot] = (edge) {v, h[u]}; h[u] = tot;
            e[++tot] = (edge) {u, h[v]}; h[v] = tot;
        }

        inline bool cmp(const int &amp;a, const int &amp;b)
        {
            return dfn[a] &lt; dfn[b];
        }

        void dfs(int u, int fa)
        {
            if (in[u] == 1) f[u][typ[u]] = node(u, u), f[u][typ[u] ^ 1] = node();
            else f[u][0] = f[u][1] = node();
            for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
                if (v != fa) {
                    dfs(v, u);
                    ans = max(ans, max(merge(f[u][0], f[v][1]), merge(f[u][1], f[v][0])) + k - (dis[u] &lt;&lt; 1));
                    f[u][0] = f[u][0] + f[v][0];
                    f[u][1] = f[u][1] + f[v][1];
                }
            h[u] = 0;
        }

        void build()
        {
            cnt = 0;
            for (int i = 1; i &lt;= cnt1; ++i) x[++cnt] = q1[i];
            for (int i = 1; i &lt;= cnt2; ++i) x[++cnt] = q2[i];
            sort(x + 1, x + cnt + 1, cmp);
            for (int i = 1; i &lt;= cnt; ++i) in[x[i]] = 1;

            tot = 0; stk[top = 1] = 1;
            for (int i = 1; i &lt;= cnt; ++i) {
                int p = lca(stk[top], x[i]);
                if (stk[top] != p) {
                    while (dfn[p] &lt;= dfn[stk[top - 1]]) add(stk[top - 1], stk[top]), --top;
                    if (stk[top] != p) add(p, stk[top]), stk[top] = p;
                }
                if (stk[top] != x[i]) stk[++top] = x[i];
            }
            --top;
            while (top) add(stk[top], stk[top + 1]), --top;

            dfs(1, 0);

            for (int i = 1; i &lt;= cnt; ++i) in[x[i]] = 0;
        }
    }

}

namespace t3
{

    struct edge 
    {
        int to, next;
        lint w;
        bool cut;
    } e[maxn * 2];
    int h[maxn], tot;
    int all, siz[maxn], res, rev;
    lint dis[maxn];

    inline void add(int u, int v, lint w)
    {
        e[++tot] = (edge) {v, h[u], w, 0}; h[u] = tot;
        e[++tot] = (edge) {u, h[v], w, 0}; h[v] = tot;
    }

    namespace original_tree
    {

        struct edge 
        {
            int to, next;
            lint w;
        } e[maxn * 2];
        int h[maxn], tot, now[maxn], cnt;

        inline void add(int u, int v, lint w)
        {
            e[++tot] = (edge) {v, h[u], w}; h[u] = tot;
            e[++tot] = (edge) {u, h[v], w}; h[v] = tot;
        }

        inline void link(int u, int v, lint w)
        {
            ++cnt;
            t3::add(cnt, v, w);
            t3::add(now[u], cnt, 0);
            now[u] = cnt;
        }

        void dfs(int u, int fa)
        {
            for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
                if (v != fa) {
                    link(u, v, e[i].w);
                    dfs(v, u);
                }
        }

        void build()
        {
            for (int i = 1; i &lt;= n; ++i) now[i] = i;
            cnt = n;
            dfs(1, 0);
        }

    }

    void dfs1(int u, int fa)
    {
        siz[u] = 1;
        for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
            if (v != fa &amp;&amp; !e[i].cut) dfs1(v, u), siz[u] += siz[v];;
    }

    void dfs2(int u, int fa)
    {
        static int mxsz;
        for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
            if (v != fa &amp;&amp; !e[i].cut) {
                mxsz = max(siz[v], all - siz[v]);
                if (rev &gt; mxsz) res = i, rev = mxsz;
                dfs2(v, u);
            }
    }    

    void dfs3(int u, int fa, int f, int &amp;cnt, int *q)
    {
        if (u &lt;= n) typ[u] = f, q[++cnt] = u;
        for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
            if (v != fa &amp;&amp; !e[i].cut)
                dis[v] = dis[u] + e[i].w, dfs3(v, u, f, cnt, q);
    }

    void solve(int u)
    {
        dfs1(u, 0);
        if (siz[u] == 1) return ;
        res = 0; rev = 1 &lt;&lt; 30; all = siz[u]; 
        dfs2(u, 0);

        int st = e[res].to, ed = e[res ^ 1].to;
        e[res].cut = e[res ^ 1].cut = 1;
        cnt1 = cnt2 = dis[st] = dis[ed] = 0;
        dfs3(st, 0, 0, cnt1, q1); dfs3(ed, 0, 1, cnt2, q2);

        for (int i = 1; i &lt;= cnt1; ++i) w[q1[i]] += dis[q1[i]];
        for (int i = 1; i &lt;= cnt2; ++i) w[q2[i]] += dis[q2[i]];
        k = e[res].w; t2::virtual_tree::build();
        for (int i = 1; i &lt;= cnt1; ++i) w[q1[i]] -= dis[q1[i]];
        for (int i = 1; i &lt;= cnt2; ++i) w[q2[i]] -= dis[q2[i]];

        solve(st);
        solve(ed);
    }

}

int main()
{
    n = gi();
    for (int u, v, i = 1; i &lt; n; ++i) u = gi(), v = gi(), t1::add(u, v, gi());
    for (int u, v, i = 1; i &lt; n; ++i) u = gi(), v = gi(), t2::add(u, v, gi());
    for (int u, v, i = 1; i &lt; n; ++i) u = gi(), v = gi(), t3::original_tree::add(u, v, gi());

    for (int i = 2; i &lt;= n * 2; ++i) Log[i] = Log[i &gt;&gt; 1] + 1;

    t1::dfs(1, 0);
    t1::prest();
    t2::dfs(1, 0);
    t2::prest();
    t3::tot = 1;
    t3::original_tree::build();
    t3::solve(1);

    printf("%lld\n", ans);

    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1043</wp:post_id>
		<wp:post_date><![CDATA[2018-12-12 23:09:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-12 15:09:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8cwc2018%e3%80%8d%e9%80%9a%e9%81%93-%e8%be%b9%e5%88%86%e6%b2%bb%e8%99%9a%e6%a0%91dp]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[25]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>倒計時</title>
		<link>http://sycstudio.com/archives/1046</link>
		<pubDate>Thu, 13 Dec 2018 08:27:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=1046</guid>
		<description></description>
		<content:encoded><![CDATA[距離本站關閉還有10天]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1046</wp:post_id>
		<wp:post_date><![CDATA[2018-12-13 16:27:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-13 08:27:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%80%92%e8%a8%88%e6%99%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[35]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
