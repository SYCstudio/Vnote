# 多项式
## 多项式加减法
直接对应系数相加减

## 多项式乘法
使用$FFT,NTT$进行多项式乘法
```cpp
void NTT(int *P,int N,int opt)
{
	for (int i=0;i<N;++i) if (i<Rader[i]) swap(P[i],P[Rader[i]]);
	for (int i=1;i<N;i<<=1)
	{
		int dw=QPow(G,(Mod-1)/(i<<1));
		if (opt==-1) dw=QPow(dw,Mod-2);
		for (int j=0;j<N;j+=(i<<1))
			for (int k=j,w=1;k<i+j;++k,w=1ll*w*dw%Mod)
			{
				int X=P[k],Y=1ll*P[k+i]*w%Mod;
				P[k]=(X+Y)%Mod;P[k+i]=((X-Y)%Mod+Mod)%Mod;
			}
	}
	if (opt==-1)
	{
		int inv=QPow(N,Mod-2);
		for (int i=0;i<N;++i) P[i]=1ll*P[i]*inv%Mod;
	}
	return;
}
```
时间复杂度$O(nlogn)$

## 多项式求导
对于多项式$A(x)=\sum\_{i \le 0}a\_ix^i$，由导数公式，可以得到其形式导数为
$$A'(x)=\sum\_{i \ge 1}ia\_{i}x^{i-1}$$
时间复杂度$O(n)$

## 多项式积分
对于多项式$A(x)=\sum\_{i \ge 0}a\_ix^i$，由基本积分公式，可以得到其积分为
$$\int A(x)=\sum\_{i \ge 1}\frac{a\_{i-1}}{i}x^i$$
时间复杂度$O(n)$

## 多项式求逆
形式化地，对于多项式$A(x)$，若有$A(x)B(x) \equiv 1 \pmod {x^n} $，则称$B(x)$为$A(x)$在$\pmod{x^n}$下的逆元。  
一般采用倍增的方式求解

$$A(x)B(x) \equiv 1 \pmod{x^n} \\\\ A(x)B(x)-1 \equiv 0 \pmod{x^n} \\\\ (A(x)B(x)-1)^2 \equiv 0 \pmod {x^{2n}} \\\\ A^2(x)B^2(x)-2A(x)B(x)+1 \equiv 0 \pmod{x^{2n}} \\\\ A(x)(2B(x)-A(x)B^2(x)) \equiv 1 \pmod {x^{2n}}$$

这样我们就可以由$A(x)$在$\pmod{x^n}$下的逆得到了在$\pmod{x^{2n}}$下的逆，如此倍增，而常数项的逆就直接用费马小定理快速幂计算。  
同时也可以看出，一个多项式若要存在逆的条件是其常数项存在逆。
```cpp
void PolyInv(int *A,int *B,int len)
{
	if (len==1){
		B[0]=QPow(A[0],Mod-2);return;
	}

	PolyInv(A,B,len>>1);

	int N,L=0;
	for (N=1;N<=len<<1;N<<=1) ++L;
	for (int i=0;i<N;++i) Rader[i]=(Rader[i>>1]>>1)|((i&1)<<(L-1)),P1[i]=P2[i]=0;
	for (int i=0;i<len;++i) P1[i]=A[i],P2[i]=B[i];
	NTT(P1,N,1);NTT(P2,N,1);
	for (int i=0;i<N;++i) P1[i]=1ll*P1[i]*P2[i]%Mod*P2[i]%Mod;
	NTT(P1,N,-1);
	for (int i=0;i<=len<<1;++i) B[i]=((2ll*B[i]%Mod-P1[i])%Mod+Mod)%Mod;
	return;
}
```
时间复杂度$O(nlogn)$

## 多项式开方
形式化地，$B^2(x) \equiv A(x) \pmod{x^n}$，则多项式$B(x)$为多项式$A(x)$开方的结果。  
同样还是用倍增的方式求解

$$B^2(x) \equiv A(x) \pmod{x^n} \\\\ B^2(x)-A(x) \equiv 0 \pmod {x^n} \\\\ (B^2(x)-A(x))^2 \equiv 0 \pmod{x^{2n}} \\\\ (B^2(x)+A(x))^2 \equiv 4B^2(x)A(x) \pmod{x^{2n}} \\\\ \lgroup \frac{B^2(x)+A(x)}{2B(x)} \rgroup ^2 \equiv A(x) \pmod{x^{2n}}$$

那么就是倍增求解，每一次多项式求逆+多项式乘法。至于常数项的开方，一般而言常数项会构造成完全平方数，这样就可以直接开方。否则，需要求解已知$b$和$p$,求$a^2 \equiv b \pmod{p}$的$a$的问题。可以用$BSGS$，也可以用二次剩余。

```cpp
void PolySqrt(RG int *A,RG int *B,RG int len)
{
	if (len==1){
		B[0]=A[0];return;//注意这里常数项的计算
	}
	PolySqrt(A,B,len>>1);
	PolyInv(B,P4,len);
	RG int N,L=0;
	for (N=1;N<=len<<1;N<<=1) ++L;
	for (RG int i=0;i<N;++i) Rader[i]=(Rader[i>>1]>>1)|((i&1)<<(L-1));
	for (RG int i=0;i<len;++i) P3[i]=A[i]；
	NTT(P3,N,1);NTT(P4,N,1);
	for (int i=0;i<N;++i) P3[i]=1ll*P3[i]*P4[i]%Mod;
	NTT(P3,N,-1);
	for (RG int i=0;i<len;++i) B[i]=1ll*(B[i]+P3[i])%Mod*inv2%Mod;
	return;
}
```
时间复杂度$O(nlogn)$