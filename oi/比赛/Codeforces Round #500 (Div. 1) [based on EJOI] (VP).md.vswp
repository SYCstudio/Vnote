vnote_backup_file_826537664 /home/illya/Documents/vnote_notebooks/oi/比赛/Codeforces Round #500 (Div. 1) [based on EJOI] (VP).md
# Codeforces Round #500 (Div. 1) \[based on EJOI] (VP)

## C.Hills

给定一行 $n$ 个整数表示高度，定义山峰为严格大于两边的高度（如果存在）的点。可以花费 1 的代价使得某一点高度 -1 ，对于每一个 $i \in [1,\lceil \frac{n}{2} \rceil]$ ，求出能选出 $i$ 座山的最小代价。

设 $F[i][j][0/1]$ 表示前 i 个高度选出 j 个山峰，第 $i$ 个是否为山峰的最小代价。 F[i][j][0] 可以从 F[i-1][j][0] 和 F[i-1][j][1] 转移过来， F[i][j][1] 可以从 F[i-2][j-1][0] 和 F[i-2][j-1][1] 转移过来，分别讨论一下。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxN=5010;

int n,A[maxN];
int F[maxN][maxN/2][2];

int main(){
    scanf("%d",&n);for (int i=1;i<=n;i++) scanf("%d",&A[i]);
    memset(F,127,sizeof(F));
    F[0][0][0]=F[0][0][1]=0;
    for (int i=1;i<=n;i++){
	for (int j=0,limit=i/2+(i&1);j<=limit;j++){
	    F[i][j][0]=min(F[i-1][j][0],F[i-1][j][1]+max(0,A[i]-A[i-1]+1));
	    if (j){
		if (i==1) F[i][j][1]=0;
		else if (i==2) F[i][j][1]=F[i-1][j-1][0]+max(0,A[i-1]-A[i]+1);
		else F[i][j][1]=min(F[i-2][j-1][1]+max(0,max(A[i-1]-A[i-2]+1,A[i-1]-A[i]+1)),F[i-2][j-1][0]+max(0,A[i-1]-A[i]+1));
	    }
	}
    }
    for (int i=1,limit=n/2+(n&1);i<=limit;i++) printf("%d ",min(F[n][i][0],F[n][i][1]));printf("\n");
    return 0;
}
```

## D.AB-Strings

给定两个仅包含 a,b 字符的字符串，每次可以交换两段前缀（前缀可以为空），求最少的操作次数使得两个串分别仅出现 a 和 b ，并给出一种构造方案。

不难发现连续的相同字符可以一起操作，那么输入进来后就压缩成 abab 或者 baba 的形式。考虑一般情况，一次好的交换可以消除两个字符，两个字符串各一个，并且这是每一次操作的上界；但当其中一个字符串长度为 1 时，操作一次并不能达到这个上界，所以在开始的时候就进行调整，把两个字符串补齐。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxN=505000;

char In[maxN];
vector<pair<int,int> > A,B,Ans;

void Init(char *S,vector<pair<int,int> > &V);
void PushBack(vector<pair<int,int> > &V,pair<int,int> p);
void Exge(int l);
int main(){
    scanf("%s",In+1);Init(In,A);scanf("%s",In+1);Init(In,B);
    int swp=0;if (A.size()>B.size()) swap(A,B),swp=1;

    if (A.back().first==B.back().first){
	if ((B.size()-A.size())%4==3) Exge((B.size()-A.size()+1)/4*2);
	int l=(B.size()-A.size())/4*2+1;A.push_back(make_pair(B[B.size()-l-1].first,0));
	Exge(l);
    }
    else if (B.size()-A.size()>2) Exge((B.size()-A.size()+1)/4*2+1);

    while (A.size()>1||B.size()>1) Exge(1);
    printf("%d\n",(int)Ans.size());
    for (int i=0,sz=Ans.size();i<sz;i++)
	swp?printf("%d %d\n",Ans[i].second,Ans[i].first):printf("%d %d\n",Ans[i].first,Ans[i].second);
    return 0;
}
void Init(char *S,vector<pair<int,int> > &V){
    for (int i=strlen(S+1);i>=1;i--) PushBack(V,make_pair(S[i],1));return;
}
void PushBack(vector<pair<int,int> > &V,pair<int,int> p){
    if (V.empty()||V.back().first!=p.first) V.push_back(p);else V.back().second+=p.second;
    return;
}
void Exge(int l){
    int tl=0;pair<int,int> la=A.back();A.pop_back();
    for (int i=l,bsz=B.size();i>=1;i--) PushBack(A,B[bsz-i]),tl+=B[bsz-i].second;
    Ans.push_back(make_pair(la.second,tl));
    for (int i=1;i<=l;i++) B.pop_back();PushBack(B,la);
    return;
}
```

## E.Cycle sort

给定一个长度为 $n$ 的序列 $A$，现在可以进行若干次操作，每次操作指定一个长度小于等于 $n$ 的任意无重序列 $B$ ，把序列 $A$ 做 $B$ 的置换，即 $A _ {B _ i} \Rightarrow A _ {B _ {i+1}}$ 。要求最后使得序列 $A$ 不降。另外给定参数 $S$ ，要求所有操作序列 $B$ 的长度之和不能超过 $S$ ，在此基础上构造一组操作次数最少的方案。

先考虑没有 $S$ 的排列怎么做。一个排列必然可以拆分成若干环，这些环中大小超过 $1$ 的都是必须至少移动一次的，这些数的个数也是操作总数量的下界；当没有 $S$ 的限制时，若只有一个这样的环，自然只要操作一次；否则，存在一种只需操作两次的构造方法，即把这些环分别断开再首尾相连，此为第一次操作，再倒序把所有接口再进行一次置换，此为第二次操作。  
考虑把上述做法推广到序列上。先排序，若排序后某位置上的数与排序前相同，那么这个数就不需要动了，剩下的数按照排列一样做。  
最后来考虑 $S$ 的限制。首先，直接把所有环单独做置换的总需要操作次数是环长之和，并且此为操作下界，若 $S$ 仍小于该下界，则一定无解。否则，若把 $K$ 个环合在一起做上述两次的构造方法，则需要 $K$ 的操作空间。想要最优化问题，首先要优化环的数量。对于权值相同但不在一个环内的数字，可以交换两个指向以合并这两个环