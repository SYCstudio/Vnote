# JOI 春合宿 2018

## 高速道路の建設（construction）

注意到这个操作很像 Access ，由于有势能分析，那么直接暴力 Access + BIT 统计答案即可。

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;

typedef long long ll;
const int maxN=101000;

class SplayData{
public:
    int ch[2],fa,cov,siz;
};

int n;
int Val[maxN],num,Num[maxN];
int BIT[maxN],tim,Tim[maxN];
SplayData S[maxN];

bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Add(int p,int key);
int Sum(int p);

int main(){
    scanf("%d",&n);for (int i=1;i<=n;i++) scanf("%d",&Val[i]),Num[i]=Val[i];
    sort(&Num[1],&Num[n+1]);num=unique(&Num[1],&Num[n+1])-Num-1;
    for (int i=1;i<=n;i++) S[i].cov=Val[i]=lower_bound(&Num[1],&Num[num+1],Val[i])-Num,S[i].siz=1;
    for (int i=1;i<n;i++){
	int a,b;scanf("%d%d",&a,&b);
	S[b].fa=a;Access(b);
    }
    return 0;
}
bool Isroot(int x){
    int fa=S[x].fa;if (S[fa].ch[0]==x||S[fa].ch[1]==x) return 0;return 1;
}
void Update(int x){
    S[x].siz=S[S[x].ch[0]].siz+S[S[x].ch[1]].siz+1;
    return;
}
void PushDown(int x){
    if (S[x].ch[0]) S[S[x].ch[0]].cov=S[x].cov;
    if (S[x].ch[1]) S[S[x].ch[1]].cov=S[x].cov;
    return;
}
void Rotate(int x){
    int y=S[x].fa,z=S[y].fa,sx=(x==S[y].ch[1]),sy=(y==S[z].ch[1]);
    S[x].fa=z;if (!Isroot(y)) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}
void Splay(int x){
    static int St[maxN],top,now;now=x;top=1;St[1]=now;
    while (!Isroot(now)) St[++top]=now=S[now].fa;
    
    while (top) PushDown(St[top--]);
    while (!Isroot(x)){
	int y=S[x].fa,z=S[y].fa;
	if (!Isroot(y)) ((x==S[y].ch[0])^(y==S[z].ch[0]))?Rotate(x):Rotate(y);
	Rotate(x);
    }
    Update(x);return;
}
void Access(int x){
    ++tim;ll Ans=0;int key=Val[x],lstx=x,skp=0,mxs=0,prex=x;x=S[x].fa;
    while (x){
	++skp;mxs=max(mxs,S[x].siz);
	Splay(x);Ans=Ans+1ll*(S[S[x].ch[0]].siz+1)*Sum(S[x].cov-1);
	Add(S[x].cov,S[S[x].ch[0]].siz+1);S[x].cov=key;
	S[x].ch[1]=lstx;lstx=x;Update(x);x=S[x].fa;
    }
    printf("%lld\n",Ans);return;
}
void Add(int p,int key){
    while (p<=num){
	if (Tim[p]!=tim) Tim[p]=tim,BIT[p]=0;
	BIT[p]+=key;p+=(p)&(-p);
    }
    return;
}
int Sum(int p){
    int ret=0;
    while (p){
	if (Tim[p]==tim) ret+=BIT[p];
	p-=(p)&(-p);
    }
    return ret;
}
```

## 柵（fences）

如果把可行的所有边连起来，问题就转化为求一个包含中间矩形区域的最小环。无向图最小环并不好作限制，故考虑计算几何中点在多边形内的判定方法：引一条射线，与多边形相交奇数次则在多边形内，否则在多边形外。考虑设 F[u][v][0/1] 表示 u,v 之间跨越射线奇数次/偶数次的最小代价，预处理之后 Floyed 转移。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cassert>
using namespace std;

#define double long double
#define ft first
#define sd second
class Point{
public:
    double x,y;
    Point(){}
    Point(double _x,double _y){
	x=_x;y=_y;return;
    }
    double len(){
	return sqrt(x*x+y*y);
    }
    double angle(){
	return atan2(y,x);
    }
};

const int maxN=310;
const double INF=1e18;
const double eps=1e-10;
const Point FAR(141*10,937*10);
const Point O(0,0);

int n,S;
Point P[maxN],T[4];
pair<double,double> Dst[maxN][maxN],G[10][10];

Point operator + (Point A,Point B);
Point operator - (Point A,Point B);
Point operator * (Point A,double B);
ostream & operator << (ostream & os,Point A);
double Cross(Point A,Point B);
double Dot(Point A,Point B);
bool same(double x,double y);
bool check(Point A,Point B);
bool Intersection(Point A,Point B,Point C,Point D);
Point Near(Point A,Point L1,Point L2);
void Path(int u,int v,Point S,Point T,Point A,Point B);
pair<double,double> Calc(int u,int v);
int main(){
    scanf("%d%d",&n,&S);
    for (int i=1;i<=n;i++) scanf("%LF%LF%LF%LF",&P[i].x,&P[i].y,&P[n+i].x,&P[n+i].y);
    T[0]=((Point){S,S});T[1]=((Point){-S,S});
    T[2]=((Point){-S,-S});T[3]=((Point){S,-S});

    for (int i=1;i<=n;i++) for (int j=i;j<=n;j++) Dst[i][j]=Dst[j][i]=Calc(i,j);

    for (int k=1;k<=n;k++)
	for (int i=1;i<=n;i++)
	    for (int j=1;j<=n;j++){
		Dst[i][j].ft=min(Dst[i][j].ft,Dst[i][k].ft+Dst[k][j].sd);
		Dst[i][j].ft=min(Dst[i][j].ft,Dst[i][k].sd+Dst[k][j].ft);
		Dst[i][j].sd=min(Dst[i][j].sd,Dst[i][k].ft+Dst[k][j].ft);
		Dst[i][j].sd=min(Dst[i][j].sd,Dst[i][k].sd+Dst[k][j].sd);
	    }

    double Ans=S*8;for (int i=1;i<=n;i++) Ans=min(Ans,Dst[i][i].ft+Dst[i][i].sd);
    printf("%.10LF\n",Ans);return 0;
}
Point operator + (Point A,Point B){
    return ((Point){A.x+B.x,A.y+B.y});
}
Point operator - (Point A,Point B){
    return ((Point){A.x-B.x,A.y-B.y});
}
Point operator * (Point A,double B){
    return ((Point){A.x*B,A.y*B});
}
ostream & operator << (ostream & os,Point A){
    os<<"("<<A.x<<","<<A.y<<")";return os;
}
double Cross(Point A,Point B){
    return A.x*B.y-A.y*B.x;
}
double Dot(Point A,Point B){
    return A.x*B.x+A.y*B.y;
}
bool same(double x,double y){
    return fabs(x-y)<eps;
}
bool check(Point A,Point B){
    for (int i=0;i<=3;i++) for (int j=i+1;j<=3;j++) if (Intersection(A,B,T[i],T[j])) return 0;
    return 1;
}
bool Intersection(Point A,Point B,Point C,Point D){
    return (Cross(B-C,D-C)*Cross(A-C,D-C)<0)&&(Cross(C-A,B-A)*Cross(D-A,B-A)<0);
}
Point Near(Point A,Point L1,Point L2){
    double l=(L2-L1).len(),t=Dot(L2-L1,A-L1)/l;
    if (t<-eps) return L1;
    if (t>l) return L2;
    return L1+(L2-L1)*(t/l);
}
void Path(int u,int v,Point S,Point T,Point A,Point B){
    if (!check(A,B)) return;
    double len=(A-B).len();
    if (Intersection(O,FAR,S,A)^Intersection(O,FAR,A,B)^Intersection(O,FAR,B,T))
	G[u][v].ft=G[v][u].ft=min(G[u][v].ft,len);
    else G[u][v].sd=G[v][u].sd=min(G[u][v].sd,len);
    return;
}
pair<double,double> Calc(int u,int v){
    for (int i=1;i<=6;i++) for (int j=1;j<=6;j++) G[i][j]=make_pair(INF,INF);
    for (int i=0;i<=1;i++) for (int j=0;j<=1;j++) Path(1,2,P[u],P[v],P[u+i*n],P[v+j*n]);
    Path(1,2,P[u],P[v],P[u],Near(P[u],P[v],P[v+n]));
    Path(1,2,P[u],P[v],P[u+n],Near(P[u+n],P[v],P[v+n]));
    Path(1,2,P[u],P[v],Near(P[v],P[u],P[u+n]),P[v]);
    Path(1,2,P[u],P[v],Near(P[v+n],P[u],P[u+n]),P[v+n]);
    for (int i=0;i<=3;i++){
	Path(1,i+3,P[u],T[i],P[u],T[i]);
	Path(1,i+3,P[u],T[i],P[u+n],T[i]);
	Path(1,i+3,P[u],T[i],Near(T[i],P[u],P[u+n]),T[i]);
    }
    
    for (int i=0;i<=3;i++){
	Path(2,i+3,P[v],T[i],P[v],T[i]);
	Path(2,i+3,P[v],T[i],P[v+n],T[i]);
	Path(2,i+3,P[v],T[i],Near(T[i],P[v],P[v+n]),T[i]);
    }
    Path(3,4,T[0],T[1],T[0],T[1]);
    Path(4,5,T[1],T[2],T[1],T[2]);
    Path(5,6,T[2],T[3],T[2],T[3]);
    Path(6,3,T[3],T[0],T[3],T[0]);
    for (int k=1;k<=6;k++)
	for (int i=1;i<=6;i++)
	    for (int j=1;j<=6;j++){
		G[i][j].ft=min(G[i][j].ft,G[i][k].ft+G[k][j].sd);
		G[i][j].ft=min(G[i][j].ft,G[i][k].sd+G[k][j].ft);
		G[i][j].sd=min(G[i][j].sd,G[i][k].ft+G[k][j].ft);
		G[i][j].sd=min(G[i][j].sd,G[i][k].sd+G[k][j].sd);
	    }
    return G[1][2];
}
```