# 7102PION Extra

## 度杂复间时

### 题目描述

标题是吸引你看进来的。  
我们的故事从第五次圣杯战争最后的大战说起。众所周知，第二魔法是操纵时间和空间的魔法。使用第二魔法时，施法者可以在过去、现在、未来的无限个平行空间中穿梭。远坂家族便是第二魔法的传承者之一。在最后的大战中，远坂凛使用家族传承的宝石剑，在自身魔力被间桐樱完全吸走的情况下，施展第二魔法，借助无限平行空间中的自然魔力，抵挡住了樱的多次攻击，为卫宫士郎赢得了时间，并成功感化了樱。最终，由伊莉雅施展第三魔法[天之杯]，彻底结束了圣杯战争的进程。  
但在战斗中，为了赢得时机，凛发动宝石剑的技能不幸使宝石剑损♂坏。圣杯战争结束后，凛前往钟楼继续学习~~膜~~魔法。随着技艺的不断提高，凛成功对宝石剑进行了一些修复。但第二魔法不知道高到哪里去了，~~凛还需要继续提高知识水平，~~宝石剑还远未到达能完全施展第二魔法的境界。现在，为了继续修复宝石剑，凛需要对宝石剑作一些研♂究。  
由于宝石剑并不完整，无法做到无限平行空间，所以目前只能在$D$个不同的**空间**中穿梭，我们把空间编号为$[1,D]$。在这$D$个空间中，每一个空间中都有$n$个**魔术刻印**，可以看作$n$个点，每一个空间中都从$1$到$n$编号。开始时，每一个空间中的任意两个**魔术刻印**均不连通。现在，凛要进行多次操作$(a,b,K)$，表示~~钦~~定一个空间$K$，在第$K$个空间的**魔术刻印**$a,b$之间连接一条**魔术回路**。保证每一条**魔术回路**只会连接在同一个空间中的**魔术刻印**。因为是回路，所以连接是**双向**的。**魔术回路**有着奇♂妙的性质，若两个**魔术刻印**能通过**魔术回路**间接相连，则认为这两个**魔术刻印**也有一条**魔术回路**相连。比如有两条**魔术回路**分别连接了**魔术刻印**$(a-b),(b-c)$，则认为**魔术刻印**$(a-c)$之间也有一条**魔术回路**。  
通过**魔术回路**连接起来的**魔术刻印**有着非常强的空间和时间性质，所以现在凛想要知道的是，在每一次操作完之后，有多少对**魔术刻印**在每一个平行空间中都是由**魔术回路**连通的。  
> 注：  
> 1.$(a,b)$与$(b,a)$看作不同的对数，即我们统计的是有序点对;  
> 2.$(a,a)$也认为是一对

### 输入
输入的第一行包含三个整数$D,n,m$，表示空间的个数，每一个空间中魔术刻印的个数和操作的个数。  
接下来$m$行，每行三个正整数$a,b,K$，表示在空间$K$的刻印$a,b$之间连接一条魔术回路。不保证在连接之前$a,b$是不连通的。

### 输出
输出$m$行，每一行一个整数表示每次操作后询问的答案。

### 样例
#### Sample Input
```plain
3 4 10
1 2 1
2 1 2
1 2 3
3 4 1
1 3 2
2 3 3
2 4 2
3 4 3
3 4 2
1 3 1
```

#### Sample Output
```plain
4
4
6
6
6
6
6
8
8
16
```

### 数据范围
对于$10\%$的数据，$D \le 5,n \le 10,m \le 10$  
对于另外$10\%$的数据，$D=1,n \le 5000,m \le 10^6$  
对于另外$20\%$的数据，$D \le 5,n \le 300,m \le 300$  
对于另外$20\%$的数据，$D \le 100,n \le 300 ,m \le 300$  
对于全部的数据，$D \le 200,n \le 5000,m \le 10^6$  

开启$subtask$，每一组数据的点都是有梯度的，部分数据随机。

### 提示
题目并不♂难

### 题解
#### 题意简述
为了防止因本人语文问题导致某些同学到现在都没有看懂题目，我决定还是先简述一下题意。 

给出$D$张图，每张图上有$n$个点。每一次连接某一张图的两个点，询问在所有图中都连通的有序点对数量。

这道题是不是特别有♂趣呢？下面来看一看做法。
#### Task1
$$D \le 5,n \le 10,m \le 10$$  
数据范围比较小，有什么比较好的办法呢？  
设$Link[i][j][k]$表示$j,k$两个点在图$i$中的连通情况。每加入一条边的时候，连接两条边然后$Floyed$传递一下，$Floyed$复杂度$O(n^3)$。查询则枚举两个点，然后在$D$张图中依次查询是否均连通，复杂度$O(Dn^2)$。当然，也可以一边修改一边算，用一个数组记录下来，但是对总复杂度没有帮助。  
总复杂度$O(m(n^3+Dn^2))$

#### Task2
$$D=1,n \le 5000,m \le 10^6$$  
$D=1$，也就是说操作全部都是在一张图上的。  
问题简化为在一张图中，每次连接两个点，求连通的点的个数。  
那么这个可以用并查集来维护，在维护并查集的同时在并查集的顶部元素维护一个$Size$，每次合并的时候更新答案就好。  
复杂度$O(m\alpha(n))$，其中$\alpha(n)$为并查集的反阿克曼函数。（你可以认为是$O(1)$）

#### Task3
$$D \le 5,n \le 300,m \le 300$$  
~~从这个点开始，似乎不太好得分了。~~  
考虑$Task2$给我们的启示，并查集？并查集维护的其实相当于为每一个点分配一个所在的连通块的编号（也就是并查集中每一个点跳到最上面的点的编号）。两个点在所有的图中都连通，**当且仅当**它们在每一张图中所属的连通块编号都相同。  
于是我们可以设$F[i][j]$表示点$i$在第$j$个图中所属的连通块编号。若两个点在所有的图中编号都相同，则说明两个点在所有的图中都连通。修改一个点的$F[i][j]$是$O(1)$的。而合并可以通过启发式的方式，做到复杂度$O(Dnlog\_n)$。至于查询的话，可以枚举两个点然后看它们的$F$值是否全部相同。  
所以，总复杂度为$O(D(nlog\_n+mn^2))$

#### Task4
$$D \le 100,n \le 300 ,m \le 300$$  

上面做法的瓶颈在于判断两个点所有的$F[u][]$是否相同时需要$O(D)$的复杂度来依次比较。如何快速判断两个点$u,v$的$F[u][i],F[v][i]$相同呢？对于每一个点，把它在每一个图中的连通块编号依次串连后起来可以看作一个字符串。判断两个字符串相等最快的方法就是$Hash$，修改和单个比较都是$O(1)$的。所以把上面的做法的比较改成$Hash$比较。  
总复杂度$O(Dnlog\_n+mn^2)$

#### Task5
$$D \le 200,n \le 5000,m \le 10^6$$  
实际上启发式合并的复杂度已经做到最低了，所以还要继续优化回答询问的复杂度。  
考虑我们把编号$Hash$后，问题实际上转化为求在$n$个$Hash$值中，有多少有序对$Hash$是相同的。一个简单的想法就是用$std::map$来记录每一种$Hash$值出现的次数，然后实时维护答案。这样的复杂度是$O(Dnlog\_n+mlog\_n)$的，(也许?)能够通过$Task5$的前半数据，也就是原题的数据点。  
为什么我们要用$std::map$呢，因为为了减少/防止冲突，$Hash$值一般都比较大（我使用的是$unsigned\ long\ long$）。如果$Hash$值在一个可以用值域数组记录下来的范围内，我们就可以直接统计每一种值的出现次数了。  
怎么办呢？方法就是把原$Hash$值再$Hash$一次，把$unsigned\ long\ long$的值域压缩到比如$10^6$以内，这样是可以开$int[]$数组存下每一种$Hash$的出现次数的，然后我们就可以比较方便地维护答案了。但是由于数据信息压缩，$Hash$冲突的可能也增大了，所以第二次$Hash$要采用挂链$Hash$的形式，可以完全避免冲突。  
这样一来，单次询问的复杂度就降低到$O(1)$，总复杂度$O(Dnlog\_n+m)$