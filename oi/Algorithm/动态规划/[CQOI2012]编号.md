# [CQOI2012]编号
[BZOJ2665 Luogu4222]

你需要给一批商品编号，其中每个编号都是一个7位16进制数（由0~9, a-f组成）。为了防止在人工处理时不小心把编号弄错，要求任意两个编号至少有三个位置对应的数字不相同。第一个编号为0000000，第二个编号为不违反上述规定的前提下最小的编号，…，每次分配一个新编号时，总是选择不和前面编号冲突的最小编号（注意编号都是16进制数，可以比较大小）。按此规律，前面若干编号分别是：0000000, 0000111, 0000222, …, 0000fff, 0001012, 0001103,0001230,0001321,0001456,…  
输入k，你的任务是求出第k小的编号。


直接暴力枚举。因为要求至少 3 个数不一样，那么如果有 5 个数一样，剩下的两个数不管一不一样都不满足要求。 7 个数里面选择 2 个数共有 21 种选法，那么设 F[i][a][b][c][d][e] 表示第 i 种选法的 5 个数为 a,b,c,d,e 时这种方案是否被选。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define F(i,a,b,c,d,e) FF[i-1][(S##a<<16)|(S##b<<12)|(S##c<<8)|(S##d<<4)|S##e]
#define RG register

const int maxS=21;
const int maxW=16;
const int inf=2147483647;

int n;
bool FF[maxS][maxW*maxW*maxW*maxW*maxW];

int main(){
	RG int S1,S2,S3,S4,S5,S6,S7;
	scanf("%d",&n);
	for (S1=0;S1<=15;++S1)
		for (S2=0;S2<=15;++S2)
			for (S3=0;S3<=15;++S3)
				for (S4=0;S4<=15;++S4)
					for (S5=0;S5<=15;++S5)
						for (S6=0;S6<=15;++S6)
							for (S7=0;S7<=15;++S7){
								if (!F(1,3,4,5,6,7)&&!F(2,2,4,5,6,7)&&!F(3,2,3,5,6,7)&&!F(4,2,3,4,6,7)&&!F(5,2,3,4,5,7)&&!F(6,2,3,4,5,6)&&!F(7,1,4,5,6,7)&&!F(8,1,3,5,6,7)&&!F(9,1,3,4,6,7)&&!F(10,1,3,4,5,7)&&!F(11,1,3,4,5,6)&&!F(12,1,2,5,6,7)&&!F(13,1,2,4,6,7)&&!F(14,1,2,4,5,7)&&!F(15,1,2,4,5,6)&&!F(16,1,2,3,6,7)&&!F(17,1,2,3,5,7)&&!F(18,1,2,3,5,6)&&!F(19,1,2,3,4,7)&&!F(20,1,2,3,4,6)&&!F(21,1,2,3,4,5)){
									--n;
									if (n==0){
										printf("%x%x%x%x%x%x%x\n",S1,S2,S3,S4,S5,S6,S7);
										return 0;
									}
									F(1,3,4,5,6,7)=F(2,2,4,5,6,7)=F(3,2,3,5,6,7)=F(4,2,3,4,6,7)=F(5,2,3,4,5,7)
										=F(6,2,3,4,5,6)=F(7,1,4,5,6,7)=F(8,1,3,5,6,7)=F(9,1,3,4,6,7)=F(10,1,3,4,5,7)
										=F(11,1,3,4,5,6)=F(12,1,2,5,6,7)=F(13,1,2,4,6,7)=F(14,1,2,4,5,7)
										=F(15,1,2,4,5,6)=F(16,1,2,3,6,7)=F(17,1,2,3,5,7)=F(18,1,2,3,5,6)
										=F(19,1,2,3,4,7)=F(20,1,2,3,4,6)=F(21,1,2,3,4,5)=1;
								}
							}
	return 0;
}
```